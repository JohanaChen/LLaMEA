{"id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "solution": "import numpy as np\n\nclass AG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 100\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8  # small value to prevent division by zero\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for all particles\n            gradient = np.zeros_like(population)\n            for i in range(self.population_size):\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient\n            population += velocities\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AG_PSO", "description": "Adaptive Gradient-based Particle Swarm Optimization (AG-PSO) combines gradient information with particle swarm dynamics to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.11464715220395104, "feedback": "The algorithm AG_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.26369339375192824, 0.26369339375192824, 0.26369339375192824, 0.2527217098980197, 0.2527217098980197, 0.2527217098980197, 0.26159828037538724, 0.26159828037538724, 0.26159828037538724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07059314518371629, 0.07059314518371629, 0.07059314518371629, 0.05261333984308769, 0.05261333984308769, 0.05261333984308769, 0.03697046231540735, 0.03697046231540735, 0.03697046231540735, 0.01694785579421898, 0.01694785579421898, 0.01694785579421898, 0.025747182087950793, 0.025747182087950793, 0.025747182087950793, 0.020838687721282834, 0.020838687721282834, 0.020838687721282834, 0.7417582505441774, 0.7417582505441774, 0.7417582505441774, 0.8693201189167548, 0.8693201189167548, 0.8693201189167548, 0.866968977699619, 0.866968977699619, 0.866968977699619, 0.036884713170196703, 0.036884713170196703, 0.036884713170196703, 0.05271489763487558, 0.05271489763487558, 0.05271489763487558, 0.05148547370465095, 0.05148547370465095, 0.05148547370465095, 0.1427244003268734, 0.1427244003268734, 0.1427244003268734, 0.14525753395885999, 0.14525753395885999, 0.14525753395885999, 0.13155176327680185, 0.13155176327680185, 0.13155176327680185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01449187574799038, 0.01449187574799038, 0.01449187574799038, 0.001873911110826687, 0.001873911110826687, 0.001873911110826687, 0.017306386352669012, 0.017306386352669012, 0.017306386352669012, 0.2949376010368683, 0.2949376010368683, 0.2949376010368683, 0.1644855357978917, 0.1644855357978917, 0.1644855357978917, 0.27085269038226834, 0.27085269038226834, 0.27085269038226834, 0.04480955656651042, 0.04480955656651042, 0.04480955656651042, 0.05347192432629455, 0.05347192432629455, 0.05347192432629455, 0.043458491884755146, 0.043458491884755146, 0.043458491884755146, 0.10055933453596011, 0.10055933453596011, 0.10055933453596011, 0.09919853983642557, 0.09919853983642557, 0.09919853983642557, 0.10773988655496503, 0.10773988655496503, 0.10773988655496503, 0.20742066888499522, 0.20742066888499522, 0.20742066888499522, 0.20386326224267803, 0.20386326224267803, 0.20386326224267803, 0.1903092090887316, 0.1903092090887316, 0.1903092090887316, 0.07446367408012833, 0.07446367408012833, 0.07446367408012833, 0.10797435841333625, 0.10797435841333625, 0.10797435841333625, 0.08019526865557036, 0.08019526865557036, 0.08019526865557036, 0.10809451436010387, 0.10809451436010387, 0.10809451436010387, 0.10878924573836024, 0.10878924573836024, 0.10878924573836024, 0.10197285410143941, 0.10197285410143941, 0.10197285410143941, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14584720349507208, 0.14584720349507208, 0.14584720349507208, 0.2941665040600233, 0.2941665040600233, 0.2941665040600233, 0.14424422271348025, 0.14424422271348025, 0.14424422271348025, 0.1030145303931389, 0.1030145303931389, 0.1030145303931389, 0.24746156225601312, 0.24746156225601312, 0.24746156225601312, 0.15751983034205264, 0.15751983034205264, 0.15751983034205264, 0.11875351027775838, 0.11875351027775838, 0.11875351027775838, 0.16555511818272595, 0.16555511818272595, 0.16555511818272595, 0.15878317176588808, 0.15878317176588808, 0.15878317176588808, 0.17140969598703926, 0.17140969598703926, 0.17140969598703926, 0.04310240722632519, 0.04310240722632519, 0.04310240722632519, 0.03426055068722922, 0.03426055068722922, 0.03426055068722922, 0.03181767539515201, 0.03181767539515201, 0.03181767539515201]}, "mutation_prompt": null}
{"id": "432febc7-72d6-40e3-81a6-85102d742491", "solution": "import numpy as np\n\nclass SG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 100\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.9  # increased inertia weight for enhanced exploration\n        self.epsilon = 1e-8\n        self.gradient_scale = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for all particles\n            gradient = np.zeros_like(population)\n            for i in range(self.population_size):\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          self.gradient_scale * gradient)  # Dynamic gradient scaling\n            population += velocities\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "SG_PSO", "description": "Smart Gradient-Boosted Particle Swarm Optimization (SG-PSO) enhances search efficiency by dynamically adjusting exploration and exploitation through adaptive gradient scaling.", "configspace": "", "generation": 1, "fitness": 0.10962245151693566, "feedback": "The algorithm SG_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "metadata": {"aucs": [0.2462489872732927, 0.2462489872732927, 0.2462489872732927, 0.16132161716293125, 0.16132161716293125, 0.16132161716293125, 0.24187971903689098, 0.24187971903689098, 0.24187971903689098, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05892116443703521, 0.05892116443703521, 0.05892116443703521, 0.05023104238082399, 0.05023104238082399, 0.05023104238082399, 0.034657122339709856, 0.034657122339709856, 0.034657122339709856, 0.026655843638310195, 0.026655843638310195, 0.026655843638310195, 0.02911948506075257, 0.02911948506075257, 0.02911948506075257, 0.024577698452712293, 0.024577698452712293, 0.024577698452712293, 0.8007034071370807, 0.8007034071370807, 0.8007034071370807, 0.8694465496863614, 0.8694465496863614, 0.8694465496863614, 0.8671056475635851, 0.8671056475635851, 0.8671056475635851, 0.03784644652360891, 0.03784644652360891, 0.03784644652360891, 0.05520228444410946, 0.05520228444410946, 0.05520228444410946, 0.05148547370465095, 0.05148547370465095, 0.05148547370465095, 0.11738181662081337, 0.11738181662081337, 0.11738181662081337, 0.1600983414615864, 0.1600983414615864, 0.1600983414615864, 0.10489995978673472, 0.10489995978673472, 0.10489995978673472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0077435175918822985, 0.0077435175918822985, 0.0077435175918822985, 0.004001580304647923, 0.004001580304647923, 0.004001580304647923, 0.007319660874074541, 0.007319660874074541, 0.007319660874074541, 0.24847032544811165, 0.24847032544811165, 0.24847032544811165, 0.16357487295103024, 0.16357487295103024, 0.16357487295103024, 0.23773047645425005, 0.23773047645425005, 0.23773047645425005, 0.03832796967994201, 0.03832796967994201, 0.03832796967994201, 0.042601544058722185, 0.042601544058722185, 0.042601544058722185, 0.04124504131012985, 0.04124504131012985, 0.04124504131012985, 0.09235483320940929, 0.09235483320940929, 0.09235483320940929, 0.09192024145267008, 0.09192024145267008, 0.09192024145267008, 0.1114936660642083, 0.1114936660642083, 0.1114936660642083, 0.19201498998640398, 0.19201498998640398, 0.19201498998640398, 0.1889921268584952, 0.1889921268584952, 0.1889921268584952, 0.17529656953476858, 0.17529656953476858, 0.17529656953476858, 0.07067539299149062, 0.07067539299149062, 0.07067539299149062, 0.11885708264633155, 0.11885708264633155, 0.11885708264633155, 0.09763723803971824, 0.09763723803971824, 0.09763723803971824, 0.10809451436010387, 0.10809451436010387, 0.10809451436010387, 0.10878924573836024, 0.10878924573836024, 0.10878924573836024, 0.10197285410143941, 0.10197285410143941, 0.10197285410143941, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14584720349507208, 0.14584720349507208, 0.14584720349507208, 0.2563786420665407, 0.2563786420665407, 0.2563786420665407, 0.143450220402075, 0.143450220402075, 0.143450220402075, 0.13152207996235576, 0.13152207996235576, 0.13152207996235576, 0.15602498019232336, 0.15602498019232336, 0.15602498019232336, 0.14540260123124027, 0.14540260123124027, 0.14540260123124027, 0.11710053557932898, 0.11710053557932898, 0.11710053557932898, 0.15384800195312764, 0.15384800195312764, 0.15384800195312764, 0.17421116919812452, 0.17421116919812452, 0.17421116919812452, 0.17871928586296804, 0.17871928586296804, 0.17871928586296804, 0.036819957561537, 0.036819957561537, 0.036819957561537, 0.03277780595234259, 0.03277780595234259, 0.03277780595234259, 0.03181767539515201, 0.03181767539515201, 0.03181767539515201]}, "mutation_prompt": null}
{"id": "b681695f-7dc3-4f26-ad7c-35fbb0f8e3d4", "solution": "import numpy as np\n\nclass AG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 100\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8  # small value to prevent division by zero\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for all particles\n            gradient = np.zeros_like(population)\n            for i in range(self.population_size):\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient\n            population += velocities\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AG_PSO", "description": "Adaptive Gradient-based Particle Swarm Optimization (AG-PSO) combines gradient information with particle swarm dynamics to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "metadata": {"aucs": [0.26369339375192824, 0.26369339375192824, 0.26369339375192824, 0.2527217098980197, 0.2527217098980197, 0.2527217098980197, 0.26159828037538724, 0.26159828037538724, 0.26159828037538724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07059314518371629, 0.07059314518371629, 0.07059314518371629, 0.05261333984308769, 0.05261333984308769, 0.05261333984308769, 0.03697046231540735, 0.03697046231540735, 0.03697046231540735, 0.01694785579421898, 0.01694785579421898, 0.01694785579421898, 0.025747182087950793, 0.025747182087950793, 0.025747182087950793, 0.020838687721282834, 0.020838687721282834, 0.020838687721282834, 0.7417582505441774, 0.7417582505441774, 0.7417582505441774, 0.8693201189167548, 0.8693201189167548, 0.8693201189167548, 0.866968977699619, 0.866968977699619, 0.866968977699619, 0.036884713170196703, 0.036884713170196703, 0.036884713170196703, 0.05271489763487558, 0.05271489763487558, 0.05271489763487558, 0.05148547370465095, 0.05148547370465095, 0.05148547370465095, 0.1427244003268734, 0.1427244003268734, 0.1427244003268734, 0.14525753395885999, 0.14525753395885999, 0.14525753395885999, 0.13155176327680185, 0.13155176327680185, 0.13155176327680185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01449187574799038, 0.01449187574799038, 0.01449187574799038, 0.001873911110826687, 0.001873911110826687, 0.001873911110826687, 0.017306386352669012, 0.017306386352669012, 0.017306386352669012, 0.2949376010368683, 0.2949376010368683, 0.2949376010368683, 0.1644855357978917, 0.1644855357978917, 0.1644855357978917, 0.27085269038226834, 0.27085269038226834, 0.27085269038226834, 0.04480955656651042, 0.04480955656651042, 0.04480955656651042, 0.05347192432629455, 0.05347192432629455, 0.05347192432629455, 0.043458491884755146, 0.043458491884755146, 0.043458491884755146, 0.10055933453596011, 0.10055933453596011, 0.10055933453596011, 0.09919853983642557, 0.09919853983642557, 0.09919853983642557, 0.10773988655496503, 0.10773988655496503, 0.10773988655496503, 0.20742066888499522, 0.20742066888499522, 0.20742066888499522, 0.20386326224267803, 0.20386326224267803, 0.20386326224267803, 0.1903092090887316, 0.1903092090887316, 0.1903092090887316, 0.07446367408012833, 0.07446367408012833, 0.07446367408012833, 0.10797435841333625, 0.10797435841333625, 0.10797435841333625, 0.08019526865557036, 0.08019526865557036, 0.08019526865557036, 0.10809451436010387, 0.10809451436010387, 0.10809451436010387, 0.10878924573836024, 0.10878924573836024, 0.10878924573836024, 0.10197285410143941, 0.10197285410143941, 0.10197285410143941, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14584720349507208, 0.14584720349507208, 0.14584720349507208, 0.2941665040600233, 0.2941665040600233, 0.2941665040600233, 0.14424422271348025, 0.14424422271348025, 0.14424422271348025, 0.1030145303931389, 0.1030145303931389, 0.1030145303931389, 0.24746156225601312, 0.24746156225601312, 0.24746156225601312, 0.15751983034205264, 0.15751983034205264, 0.15751983034205264, 0.11875351027775838, 0.11875351027775838, 0.11875351027775838, 0.16555511818272595, 0.16555511818272595, 0.16555511818272595, 0.15878317176588808, 0.15878317176588808, 0.15878317176588808, 0.17140969598703926, 0.17140969598703926, 0.17140969598703926, 0.04310240722632519, 0.04310240722632519, 0.04310240722632519, 0.03426055068722922, 0.03426055068722922, 0.03426055068722922, 0.03181767539515201, 0.03181767539515201, 0.03181767539515201]}, "mutation_prompt": null}
{"id": "e3dfeb50-6460-4da8-8b97-207d98c0a384", "solution": "import numpy as np\n\nclass AG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 100\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8  # small value to prevent division by zero\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for all particles\n            gradient = np.zeros_like(population)\n            for i in range(self.population_size):\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient\n            population += velocities\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AG_PSO", "description": "Adaptive Gradient-based Particle Swarm Optimization (AG-PSO) combines gradient information with particle swarm dynamics to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "metadata": {"aucs": [0.26369339375192824, 0.26369339375192824, 0.26369339375192824, 0.2527217098980197, 0.2527217098980197, 0.2527217098980197, 0.26159828037538724, 0.26159828037538724, 0.26159828037538724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07059314518371629, 0.07059314518371629, 0.07059314518371629, 0.05261333984308769, 0.05261333984308769, 0.05261333984308769, 0.03697046231540735, 0.03697046231540735, 0.03697046231540735, 0.01694785579421898, 0.01694785579421898, 0.01694785579421898, 0.025747182087950793, 0.025747182087950793, 0.025747182087950793, 0.020838687721282834, 0.020838687721282834, 0.020838687721282834, 0.7417582505441774, 0.7417582505441774, 0.7417582505441774, 0.8693201189167548, 0.8693201189167548, 0.8693201189167548, 0.866968977699619, 0.866968977699619, 0.866968977699619, 0.036884713170196703, 0.036884713170196703, 0.036884713170196703, 0.05271489763487558, 0.05271489763487558, 0.05271489763487558, 0.05148547370465095, 0.05148547370465095, 0.05148547370465095, 0.1427244003268734, 0.1427244003268734, 0.1427244003268734, 0.14525753395885999, 0.14525753395885999, 0.14525753395885999, 0.13155176327680185, 0.13155176327680185, 0.13155176327680185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01449187574799038, 0.01449187574799038, 0.01449187574799038, 0.001873911110826687, 0.001873911110826687, 0.001873911110826687, 0.017306386352669012, 0.017306386352669012, 0.017306386352669012, 0.2949376010368683, 0.2949376010368683, 0.2949376010368683, 0.1644855357978917, 0.1644855357978917, 0.1644855357978917, 0.27085269038226834, 0.27085269038226834, 0.27085269038226834, 0.04480955656651042, 0.04480955656651042, 0.04480955656651042, 0.05347192432629455, 0.05347192432629455, 0.05347192432629455, 0.043458491884755146, 0.043458491884755146, 0.043458491884755146, 0.10055933453596011, 0.10055933453596011, 0.10055933453596011, 0.09919853983642557, 0.09919853983642557, 0.09919853983642557, 0.10773988655496503, 0.10773988655496503, 0.10773988655496503, 0.20742066888499522, 0.20742066888499522, 0.20742066888499522, 0.20386326224267803, 0.20386326224267803, 0.20386326224267803, 0.1903092090887316, 0.1903092090887316, 0.1903092090887316, 0.07446367408012833, 0.07446367408012833, 0.07446367408012833, 0.10797435841333625, 0.10797435841333625, 0.10797435841333625, 0.08019526865557036, 0.08019526865557036, 0.08019526865557036, 0.10809451436010387, 0.10809451436010387, 0.10809451436010387, 0.10878924573836024, 0.10878924573836024, 0.10878924573836024, 0.10197285410143941, 0.10197285410143941, 0.10197285410143941, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14584720349507208, 0.14584720349507208, 0.14584720349507208, 0.2941665040600233, 0.2941665040600233, 0.2941665040600233, 0.14424422271348025, 0.14424422271348025, 0.14424422271348025, 0.1030145303931389, 0.1030145303931389, 0.1030145303931389, 0.24746156225601312, 0.24746156225601312, 0.24746156225601312, 0.15751983034205264, 0.15751983034205264, 0.15751983034205264, 0.11875351027775838, 0.11875351027775838, 0.11875351027775838, 0.16555511818272595, 0.16555511818272595, 0.16555511818272595, 0.15878317176588808, 0.15878317176588808, 0.15878317176588808, 0.17140969598703926, 0.17140969598703926, 0.17140969598703926, 0.04310240722632519, 0.04310240722632519, 0.04310240722632519, 0.03426055068722922, 0.03426055068722922, 0.03426055068722922, 0.03181767539515201, 0.03181767539515201, 0.03181767539515201]}, "mutation_prompt": null}
{"id": "42b0f56a-dda6-47cf-88bd-cef84e3bb771", "solution": "import numpy as np\n\nclass AG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 100\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8  # small value to prevent division by zero\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for all particles\n            gradient = np.zeros_like(population)\n            for i in range(self.population_size):\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient\n            population += velocities\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AG_PSO", "description": "Adaptive Gradient-based Particle Swarm Optimization (AG-PSO) combines gradient information with particle swarm dynamics to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "metadata": {"aucs": [0.26369339375192824, 0.26369339375192824, 0.26369339375192824, 0.2527217098980197, 0.2527217098980197, 0.2527217098980197, 0.26159828037538724, 0.26159828037538724, 0.26159828037538724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07059314518371629, 0.07059314518371629, 0.07059314518371629, 0.05261333984308769, 0.05261333984308769, 0.05261333984308769, 0.03697046231540735, 0.03697046231540735, 0.03697046231540735, 0.01694785579421898, 0.01694785579421898, 0.01694785579421898, 0.025747182087950793, 0.025747182087950793, 0.025747182087950793, 0.020838687721282834, 0.020838687721282834, 0.020838687721282834, 0.7417582505441774, 0.7417582505441774, 0.7417582505441774, 0.8693201189167548, 0.8693201189167548, 0.8693201189167548, 0.866968977699619, 0.866968977699619, 0.866968977699619, 0.036884713170196703, 0.036884713170196703, 0.036884713170196703, 0.05271489763487558, 0.05271489763487558, 0.05271489763487558, 0.05148547370465095, 0.05148547370465095, 0.05148547370465095, 0.1427244003268734, 0.1427244003268734, 0.1427244003268734, 0.14525753395885999, 0.14525753395885999, 0.14525753395885999, 0.13155176327680185, 0.13155176327680185, 0.13155176327680185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01449187574799038, 0.01449187574799038, 0.01449187574799038, 0.001873911110826687, 0.001873911110826687, 0.001873911110826687, 0.017306386352669012, 0.017306386352669012, 0.017306386352669012, 0.2949376010368683, 0.2949376010368683, 0.2949376010368683, 0.1644855357978917, 0.1644855357978917, 0.1644855357978917, 0.27085269038226834, 0.27085269038226834, 0.27085269038226834, 0.04480955656651042, 0.04480955656651042, 0.04480955656651042, 0.05347192432629455, 0.05347192432629455, 0.05347192432629455, 0.043458491884755146, 0.043458491884755146, 0.043458491884755146, 0.10055933453596011, 0.10055933453596011, 0.10055933453596011, 0.09919853983642557, 0.09919853983642557, 0.09919853983642557, 0.10773988655496503, 0.10773988655496503, 0.10773988655496503, 0.20742066888499522, 0.20742066888499522, 0.20742066888499522, 0.20386326224267803, 0.20386326224267803, 0.20386326224267803, 0.1903092090887316, 0.1903092090887316, 0.1903092090887316, 0.07446367408012833, 0.07446367408012833, 0.07446367408012833, 0.10797435841333625, 0.10797435841333625, 0.10797435841333625, 0.08019526865557036, 0.08019526865557036, 0.08019526865557036, 0.10809451436010387, 0.10809451436010387, 0.10809451436010387, 0.10878924573836024, 0.10878924573836024, 0.10878924573836024, 0.10197285410143941, 0.10197285410143941, 0.10197285410143941, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14584720349507208, 0.14584720349507208, 0.14584720349507208, 0.2941665040600233, 0.2941665040600233, 0.2941665040600233, 0.14424422271348025, 0.14424422271348025, 0.14424422271348025, 0.1030145303931389, 0.1030145303931389, 0.1030145303931389, 0.24746156225601312, 0.24746156225601312, 0.24746156225601312, 0.15751983034205264, 0.15751983034205264, 0.15751983034205264, 0.11875351027775838, 0.11875351027775838, 0.11875351027775838, 0.16555511818272595, 0.16555511818272595, 0.16555511818272595, 0.15878317176588808, 0.15878317176588808, 0.15878317176588808, 0.17140969598703926, 0.17140969598703926, 0.17140969598703926, 0.04310240722632519, 0.04310240722632519, 0.04310240722632519, 0.03426055068722922, 0.03426055068722922, 0.03426055068722922, 0.03181767539515201, 0.03181767539515201, 0.03181767539515201]}, "mutation_prompt": null}
{"id": "a9be892b-f037-4d45-a145-e429a04e6d6d", "solution": "import numpy as np\n\nclass HGE_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.2  # cognitive coefficient\n        self.c2 = 1.8  # social coefficient\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8  # small value to prevent division by zero\n        self.mutation_factor = 0.8  # for differential evolution\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for a subset of particles\n            gradient = np.zeros_like(population)\n            chosen_indices = np.random.choice(self.population_size, self.population_size // 2, replace=False)\n            for i in chosen_indices:\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient selectively\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "HGE_PSO", "description": "Hybrid Gradient Evolutionary Particle Swarm Optimization (HGE-PSO) integrates differential evolution strategies with adaptive gradient-based particle dynamics to enhance exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.17238415669692914, "feedback": "The algorithm HGE_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.22.", "error": "", "parent_id": "f0313ee4-07a2-4ea5-889b-0c7b613f7e9e", "metadata": {"aucs": [0.5389430559856162, 0.5389430559856162, 0.5389430559856162, 0.5323865260834502, 0.5323865260834502, 0.5323865260834502, 0.5139592478770498, 0.5139592478770498, 0.5139592478770498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09898077723510701, 0.09898077723510701, 0.09898077723510701, 0.05340960150972063, 0.05340960150972063, 0.05340960150972063, 0.0764012280530425, 0.0764012280530425, 0.0764012280530425, 0.07401574364124175, 0.07401574364124175, 0.07401574364124175, 0.05759885006216847, 0.05759885006216847, 0.05759885006216847, 0.039746232976296425, 0.039746232976296425, 0.039746232976296425, 0.912707265638065, 0.912707265638065, 0.912707265638065, 0.912952084406533, 0.912952084406533, 0.912952084406533, 0.8917367812609889, 0.8917367812609889, 0.8917367812609889, 0.11043688539154539, 0.11043688539154539, 0.11043688539154539, 0.08740626018386666, 0.08740626018386666, 0.08740626018386666, 0.10323707124719017, 0.10323707124719017, 0.10323707124719017, 0.6183682782319335, 0.6183682782319335, 0.6183682782319335, 0.1848671184636138, 0.1848671184636138, 0.1848671184636138, 0.21129148989109758, 0.21129148989109758, 0.21129148989109758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02845996182465882, 0.02845996182465882, 0.02845996182465882, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03134301019042063, 0.03134301019042063, 0.03134301019042063, 0.01087784264311853, 0.01087784264311853, 0.01087784264311853, 0.010016363165759712, 0.010016363165759712, 0.010016363165759712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061315536862090125, 0.061315536862090125, 0.061315536862090125, 0.04109265802827289, 0.04109265802827289, 0.04109265802827289, 0.048928793929639336, 0.048928793929639336, 0.048928793929639336, 0.43208941863659833, 0.43208941863659833, 0.43208941863659833, 0.38471584854849994, 0.38471584854849994, 0.38471584854849994, 0.4154584247617614, 0.4154584247617614, 0.4154584247617614, 0.08127987153325744, 0.08127987153325744, 0.08127987153325744, 0.06389599482904595, 0.06389599482904595, 0.06389599482904595, 0.05964621461284292, 0.05964621461284292, 0.05964621461284292, 0.11569098450318938, 0.11569098450318938, 0.11569098450318938, 0.12230234286912378, 0.12230234286912378, 0.12230234286912378, 0.12126802842910489, 0.12126802842910489, 0.12126802842910489, 0.27691234997456937, 0.27691234997456937, 0.27691234997456937, 0.2720498656973108, 0.2720498656973108, 0.2720498656973108, 0.2471148331374533, 0.2471148331374533, 0.2471148331374533, 0.14616911713848035, 0.14616911713848035, 0.14616911713848035, 0.16022800635535528, 0.16022800635535528, 0.16022800635535528, 0.10447319744642158, 0.10447319744642158, 0.10447319744642158, 0.13638182816890898, 0.13638182816890898, 0.13638182816890898, 0.13463802327354601, 0.13463802327354601, 0.13463802327354601, 0.1338189335001433, 0.1338189335001433, 0.1338189335001433, 0.1668568670778321, 0.1668568670778321, 0.1668568670778321, 0.15854932500502805, 0.15854932500502805, 0.15854932500502805, 0.18696410979750278, 0.18696410979750278, 0.18696410979750278, 0.7126587724686791, 0.7126587724686791, 0.7126587724686791, 0.15317280871466266, 0.15317280871466266, 0.15317280871466266, 0.16457956997140633, 0.16457956997140633, 0.16457956997140633, 0.1629289771458894, 0.1629289771458894, 0.1629289771458894, 0.1993590012011226, 0.1993590012011226, 0.1993590012011226, 0.1599788749182608, 0.1599788749182608, 0.1599788749182608, 0.17429298801897752, 0.17429298801897752, 0.17429298801897752, 0.1688483410916055, 0.1688483410916055, 0.1688483410916055, 0.17154093876879395, 0.17154093876879395, 0.17154093876879395, 0.05414550106633509, 0.05414550106633509, 0.05414550106633509, 0.058525432153858636, 0.058525432153858636, 0.058525432153858636, 0.059245826580845096, 0.059245826580845096, 0.059245826580845096]}, "mutation_prompt": null}
{"id": "059a5985-5903-4711-8d24-e6bda4bfd956", "solution": "import numpy as np\n\nclass AGA_EPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5  # increased cognitive coefficient for faster adaptation\n        self.c2 = 1.5  # adjusted social coefficient for balanced attraction\n        self.inertia_weight = 0.7  # slightly higher inertia for stability\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # increased for more aggressive DE\n        self.crossover_rate = 0.8  # slightly reduced for focused DE\n        self.adaptive_scale = 0.01  # scaling factor for adaptive gradient influence\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for a subset of particles\n            gradient = np.zeros_like(population)\n            chosen_indices = np.random.choice(self.population_size, self.population_size // 2, replace=False)\n            for i in chosen_indices:\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptively scale the gradient contribution\n            gradient *= self.adaptive_scale\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          gradient)  # Incorporating adaptively scaled gradient\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AGA_EPSO", "description": "Adaptive Gradient-Assisted Evolutionary Particle Swarm Optimization (AGA-EPSO) enhances the exploration-exploitation balance through adaptive gradient scaling and dynamic parameter tuning within particle and evolutionary dynamics.", "configspace": "", "generation": 6, "fitness": 0.1513727505895457, "feedback": "The algorithm AGA_EPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "a9be892b-f037-4d45-a145-e429a04e6d6d", "metadata": {"aucs": [0.395834321328567, 0.395834321328567, 0.395834321328567, 0.3547927891386896, 0.3547927891386896, 0.3547927891386896, 0.36446547766844517, 0.36446547766844517, 0.36446547766844517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06106155363156862, 0.06106155363156862, 0.06106155363156862, 0.08108775314170125, 0.08108775314170125, 0.08108775314170125, 0.059076401647935706, 0.059076401647935706, 0.059076401647935706, 0.05334422875568212, 0.05334422875568212, 0.05334422875568212, 0.03117113386031456, 0.03117113386031456, 0.03117113386031456, 0.060269429412009745, 0.060269429412009745, 0.060269429412009745, 0.935779122743061, 0.935779122743061, 0.935779122743061, 0.9349126588218601, 0.9349126588218601, 0.9349126588218601, 0.9342124081781744, 0.9342124081781744, 0.9342124081781744, 0.05199370933491321, 0.05199370933491321, 0.05199370933491321, 0.08564634618734857, 0.08564634618734857, 0.08564634618734857, 0.10112584952072323, 0.10112584952072323, 0.10112584952072323, 0.20753290155625204, 0.20753290155625204, 0.20753290155625204, 0.14984499165688903, 0.14984499165688903, 0.14984499165688903, 0.31512038686290633, 0.31512038686290633, 0.31512038686290633, 0.04851238416292125, 0.04851238416292125, 0.04851238416292125, 0.02470449998842017, 0.02470449998842017, 0.02470449998842017, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010463740638954055, 0.0010463740638954055, 0.0010463740638954055, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006946808787471337, 0.006946808787471337, 0.006946808787471337, 0.04020599429513172, 0.04020599429513172, 0.04020599429513172, 0.029819841905785127, 0.029819841905785127, 0.029819841905785127, 0.33918825068376224, 0.33918825068376224, 0.33918825068376224, 0.35669194334264653, 0.35669194334264653, 0.35669194334264653, 0.35338286777359285, 0.35338286777359285, 0.35338286777359285, 0.07834707712032718, 0.07834707712032718, 0.07834707712032718, 0.0705177505534984, 0.0705177505534984, 0.0705177505534984, 0.053191566160380566, 0.053191566160380566, 0.053191566160380566, 0.11813303566539379, 0.11813303566539379, 0.11813303566539379, 0.11879597655641083, 0.11879597655641083, 0.11879597655641083, 0.11511623464851906, 0.11511623464851906, 0.11511623464851906, 0.2494688865925907, 0.2494688865925907, 0.2494688865925907, 0.24786119272559348, 0.24786119272559348, 0.24786119272559348, 0.23879853982065546, 0.23879853982065546, 0.23879853982065546, 0.1066094257641329, 0.1066094257641329, 0.1066094257641329, 0.13525576282632668, 0.13525576282632668, 0.13525576282632668, 0.09864040725021916, 0.09864040725021916, 0.09864040725021916, 0.12874341071918805, 0.12874341071918805, 0.12874341071918805, 0.16543217153039458, 0.16543217153039458, 0.16543217153039458, 0.15916769523520358, 0.15916769523520358, 0.15916769523520358, 0.15018324552637186, 0.15018324552637186, 0.15018324552637186, 0.1504468783004249, 0.1504468783004249, 0.1504468783004249, 0.15002236130157653, 0.15002236130157653, 0.15002236130157653, 0.4888279424422495, 0.4888279424422495, 0.4888279424422495, 0.16490508902846246, 0.16490508902846246, 0.16490508902846246, 0.1499877567560447, 0.1499877567560447, 0.1499877567560447, 0.16174746779486993, 0.16174746779486993, 0.16174746779486993, 0.193546887060409, 0.193546887060409, 0.193546887060409, 0.14283231794041729, 0.14283231794041729, 0.14283231794041729, 0.17158704740397002, 0.17158704740397002, 0.17158704740397002, 0.16167627299721066, 0.16167627299721066, 0.16167627299721066, 0.18880433758654136, 0.18880433758654136, 0.18880433758654136, 0.0670276040765937, 0.0670276040765937, 0.0670276040765937, 0.04224682657274059, 0.04224682657274059, 0.04224682657274059, 0.051646446039905425, 0.051646446039905425, 0.051646446039905425]}, "mutation_prompt": null}
{"id": "4084e111-3677-42ed-bc14-0b4be7564af1", "solution": "import numpy as np\n\nclass QESO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60  # Adjusted for better exploration\n        self.c1 = 1.5  # Improved cognitive coefficient\n        self.c2 = 1.5  # Improved social coefficient\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-6  # Enhanced precision\n        self.mutation_factor = 0.9  # Enhanced mutation factor\n        self.crossover_rate = 0.85\n        self.quantum_factor = 0.03  # Quantum influence factor\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Quantum-inspired position update\n            quantum_shift = np.random.uniform(-self.quantum_factor, self.quantum_factor, (self.population_size, self.dim))\n            population += quantum_shift\n\n            # Compute gradients for a subset of particles\n            gradient = np.zeros_like(population)\n            chosen_indices = np.random.choice(self.population_size, self.population_size // 3, replace=False)\n            for i in chosen_indices:\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.02 * gradient)  # Enhanced gradient influence\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QESO", "description": "Quantum-inspired Evolutionary Swarm Optimization (QESO) uses quantum superposition principles to enhance exploration and precision in dynamic particle adaptation.", "configspace": "", "generation": 7, "fitness": 0.16828429664459124, "feedback": "The algorithm QESO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.21.", "error": "", "parent_id": "a9be892b-f037-4d45-a145-e429a04e6d6d", "metadata": {"aucs": [0.41049121443142733, 0.41049121443142733, 0.41049121443142733, 0.39395668313688126, 0.39395668313688126, 0.39395668313688126, 0.42460725121215814, 0.42460725121215814, 0.42460725121215814, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06555083428335051, 0.06555083428335051, 0.06555083428335051, 0.06121866674518883, 0.06121866674518883, 0.06121866674518883, 0.0704109248407393, 0.0704109248407393, 0.0704109248407393, 0.06718587753878547, 0.06718587753878547, 0.06718587753878547, 0.027389748404426983, 0.027389748404426983, 0.027389748404426983, 0.037842777389033855, 0.037842777389033855, 0.037842777389033855, 0.9599685595550175, 0.9599685595550175, 0.9599685595550175, 0.9179881516462104, 0.9179881516462104, 0.9179881516462104, 0.96139727688049, 0.96139727688049, 0.96139727688049, 0.11985720425738489, 0.11985720425738489, 0.11985720425738489, 0.08995538305356154, 0.08995538305356154, 0.08995538305356154, 0.1313715178169116, 0.1313715178169116, 0.1313715178169116, 0.27693981659913713, 0.27693981659913713, 0.27693981659913713, 0.19833750067957467, 0.19833750067957467, 0.19833750067957467, 0.3053773776716747, 0.3053773776716747, 0.3053773776716747, 0.026552691659151084, 0.026552691659151084, 0.026552691659151084, 0.022431206950144, 0.022431206950144, 0.022431206950144, 0.03384674385136299, 0.03384674385136299, 0.03384674385136299, 0.061646022698372493, 0.061646022698372493, 0.061646022698372493, 0.014945910994621059, 0.014945910994621059, 0.014945910994621059, 0.022188749210483194, 0.022188749210483194, 0.022188749210483194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020675317638638835, 0.020675317638638835, 0.020675317638638835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00689884982526856, 0.00689884982526856, 0.00689884982526856, 0.03262582625365229, 0.03262582625365229, 0.03262582625365229, 0.021125730304073276, 0.021125730304073276, 0.021125730304073276, 0.39631660431604354, 0.39631660431604354, 0.39631660431604354, 0.3555169211934103, 0.3555169211934103, 0.3555169211934103, 0.39314281888517577, 0.39314281888517577, 0.39314281888517577, 0.06378168613863977, 0.06378168613863977, 0.06378168613863977, 0.06929139756165681, 0.06929139756165681, 0.06929139756165681, 0.07832800004310536, 0.07832800004310536, 0.07832800004310536, 0.12994339790703602, 0.12994339790703602, 0.12994339790703602, 0.13121918723298565, 0.13121918723298565, 0.13121918723298565, 0.10885297830504004, 0.10885297830504004, 0.10885297830504004, 0.23322992037333756, 0.23322992037333756, 0.23322992037333756, 0.27239572427309644, 0.27239572427309644, 0.27239572427309644, 0.25038087018434296, 0.25038087018434296, 0.25038087018434296, 0.1344064594069354, 0.1344064594069354, 0.1344064594069354, 0.11505216213701586, 0.11505216213701586, 0.11505216213701586, 0.10608583743279121, 0.10608583743279121, 0.10608583743279121, 0.18046098173120884, 0.18046098173120884, 0.18046098173120884, 0.1445300155795861, 0.1445300155795861, 0.1445300155795861, 0.18465806359997838, 0.18465806359997838, 0.18465806359997838, 0.16600843218279027, 0.16600843218279027, 0.16600843218279027, 0.1575265187840974, 0.1575265187840974, 0.1575265187840974, 0.16002035782787605, 0.16002035782787605, 0.16002035782787605, 0.668879046716031, 0.668879046716031, 0.668879046716031, 0.15121540260446964, 0.15121540260446964, 0.15121540260446964, 0.1675106746542615, 0.1675106746542615, 0.1675106746542615, 0.4375937937613884, 0.4375937937613884, 0.4375937937613884, 0.2034516209100925, 0.2034516209100925, 0.2034516209100925, 0.1506120905342817, 0.1506120905342817, 0.1506120905342817, 0.17636914714668783, 0.17636914714668783, 0.17636914714668783, 0.1890343123759357, 0.1890343123759357, 0.1890343123759357, 0.19065305929479115, 0.19065305929479115, 0.19065305929479115, 0.06352364094168061, 0.06352364094168061, 0.06352364094168061, 0.0511329745659288, 0.0511329745659288, 0.0511329745659288, 0.05146144428114863, 0.05146144428114863, 0.05146144428114863]}, "mutation_prompt": null}
{"id": "6a5bd979-cddc-453d-8981-b4e23fc1204e", "solution": "import numpy as np\n\nclass HGE_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.2  # cognitive coefficient\n        self.c2 = 1.8  # social coefficient\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8  # small value to prevent division by zero\n        self.mutation_factor = 0.8  # for differential evolution\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Compute gradients for a subset of particles\n            gradient = np.zeros_like(population)\n            chosen_indices = np.random.choice(self.population_size, self.population_size // 2, replace=False)\n            for i in chosen_indices:\n                original_value = func(population[i])\n                for d in range(self.dim):\n                    step = np.zeros(self.dim)\n                    step[d] = self.epsilon\n                    gradient[i][d] = (func(population[i] + step) - original_value) / self.epsilon\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population) -\n                          0.01 * gradient)  # Incorporating gradient selectively\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "HGE_PSO", "description": "Hybrid Gradient Evolutionary Particle Swarm Optimization (HGE-PSO) integrates differential evolution strategies with adaptive gradient-based particle dynamics to enhance exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a9be892b-f037-4d45-a145-e429a04e6d6d", "metadata": {"aucs": [0.5389430559856162, 0.5389430559856162, 0.5389430559856162, 0.5323865260834502, 0.5323865260834502, 0.5323865260834502, 0.5139592478770498, 0.5139592478770498, 0.5139592478770498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09898077723510701, 0.09898077723510701, 0.09898077723510701, 0.05340960150972063, 0.05340960150972063, 0.05340960150972063, 0.0764012280530425, 0.0764012280530425, 0.0764012280530425, 0.07401574364124175, 0.07401574364124175, 0.07401574364124175, 0.05759885006216847, 0.05759885006216847, 0.05759885006216847, 0.039746232976296425, 0.039746232976296425, 0.039746232976296425, 0.912707265638065, 0.912707265638065, 0.912707265638065, 0.912952084406533, 0.912952084406533, 0.912952084406533, 0.8917367812609889, 0.8917367812609889, 0.8917367812609889, 0.11043688539154539, 0.11043688539154539, 0.11043688539154539, 0.08740626018386666, 0.08740626018386666, 0.08740626018386666, 0.10323707124719017, 0.10323707124719017, 0.10323707124719017, 0.6183682782319335, 0.6183682782319335, 0.6183682782319335, 0.1848671184636138, 0.1848671184636138, 0.1848671184636138, 0.21129148989109758, 0.21129148989109758, 0.21129148989109758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02845996182465882, 0.02845996182465882, 0.02845996182465882, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03134301019042063, 0.03134301019042063, 0.03134301019042063, 0.01087784264311853, 0.01087784264311853, 0.01087784264311853, 0.010016363165759712, 0.010016363165759712, 0.010016363165759712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061315536862090125, 0.061315536862090125, 0.061315536862090125, 0.04109265802827289, 0.04109265802827289, 0.04109265802827289, 0.048928793929639336, 0.048928793929639336, 0.048928793929639336, 0.43208941863659833, 0.43208941863659833, 0.43208941863659833, 0.38471584854849994, 0.38471584854849994, 0.38471584854849994, 0.4154584247617614, 0.4154584247617614, 0.4154584247617614, 0.08127987153325744, 0.08127987153325744, 0.08127987153325744, 0.06389599482904595, 0.06389599482904595, 0.06389599482904595, 0.05964621461284292, 0.05964621461284292, 0.05964621461284292, 0.11569098450318938, 0.11569098450318938, 0.11569098450318938, 0.12230234286912378, 0.12230234286912378, 0.12230234286912378, 0.12126802842910489, 0.12126802842910489, 0.12126802842910489, 0.27691234997456937, 0.27691234997456937, 0.27691234997456937, 0.2720498656973108, 0.2720498656973108, 0.2720498656973108, 0.2471148331374533, 0.2471148331374533, 0.2471148331374533, 0.14616911713848035, 0.14616911713848035, 0.14616911713848035, 0.16022800635535528, 0.16022800635535528, 0.16022800635535528, 0.10447319744642158, 0.10447319744642158, 0.10447319744642158, 0.13638182816890898, 0.13638182816890898, 0.13638182816890898, 0.13463802327354601, 0.13463802327354601, 0.13463802327354601, 0.1338189335001433, 0.1338189335001433, 0.1338189335001433, 0.1668568670778321, 0.1668568670778321, 0.1668568670778321, 0.15854932500502805, 0.15854932500502805, 0.15854932500502805, 0.18696410979750278, 0.18696410979750278, 0.18696410979750278, 0.7126587724686791, 0.7126587724686791, 0.7126587724686791, 0.15317280871466266, 0.15317280871466266, 0.15317280871466266, 0.16457956997140633, 0.16457956997140633, 0.16457956997140633, 0.1629289771458894, 0.1629289771458894, 0.1629289771458894, 0.1993590012011226, 0.1993590012011226, 0.1993590012011226, 0.1599788749182608, 0.1599788749182608, 0.1599788749182608, 0.17429298801897752, 0.17429298801897752, 0.17429298801897752, 0.1688483410916055, 0.1688483410916055, 0.1688483410916055, 0.17154093876879395, 0.17154093876879395, 0.17154093876879395, 0.05414550106633509, 0.05414550106633509, 0.05414550106633509, 0.058525432153858636, 0.058525432153858636, 0.058525432153858636, 0.059245826580845096, 0.059245826580845096, 0.059245826580845096]}, "mutation_prompt": null}
{"id": "ba4fd30a-ec16-4734-9ff3-f4b2e228e108", "solution": "import numpy as np\n\nclass QE_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.0  # reduced cognitive coefficient\n        self.c2 = 2.0  # increased social coefficient for better convergence\n        self.inertia_weight = 0.7  # slightly increased inertia\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.crossover_rate = 0.85  # slightly decreased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Compute quantum-inspired random walks for particles\n            quantum_step_size = np.random.uniform(-0.2, 0.2, self.dim)\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population))\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_PSO", "description": "Quantum-inspired Evolutionary Particle Swarm Optimization (QE-PSO) integrates quantum behavior principles with adaptive evolutionary strategies for robust exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.22878509596492852, "feedback": "The algorithm QE_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "a9be892b-f037-4d45-a145-e429a04e6d6d", "metadata": {"aucs": [0.5957996898577966, 0.5957996898577966, 0.5957996898577966, 0.522987602193218, 0.522987602193218, 0.522987602193218, 0.5665483864660236, 0.5665483864660236, 0.5665483864660236, 0.02248718799328364, 0.02248718799328364, 0.02248718799328364, 0.04248074211329367, 0.04248074211329367, 0.04248074211329367, 0.10709017671795062, 0.10709017671795062, 0.10709017671795062, 0.10295311176983413, 0.10295311176983413, 0.10295311176983413, 0.10226165990450387, 0.10226165990450387, 0.10226165990450387, 0.07046062390210195, 0.07046062390210195, 0.07046062390210195, 0.1069033968077534, 0.1069033968077534, 0.1069033968077534, 0.0916109455153804, 0.0916109455153804, 0.0916109455153804, 0.044570085890651145, 0.044570085890651145, 0.044570085890651145, 0.9778450874511161, 0.9778450874511161, 0.9778450874511161, 0.98956831766005, 0.98956831766005, 0.98956831766005, 0.9709006367294656, 0.9709006367294656, 0.9709006367294656, 0.36885757396504903, 0.36885757396504903, 0.36885757396504903, 0.3316810699418937, 0.3316810699418937, 0.3316810699418937, 0.2897726634747789, 0.2897726634747789, 0.2897726634747789, 0.35335973442784274, 0.35335973442784274, 0.35335973442784274, 0.15641371100588608, 0.15641371100588608, 0.15641371100588608, 0.5927972257582717, 0.5927972257582717, 0.5927972257582717, 0.1910090359306309, 0.1910090359306309, 0.1910090359306309, 0.09618624885759797, 0.09618624885759797, 0.09618624885759797, 0.17392709294465636, 0.17392709294465636, 0.17392709294465636, 0.09750505491850348, 0.09750505491850348, 0.09750505491850348, 0.14533260065507236, 0.14533260065507236, 0.14533260065507236, 0.07788589353979603, 0.07788589353979603, 0.07788589353979603, 0.02863584917538342, 0.02863584917538342, 0.02863584917538342, 0.021260872130176134, 0.021260872130176134, 0.021260872130176134, 0.04735093906358434, 0.04735093906358434, 0.04735093906358434, 0.14360535444569145, 0.14360535444569145, 0.14360535444569145, 0.06055822288898727, 0.06055822288898727, 0.06055822288898727, 0.031043616212120706, 0.031043616212120706, 0.031043616212120706, 0.0296179431119159, 0.0296179431119159, 0.0296179431119159, 0.07889037331986615, 0.07889037331986615, 0.07889037331986615, 0.05896940458526312, 0.05896940458526312, 0.05896940458526312, 0.12158131045323084, 0.12158131045323084, 0.12158131045323084, 0.11171955234941433, 0.11171955234941433, 0.11171955234941433, 0.04945527503302727, 0.04945527503302727, 0.04945527503302727, 0.49290833494735375, 0.49290833494735375, 0.49290833494735375, 0.48606792220522543, 0.48606792220522543, 0.48606792220522543, 0.44237628420045727, 0.44237628420045727, 0.44237628420045727, 0.0900528580396891, 0.0900528580396891, 0.0900528580396891, 0.1127662437738629, 0.1127662437738629, 0.1127662437738629, 0.1347115597861237, 0.1347115597861237, 0.1347115597861237, 0.19423293835310695, 0.19423293835310695, 0.19423293835310695, 0.14734246788821603, 0.14734246788821603, 0.14734246788821603, 0.24361616388936047, 0.24361616388936047, 0.24361616388936047, 0.23659578691254723, 0.23659578691254723, 0.23659578691254723, 0.2049665169752678, 0.2049665169752678, 0.2049665169752678, 0.3156770101445614, 0.3156770101445614, 0.3156770101445614, 0.1391342459992151, 0.1391342459992151, 0.1391342459992151, 0.2043477475339529, 0.2043477475339529, 0.2043477475339529, 0.14724982449214552, 0.14724982449214552, 0.14724982449214552, 0.14756157632829914, 0.14756157632829914, 0.14756157632829914, 0.18218474498845194, 0.18218474498845194, 0.18218474498845194, 0.1668539560305511, 0.1668539560305511, 0.1668539560305511, 0.18182267232482907, 0.18182267232482907, 0.18182267232482907, 0.23853710119503269, 0.23853710119503269, 0.23853710119503269, 0.1974040158094591, 0.1974040158094591, 0.1974040158094591, 0.745734116497959, 0.745734116497959, 0.745734116497959, 0.15378851556457507, 0.15378851556457507, 0.15378851556457507, 0.16560486082026504, 0.16560486082026504, 0.16560486082026504, 0.16501274703237545, 0.16501274703237545, 0.16501274703237545, 0.6282678392550289, 0.6282678392550289, 0.6282678392550289, 0.14747496754614453, 0.14747496754614453, 0.14747496754614453, 0.18214584710498605, 0.18214584710498605, 0.18214584710498605, 0.1882016305723656, 0.1882016305723656, 0.1882016305723656, 0.1759242602142611, 0.1759242602142611, 0.1759242602142611, 0.08211510184176463, 0.08211510184176463, 0.08211510184176463, 0.07379439622678297, 0.07379439622678297, 0.07379439622678297, 0.08616838581957342, 0.08616838581957342, 0.08616838581957342]}, "mutation_prompt": null}
{"id": "2684bf53-ce7a-406a-ade6-8888b4815511", "solution": "import numpy as np\n\nclass QE_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5  # adjusted cognitive coefficient for better exploration\n        self.c2 = 1.5  # adjusted social coefficient for balanced influence\n        self.inertia_weight = 0.8  # adaptive inertia weight for improved stability\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8  # reduced mutation factor for controlled exploration\n        self.crossover_rate = 0.9  # slightly increased crossover rate for exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Compute quantum-inspired random walks for particles\n            quantum_step_size = np.random.uniform(-0.1, 0.1, self.dim)  # more conservative quantum step\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population))\n            population += velocities\n\n            # Apply differential evolution strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_PSO", "description": "Quantum-Inspired Evolutionary Particle Swarm Optimization with Adaptive Mutation and Inertia Adjustments enhances exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 10, "fitness": 0.21313579628947787, "feedback": "The algorithm QE_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "ba4fd30a-ec16-4734-9ff3-f4b2e228e108", "metadata": {"aucs": [0.4468866186331064, 0.4468866186331064, 0.4468866186331064, 0.45998841361303444, 0.45998841361303444, 0.45998841361303444, 0.46338673756404414, 0.46338673756404414, 0.46338673756404414, 0.08942175373916195, 0.08942175373916195, 0.08942175373916195, 0.015188582009368456, 0.015188582009368456, 0.015188582009368456, 0.07681244076447435, 0.07681244076447435, 0.07681244076447435, 0.10460755898591667, 0.10460755898591667, 0.10460755898591667, 0.09603462471542812, 0.09603462471542812, 0.09603462471542812, 0.11322227053998868, 0.11322227053998868, 0.11322227053998868, 0.09400704570193452, 0.09400704570193452, 0.09400704570193452, 0.11210214318049416, 0.11210214318049416, 0.11210214318049416, 0.06128836695467321, 0.06128836695467321, 0.06128836695467321, 0.9728811088740295, 0.9728811088740295, 0.9728811088740295, 0.9760649810423826, 0.9760649810423826, 0.9760649810423826, 0.9759834104048406, 0.9759834104048406, 0.9759834104048406, 0.30384676255833387, 0.30384676255833387, 0.30384676255833387, 0.26423163891387735, 0.26423163891387735, 0.26423163891387735, 0.30149761575416556, 0.30149761575416556, 0.30149761575416556, 0.45849778991026524, 0.45849778991026524, 0.45849778991026524, 0.26533382202928135, 0.26533382202928135, 0.26533382202928135, 0.24197821460290403, 0.24197821460290403, 0.24197821460290403, 0.1555562147997669, 0.1555562147997669, 0.1555562147997669, 0.11608837104369774, 0.11608837104369774, 0.11608837104369774, 0.11429935033649052, 0.11429935033649052, 0.11429935033649052, 0.08834664684913773, 0.08834664684913773, 0.08834664684913773, 0.15909510834080143, 0.15909510834080143, 0.15909510834080143, 0.06730691267577027, 0.06730691267577027, 0.06730691267577027, 0.04017559860013831, 0.04017559860013831, 0.04017559860013831, 0.031214072652829605, 0.031214072652829605, 0.031214072652829605, 0.0015726646764896435, 0.0015726646764896435, 0.0015726646764896435, 0.07869761270010678, 0.07869761270010678, 0.07869761270010678, 0.04297180714096316, 0.04297180714096316, 0.04297180714096316, 0.07275293248805337, 0.07275293248805337, 0.07275293248805337, 0.01228970545136343, 0.01228970545136343, 0.01228970545136343, 0.0179049367378864, 0.0179049367378864, 0.0179049367378864, 0.025459249195090683, 0.025459249195090683, 0.025459249195090683, 0.04313923530740671, 0.04313923530740671, 0.04313923530740671, 0.04618344164740262, 0.04618344164740262, 0.04618344164740262, 0.11527681286073677, 0.11527681286073677, 0.11527681286073677, 0.42133380120394703, 0.42133380120394703, 0.42133380120394703, 0.39322557542282466, 0.39322557542282466, 0.39322557542282466, 0.38633171169079583, 0.38633171169079583, 0.38633171169079583, 0.09751716825663026, 0.09751716825663026, 0.09751716825663026, 0.10664775707546015, 0.10664775707546015, 0.10664775707546015, 0.08825861828682557, 0.08825861828682557, 0.08825861828682557, 0.27237314663593426, 0.27237314663593426, 0.27237314663593426, 0.17186436820172857, 0.17186436820172857, 0.17186436820172857, 0.16777881120054572, 0.16777881120054572, 0.16777881120054572, 0.2463110892238921, 0.2463110892238921, 0.2463110892238921, 0.3322184374219801, 0.3322184374219801, 0.3322184374219801, 0.3073685785753759, 0.3073685785753759, 0.3073685785753759, 0.13609018458457012, 0.13609018458457012, 0.13609018458457012, 0.20144385918057384, 0.20144385918057384, 0.20144385918057384, 0.1220654124092766, 0.1220654124092766, 0.1220654124092766, 0.1942320159742459, 0.1942320159742459, 0.1942320159742459, 0.19166735928296552, 0.19166735928296552, 0.19166735928296552, 0.21223140450589906, 0.21223140450589906, 0.21223140450589906, 0.2483534695978734, 0.2483534695978734, 0.2483534695978734, 0.2948366976404492, 0.2948366976404492, 0.2948366976404492, 0.18986115172028728, 0.18986115172028728, 0.18986115172028728, 0.7440858466074217, 0.7440858466074217, 0.7440858466074217, 0.15564879203443582, 0.15564879203443582, 0.15564879203443582, 0.16741061165432314, 0.16741061165432314, 0.16741061165432314, 0.16490806035333594, 0.16490806035333594, 0.16490806035333594, 0.20559967250617106, 0.20559967250617106, 0.20559967250617106, 0.15162417755427615, 0.15162417755427615, 0.15162417755427615, 0.19341338489109405, 0.19341338489109405, 0.19341338489109405, 0.17932670036029918, 0.17932670036029918, 0.17932670036029918, 0.2024291272531762, 0.2024291272531762, 0.2024291272531762, 0.09236581116588238, 0.09236581116588238, 0.09236581116588238, 0.09300275277618852, 0.09300275277618852, 0.09300275277618852, 0.09235920359788574, 0.09235920359788574, 0.09235920359788574]}, "mutation_prompt": null}
{"id": "48c7606e-0499-48cf-99c8-102570d82718", "solution": "import numpy as np\n\nclass QE_GPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5  # moderate cognitive coefficient\n        self.c2 = 1.5  # moderate social coefficient\n        self.inertia_weight = 0.6  # balanced inertia\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8  # balanced mutation factor\n        self.crossover_rate = 0.9  # increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Quantum-inspired random walks with enhanced variance\n            quantum_step_size = np.random.uniform(-0.25, 0.25, self.dim)\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n            \n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population))\n            population += velocities\n\n            # Apply genetic-inspired mutation and crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_GPSO", "description": "Quantum-Enhanced Genetic Particle Swarm Optimization (QE-GPSO) fuses quantum random walks with genetic operators for enhanced search diversity and convergence.", "configspace": "", "generation": 11, "fitness": 0.26476568661649263, "feedback": "The algorithm QE_GPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "ba4fd30a-ec16-4734-9ff3-f4b2e228e108", "metadata": {"aucs": [0.6540144457156398, 0.6540144457156398, 0.6540144457156398, 0.6954247925714394, 0.6954247925714394, 0.6954247925714394, 0.7026045966963166, 0.7026045966963166, 0.7026045966963166, 0.11841030735421587, 0.11841030735421587, 0.11841030735421587, 0.1423782906033939, 0.1423782906033939, 0.1423782906033939, 0.036026685712614914, 0.036026685712614914, 0.036026685712614914, 0.10350678263515878, 0.10350678263515878, 0.10350678263515878, 0.1091260749381785, 0.1091260749381785, 0.1091260749381785, 0.12097628027285212, 0.12097628027285212, 0.12097628027285212, 0.08544966184829539, 0.08544966184829539, 0.08544966184829539, 0.11843437488631792, 0.11843437488631792, 0.11843437488631792, 0.12149130877606062, 0.12149130877606062, 0.12149130877606062, 0.9750760171757289, 0.9750760171757289, 0.9750760171757289, 0.9760337849883977, 0.9760337849883977, 0.9760337849883977, 0.9759222759044405, 0.9759222759044405, 0.9759222759044405, 0.4092605817213877, 0.4092605817213877, 0.4092605817213877, 0.4187636897445828, 0.4187636897445828, 0.4187636897445828, 0.4026899058577612, 0.4026899058577612, 0.4026899058577612, 0.48085251696228193, 0.48085251696228193, 0.48085251696228193, 0.2702496008523422, 0.2702496008523422, 0.2702496008523422, 0.18030562935436878, 0.18030562935436878, 0.18030562935436878, 0.26581842080642193, 0.26581842080642193, 0.26581842080642193, 0.12153788511328789, 0.12153788511328789, 0.12153788511328789, 0.17817975598427604, 0.17817975598427604, 0.17817975598427604, 0.11881877483527659, 0.11881877483527659, 0.11881877483527659, 0.11217472054623978, 0.11217472054623978, 0.11217472054623978, 0.10460327797636615, 0.10460327797636615, 0.10460327797636615, 0.054798880951233864, 0.054798880951233864, 0.054798880951233864, 0.10833457517457123, 0.10833457517457123, 0.10833457517457123, 0.15630057177831458, 0.15630057177831458, 0.15630057177831458, 0.23472039986172144, 0.23472039986172144, 0.23472039986172144, 0.07065733774931482, 0.07065733774931482, 0.07065733774931482, 0.3272739477373723, 0.3272739477373723, 0.3272739477373723, 0.05395676655588599, 0.05395676655588599, 0.05395676655588599, 0.12062105540103862, 0.12062105540103862, 0.12062105540103862, 0.14477117739962653, 0.14477117739962653, 0.14477117739962653, 0.09453664208087698, 0.09453664208087698, 0.09453664208087698, 0.11454672118366194, 0.11454672118366194, 0.11454672118366194, 0.22729271459941114, 0.22729271459941114, 0.22729271459941114, 0.5436211898047346, 0.5436211898047346, 0.5436211898047346, 0.5368101376940743, 0.5368101376940743, 0.5368101376940743, 0.506967758233096, 0.506967758233096, 0.506967758233096, 0.12212738002340628, 0.12212738002340628, 0.12212738002340628, 0.3027186982602509, 0.3027186982602509, 0.3027186982602509, 0.1375801882393587, 0.1375801882393587, 0.1375801882393587, 0.4797739402715422, 0.4797739402715422, 0.4797739402715422, 0.1740745600046819, 0.1740745600046819, 0.1740745600046819, 0.231897287218096, 0.231897287218096, 0.231897287218096, 0.35546770812671924, 0.35546770812671924, 0.35546770812671924, 0.21283045785777166, 0.21283045785777166, 0.21283045785777166, 0.34763393285289323, 0.34763393285289323, 0.34763393285289323, 0.13826419808478863, 0.13826419808478863, 0.13826419808478863, 0.1945945158271949, 0.1945945158271949, 0.1945945158271949, 0.12775321273191131, 0.12775321273191131, 0.12775321273191131, 0.17249910056736806, 0.17249910056736806, 0.17249910056736806, 0.19167299135280857, 0.19167299135280857, 0.19167299135280857, 0.21205621037568123, 0.21205621037568123, 0.21205621037568123, 0.22064635133182153, 0.22064635133182153, 0.22064635133182153, 0.20842696452695186, 0.20842696452695186, 0.20842696452695186, 0.39880870679289715, 0.39880870679289715, 0.39880870679289715, 0.8103832717913435, 0.8103832717913435, 0.8103832717913435, 0.15589876031204075, 0.15589876031204075, 0.15589876031204075, 0.1690753104890622, 0.1690753104890622, 0.1690753104890622, 0.16551201227026957, 0.16551201227026957, 0.16551201227026957, 0.2070409545524433, 0.2070409545524433, 0.2070409545524433, 0.15228323374551023, 0.15228323374551023, 0.15228323374551023, 0.17813767434491456, 0.17813767434491456, 0.17813767434491456, 0.18731704798355586, 0.18731704798355586, 0.18731704798355586, 0.2093597302606448, 0.2093597302606448, 0.2093597302606448, 0.09516761708018762, 0.09516761708018762, 0.09516761708018762, 0.09248114819751374, 0.09248114819751374, 0.09248114819751374, 0.11830595487525919, 0.11830595487525919, 0.11830595487525919]}, "mutation_prompt": null}
{"id": "99960324-2db2-4802-b73d-548a2f1d1f05", "solution": "import numpy as np\n\nclass AQG_PSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.0  # adaptive cognitive coefficient\n        self.c2 = 2.0  # adaptive social coefficient\n        self.inertia_weight = 0.7  # adaptive inertia\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.7  # dynamic mutation factor\n        self.crossover_rate = 0.85  # balanced crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Adaptive quantum-inspired random walks\n            quantum_step_size = np.random.uniform(-0.2, 0.2, self.dim)\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n            \n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions with adaptive coefficients\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (self.inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population))\n            population += velocities\n\n            # Apply dynamic mutation and crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQG_PSO", "description": "Adaptive Quantum Genetic PSO (AQG-PSO) utilizes adaptive coefficients and dynamic mutation to enhance global exploration and local exploitation.", "configspace": "", "generation": 12, "fitness": 0.23718718878387207, "feedback": "The algorithm AQG_PSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "48c7606e-0499-48cf-99c8-102570d82718", "metadata": {"aucs": [0.6161517272647825, 0.6161517272647825, 0.6161517272647825, 0.6073437687303904, 0.6073437687303904, 0.6073437687303904, 0.6123745538815527, 0.6123745538815527, 0.6123745538815527, 0.10355719749192727, 0.10355719749192727, 0.10355719749192727, 0.05216786531274065, 0.05216786531274065, 0.05216786531274065, 0.03693442085413157, 0.03693442085413157, 0.03693442085413157, 0.10373159417283606, 0.10373159417283606, 0.10373159417283606, 0.06587139367929284, 0.06587139367929284, 0.06587139367929284, 0.10033619087133283, 0.10033619087133283, 0.10033619087133283, 0.09310484659176199, 0.09310484659176199, 0.09310484659176199, 0.19118727660013612, 0.19118727660013612, 0.19118727660013612, 0.09783597215327877, 0.09783597215327877, 0.09783597215327877, 0.9768809601776454, 0.9768809601776454, 0.9768809601776454, 0.9895623307749069, 0.9895623307749069, 0.9895623307749069, 0.9772915307990739, 0.9772915307990739, 0.9772915307990739, 0.41319713599415786, 0.41319713599415786, 0.41319713599415786, 0.3418636916491722, 0.3418636916491722, 0.3418636916491722, 0.37178187125877804, 0.37178187125877804, 0.37178187125877804, 0.7584694354134441, 0.7584694354134441, 0.7584694354134441, 0.15576764797519882, 0.15576764797519882, 0.15576764797519882, 0.6035726492784104, 0.6035726492784104, 0.6035726492784104, 0.18777794026128525, 0.18777794026128525, 0.18777794026128525, 0.1300670458520239, 0.1300670458520239, 0.1300670458520239, 0.11276423202016173, 0.11276423202016173, 0.11276423202016173, 0.10758212566833769, 0.10758212566833769, 0.10758212566833769, 0.09198000758397051, 0.09198000758397051, 0.09198000758397051, 0.11818312947855536, 0.11818312947855536, 0.11818312947855536, 0.06078474498285502, 0.06078474498285502, 0.06078474498285502, 0.015585714626035752, 0.015585714626035752, 0.015585714626035752, 0.07224054633519461, 0.07224054633519461, 0.07224054633519461, 0.03728277631674026, 0.03728277631674026, 0.03728277631674026, 0.022141720894934935, 0.022141720894934935, 0.022141720894934935, 0.10603741641455033, 0.10603741641455033, 0.10603741641455033, 0.03008670348399245, 0.03008670348399245, 0.03008670348399245, 0.1286424170243845, 0.1286424170243845, 0.1286424170243845, 0.058504146290443315, 0.058504146290443315, 0.058504146290443315, 0.06940190751341946, 0.06940190751341946, 0.06940190751341946, 0.037901218705895356, 0.037901218705895356, 0.037901218705895356, 0.046748662278636166, 0.046748662278636166, 0.046748662278636166, 0.4659548932378028, 0.4659548932378028, 0.4659548932378028, 0.5198149718782374, 0.5198149718782374, 0.5198149718782374, 0.5130005779610824, 0.5130005779610824, 0.5130005779610824, 0.06851096994058103, 0.06851096994058103, 0.06851096994058103, 0.09321032153457787, 0.09321032153457787, 0.09321032153457787, 0.05689669134489195, 0.05689669134489195, 0.05689669134489195, 0.30912312171794953, 0.30912312171794953, 0.30912312171794953, 0.15853360976005482, 0.15853360976005482, 0.15853360976005482, 0.17863259712842106, 0.17863259712842106, 0.17863259712842106, 0.22748051493269972, 0.22748051493269972, 0.22748051493269972, 0.30667539057107884, 0.30667539057107884, 0.30667539057107884, 0.2905889195492477, 0.2905889195492477, 0.2905889195492477, 0.13275981027251382, 0.13275981027251382, 0.13275981027251382, 0.18378995279522437, 0.18378995279522437, 0.18378995279522437, 0.24351418722448193, 0.24351418722448193, 0.24351418722448193, 0.17046286328563542, 0.17046286328563542, 0.17046286328563542, 0.17850622298778052, 0.17850622298778052, 0.17850622298778052, 0.15810714796599623, 0.15810714796599623, 0.15810714796599623, 0.22350373844610305, 0.22350373844610305, 0.22350373844610305, 0.2375100911160123, 0.2375100911160123, 0.2375100911160123, 0.1890811673769036, 0.1890811673769036, 0.1890811673769036, 0.7782099507304483, 0.7782099507304483, 0.7782099507304483, 0.1530911872936811, 0.1530911872936811, 0.1530911872936811, 0.16705389864155862, 0.16705389864155862, 0.16705389864155862, 0.16534392960133104, 0.16534392960133104, 0.16534392960133104, 0.20042412941116805, 0.20042412941116805, 0.20042412941116805, 0.1519987624877216, 0.1519987624877216, 0.1519987624877216, 0.19541550391590679, 0.19541550391590679, 0.19541550391590679, 0.18926766993122401, 0.18926766993122401, 0.18926766993122401, 0.1774971861209007, 0.1774971861209007, 0.1774971861209007, 0.08241515096421204, 0.08241515096421204, 0.08241515096421204, 0.09361881937193706, 0.09361881937193706, 0.09361881937193706, 0.11478712628505727, 0.11478712628505727, 0.11478712628505727]}, "mutation_prompt": null}
{"id": "8fcbc2c1-eff7-436c-8ec8-d0bfce86fd91", "solution": "import numpy as np\n\nclass QG_CPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.7  # slightly increased cognitive coefficient\n        self.c2 = 1.7  # slightly increased social coefficient\n        self.inertia_weight = 0.7  # increased inertia for exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85  # slightly increased mutation factor\n        self.crossover_rate = 0.95  # further increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.population_size\n\n        def chaotic_sequence(length):\n            # Generate a chaotic sequence using logistic map\n            x = 0.7\n            sequence = []\n            for _ in range(length):\n                x = 4 * x * (1 - x)\n                sequence.append(x)\n            return np.array(sequence)\n\n        chaotic_weights = chaotic_sequence(self.budget)\n\n        while evaluations < self.budget:\n            # Chaotic-inspired random walks for inertia modulation\n            chaotic_index = evaluations % len(chaotic_weights)\n            inertia_weight = self.inertia_weight * chaotic_weights[chaotic_index]\n\n            # Quantum-inspired random walks with enhanced variance\n            quantum_step_size = np.random.uniform(-0.3, 0.3, self.dim)\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n            \n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions with chaotic inertia\n            r1, r2 = np.random.rand(), np.random.rand()\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - population) +\n                          self.c2 * r2 * (global_best - population))\n            population += velocities\n\n            # Apply genetic-inspired mutation and crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QG_CPSO", "description": "Quantum Genetic Chaotic Particle Swarm Optimization (QG-CPSO) integrates chaotic maps and enhanced genetic operations for diverse exploration and fast convergence.", "configspace": "", "generation": 13, "fitness": 0.2528028787472549, "feedback": "The algorithm QG_CPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "48c7606e-0499-48cf-99c8-102570d82718", "metadata": {"aucs": [0.7741566899415315, 0.7741566899415315, 0.7741566899415315, 0.7381616893747267, 0.7381616893747267, 0.7381616893747267, 0.7480246744315424, 0.7480246744315424, 0.7480246744315424, 0.034189068713952886, 0.034189068713952886, 0.034189068713952886, 0.07589402763557695, 0.07589402763557695, 0.07589402763557695, 0.059987095200700224, 0.059987095200700224, 0.059987095200700224, 0.07569815059226492, 0.07569815059226492, 0.07569815059226492, 0.022755801551518573, 0.022755801551518573, 0.022755801551518573, 0.09276738998399725, 0.09276738998399725, 0.09276738998399725, 0.05086616073292205, 0.05086616073292205, 0.05086616073292205, 0.11960418702251696, 0.11960418702251696, 0.11960418702251696, 0.050021595008015174, 0.050021595008015174, 0.050021595008015174, 0.987827131338063, 0.987827131338063, 0.987827131338063, 0.9778052616680142, 0.9778052616680142, 0.9778052616680142, 0.9778088732801182, 0.9778088732801182, 0.9778088732801182, 0.38056018991134466, 0.38056018991134466, 0.38056018991134466, 0.38962928105297046, 0.38962928105297046, 0.38962928105297046, 0.4109294653079454, 0.4109294653079454, 0.4109294653079454, 0.21638304334162606, 0.21638304334162606, 0.21638304334162606, 0.16131170632082925, 0.16131170632082925, 0.16131170632082925, 0.15900730839815969, 0.15900730839815969, 0.15900730839815969, 0.23231970351227593, 0.23231970351227593, 0.23231970351227593, 0.2316536356872858, 0.2316536356872858, 0.2316536356872858, 0.20955138699863995, 0.20955138699863995, 0.20955138699863995, 0.04468759459469862, 0.04468759459469862, 0.04468759459469862, 0.15938173146547574, 0.15938173146547574, 0.15938173146547574, 0.10085805766459122, 0.10085805766459122, 0.10085805766459122, 0.0637727127986234, 0.0637727127986234, 0.0637727127986234, 0.00020186570530400516, 0.00020186570530400516, 0.00020186570530400516, 0.04505536204152538, 0.04505536204152538, 0.04505536204152538, 0.48650237087899784, 0.48650237087899784, 0.48650237087899784, 0.02043587681498793, 0.02043587681498793, 0.02043587681498793, 0.09780980218522672, 0.09780980218522672, 0.09780980218522672, 0.04334111347277214, 0.04334111347277214, 0.04334111347277214, 0.18270321060023653, 0.18270321060023653, 0.18270321060023653, 0.12246809327898245, 0.12246809327898245, 0.12246809327898245, 0.08804205789036168, 0.08804205789036168, 0.08804205789036168, 0.27453049570551225, 0.27453049570551225, 0.27453049570551225, 0.2071649863005326, 0.2071649863005326, 0.2071649863005326, 0.6022623064924791, 0.6022623064924791, 0.6022623064924791, 0.549590866056725, 0.549590866056725, 0.549590866056725, 0.6808157029965032, 0.6808157029965032, 0.6808157029965032, 0.11542690913632336, 0.11542690913632336, 0.11542690913632336, 0.043098888279949676, 0.043098888279949676, 0.043098888279949676, 0.08283961073216473, 0.08283961073216473, 0.08283961073216473, 0.2633297828078994, 0.2633297828078994, 0.2633297828078994, 0.19539274936385242, 0.19539274936385242, 0.19539274936385242, 0.2177489346012339, 0.2177489346012339, 0.2177489346012339, 0.37373059479045245, 0.37373059479045245, 0.37373059479045245, 0.36896949593893347, 0.36896949593893347, 0.36896949593893347, 0.36337179741683423, 0.36337179741683423, 0.36337179741683423, 0.11722478290445615, 0.11722478290445615, 0.11722478290445615, 0.22730709145744687, 0.22730709145744687, 0.22730709145744687, 0.1399180121257383, 0.1399180121257383, 0.1399180121257383, 0.18796733690552614, 0.18796733690552614, 0.18796733690552614, 0.20247410562769153, 0.20247410562769153, 0.20247410562769153, 0.2159562429820373, 0.2159562429820373, 0.2159562429820373, 0.18838458085818033, 0.18838458085818033, 0.18838458085818033, 0.1902018984556385, 0.1902018984556385, 0.1902018984556385, 0.17710290357068703, 0.17710290357068703, 0.17710290357068703, 0.9077577859140028, 0.9077577859140028, 0.9077577859140028, 0.1585319269005373, 0.1585319269005373, 0.1585319269005373, 0.16973518009476396, 0.16973518009476396, 0.16973518009476396, 0.1259444397125009, 0.1259444397125009, 0.1259444397125009, 0.20831730858838593, 0.20831730858838593, 0.20831730858838593, 0.15551217066771228, 0.15551217066771228, 0.15551217066771228, 0.19547045922269035, 0.19547045922269035, 0.19547045922269035, 0.18729114228741506, 0.18729114228741506, 0.18729114228741506, 0.22567629241342357, 0.22567629241342357, 0.22567629241342357, 0.06994748586744315, 0.06994748586744315, 0.06994748586744315, 0.07436763460642415, 0.07436763460642415, 0.07436763460642415, 0.10627200162192929, 0.10627200162192929, 0.10627200162192929]}, "mutation_prompt": null}
{"id": "97cbb083-7b8c-47e2-b344-c1c705efe094", "solution": "import numpy as np\n\nclass QE_EHA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60  # increased population size for diversity\n        self.c1 = 1.7  # slightly increased cognitive coefficient\n        self.c2 = 1.3  # slightly decreased social coefficient\n        self.inertia_weight = 0.5  # reduced inertia for faster convergence\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.crossover_rate = 0.85  # slightly reduced crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Quantum-inspired random walks with enhanced variance\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.1\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            # Apply genetic-inspired mutation and crossover\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_EHA", "description": "Quantum-Enhanced Evolutionary Hybrid Algorithm (QE-EHA) combines quantum-inspired random walks with evolutionary strategies for robust exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.30104194206119717, "feedback": "The algorithm QE_EHA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "48c7606e-0499-48cf-99c8-102570d82718", "metadata": {"aucs": [0.7033763767160736, 0.7033763767160736, 0.7033763767160736, 0.6979086929928526, 0.6979086929928526, 0.6979086929928526, 0.7505128174684508, 0.7505128174684508, 0.7505128174684508, 0.0854983715472124, 0.0854983715472124, 0.0854983715472124, 0.21756527008293514, 0.21756527008293514, 0.21756527008293514, 0.07574093212482402, 0.07574093212482402, 0.07574093212482402, 0.11021160524616447, 0.11021160524616447, 0.11021160524616447, 0.13729654124243118, 0.13729654124243118, 0.13729654124243118, 0.10067022340260157, 0.10067022340260157, 0.10067022340260157, 0.10059483440240835, 0.10059483440240835, 0.10059483440240835, 0.10285839274117714, 0.10285839274117714, 0.10285839274117714, 0.08466433076025293, 0.08466433076025293, 0.08466433076025293, 0.9602731958090451, 0.9602731958090451, 0.9602731958090451, 0.972238688760861, 0.972238688760861, 0.972238688760861, 0.9731615541010015, 0.9731615541010015, 0.9731615541010015, 0.43902227591890775, 0.43902227591890775, 0.43902227591890775, 0.47563862067256935, 0.47563862067256935, 0.47563862067256935, 0.4161227368803332, 0.4161227368803332, 0.4161227368803332, 0.7831173633526795, 0.7831173633526795, 0.7831173633526795, 0.20618898029437138, 0.20618898029437138, 0.20618898029437138, 0.7383217681017128, 0.7383217681017128, 0.7383217681017128, 0.38189185617777743, 0.38189185617777743, 0.38189185617777743, 0.2963714057916609, 0.2963714057916609, 0.2963714057916609, 0.1259685983826161, 0.1259685983826161, 0.1259685983826161, 0.24341047800922522, 0.24341047800922522, 0.24341047800922522, 0.1847976133796566, 0.1847976133796566, 0.1847976133796566, 0.10226322069420579, 0.10226322069420579, 0.10226322069420579, 0.32683739590951133, 0.32683739590951133, 0.32683739590951133, 0.037474837211545986, 0.037474837211545986, 0.037474837211545986, 0.2490182377582233, 0.2490182377582233, 0.2490182377582233, 0.31003447723966626, 0.31003447723966626, 0.31003447723966626, 0.2425702849216349, 0.2425702849216349, 0.2425702849216349, 0.39616107039478177, 0.39616107039478177, 0.39616107039478177, 0.03851489748931858, 0.03851489748931858, 0.03851489748931858, 0.11044805629379384, 0.11044805629379384, 0.11044805629379384, 0.09118241815605121, 0.09118241815605121, 0.09118241815605121, 0.2067849096290465, 0.2067849096290465, 0.2067849096290465, 0.1425895729585409, 0.1425895729585409, 0.1425895729585409, 0.24914407917638903, 0.24914407917638903, 0.24914407917638903, 0.5292505593785235, 0.5292505593785235, 0.5292505593785235, 0.6061313207407105, 0.6061313207407105, 0.6061313207407105, 0.5460233921414869, 0.5460233921414869, 0.5460233921414869, 0.10456852536023886, 0.10456852536023886, 0.10456852536023886, 0.09581922708495583, 0.09581922708495583, 0.09581922708495583, 0.11017008253190308, 0.11017008253190308, 0.11017008253190308, 0.19360642471800027, 0.19360642471800027, 0.19360642471800027, 0.19229694417348486, 0.19229694417348486, 0.19229694417348486, 0.18672508705543645, 0.18672508705543645, 0.18672508705543645, 0.43424758277659237, 0.43424758277659237, 0.43424758277659237, 0.33843428076197757, 0.33843428076197757, 0.33843428076197757, 0.35928743031411337, 0.35928743031411337, 0.35928743031411337, 0.16934445007955856, 0.16934445007955856, 0.16934445007955856, 0.3263957075903021, 0.3263957075903021, 0.3263957075903021, 0.1300648221566616, 0.1300648221566616, 0.1300648221566616, 0.23049097180063693, 0.23049097180063693, 0.23049097180063693, 0.21059782901036184, 0.21059782901036184, 0.21059782901036184, 0.20610184588425884, 0.20610184588425884, 0.20610184588425884, 0.1880403922082422, 0.1880403922082422, 0.1880403922082422, 0.19476068680578806, 0.19476068680578806, 0.19476068680578806, 0.21836828544904918, 0.21836828544904918, 0.21836828544904918, 0.8610304728581668, 0.8610304728581668, 0.8610304728581668, 0.15609601934941342, 0.15609601934941342, 0.15609601934941342, 0.1681795493101239, 0.1681795493101239, 0.1681795493101239, 0.8055528184254064, 0.8055528184254064, 0.8055528184254064, 0.20601148584932205, 0.20601148584932205, 0.20601148584932205, 0.15363516289704404, 0.15363516289704404, 0.15363516289704404, 0.20349750764582064, 0.20349750764582064, 0.20349750764582064, 0.19825502244215787, 0.19825502244215787, 0.19825502244215787, 0.18594020276885448, 0.18594020276885448, 0.18594020276885448, 0.09341721573145101, 0.09341721573145101, 0.09341721573145101, 0.09543758810067227, 0.09543758810067227, 0.09543758810067227, 0.11079395281297089, 0.11079395281297089, 0.11079395281297089]}, "mutation_prompt": null}
{"id": "142391c6-afb4-45cf-9956-d22c1d32b6d1", "solution": "import numpy as np\n\nclass QE_AEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50  # reduced population size to allow more evaluations per individual\n        self.c1 = 1.5  # adjusted cognitive coefficient for adaptivity\n        self.c2 = 1.5  # balanced social coefficient\n        self.inertia_weight = 0.7  # increased inertia for better exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8  # adaptive mutation factor\n        self.crossover_rate_base = 0.8  # base crossover rate\n        self.crossover_rate_max = 0.95  # max crossover rate for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Quantum-inspired random walks with adaptive variance\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions with an adaptive strategy\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * ((self.budget - evaluations) / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            # Adaptive mutation and crossover\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 ((self.budget - evaluations) / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_AEEA", "description": "Quantum-Enhanced Adaptive Evolutionary Algorithm (QE-AEEA) utilizes adaptive parameters and quantum-inspired strategies for dynamic exploration and exploitation balancing.", "configspace": "", "generation": 15, "fitness": 0.30460083734971205, "feedback": "The algorithm QE_AEEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "97cbb083-7b8c-47e2-b344-c1c705efe094", "metadata": {"aucs": [0.7123419533822092, 0.7123419533822092, 0.7123419533822092, 0.7071118986798836, 0.7071118986798836, 0.7071118986798836, 0.7083185651052529, 0.7083185651052529, 0.7083185651052529, 0.06496158696906473, 0.06496158696906473, 0.06496158696906473, 0.33300755230615153, 0.33300755230615153, 0.33300755230615153, 0.15028746812457916, 0.15028746812457916, 0.15028746812457916, 0.14536694150577112, 0.14536694150577112, 0.14536694150577112, 0.10469216659599767, 0.10469216659599767, 0.10469216659599767, 0.12195826063302251, 0.12195826063302251, 0.12195826063302251, 0.09660643683361081, 0.09660643683361081, 0.09660643683361081, 0.09279494231234253, 0.09279494231234253, 0.09279494231234253, 0.10113451021451692, 0.10113451021451692, 0.10113451021451692, 0.9765978266457307, 0.9765978266457307, 0.9765978266457307, 0.9756161202983241, 0.9756161202983241, 0.9756161202983241, 0.9689492079792074, 0.9689492079792074, 0.9689492079792074, 0.4804991798175201, 0.4804991798175201, 0.4804991798175201, 0.48251077674661735, 0.48251077674661735, 0.48251077674661735, 0.41642265788773447, 0.41642265788773447, 0.41642265788773447, 0.7018248779990255, 0.7018248779990255, 0.7018248779990255, 0.6884278546129432, 0.6884278546129432, 0.6884278546129432, 0.6465036497955017, 0.6465036497955017, 0.6465036497955017, 0.1257406178787529, 0.1257406178787529, 0.1257406178787529, 0.12137007644168729, 0.12137007644168729, 0.12137007644168729, 0.41165015819453044, 0.41165015819453044, 0.41165015819453044, 0.1807841106036412, 0.1807841106036412, 0.1807841106036412, 0.16922071398800786, 0.16922071398800786, 0.16922071398800786, 0.31453630687275735, 0.31453630687275735, 0.31453630687275735, 0.17667412340947086, 0.17667412340947086, 0.17667412340947086, 0.0334623546490066, 0.0334623546490066, 0.0334623546490066, 0.0045529259608568795, 0.0045529259608568795, 0.0045529259608568795, 0.12986989230979218, 0.12986989230979218, 0.12986989230979218, 0.3810612746030808, 0.3810612746030808, 0.3810612746030808, 0.4792450702607395, 0.4792450702607395, 0.4792450702607395, 0.03650358380274665, 0.03650358380274665, 0.03650358380274665, 0.06655519001897314, 0.06655519001897314, 0.06655519001897314, 0.05906483630871118, 0.05906483630871118, 0.05906483630871118, 0.1918009159976144, 0.1918009159976144, 0.1918009159976144, 0.2614064813858884, 0.2614064813858884, 0.2614064813858884, 0.09424261260334099, 0.09424261260334099, 0.09424261260334099, 0.623666771418053, 0.623666771418053, 0.623666771418053, 0.6019833303148152, 0.6019833303148152, 0.6019833303148152, 0.6008814336608455, 0.6008814336608455, 0.6008814336608455, 0.09990230704033254, 0.09990230704033254, 0.09990230704033254, 0.16072447332418383, 0.16072447332418383, 0.16072447332418383, 0.09888711834311448, 0.09888711834311448, 0.09888711834311448, 0.19037625617626586, 0.19037625617626586, 0.19037625617626586, 0.18200394593658475, 0.18200394593658475, 0.18200394593658475, 0.31062112454922375, 0.31062112454922375, 0.31062112454922375, 0.3853259632540693, 0.3853259632540693, 0.3853259632540693, 0.4234695388782538, 0.4234695388782538, 0.4234695388782538, 0.35224158697626684, 0.35224158697626684, 0.35224158697626684, 0.20920816706148848, 0.20920816706148848, 0.20920816706148848, 0.1885790964114965, 0.1885790964114965, 0.1885790964114965, 0.20255141776995156, 0.20255141776995156, 0.20255141776995156, 0.24112011285258095, 0.24112011285258095, 0.24112011285258095, 0.21133495511075173, 0.21133495511075173, 0.21133495511075173, 0.21797202066081445, 0.21797202066081445, 0.21797202066081445, 0.1932322140182109, 0.1932322140182109, 0.1932322140182109, 0.19064710681820662, 0.19064710681820662, 0.19064710681820662, 0.2092956486659887, 0.2092956486659887, 0.2092956486659887, 0.8243206555245711, 0.8243206555245711, 0.8243206555245711, 0.16335346317911392, 0.16335346317911392, 0.16335346317911392, 0.1685091029332576, 0.1685091029332576, 0.1685091029332576, 0.7377427195162967, 0.7377427195162967, 0.7377427195162967, 0.20759238673753033, 0.20759238673753033, 0.20759238673753033, 0.12682615319848678, 0.12682615319848678, 0.12682615319848678, 0.18686812042922707, 0.18686812042922707, 0.18686812042922707, 0.20590347134959697, 0.20590347134959697, 0.20590347134959697, 0.20414087755549504, 0.20414087755549504, 0.20414087755549504, 0.08248302398857099, 0.08248302398857099, 0.08248302398857099, 0.09274456652337137, 0.09274456652337137, 0.09274456652337137, 0.12307547926764473, 0.12307547926764473, 0.12307547926764473]}, "mutation_prompt": null}
{"id": "e195e83c-b0f6-4cec-8179-a07a5355be1a", "solution": "import numpy as np\n\nclass QE_AEEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50  # reduced population size to allow more evaluations per individual\n        self.c1 = 1.5  # adjusted cognitive coefficient for adaptivity\n        self.c2 = 1.5  # balanced social coefficient\n        self.inertia_weight = 0.7  # increased inertia for better exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8  # adaptive mutation factor\n        self.crossover_rate_base = 0.8  # base crossover rate\n        self.crossover_rate_max = 0.95  # max crossover rate for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Quantum-inspired random walks with adaptive variance\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            # Evaluate quantum-inspired population\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            # Update personal best with quantum-inspired population\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            # Update velocities and positions with an adaptive strategy\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * ((self.budget - evaluations) / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            # Adaptive mutation and crossover\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 ((self.budget - evaluations) / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            # Enforce bounds\n            population = np.clip(population, lower_bound, upper_bound)\n\n            # Evaluate and update personal bests\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_AEEA", "description": "Quantum-Enhanced Adaptive Evolutionary Algorithm (QE-AEEA) utilizes adaptive parameters and quantum-inspired strategies for dynamic exploration and exploitation balancing.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "142391c6-afb4-45cf-9956-d22c1d32b6d1", "metadata": {"aucs": [0.7123419533822092, 0.7123419533822092, 0.7123419533822092, 0.7071118986798836, 0.7071118986798836, 0.7071118986798836, 0.7083185651052529, 0.7083185651052529, 0.7083185651052529, 0.06496158696906473, 0.06496158696906473, 0.06496158696906473, 0.33300755230615153, 0.33300755230615153, 0.33300755230615153, 0.15028746812457916, 0.15028746812457916, 0.15028746812457916, 0.14536694150577112, 0.14536694150577112, 0.14536694150577112, 0.10469216659599767, 0.10469216659599767, 0.10469216659599767, 0.12195826063302251, 0.12195826063302251, 0.12195826063302251, 0.09660643683361081, 0.09660643683361081, 0.09660643683361081, 0.09279494231234253, 0.09279494231234253, 0.09279494231234253, 0.10113451021451692, 0.10113451021451692, 0.10113451021451692, 0.9765978266457307, 0.9765978266457307, 0.9765978266457307, 0.9756161202983241, 0.9756161202983241, 0.9756161202983241, 0.9689492079792074, 0.9689492079792074, 0.9689492079792074, 0.4804991798175201, 0.4804991798175201, 0.4804991798175201, 0.48251077674661735, 0.48251077674661735, 0.48251077674661735, 0.41642265788773447, 0.41642265788773447, 0.41642265788773447, 0.7018248779990255, 0.7018248779990255, 0.7018248779990255, 0.6884278546129432, 0.6884278546129432, 0.6884278546129432, 0.6465036497955017, 0.6465036497955017, 0.6465036497955017, 0.1257406178787529, 0.1257406178787529, 0.1257406178787529, 0.12137007644168729, 0.12137007644168729, 0.12137007644168729, 0.41165015819453044, 0.41165015819453044, 0.41165015819453044, 0.1807841106036412, 0.1807841106036412, 0.1807841106036412, 0.16922071398800786, 0.16922071398800786, 0.16922071398800786, 0.31453630687275735, 0.31453630687275735, 0.31453630687275735, 0.17667412340947086, 0.17667412340947086, 0.17667412340947086, 0.0334623546490066, 0.0334623546490066, 0.0334623546490066, 0.0045529259608568795, 0.0045529259608568795, 0.0045529259608568795, 0.12986989230979218, 0.12986989230979218, 0.12986989230979218, 0.3810612746030808, 0.3810612746030808, 0.3810612746030808, 0.4792450702607395, 0.4792450702607395, 0.4792450702607395, 0.03650358380274665, 0.03650358380274665, 0.03650358380274665, 0.06655519001897314, 0.06655519001897314, 0.06655519001897314, 0.05906483630871118, 0.05906483630871118, 0.05906483630871118, 0.1918009159976144, 0.1918009159976144, 0.1918009159976144, 0.2614064813858884, 0.2614064813858884, 0.2614064813858884, 0.09424261260334099, 0.09424261260334099, 0.09424261260334099, 0.623666771418053, 0.623666771418053, 0.623666771418053, 0.6019833303148152, 0.6019833303148152, 0.6019833303148152, 0.6008814336608455, 0.6008814336608455, 0.6008814336608455, 0.09990230704033254, 0.09990230704033254, 0.09990230704033254, 0.16072447332418383, 0.16072447332418383, 0.16072447332418383, 0.09888711834311448, 0.09888711834311448, 0.09888711834311448, 0.19037625617626586, 0.19037625617626586, 0.19037625617626586, 0.18200394593658475, 0.18200394593658475, 0.18200394593658475, 0.31062112454922375, 0.31062112454922375, 0.31062112454922375, 0.3853259632540693, 0.3853259632540693, 0.3853259632540693, 0.4234695388782538, 0.4234695388782538, 0.4234695388782538, 0.35224158697626684, 0.35224158697626684, 0.35224158697626684, 0.20920816706148848, 0.20920816706148848, 0.20920816706148848, 0.1885790964114965, 0.1885790964114965, 0.1885790964114965, 0.20255141776995156, 0.20255141776995156, 0.20255141776995156, 0.24112011285258095, 0.24112011285258095, 0.24112011285258095, 0.21133495511075173, 0.21133495511075173, 0.21133495511075173, 0.21797202066081445, 0.21797202066081445, 0.21797202066081445, 0.1932322140182109, 0.1932322140182109, 0.1932322140182109, 0.19064710681820662, 0.19064710681820662, 0.19064710681820662, 0.2092956486659887, 0.2092956486659887, 0.2092956486659887, 0.8243206555245711, 0.8243206555245711, 0.8243206555245711, 0.16335346317911392, 0.16335346317911392, 0.16335346317911392, 0.1685091029332576, 0.1685091029332576, 0.1685091029332576, 0.7377427195162967, 0.7377427195162967, 0.7377427195162967, 0.20759238673753033, 0.20759238673753033, 0.20759238673753033, 0.12682615319848678, 0.12682615319848678, 0.12682615319848678, 0.18686812042922707, 0.18686812042922707, 0.18686812042922707, 0.20590347134959697, 0.20590347134959697, 0.20590347134959697, 0.20414087755549504, 0.20414087755549504, 0.20414087755549504, 0.08248302398857099, 0.08248302398857099, 0.08248302398857099, 0.09274456652337137, 0.09274456652337137, 0.09274456652337137, 0.12307547926764473, 0.12307547926764473, 0.12307547926764473]}, "mutation_prompt": null}
{"id": "14216d75-cd3d-48df-b697-18a208488fdb", "solution": "import numpy as np\n\nclass QE_DSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60  # increased population size for diversity\n        self.c1 = 1.3  # adjusted cognitive coefficient for better local search\n        self.c2 = 1.7  # adjusted social coefficient for stronger global search\n        self.inertia_weight = 0.6  # adjusted inertia for adaptive exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # increased mutation factor for variability\n        self.crossover_rate_base = 0.85  # slightly increased base crossover rate\n        self.crossover_rate_max = 0.98  # increased max crossover rate for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.randn(self.population_size, self.dim)\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                inertia_weight_dynamic = self.inertia_weight * ((self.budget - evaluations) / self.budget)\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 ((self.budget - evaluations) / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_DSO", "description": "Quantum-Enhanced Dynamic Swarm Optimization (QE-DSO) incorporates dynamic parameter adjustment and quantum-inspired exploration for robust global optimization.", "configspace": "", "generation": 17, "fitness": 0.29183739328028535, "feedback": "The algorithm QE_DSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "142391c6-afb4-45cf-9956-d22c1d32b6d1", "metadata": {"aucs": [0.6816268252516787, 0.6816268252516787, 0.6816268252516787, 0.6891044168182191, 0.6891044168182191, 0.6891044168182191, 0.6982896241582486, 0.6982896241582486, 0.6982896241582486, 0.3322890499528911, 0.3322890499528911, 0.3322890499528911, 0.030009126968630673, 0.030009126968630673, 0.030009126968630673, 0.10178028348355694, 0.10178028348355694, 0.10178028348355694, 0.13983960437043808, 0.13983960437043808, 0.13983960437043808, 0.10813465417402346, 0.10813465417402346, 0.10813465417402346, 0.11082610104539292, 0.11082610104539292, 0.11082610104539292, 0.09754280651430147, 0.09754280651430147, 0.09754280651430147, 0.09665120565448737, 0.09665120565448737, 0.09665120565448737, 0.087433857965593, 0.087433857965593, 0.087433857965593, 0.971267405177484, 0.971267405177484, 0.971267405177484, 0.972867343124277, 0.972867343124277, 0.972867343124277, 0.9744375101571091, 0.9744375101571091, 0.9744375101571091, 0.3817222248321691, 0.3817222248321691, 0.3817222248321691, 0.4059932583195902, 0.4059932583195902, 0.4059932583195902, 0.45639902252826237, 0.45639902252826237, 0.45639902252826237, 0.65282482559416, 0.65282482559416, 0.65282482559416, 0.5724732004786521, 0.5724732004786521, 0.5724732004786521, 0.6378606733863899, 0.6378606733863899, 0.6378606733863899, 0.2543255773505444, 0.2543255773505444, 0.2543255773505444, 0.2909035846383664, 0.2909035846383664, 0.2909035846383664, 0.21360390624435344, 0.21360390624435344, 0.21360390624435344, 0.08823773056155293, 0.08823773056155293, 0.08823773056155293, 0.408972083076076, 0.408972083076076, 0.408972083076076, 0.11444706008911221, 0.11444706008911221, 0.11444706008911221, 0.09392240782374339, 0.09392240782374339, 0.09392240782374339, 0.001935966091321295, 0.001935966091321295, 0.001935966091321295, 0.019845962752188084, 0.019845962752188084, 0.019845962752188084, 0.31066809176132293, 0.31066809176132293, 0.31066809176132293, 0.05682221793510056, 0.05682221793510056, 0.05682221793510056, 0.30682156755046575, 0.30682156755046575, 0.30682156755046575, 0.03492589009891145, 0.03492589009891145, 0.03492589009891145, 0.05552176987926993, 0.05552176987926993, 0.05552176987926993, 0.048725452917509404, 0.048725452917509404, 0.048725452917509404, 0.21699781690656184, 0.21699781690656184, 0.21699781690656184, 0.21219454506139546, 0.21219454506139546, 0.21219454506139546, 0.2292521056343454, 0.2292521056343454, 0.2292521056343454, 0.5856464370744422, 0.5856464370744422, 0.5856464370744422, 0.5870523792874476, 0.5870523792874476, 0.5870523792874476, 0.5381860375215308, 0.5381860375215308, 0.5381860375215308, 0.10880993561914587, 0.10880993561914587, 0.10880993561914587, 0.11380488082289297, 0.11380488082289297, 0.11380488082289297, 0.13387019060091265, 0.13387019060091265, 0.13387019060091265, 0.22826945576690783, 0.22826945576690783, 0.22826945576690783, 0.1778104100205179, 0.1778104100205179, 0.1778104100205179, 0.1877364904019907, 0.1877364904019907, 0.1877364904019907, 0.24405334147027002, 0.24405334147027002, 0.24405334147027002, 0.4143767749069718, 0.4143767749069718, 0.4143767749069718, 0.3729596350911898, 0.3729596350911898, 0.3729596350911898, 0.28744619717240016, 0.28744619717240016, 0.28744619717240016, 0.18854520327372204, 0.18854520327372204, 0.18854520327372204, 0.23744831613077344, 0.23744831613077344, 0.23744831613077344, 0.21464370039820346, 0.21464370039820346, 0.21464370039820346, 0.21408309423883887, 0.21408309423883887, 0.21408309423883887, 0.26355284462749995, 0.26355284462749995, 0.26355284462749995, 0.23151230845554638, 0.23151230845554638, 0.23151230845554638, 0.18984260332593184, 0.18984260332593184, 0.18984260332593184, 0.19373965670808047, 0.19373965670808047, 0.19373965670808047, 0.8269257924274195, 0.8269257924274195, 0.8269257924274195, 0.1643515249204215, 0.1643515249204215, 0.1643515249204215, 0.16741037102989487, 0.16741037102989487, 0.16741037102989487, 0.7470441817033233, 0.7470441817033233, 0.7470441817033233, 0.20397068463334622, 0.20397068463334622, 0.20397068463334622, 0.152498504790767, 0.152498504790767, 0.152498504790767, 0.18026134397724813, 0.18026134397724813, 0.18026134397724813, 0.2003339092096491, 0.2003339092096491, 0.2003339092096491, 0.19979910825652114, 0.19979910825652114, 0.19979910825652114, 0.09111068996084049, 0.09111068996084049, 0.09111068996084049, 0.09240986314134203, 0.09240986314134203, 0.09240986314134203, 0.11528969288685931, 0.11528969288685931, 0.11528969288685931]}, "mutation_prompt": null}
{"id": "ea0936be-8dee-4d29-95b1-b4c4d9d35173", "solution": "import numpy as np\n\nclass QE_AEES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.4  # slightly adjusted cognitive coefficient\n        self.c2 = 1.6  # slightly adjusted social coefficient\n        self.inertia_weight = 0.6  # lower inertia for faster convergence\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # slightly increased mutation factor\n        self.crossover_rate_base = 0.75  # slightly reduced base crossover rate\n        self.crossover_rate_max = 0.9  # slightly reduced max crossover rate\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * ((self.budget - evaluations) / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 ((self.budget - evaluations) / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_AEES", "description": "Quantum-Enhanced Adaptive Evolutionary Strategy (QE-AEES) leverages quantum-inspired perturbations and adaptive strategies for enhanced exploration and exploitation balance in optimization.", "configspace": "", "generation": 18, "fitness": 0.3206281563228362, "feedback": "The algorithm QE_AEES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "142391c6-afb4-45cf-9956-d22c1d32b6d1", "metadata": {"aucs": [0.7516825778851234, 0.7516825778851234, 0.7516825778851234, 0.7304839843590797, 0.7304839843590797, 0.7304839843590797, 0.7441863969863871, 0.7441863969863871, 0.7441863969863871, 0.4297172293284889, 0.4297172293284889, 0.4297172293284889, 0.3787283483005337, 0.3787283483005337, 0.3787283483005337, 0.41635620169630516, 0.41635620169630516, 0.41635620169630516, 0.10975691684903655, 0.10975691684903655, 0.10975691684903655, 0.10250807722014887, 0.10250807722014887, 0.10250807722014887, 0.10302339927167536, 0.10302339927167536, 0.10302339927167536, 0.10986984525082877, 0.10986984525082877, 0.10986984525082877, 0.1202074190418373, 0.1202074190418373, 0.1202074190418373, 0.12446479133896304, 0.12446479133896304, 0.12446479133896304, 0.9730861220284992, 0.9730861220284992, 0.9730861220284992, 0.9768320078366055, 0.9768320078366055, 0.9768320078366055, 0.9745531044322907, 0.9745531044322907, 0.9745531044322907, 0.4227320995698759, 0.4227320995698759, 0.4227320995698759, 0.5223396849357446, 0.5223396849357446, 0.5223396849357446, 0.5432216633152905, 0.5432216633152905, 0.5432216633152905, 0.6974409354706264, 0.6974409354706264, 0.6974409354706264, 0.19043418388168287, 0.19043418388168287, 0.19043418388168287, 0.21854306910009913, 0.21854306910009913, 0.21854306910009913, 0.19565503720873256, 0.19565503720873256, 0.19565503720873256, 0.3048809201459989, 0.3048809201459989, 0.3048809201459989, 0.4875932720717583, 0.4875932720717583, 0.4875932720717583, 0.37299984405667475, 0.37299984405667475, 0.37299984405667475, 0.38565889018501653, 0.38565889018501653, 0.38565889018501653, 0.2092521745173821, 0.2092521745173821, 0.2092521745173821, 0.07453147641450708, 0.07453147641450708, 0.07453147641450708, 0.01179580375581879, 0.01179580375581879, 0.01179580375581879, 0.06364540854345269, 0.06364540854345269, 0.06364540854345269, 0.45599489194949006, 0.45599489194949006, 0.45599489194949006, 0.34418608503315795, 0.34418608503315795, 0.34418608503315795, 0.41295706317190495, 0.41295706317190495, 0.41295706317190495, 0.04013465119282755, 0.04013465119282755, 0.04013465119282755, 0.22087306205727197, 0.22087306205727197, 0.22087306205727197, 0.05087210064013181, 0.05087210064013181, 0.05087210064013181, 0.28660114195716124, 0.28660114195716124, 0.28660114195716124, 0.1982841897612443, 0.1982841897612443, 0.1982841897612443, 0.16959472523449715, 0.16959472523449715, 0.16959472523449715, 0.5774618865240336, 0.5774618865240336, 0.5774618865240336, 0.6063010218249009, 0.6063010218249009, 0.6063010218249009, 0.6365254704784074, 0.6365254704784074, 0.6365254704784074, 0.1407831574452577, 0.1407831574452577, 0.1407831574452577, 0.12011517386751625, 0.12011517386751625, 0.12011517386751625, 0.1358731044798509, 0.1358731044798509, 0.1358731044798509, 0.1412947785024904, 0.1412947785024904, 0.1412947785024904, 0.15527192390874311, 0.15527192390874311, 0.15527192390874311, 0.3883133931413064, 0.3883133931413064, 0.3883133931413064, 0.29350001168741535, 0.29350001168741535, 0.29350001168741535, 0.33496181508357603, 0.33496181508357603, 0.33496181508357603, 0.17798725893832978, 0.17798725893832978, 0.17798725893832978, 0.13734485530892893, 0.13734485530892893, 0.13734485530892893, 0.2264812948354883, 0.2264812948354883, 0.2264812948354883, 0.18046186933736608, 0.18046186933736608, 0.18046186933736608, 0.19080987443188446, 0.19080987443188446, 0.19080987443188446, 0.19629061383301127, 0.19629061383301127, 0.19629061383301127, 0.21258960321767506, 0.21258960321767506, 0.21258960321767506, 0.22462382375623113, 0.22462382375623113, 0.22462382375623113, 0.1945343741201062, 0.1945343741201062, 0.1945343741201062, 0.1793591731091585, 0.1793591731091585, 0.1793591731091585, 0.8489717389933786, 0.8489717389933786, 0.8489717389933786, 0.15629094033441904, 0.15629094033441904, 0.15629094033441904, 0.16717286428134936, 0.16717286428134936, 0.16717286428134936, 0.20554020627614167, 0.20554020627614167, 0.20554020627614167, 0.6878791550924568, 0.6878791550924568, 0.6878791550924568, 0.7142922986845408, 0.7142922986845408, 0.7142922986845408, 0.21413118221199723, 0.21413118221199723, 0.21413118221199723, 0.1806381499573403, 0.1806381499573403, 0.1806381499573403, 0.18552872116941332, 0.18552872116941332, 0.18552872116941332, 0.10595943761696092, 0.10595943761696092, 0.10595943761696092, 0.12368324825588006, 0.12368324825588006, 0.12368324825588006, 0.11857603854249721, 0.11857603854249721, 0.11857603854249721]}, "mutation_prompt": null}
{"id": "0a4d379a-3bfb-4d9c-96ec-cabd13845399", "solution": "import numpy as np\n\nclass QE_AEES_2_0:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.2  # further adjusted cognitive coefficient\n        self.c2 = 1.8  # further adjusted social coefficient\n        self.inertia_weight = 0.7  # increased inertia for better exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85  # slightly reduced mutation factor\n        self.crossover_rate_base = 0.7  # slightly reduced base crossover rate\n        self.crossover_rate_max = 0.95  # increased max crossover rate\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.1\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * ((self.budget - evaluations) / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 ((self.budget - evaluations) / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QE_AEES_2_0", "description": "Quantum-Enhanced Adaptive Evolutionary Strategy 2.0 (QE-AEES 2.0) introduces adaptive learning rates and dynamic hyperparameter adjustment for improved convergence in complex optimization landscapes.", "configspace": "", "generation": 19, "fitness": 0.2767183148341605, "feedback": "The algorithm QE_AEES_2_0 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "ea0936be-8dee-4d29-95b1-b4c4d9d35173", "metadata": {"aucs": [0.7214422822528543, 0.7214422822528543, 0.7214422822528543, 0.6863807157815073, 0.6863807157815073, 0.6863807157815073, 0.6920823347706124, 0.6920823347706124, 0.6920823347706124, 0.312416048964552, 0.312416048964552, 0.312416048964552, 0.33102150393779006, 0.33102150393779006, 0.33102150393779006, 0.2397039081213551, 0.2397039081213551, 0.2397039081213551, 0.09424155046438953, 0.09424155046438953, 0.09424155046438953, 0.10532179225006022, 0.10532179225006022, 0.10532179225006022, 0.10312440729499517, 0.10312440729499517, 0.10312440729499517, 0.09529756634086939, 0.09529756634086939, 0.09529756634086939, 0.10854773674697427, 0.10854773674697427, 0.10854773674697427, 0.08919307327176196, 0.08919307327176196, 0.08919307327176196, 0.9766906104344079, 0.9766906104344079, 0.9766906104344079, 0.9903096479740289, 0.9903096479740289, 0.9903096479740289, 0.9868305614945337, 0.9868305614945337, 0.9868305614945337, 0.4531333427701907, 0.4531333427701907, 0.4531333427701907, 0.5331821319423058, 0.5331821319423058, 0.5331821319423058, 0.41753231747071795, 0.41753231747071795, 0.41753231747071795, 0.21246647675290664, 0.21246647675290664, 0.21246647675290664, 0.20752172944283598, 0.20752172944283598, 0.20752172944283598, 0.22137676265964024, 0.22137676265964024, 0.22137676265964024, 0.1684648091462848, 0.1684648091462848, 0.1684648091462848, 0.12280632672582337, 0.12280632672582337, 0.12280632672582337, 0.1228030676054721, 0.1228030676054721, 0.1228030676054721, 0.19401564296548957, 0.19401564296548957, 0.19401564296548957, 0.40079778705946834, 0.40079778705946834, 0.40079778705946834, 0.38657414161056636, 0.38657414161056636, 0.38657414161056636, 0.0659488292327105, 0.0659488292327105, 0.0659488292327105, 0.11394522680459118, 0.11394522680459118, 0.11394522680459118, 0.011490355149054943, 0.011490355149054943, 0.011490355149054943, 0.3293502457598261, 0.3293502457598261, 0.3293502457598261, 0.03198380394590217, 0.03198380394590217, 0.03198380394590217, 0.03987452494096344, 0.03987452494096344, 0.03987452494096344, 0.03598901356087103, 0.03598901356087103, 0.03598901356087103, 0.056270248179767446, 0.056270248179767446, 0.056270248179767446, 0.18982912293642462, 0.18982912293642462, 0.18982912293642462, 0.1713423001024066, 0.1713423001024066, 0.1713423001024066, 0.2147907039097594, 0.2147907039097594, 0.2147907039097594, 0.285007019950692, 0.285007019950692, 0.285007019950692, 0.5271854724423805, 0.5271854724423805, 0.5271854724423805, 0.583071579372175, 0.583071579372175, 0.583071579372175, 0.5418937264106117, 0.5418937264106117, 0.5418937264106117, 0.10953306422539677, 0.10953306422539677, 0.10953306422539677, 0.39774164305440574, 0.39774164305440574, 0.39774164305440574, 0.09851899568257216, 0.09851899568257216, 0.09851899568257216, 0.19053193723281137, 0.19053193723281137, 0.19053193723281137, 0.18516412410240002, 0.18516412410240002, 0.18516412410240002, 0.34597988345772657, 0.34597988345772657, 0.34597988345772657, 0.30504690094750386, 0.30504690094750386, 0.30504690094750386, 0.35812790486220814, 0.35812790486220814, 0.35812790486220814, 0.32953074443143415, 0.32953074443143415, 0.32953074443143415, 0.24464190098910998, 0.24464190098910998, 0.24464190098910998, 0.17962875081705754, 0.17962875081705754, 0.17962875081705754, 0.25323238286972294, 0.25323238286972294, 0.25323238286972294, 0.18931456761518106, 0.18931456761518106, 0.18931456761518106, 0.19797539871187853, 0.19797539871187853, 0.19797539871187853, 0.20930161943567804, 0.20930161943567804, 0.20930161943567804, 0.1962240596403252, 0.1962240596403252, 0.1962240596403252, 0.20730315677725275, 0.20730315677725275, 0.20730315677725275, 0.20596533636168146, 0.20596533636168146, 0.20596533636168146, 0.7962726492694988, 0.7962726492694988, 0.7962726492694988, 0.1553789166591356, 0.1553789166591356, 0.1553789166591356, 0.16687333949842487, 0.16687333949842487, 0.16687333949842487, 0.20589616356733953, 0.20589616356733953, 0.20589616356733953, 0.2055222969621665, 0.2055222969621665, 0.2055222969621665, 0.1270790383736381, 0.1270790383736381, 0.1270790383736381, 0.199080191750173, 0.199080191750173, 0.199080191750173, 0.21329103947180417, 0.21329103947180417, 0.21329103947180417, 0.21222238466080168, 0.21222238466080168, 0.21222238466080168, 0.08776869145606869, 0.08776869145606869, 0.08776869145606869, 0.08521961051275961, 0.08521961051275961, 0.08521961051275961, 0.09410152571286634, 0.09410152571286634, 0.09410152571286634]}, "mutation_prompt": null}
{"id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "solution": "import numpy as np\n\nclass QLAS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 1.0\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.85\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLAS", "description": "Quantum-Leveraged Adaptive Strategy (QLAS) integrates quantum-inspired perturbations with dynamic learning rates for improved optimization efficiency.", "configspace": "", "generation": 20, "fitness": 0.32716145892491294, "feedback": "The algorithm QLAS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "ea0936be-8dee-4d29-95b1-b4c4d9d35173", "metadata": {"aucs": [0.7302443456572969, 0.7302443456572969, 0.7302443456572969, 0.751844691298075, 0.751844691298075, 0.751844691298075, 0.751785129103443, 0.751785129103443, 0.751785129103443, 0.11892793520963552, 0.11892793520963552, 0.11892793520963552, 0.47985795860490665, 0.47985795860490665, 0.47985795860490665, 0.04230308675750294, 0.04230308675750294, 0.04230308675750294, 0.1200392489987625, 0.1200392489987625, 0.1200392489987625, 0.10895002797866915, 0.10895002797866915, 0.10895002797866915, 0.12015130640941885, 0.12015130640941885, 0.12015130640941885, 0.10328312955186958, 0.10328312955186958, 0.10328312955186958, 0.11085996332927117, 0.11085996332927117, 0.11085996332927117, 0.07335040182139452, 0.07335040182139452, 0.07335040182139452, 0.9743065701481649, 0.9743065701481649, 0.9743065701481649, 0.9737748260956599, 0.9737748260956599, 0.9737748260956599, 0.9731432310804384, 0.9731432310804384, 0.9731432310804384, 0.45173543975962926, 0.45173543975962926, 0.45173543975962926, 0.3682533587754221, 0.3682533587754221, 0.3682533587754221, 0.46688809987307867, 0.46688809987307867, 0.46688809987307867, 0.6990252726271992, 0.6990252726271992, 0.6990252726271992, 0.778880950480762, 0.778880950480762, 0.778880950480762, 0.7134993147079283, 0.7134993147079283, 0.7134993147079283, 0.3179513586106134, 0.3179513586106134, 0.3179513586106134, 0.1328419583678344, 0.1328419583678344, 0.1328419583678344, 0.2698632172722045, 0.2698632172722045, 0.2698632172722045, 0.22027419321771047, 0.22027419321771047, 0.22027419321771047, 0.19901119663510702, 0.19901119663510702, 0.19901119663510702, 0.12423709047656173, 0.12423709047656173, 0.12423709047656173, 0.11840972361793844, 0.11840972361793844, 0.11840972361793844, 0.29701430993877265, 0.29701430993877265, 0.29701430993877265, 0.39484007679948063, 0.39484007679948063, 0.39484007679948063, 0.37921362161915817, 0.37921362161915817, 0.37921362161915817, 0.12385409559929594, 0.12385409559929594, 0.12385409559929594, 0.4304145745665261, 0.4304145745665261, 0.4304145745665261, 0.04345684713947573, 0.04345684713947573, 0.04345684713947573, 0.0703620939399483, 0.0703620939399483, 0.0703620939399483, 0.05705073879147948, 0.05705073879147948, 0.05705073879147948, 0.1679589101090605, 0.1679589101090605, 0.1679589101090605, 0.2746927321793754, 0.2746927321793754, 0.2746927321793754, 0.258921022185836, 0.258921022185836, 0.258921022185836, 0.6567107793179761, 0.6567107793179761, 0.6567107793179761, 0.6431993222457553, 0.6431993222457553, 0.6431993222457553, 0.6489881657955171, 0.6489881657955171, 0.6489881657955171, 0.14430798006123657, 0.14430798006123657, 0.14430798006123657, 0.12315376156875868, 0.12315376156875868, 0.12315376156875868, 0.10385406196622937, 0.10385406196622937, 0.10385406196622937, 0.2746402302547445, 0.2746402302547445, 0.2746402302547445, 0.3276446698475587, 0.3276446698475587, 0.3276446698475587, 0.24501557415304664, 0.24501557415304664, 0.24501557415304664, 0.27454906278898505, 0.27454906278898505, 0.27454906278898505, 0.2777077403503052, 0.2777077403503052, 0.2777077403503052, 0.34498221877656865, 0.34498221877656865, 0.34498221877656865, 0.14317808136723964, 0.14317808136723964, 0.14317808136723964, 0.1953951642365116, 0.1953951642365116, 0.1953951642365116, 0.3052581638412937, 0.3052581638412937, 0.3052581638412937, 0.23083083181570574, 0.23083083181570574, 0.23083083181570574, 0.2563023077483463, 0.2563023077483463, 0.2563023077483463, 0.19752014377262872, 0.19752014377262872, 0.19752014377262872, 0.18232816119135453, 0.18232816119135453, 0.18232816119135453, 0.1884196974837692, 0.1884196974837692, 0.1884196974837692, 0.19119095181481416, 0.19119095181481416, 0.19119095181481416, 0.8474294089773425, 0.8474294089773425, 0.8474294089773425, 0.811953714143947, 0.811953714143947, 0.811953714143947, 0.16790980255848553, 0.16790980255848553, 0.16790980255848553, 0.7165226446720743, 0.7165226446720743, 0.7165226446720743, 0.2082157547885123, 0.2082157547885123, 0.2082157547885123, 0.15352338702667734, 0.15352338702667734, 0.15352338702667734, 0.18100280424377357, 0.18100280424377357, 0.18100280424377357, 0.19090726154569415, 0.19090726154569415, 0.19090726154569415, 0.23966202185259078, 0.23966202185259078, 0.23966202185259078, 0.10272577030817409, 0.10272577030817409, 0.10272577030817409, 0.0865925215206913, 0.0865925215206913, 0.0865925215206913, 0.1025308312225166, 0.1025308312225166, 0.1025308312225166]}, "mutation_prompt": null}
{"id": "9c460d04-3f55-4cc5-964f-0eb61c62ce54", "solution": "import numpy as np\n\nclass QLDHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.harmony_memory_size = 30\n        self.harmony_consideration_rate = 0.95\n        self.adjustment_rate = 0.2\n        self.quantum_perturbation_rate = 0.05\n        self.mutation_factor = 1.0\n        self.epsilon = 1e-8\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        harmony_memory = np.random.uniform(lower_bound, upper_bound, (self.harmony_memory_size, self.dim))\n        personal_best = np.copy(harmony_memory)\n        personal_best_values = np.array([func(ind) for ind in harmony_memory])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.harmony_memory_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                new_harmony = np.copy(global_best)\n                for d in range(self.dim):\n                    if np.random.rand() < self.harmony_consideration_rate:\n                        idx = np.random.choice(self.harmony_memory_size)\n                        new_harmony[d] = harmony_memory[idx, d]\n                    if np.random.rand() < self.adjustment_rate:\n                        new_harmony[d] += self.quantum_perturbation_rate * np.random.normal()\n\n                new_harmony = np.clip(new_harmony, lower_bound, upper_bound)\n                fitness = func(new_harmony)\n                evaluations += 1\n\n                if fitness < np.max(personal_best_values):\n                    max_idx = np.argmax(personal_best_values)\n                    personal_best[max_idx] = new_harmony\n                    personal_best_values[max_idx] = fitness\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = max_idx\n                        global_best = personal_best[max_idx]\n                \n                if evaluations >= self.budget:\n                    break\n            \n            perturbation = np.random.normal(0, 1, (self.harmony_memory_size, self.dim))\n            quantum_harmonies = harmony_memory + self.quantum_perturbation_rate * perturbation\n            quantum_harmonies = np.clip(quantum_harmonies, lower_bound, upper_bound)\n            quantum_values = np.array([func(ind) for ind in quantum_harmonies])\n\n            for i in range(self.harmony_memory_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_harmonies[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            evaluations += self.harmony_memory_size\n\n        return global_best", "name": "QLDHS", "description": "Quantum-Leveraged Dynamic Harmony Search (QLDHS) combines quantum-inspired perturbations with a harmony search-based adaptive learning strategy for enhanced optimization.", "configspace": "", "generation": 21, "fitness": 0.08500362437675131, "feedback": "The algorithm QLDHS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "metadata": {"aucs": [0.15351421719063907, 0.15351421719063907, 0.15351421719063907, 0.16317844519145852, 0.16317844519145852, 0.16317844519145852, 0.16285472895584296, 0.16285472895584296, 0.16285472895584296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038545402737619194, 0.038545402737619194, 0.038545402737619194, 0.04694945117379434, 0.04694945117379434, 0.04694945117379434, 0.06469154581841463, 0.06469154581841463, 0.06469154581841463, 0.024499430607688222, 0.024499430607688222, 0.024499430607688222, 0.02531361714582714, 0.02531361714582714, 0.02531361714582714, 0.030621110960424414, 0.030621110960424414, 0.030621110960424414, 0.06857790877687497, 0.06857790877687497, 0.06857790877687497, 0.07324626732610762, 0.07324626732610762, 0.07324626732610762, 0.0722942483663046, 0.0722942483663046, 0.0722942483663046, 0.09344301040855174, 0.09344301040855174, 0.09344301040855174, 0.0793928348295665, 0.0793928348295665, 0.0793928348295665, 0.10732473430006362, 0.10732473430006362, 0.10732473430006362, 0.11669941831310349, 0.11669941831310349, 0.11669941831310349, 0.12256135725220685, 0.12256135725220685, 0.12256135725220685, 0.11054222943306335, 0.11054222943306335, 0.11054222943306335, 0.010143014412096973, 0.010143014412096973, 0.010143014412096973, 0.013418499952336238, 0.013418499952336238, 0.013418499952336238, 0.012866112912240713, 0.012866112912240713, 0.012866112912240713, 0.00010814095257805079, 0.00010814095257805079, 0.00010814095257805079, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06727701630683025, 0.06727701630683025, 0.06727701630683025, 0.011405083298300256, 0.011405083298300256, 0.011405083298300256, 0.07447751031316163, 0.07447751031316163, 0.07447751031316163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005556054680153633, 0.0005556054680153633, 0.0005556054680153633, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015594487055085482, 0.015594487055085482, 0.015594487055085482, 0.1890394841647779, 0.1890394841647779, 0.1890394841647779, 0.16935969841921483, 0.16935969841921483, 0.16935969841921483, 0.1721754645489071, 0.1721754645489071, 0.1721754645489071, 0.04309565343979993, 0.04309565343979993, 0.04309565343979993, 0.04009191128966727, 0.04009191128966727, 0.04009191128966727, 0.03960507591652018, 0.03960507591652018, 0.03960507591652018, 0.12316238562160875, 0.12316238562160875, 0.12316238562160875, 0.11213036869233528, 0.11213036869233528, 0.11213036869233528, 0.12761379783508198, 0.12761379783508198, 0.12761379783508198, 0.17800515748441448, 0.17800515748441448, 0.17800515748441448, 0.1568286750964598, 0.1568286750964598, 0.1568286750964598, 0.16501272566323189, 0.16501272566323189, 0.16501272566323189, 0.11854601731300718, 0.11854601731300718, 0.11854601731300718, 0.1171035635542228, 0.1171035635542228, 0.1171035635542228, 0.10186319351290751, 0.10186319351290751, 0.10186319351290751, 0.14560310873280247, 0.14560310873280247, 0.14560310873280247, 0.16089281568456537, 0.16089281568456537, 0.16089281568456537, 0.1514604694293057, 0.1514604694293057, 0.1514604694293057, 0.15265555768059125, 0.15265555768059125, 0.15265555768059125, 0.14593735353848247, 0.14593735353848247, 0.14593735353848247, 0.12485254164902293, 0.12485254164902293, 0.12485254164902293, 0.1579271273958851, 0.1579271273958851, 0.1579271273958851, 0.14004283559016717, 0.14004283559016717, 0.14004283559016717, 0.139499786903432, 0.139499786903432, 0.139499786903432, 0.23642903882586364, 0.23642903882586364, 0.23642903882586364, 0.11229094026449749, 0.11229094026449749, 0.11229094026449749, 0.11879077541184213, 0.11879077541184213, 0.11879077541184213, 0.1813413195431749, 0.1813413195431749, 0.1813413195431749, 0.20177508833973423, 0.20177508833973423, 0.20177508833973423, 0.17982415054358658, 0.17982415054358658, 0.17982415054358658, 0.052309445652198305, 0.052309445652198305, 0.052309445652198305, 0.05105776986959831, 0.05105776986959831, 0.05105776986959831, 0.052642228060991725, 0.052642228060991725, 0.052642228060991725]}, "mutation_prompt": null}
{"id": "85cddb96-0847-4695-a97b-7508302ff284", "solution": "import numpy as np\n\nclass QEEO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.9\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 1.2\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEEO", "description": "Quantum-Enhanced Evolutionary Optimization (QEEO) leverages quantum-inspired mutations and adaptive crossover for robust exploration and convergence.", "configspace": "", "generation": 22, "fitness": 0.291001114255176, "feedback": "The algorithm QEEO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "metadata": {"aucs": [0.6715517428307696, 0.6715517428307696, 0.6715517428307696, 0.6623524084044532, 0.6623524084044532, 0.6623524084044532, 0.7015700586875075, 0.7015700586875075, 0.7015700586875075, 0.29936977828214617, 0.29936977828214617, 0.29936977828214617, 0.2177698948514909, 0.2177698948514909, 0.2177698948514909, 0.15975251330164408, 0.15975251330164408, 0.15975251330164408, 0.12637201423901312, 0.12637201423901312, 0.12637201423901312, 0.10164165662053692, 0.10164165662053692, 0.10164165662053692, 0.09840379523442466, 0.09840379523442466, 0.09840379523442466, 0.10982646724033984, 0.10982646724033984, 0.10982646724033984, 0.10224083524595551, 0.10224083524595551, 0.10224083524595551, 0.09883177002540322, 0.09883177002540322, 0.09883177002540322, 0.986933635707308, 0.986933635707308, 0.986933635707308, 0.9845394125893918, 0.9845394125893918, 0.9845394125893918, 0.9870186745970262, 0.9870186745970262, 0.9870186745970262, 0.3605929085011409, 0.3605929085011409, 0.3605929085011409, 0.4330010003206489, 0.4330010003206489, 0.4330010003206489, 0.3469989505334421, 0.3469989505334421, 0.3469989505334421, 0.6352651917097261, 0.6352651917097261, 0.6352651917097261, 0.1876625289375744, 0.1876625289375744, 0.1876625289375744, 0.7378228727622098, 0.7378228727622098, 0.7378228727622098, 0.21850947456200553, 0.21850947456200553, 0.21850947456200553, 0.15769792301990415, 0.15769792301990415, 0.15769792301990415, 0.23472826378446576, 0.23472826378446576, 0.23472826378446576, 0.3569562776109789, 0.3569562776109789, 0.3569562776109789, 0.21725463929608357, 0.21725463929608357, 0.21725463929608357, 0.10321825646280391, 0.10321825646280391, 0.10321825646280391, 0.04736177715693579, 0.04736177715693579, 0.04736177715693579, 0.2698006229537503, 0.2698006229537503, 0.2698006229537503, 0.26005813591645566, 0.26005813591645566, 0.26005813591645566, 0.10387561035749548, 0.10387561035749548, 0.10387561035749548, 0.3195345306870262, 0.3195345306870262, 0.3195345306870262, 0.14993526325966922, 0.14993526325966922, 0.14993526325966922, 0.03915780958745485, 0.03915780958745485, 0.03915780958745485, 0.056117105985676985, 0.056117105985676985, 0.056117105985676985, 0.056205500552914955, 0.056205500552914955, 0.056205500552914955, 0.22659149103491305, 0.22659149103491305, 0.22659149103491305, 0.20522966298973455, 0.20522966298973455, 0.20522966298973455, 0.22118137042397956, 0.22118137042397956, 0.22118137042397956, 0.5870879021484772, 0.5870879021484772, 0.5870879021484772, 0.5204912665818822, 0.5204912665818822, 0.5204912665818822, 0.5450162243923797, 0.5450162243923797, 0.5450162243923797, 0.12880550738405616, 0.12880550738405616, 0.12880550738405616, 0.1380788046189826, 0.1380788046189826, 0.1380788046189826, 0.07589123020100674, 0.07589123020100674, 0.07589123020100674, 0.34611718789927537, 0.34611718789927537, 0.34611718789927537, 0.29093432529505625, 0.29093432529505625, 0.29093432529505625, 0.16838021882307985, 0.16838021882307985, 0.16838021882307985, 0.2587636693878187, 0.2587636693878187, 0.2587636693878187, 0.19110903397298995, 0.19110903397298995, 0.19110903397298995, 0.34978804220706594, 0.34978804220706594, 0.34978804220706594, 0.1327711398288105, 0.1327711398288105, 0.1327711398288105, 0.25271993633313805, 0.25271993633313805, 0.25271993633313805, 0.258212544726525, 0.258212544726525, 0.258212544726525, 0.2263262882147855, 0.2263262882147855, 0.2263262882147855, 0.22905763958600633, 0.22905763958600633, 0.22905763958600633, 0.22991743099499995, 0.22991743099499995, 0.22991743099499995, 0.2340460153598315, 0.2340460153598315, 0.2340460153598315, 0.19936370836498696, 0.19936370836498696, 0.19936370836498696, 0.23607618113692241, 0.23607618113692241, 0.23607618113692241, 0.8007929392161286, 0.8007929392161286, 0.8007929392161286, 0.15656343709776643, 0.15656343709776643, 0.15656343709776643, 0.1674585920771231, 0.1674585920771231, 0.1674585920771231, 0.7453794897325394, 0.7453794897325394, 0.7453794897325394, 0.20188302732110586, 0.20188302732110586, 0.20188302732110586, 0.1528978955928445, 0.1528978955928445, 0.1528978955928445, 0.1929007537276547, 0.1929007537276547, 0.1929007537276547, 0.20585738908301288, 0.20585738908301288, 0.20585738908301288, 0.19093901599207153, 0.19093901599207153, 0.19093901599207153, 0.09473836687313619, 0.09473836687313619, 0.09473836687313619, 0.08440513874913469, 0.08440513874913469, 0.08440513874913469, 0.10637805718767235, 0.10637805718767235, 0.10637805718767235]}, "mutation_prompt": null}
{"id": "b2baa2b0-e153-4519-8d96-16c79aadd946", "solution": "import numpy as np\n\nclass QIES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QIES", "description": "Quantum-Inspired Evolutionary Swarm (QIES) combines quantum perturbations with swarm intelligence and adaptive crossover for enhanced convergence.", "configspace": "", "generation": 23, "fitness": 0.28927277070294427, "feedback": "The algorithm QIES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "metadata": {"aucs": [0.7141507787011931, 0.7141507787011931, 0.7141507787011931, 0.7321749837578733, 0.7321749837578733, 0.7321749837578733, 0.7139228875811219, 0.7139228875811219, 0.7139228875811219, 0.11842656747840008, 0.11842656747840008, 0.11842656747840008, 0.12332247050741552, 0.12332247050741552, 0.12332247050741552, 0.01416616551602512, 0.01416616551602512, 0.01416616551602512, 0.09245338240033107, 0.09245338240033107, 0.09245338240033107, 0.08013708715830292, 0.08013708715830292, 0.08013708715830292, 0.1549452972074632, 0.1549452972074632, 0.1549452972074632, 0.14654970824516023, 0.14654970824516023, 0.14654970824516023, 0.09916652583039054, 0.09916652583039054, 0.09916652583039054, 0.0938844000350153, 0.0938844000350153, 0.0938844000350153, 0.9762110780620263, 0.9762110780620263, 0.9762110780620263, 0.9766441149037541, 0.9766441149037541, 0.9766441149037541, 0.9745611908106762, 0.9745611908106762, 0.9745611908106762, 0.46641634730148385, 0.46641634730148385, 0.46641634730148385, 0.4636832296109217, 0.4636832296109217, 0.4636832296109217, 0.5163076010201693, 0.5163076010201693, 0.5163076010201693, 0.2173663168239124, 0.2173663168239124, 0.2173663168239124, 0.20320949258855114, 0.20320949258855114, 0.20320949258855114, 0.6826240070188587, 0.6826240070188587, 0.6826240070188587, 0.2667299668239821, 0.2667299668239821, 0.2667299668239821, 0.16392069839769152, 0.16392069839769152, 0.16392069839769152, 0.16246760091910217, 0.16246760091910217, 0.16246760091910217, 0.25415081372960546, 0.25415081372960546, 0.25415081372960546, 0.11034781372404401, 0.11034781372404401, 0.11034781372404401, 0.299662115652665, 0.299662115652665, 0.299662115652665, 0.08779223421742188, 0.08779223421742188, 0.08779223421742188, 0.40089766886691114, 0.40089766886691114, 0.40089766886691114, 0.006489814668463656, 0.006489814668463656, 0.006489814668463656, 0.13500473334475427, 0.13500473334475427, 0.13500473334475427, 0.3388917684089574, 0.3388917684089574, 0.3388917684089574, 0.22118016081104452, 0.22118016081104452, 0.22118016081104452, 0.03730010905442793, 0.03730010905442793, 0.03730010905442793, 0.15067543080826784, 0.15067543080826784, 0.15067543080826784, 0.04999357258702153, 0.04999357258702153, 0.04999357258702153, 0.25524631174466395, 0.25524631174466395, 0.25524631174466395, 0.13121160066128745, 0.13121160066128745, 0.13121160066128745, 0.050125260648567704, 0.050125260648567704, 0.050125260648567704, 0.5901841404649311, 0.5901841404649311, 0.5901841404649311, 0.5835728859250224, 0.5835728859250224, 0.5835728859250224, 0.5444373450500761, 0.5444373450500761, 0.5444373450500761, 0.11398132055295795, 0.11398132055295795, 0.11398132055295795, 0.10083250418159928, 0.10083250418159928, 0.10083250418159928, 0.07558728425706829, 0.07558728425706829, 0.07558728425706829, 0.40836740868112786, 0.40836740868112786, 0.40836740868112786, 0.20226398602677043, 0.20226398602677043, 0.20226398602677043, 0.542276517307958, 0.542276517307958, 0.542276517307958, 0.30822571929086395, 0.30822571929086395, 0.30822571929086395, 0.29939085218796424, 0.29939085218796424, 0.29939085218796424, 0.44908347912305013, 0.44908347912305013, 0.44908347912305013, 0.18877952359191652, 0.18877952359191652, 0.18877952359191652, 0.29683511018952013, 0.29683511018952013, 0.29683511018952013, 0.14702651124091848, 0.14702651124091848, 0.14702651124091848, 0.19927878863544313, 0.19927878863544313, 0.19927878863544313, 0.20445296635503651, 0.20445296635503651, 0.20445296635503651, 0.2286339111870873, 0.2286339111870873, 0.2286339111870873, 0.22358481114605233, 0.22358481114605233, 0.22358481114605233, 0.18609054868733288, 0.18609054868733288, 0.18609054868733288, 0.20637663840045384, 0.20637663840045384, 0.20637663840045384, 0.8060386200476612, 0.8060386200476612, 0.8060386200476612, 0.1616242214579584, 0.1616242214579584, 0.1616242214579584, 0.16886124729408147, 0.16886124729408147, 0.16886124729408147, 0.7184453525535104, 0.7184453525535104, 0.7184453525535104, 0.204495331547502, 0.204495331547502, 0.204495331547502, 0.12777875678371386, 0.12777875678371386, 0.12777875678371386, 0.18662703643347178, 0.18662703643347178, 0.18662703643347178, 0.19020109220383852, 0.19020109220383852, 0.19020109220383852, 0.17361978535014677, 0.17361978535014677, 0.17361978535014677, 0.10755089328759893, 0.10755089328759893, 0.10755089328759893, 0.08657920514015838, 0.08657920514015838, 0.08657920514015838, 0.11414438840126773, 0.11414438840126773, 0.11414438840126773]}, "mutation_prompt": null}
{"id": "b266a7f5-8c2f-4df0-b1b2-89fbfcf1f0a1", "solution": "import numpy as np\n\nclass QLGD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.learning_rate = 0.05\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.8\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.85\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound) * 0.05\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]) -\n                                 self.learning_rate * np.sign(personal_best[i] - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    fitness = func(population[i])\n                    evaluations += 1\n                    if fitness < personal_best_values[i]:\n                        personal_best_values[i] = fitness\n                        personal_best[i] = population[i]\n                    if fitness < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLGD", "description": "Quantum-Leveraged Gradient Descent (QLGD) combines quantum-inspired perturbations with adaptive gradient-based updates for enhanced optimization performance.", "configspace": "", "generation": 24, "fitness": 0.26408994577530936, "feedback": "The algorithm QLGD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "metadata": {"aucs": [0.6528935655124453, 0.6528935655124453, 0.6528935655124453, 0.5994640677833766, 0.5994640677833766, 0.5994640677833766, 0.6469809036842076, 0.6469809036842076, 0.6469809036842076, 0.018359971798300512, 0.018359971798300512, 0.018359971798300512, 0.05380613375479082, 0.05380613375479082, 0.05380613375479082, 0.0041813308205302935, 0.0041813308205302935, 0.0041813308205302935, 0.13672115127809703, 0.13672115127809703, 0.13672115127809703, 0.12185110897604023, 0.12185110897604023, 0.12185110897604023, 0.11392682973226342, 0.11392682973226342, 0.11392682973226342, 0.123286728483329, 0.123286728483329, 0.123286728483329, 0.08978420484971283, 0.08978420484971283, 0.08978420484971283, 0.09655120581505694, 0.09655120581505694, 0.09655120581505694, 0.9726115869533664, 0.9726115869533664, 0.9726115869533664, 0.9745248720680619, 0.9745248720680619, 0.9745248720680619, 0.97302071041858, 0.97302071041858, 0.97302071041858, 0.3945531526973236, 0.3945531526973236, 0.3945531526973236, 0.37340283128672713, 0.37340283128672713, 0.37340283128672713, 0.42294218266302197, 0.42294218266302197, 0.42294218266302197, 0.7440513615897275, 0.7440513615897275, 0.7440513615897275, 0.21037985877846577, 0.21037985877846577, 0.21037985877846577, 0.22464926466870627, 0.22464926466870627, 0.22464926466870627, 0.23742481104140456, 0.23742481104140456, 0.23742481104140456, 0.21564431493716718, 0.21564431493716718, 0.21564431493716718, 0.121164684020313, 0.121164684020313, 0.121164684020313, 0.19404237067971497, 0.19404237067971497, 0.19404237067971497, 0.12192485011027487, 0.12192485011027487, 0.12192485011027487, 0.23186430130709446, 0.23186430130709446, 0.23186430130709446, 0.002439653560812771, 0.002439653560812771, 0.002439653560812771, 0.03682363663926902, 0.03682363663926902, 0.03682363663926902, 0.08497820030043035, 0.08497820030043035, 0.08497820030043035, 0.09707735110298632, 0.09707735110298632, 0.09707735110298632, 0.12664357800075776, 0.12664357800075776, 0.12664357800075776, 0.1612086526198505, 0.1612086526198505, 0.1612086526198505, 0.03335144342225771, 0.03335144342225771, 0.03335144342225771, 0.07183468279650751, 0.07183468279650751, 0.07183468279650751, 0.057057596691950874, 0.057057596691950874, 0.057057596691950874, 0.10276274201204683, 0.10276274201204683, 0.10276274201204683, 0.1630943691852682, 0.1630943691852682, 0.1630943691852682, 0.20510020184867528, 0.20510020184867528, 0.20510020184867528, 0.5400595379261632, 0.5400595379261632, 0.5400595379261632, 0.503516663791906, 0.503516663791906, 0.503516663791906, 0.48700997497771004, 0.48700997497771004, 0.48700997497771004, 0.10244618076137646, 0.10244618076137646, 0.10244618076137646, 0.11231598607131277, 0.11231598607131277, 0.11231598607131277, 0.10537386709742169, 0.10537386709742169, 0.10537386709742169, 0.22853413521646926, 0.22853413521646926, 0.22853413521646926, 0.17676057728248673, 0.17676057728248673, 0.17676057728248673, 0.2524924793157478, 0.2524924793157478, 0.2524924793157478, 0.35472963417412007, 0.35472963417412007, 0.35472963417412007, 0.3559813705887024, 0.3559813705887024, 0.3559813705887024, 0.33779009036262053, 0.33779009036262053, 0.33779009036262053, 0.2146547028518988, 0.2146547028518988, 0.2146547028518988, 0.2601947748723916, 0.2601947748723916, 0.2601947748723916, 0.24076494465292797, 0.24076494465292797, 0.24076494465292797, 0.20915672224402826, 0.20915672224402826, 0.20915672224402826, 0.2157337222281236, 0.2157337222281236, 0.2157337222281236, 0.2272442183088963, 0.2272442183088963, 0.2272442183088963, 0.20764976573071647, 0.20764976573071647, 0.20764976573071647, 0.2456024225853919, 0.2456024225853919, 0.2456024225853919, 0.25156194070488025, 0.25156194070488025, 0.25156194070488025, 0.8510380197344497, 0.8510380197344497, 0.8510380197344497, 0.1572709964711123, 0.1572709964711123, 0.1572709964711123, 0.1682817567922491, 0.1682817567922491, 0.1682817567922491, 0.7638811079385991, 0.7638811079385991, 0.7638811079385991, 0.20779778034946728, 0.20779778034946728, 0.20779778034946728, 0.15305474121812912, 0.15305474121812912, 0.15305474121812912, 0.18294861633012316, 0.18294861633012316, 0.18294861633012316, 0.1982256739616418, 0.1982256739616418, 0.1982256739616418, 0.1822267868378341, 0.1822267868378341, 0.1822267868378341, 0.11019901394094722, 0.11019901394094722, 0.11019901394094722, 0.08281049087249592, 0.08281049087249592, 0.08281049087249592, 0.11478693574101795, 0.11478693574101795, 0.11478693574101795]}, "mutation_prompt": null}
{"id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 25, "fitness": 0.33662596509308823, "feedback": "The algorithm QLASPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "36dcb282-a7e0-4d4b-b478-2a3114bb300b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "7a1edf1d-d099-4baf-82aa-d09881779cb8", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "a5ba9fea-c142-4b5a-a0e8-1440407973be", "solution": "import numpy as np\n\nclass EnhancedQLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.6  # increased acceleration coefficient for exploration\n        self.c2 = 1.8  # increased acceleration coefficient for exploitation\n        self.inertia_weight = 0.7  # higher initial inertia\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.1, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget)) ** 0.5  # nonlinear decay\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n                hybrid_mutant = (population[i] + global_best) / 2  # hybrid mutation strategy\n                if evaluations < self.budget and func(hybrid_mutant) < personal_best_values[i]:\n                    personal_best[i] = hybrid_mutant\n                    evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.3 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "EnhancedQLASPlus", "description": "Enhanced Quantum-Leveraged Adaptive Strategy with dynamic inertia and hybrid mutation strategies for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.243518722274658, "feedback": "The algorithm EnhancedQLASPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.4951513902957476, 0.4951513902957476, 0.4951513902957476, 0.5673326852823874, 0.5673326852823874, 0.5673326852823874, 0.5105282738454723, 0.5105282738454723, 0.5105282738454723, 0.020066412026071734, 0.020066412026071734, 0.020066412026071734, 0.1614159395687519, 0.1614159395687519, 0.1614159395687519, 0.06119084502806871, 0.06119084502806871, 0.06119084502806871, 0.11418530462802223, 0.11418530462802223, 0.11418530462802223, 0.10924035242110441, 0.10924035242110441, 0.10924035242110441, 0.08721817445874203, 0.08721817445874203, 0.08721817445874203, 0.09765441463909519, 0.09765441463909519, 0.09765441463909519, 0.07955835379376863, 0.07955835379376863, 0.07955835379376863, 0.09035876145601218, 0.09035876145601218, 0.09035876145601218, 0.9636568511342286, 0.9636568511342286, 0.9636568511342286, 0.9272067560375893, 0.9272067560375893, 0.9272067560375893, 0.9851151601970631, 0.9851151601970631, 0.9851151601970631, 0.31619521836303066, 0.31619521836303066, 0.31619521836303066, 0.27731165486732956, 0.27731165486732956, 0.27731165486732956, 0.25848837107632994, 0.25848837107632994, 0.25848837107632994, 0.5613214900706764, 0.5613214900706764, 0.5613214900706764, 0.2480732376418996, 0.2480732376418996, 0.2480732376418996, 0.5788492958624799, 0.5788492958624799, 0.5788492958624799, 0.17273684662126576, 0.17273684662126576, 0.17273684662126576, 0.17630222422601927, 0.17630222422601927, 0.17630222422601927, 0.15627879666667066, 0.15627879666667066, 0.15627879666667066, 0.1054386556614687, 0.1054386556614687, 0.1054386556614687, 0.14066890146658773, 0.14066890146658773, 0.14066890146658773, 0.18988957133473183, 0.18988957133473183, 0.18988957133473183, 0.0376743644610118, 0.0376743644610118, 0.0376743644610118, 0.002158168713089381, 0.002158168713089381, 0.002158168713089381, 0.10583071787748577, 0.10583071787748577, 0.10583071787748577, 0.08360829756807964, 0.08360829756807964, 0.08360829756807964, 0.049465671884074025, 0.049465671884074025, 0.049465671884074025, 0.04423671492301018, 0.04423671492301018, 0.04423671492301018, 0.0234209370640317, 0.0234209370640317, 0.0234209370640317, 0.033282078287281025, 0.033282078287281025, 0.033282078287281025, 0.02242515701290393, 0.02242515701290393, 0.02242515701290393, 0.12108658509373249, 0.12108658509373249, 0.12108658509373249, 0.1711325089815875, 0.1711325089815875, 0.1711325089815875, 0.12180496113925565, 0.12180496113925565, 0.12180496113925565, 0.4577143295063505, 0.4577143295063505, 0.4577143295063505, 0.43346562449816184, 0.43346562449816184, 0.43346562449816184, 0.42392927282163595, 0.42392927282163595, 0.42392927282163595, 0.09559224414734946, 0.09559224414734946, 0.09559224414734946, 0.09704115933889679, 0.09704115933889679, 0.09704115933889679, 0.08412399556802608, 0.08412399556802608, 0.08412399556802608, 0.25897993207031356, 0.25897993207031356, 0.25897993207031356, 0.1800955571288967, 0.1800955571288967, 0.1800955571288967, 0.24913769014077447, 0.24913769014077447, 0.24913769014077447, 0.27920059899171856, 0.27920059899171856, 0.27920059899171856, 0.3178951002937277, 0.3178951002937277, 0.3178951002937277, 0.32936701221845777, 0.32936701221845777, 0.32936701221845777, 0.2167691195944561, 0.2167691195944561, 0.2167691195944561, 0.21680699462208552, 0.21680699462208552, 0.21680699462208552, 0.18861516557399083, 0.18861516557399083, 0.18861516557399083, 0.199712784335073, 0.199712784335073, 0.199712784335073, 0.17265864023190913, 0.17265864023190913, 0.17265864023190913, 0.18174948591974704, 0.18174948591974704, 0.18174948591974704, 0.2066757047561817, 0.2066757047561817, 0.2066757047561817, 0.18030494903734218, 0.18030494903734218, 0.18030494903734218, 0.21682847275014216, 0.21682847275014216, 0.21682847275014216, 0.7421999800937329, 0.7421999800937329, 0.7421999800937329, 0.5913012980842735, 0.5913012980842735, 0.5913012980842735, 0.16806205086179382, 0.16806205086179382, 0.16806205086179382, 0.6258772326172082, 0.6258772326172082, 0.6258772326172082, 0.20391400903605317, 0.20391400903605317, 0.20391400903605317, 0.1498200916316026, 0.1498200916316026, 0.1498200916316026, 0.17876147837861922, 0.17876147837861922, 0.17876147837861922, 0.18507608525787533, 0.18507608525787533, 0.18507608525787533, 0.17622136630336716, 0.17622136630336716, 0.17622136630336716, 0.07788090879698029, 0.07788090879698029, 0.07788090879698029, 0.07871493902227922, 0.07871493902227922, 0.07871493902227922, 0.10129462847019821, 0.10129462847019821, 0.10129462847019821]}, "mutation_prompt": null}
{"id": "4c415ab4-c0f8-4927-b38c-12e73edb177d", "solution": "import numpy as np\n\nclass QLASPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.6\n        self.c2 = 1.8\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.1, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlusPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS++) with dynamic population and feedback-enhanced perturbations for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.2946384848518997, "feedback": "The algorithm QLASPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6742892753403587, 0.6742892753403587, 0.6742892753403587, 0.6644722398466267, 0.6644722398466267, 0.6644722398466267, 0.7381766284586555, 0.7381766284586555, 0.7381766284586555, 0.32221246996299235, 0.32221246996299235, 0.32221246996299235, 0.20284124051073493, 0.20284124051073493, 0.20284124051073493, 0.011288581332185466, 0.011288581332185466, 0.011288581332185466, 0.14145324481434562, 0.14145324481434562, 0.14145324481434562, 0.13277540575691094, 0.13277540575691094, 0.13277540575691094, 0.10760388094939499, 0.10760388094939499, 0.10760388094939499, 0.11884942605885385, 0.11884942605885385, 0.11884942605885385, 0.08701106894564314, 0.08701106894564314, 0.08701106894564314, 0.10973048080832126, 0.10973048080832126, 0.10973048080832126, 0.9734512107823761, 0.9734512107823761, 0.9734512107823761, 0.9467863244066028, 0.9467863244066028, 0.9467863244066028, 0.9752905152814675, 0.9752905152814675, 0.9752905152814675, 0.41897562866655513, 0.41897562866655513, 0.41897562866655513, 0.3651311339382024, 0.3651311339382024, 0.3651311339382024, 0.38169895256237374, 0.38169895256237374, 0.38169895256237374, 0.7278877939234442, 0.7278877939234442, 0.7278877939234442, 0.6944364894809023, 0.6944364894809023, 0.6944364894809023, 0.6513824147316509, 0.6513824147316509, 0.6513824147316509, 0.23704339018437615, 0.23704339018437615, 0.23704339018437615, 0.19371261099367787, 0.19371261099367787, 0.19371261099367787, 0.19267253101581938, 0.19267253101581938, 0.19267253101581938, 0.11106040582109655, 0.11106040582109655, 0.11106040582109655, 0.1885073261202801, 0.1885073261202801, 0.1885073261202801, 0.17550699584694085, 0.17550699584694085, 0.17550699584694085, 0.042549690577701194, 0.042549690577701194, 0.042549690577701194, 0.0064803106665473065, 0.0064803106665473065, 0.0064803106665473065, 0.09705904767437712, 0.09705904767437712, 0.09705904767437712, 0.23926044350437048, 0.23926044350437048, 0.23926044350437048, 0.23278721463065555, 0.23278721463065555, 0.23278721463065555, 0.28204217351155736, 0.28204217351155736, 0.28204217351155736, 0.116879141440135, 0.116879141440135, 0.116879141440135, 0.06362012191470734, 0.06362012191470734, 0.06362012191470734, 0.06848609411806361, 0.06848609411806361, 0.06848609411806361, 0.1956933367336593, 0.1956933367336593, 0.1956933367336593, 0.2363678399432546, 0.2363678399432546, 0.2363678399432546, 0.22678816129010548, 0.22678816129010548, 0.22678816129010548, 0.5608752786325819, 0.5608752786325819, 0.5608752786325819, 0.5517640915459543, 0.5517640915459543, 0.5517640915459543, 0.6289537068146844, 0.6289537068146844, 0.6289537068146844, 0.11630523154759143, 0.11630523154759143, 0.11630523154759143, 0.11981471049995762, 0.11981471049995762, 0.11981471049995762, 0.1605170604853382, 0.1605170604853382, 0.1605170604853382, 0.2158911139607993, 0.2158911139607993, 0.2158911139607993, 0.24451711100890894, 0.24451711100890894, 0.24451711100890894, 0.21736571245040992, 0.21736571245040992, 0.21736571245040992, 0.34830994485045297, 0.34830994485045297, 0.34830994485045297, 0.32724585957762875, 0.32724585957762875, 0.32724585957762875, 0.35969540542730183, 0.35969540542730183, 0.35969540542730183, 0.18449730032208878, 0.18449730032208878, 0.18449730032208878, 0.28490537010203587, 0.28490537010203587, 0.28490537010203587, 0.13337053391720732, 0.13337053391720732, 0.13337053391720732, 0.20848746758250003, 0.20848746758250003, 0.20848746758250003, 0.20162019208379167, 0.20162019208379167, 0.20162019208379167, 0.24687034315136336, 0.24687034315136336, 0.24687034315136336, 0.16987799847171137, 0.16987799847171137, 0.16987799847171137, 0.18118894407016517, 0.18118894407016517, 0.18118894407016517, 0.218482570990558, 0.218482570990558, 0.218482570990558, 0.832272622531682, 0.832272622531682, 0.832272622531682, 0.15644548988502505, 0.15644548988502505, 0.15644548988502505, 0.16861865684882793, 0.16861865684882793, 0.16861865684882793, 0.743562582789276, 0.743562582789276, 0.743562582789276, 0.20896754245219695, 0.20896754245219695, 0.20896754245219695, 0.15133444363316917, 0.15133444363316917, 0.15133444363316917, 0.1870192352072898, 0.1870192352072898, 0.1870192352072898, 0.22204211037296206, 0.22204211037296206, 0.22204211037296206, 0.21954269935750736, 0.21954269935750736, 0.21954269935750736, 0.08818255504376771, 0.08818255504376771, 0.08818255504376771, 0.09537649515682423, 0.09537649515682423, 0.09537649515682423, 0.1077892860192936, 0.1077892860192936, 0.1077892860192936]}, "mutation_prompt": null}
{"id": "2110b950-19ed-4d62-b7fa-1b108e4462fe", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "916b63f5-c488-4aa0-a5e2-095e089003d5", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "0f084ae1-5a31-464d-bfa4-0ca3ed3ac3a3", "solution": "import numpy as np\n\nclass QLESH:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.07, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / (2 * self.budget)))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.3 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLESH", "description": "Quantum-Leveraged Enhanced Swarm Hybrid (QLESH) uses dynamic adaptive strategies with quantum perturbations and hybrid selection to optimize performance across diverse landscapes.", "configspace": "", "generation": 31, "fitness": 0.3309488486362117, "feedback": "The algorithm QLESH got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7744228348043611, 0.7744228348043611, 0.7744228348043611, 0.7419917806523815, 0.7419917806523815, 0.7419917806523815, 0.7580063160236565, 0.7580063160236565, 0.7580063160236565, 0.3090999087490124, 0.3090999087490124, 0.3090999087490124, 0.45455206262787495, 0.45455206262787495, 0.45455206262787495, 0.14217898922796213, 0.14217898922796213, 0.14217898922796213, 0.12695549471999457, 0.12695549471999457, 0.12695549471999457, 0.10698816765950891, 0.10698816765950891, 0.10698816765950891, 0.1323227358069553, 0.1323227358069553, 0.1323227358069553, 0.11689539891129241, 0.11689539891129241, 0.11689539891129241, 0.09997222681547113, 0.09997222681547113, 0.09997222681547113, 0.07436986481668706, 0.07436986481668706, 0.07436986481668706, 0.9625920842099972, 0.9625920842099972, 0.9625920842099972, 0.9877485574733748, 0.9877485574733748, 0.9877485574733748, 0.966874629642756, 0.966874629642756, 0.966874629642756, 0.46605970313524214, 0.46605970313524214, 0.46605970313524214, 0.4492463360836634, 0.4492463360836634, 0.4492463360836634, 0.47684701736040547, 0.47684701736040547, 0.47684701736040547, 0.747388089385524, 0.747388089385524, 0.747388089385524, 0.7386740371690288, 0.7386740371690288, 0.7386740371690288, 0.2761226956791145, 0.2761226956791145, 0.2761226956791145, 0.21704022464268335, 0.21704022464268335, 0.21704022464268335, 0.5460876620159848, 0.5460876620159848, 0.5460876620159848, 0.16367637852899009, 0.16367637852899009, 0.16367637852899009, 0.27324988551994844, 0.27324988551994844, 0.27324988551994844, 0.12515912574547206, 0.12515912574547206, 0.12515912574547206, 0.49959054667240343, 0.49959054667240343, 0.49959054667240343, 0.05630521871877847, 0.05630521871877847, 0.05630521871877847, 0.017628553666387048, 0.017628553666387048, 0.017628553666387048, 0.36666036977557204, 0.36666036977557204, 0.36666036977557204, 0.5123881286251006, 0.5123881286251006, 0.5123881286251006, 0.33153937461933924, 0.33153937461933924, 0.33153937461933924, 0.3413773509229271, 0.3413773509229271, 0.3413773509229271, 0.05813300552563272, 0.05813300552563272, 0.05813300552563272, 0.1903965233734125, 0.1903965233734125, 0.1903965233734125, 0.10261296003770004, 0.10261296003770004, 0.10261296003770004, 0.31733410686201313, 0.31733410686201313, 0.31733410686201313, 0.30422773318466867, 0.30422773318466867, 0.30422773318466867, 0.07746395749853285, 0.07746395749853285, 0.07746395749853285, 0.6294332744186575, 0.6294332744186575, 0.6294332744186575, 0.5605257931736101, 0.5605257931736101, 0.5605257931736101, 0.609824011081175, 0.609824011081175, 0.609824011081175, 0.08828178843691326, 0.08828178843691326, 0.08828178843691326, 0.10448590830637206, 0.10448590830637206, 0.10448590830637206, 0.10697539627283403, 0.10697539627283403, 0.10697539627283403, 0.22004182236391912, 0.22004182236391912, 0.22004182236391912, 0.3112257717723511, 0.3112257717723511, 0.3112257717723511, 0.3079939337941553, 0.3079939337941553, 0.3079939337941553, 0.42554650048726905, 0.42554650048726905, 0.42554650048726905, 0.40409003414826106, 0.40409003414826106, 0.40409003414826106, 0.3481084346370312, 0.3481084346370312, 0.3481084346370312, 0.2549703723006357, 0.2549703723006357, 0.2549703723006357, 0.1976362899275501, 0.1976362899275501, 0.1976362899275501, 0.35162489524835194, 0.35162489524835194, 0.35162489524835194, 0.20438340254107068, 0.20438340254107068, 0.20438340254107068, 0.2235017459603188, 0.2235017459603188, 0.2235017459603188, 0.20721470687763, 0.20721470687763, 0.20721470687763, 0.1862161454067076, 0.1862161454067076, 0.1862161454067076, 0.2204684185037903, 0.2204684185037903, 0.2204684185037903, 0.20574834592733904, 0.20574834592733904, 0.20574834592733904, 0.8517674135267128, 0.8517674135267128, 0.8517674135267128, 0.8134371445631365, 0.8134371445631365, 0.8134371445631365, 0.16580742376982904, 0.16580742376982904, 0.16580742376982904, 0.16589065143061632, 0.16589065143061632, 0.16589065143061632, 0.209406715260276, 0.209406715260276, 0.209406715260276, 0.16480826941072624, 0.16480826941072624, 0.16480826941072624, 0.19011579745347296, 0.19011579745347296, 0.19011579745347296, 0.19815723868485124, 0.19815723868485124, 0.19815723868485124, 0.19877142476174214, 0.19877142476174214, 0.19877142476174214, 0.10103480943622067, 0.10103480943622067, 0.10103480943622067, 0.08469338092407486, 0.08469338092407486, 0.08469338092407486, 0.10594980410983168, 0.10594980410983168, 0.10594980410983168]}, "mutation_prompt": null}
{"id": "ac81602b-aee1-4db8-931b-b825362248ca", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "7ef819db-9901-4e40-8b0b-baa4b01db154", "solution": "import numpy as np\n\nclass EQLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.7\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor_base = 0.8\n        self.mutation_factor_max = 1.0\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_factor = self.mutation_factor_base + (self.mutation_factor_max - self.mutation_factor_base) * \\\n                                      (1 - (evaluations / self.budget))\n                    mutation_vector = (population[indices[0]] +\n                                       mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.3 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "EQLASPlus", "description": "Enhanced Quantum-Leveraged Adaptive Strategy (EQLAS+) integrates dynamic parameter tuning and adaptive mutation strategies to improve convergence.", "configspace": "", "generation": 33, "fitness": 0.2769219039737301, "feedback": "The algorithm EQLASPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6517158357262953, 0.6517158357262953, 0.6517158357262953, 0.6375376842340789, 0.6375376842340789, 0.6375376842340789, 0.6989161781773578, 0.6989161781773578, 0.6989161781773578, 0.03839855664181946, 0.03839855664181946, 0.03839855664181946, 0.25849647650473184, 0.25849647650473184, 0.25849647650473184, 0.21790621665121146, 0.21790621665121146, 0.21790621665121146, 0.09220520247557418, 0.09220520247557418, 0.09220520247557418, 0.09126552685683642, 0.09126552685683642, 0.09126552685683642, 0.13714173923185968, 0.13714173923185968, 0.13714173923185968, 0.08990812724164243, 0.08990812724164243, 0.08990812724164243, 0.09120417660939861, 0.09120417660939861, 0.09120417660939861, 0.12631803279929865, 0.12631803279929865, 0.12631803279929865, 0.9730857161542282, 0.9730857161542282, 0.9730857161542282, 0.9752014460876322, 0.9752014460876322, 0.9752014460876322, 0.9868969977758932, 0.9868969977758932, 0.9868969977758932, 0.33284799117273756, 0.33284799117273756, 0.33284799117273756, 0.3533043500758668, 0.3533043500758668, 0.3533043500758668, 0.3327701171508355, 0.3327701171508355, 0.3327701171508355, 0.6183855087020804, 0.6183855087020804, 0.6183855087020804, 0.20411403180794263, 0.20411403180794263, 0.20411403180794263, 0.6255461556297661, 0.6255461556297661, 0.6255461556297661, 0.23942578907895806, 0.23942578907895806, 0.23942578907895806, 0.12078606155604121, 0.12078606155604121, 0.12078606155604121, 0.11166409478866257, 0.11166409478866257, 0.11166409478866257, 0.15089897039749545, 0.15089897039749545, 0.15089897039749545, 0.20595685890689186, 0.20595685890689186, 0.20595685890689186, 0.29973708669209354, 0.29973708669209354, 0.29973708669209354, 0.061139917974637914, 0.061139917974637914, 0.061139917974637914, 0.060625228010837806, 0.060625228010837806, 0.060625228010837806, 0.010223094244114495, 0.010223094244114495, 0.010223094244114495, 0.2500894278687794, 0.2500894278687794, 0.2500894278687794, 0.2989566353272578, 0.2989566353272578, 0.2989566353272578, 0.12819405217508406, 0.12819405217508406, 0.12819405217508406, 0.029207845322430703, 0.029207845322430703, 0.029207845322430703, 0.10105794386212952, 0.10105794386212952, 0.10105794386212952, 0.06791520944914131, 0.06791520944914131, 0.06791520944914131, 0.17512163359244715, 0.17512163359244715, 0.17512163359244715, 0.2281089251414251, 0.2281089251414251, 0.2281089251414251, 0.25848950565380213, 0.25848950565380213, 0.25848950565380213, 0.5368890594913643, 0.5368890594913643, 0.5368890594913643, 0.5153141054154278, 0.5153141054154278, 0.5153141054154278, 0.5654681373162619, 0.5654681373162619, 0.5654681373162619, 0.11200280441227028, 0.11200280441227028, 0.11200280441227028, 0.128906974680138, 0.128906974680138, 0.128906974680138, 0.12180231447336864, 0.12180231447336864, 0.12180231447336864, 0.25502883647914965, 0.25502883647914965, 0.25502883647914965, 0.3299612290294692, 0.3299612290294692, 0.3299612290294692, 0.22637686779480903, 0.22637686779480903, 0.22637686779480903, 0.3384588844323043, 0.3384588844323043, 0.3384588844323043, 0.35998227158877827, 0.35998227158877827, 0.35998227158877827, 0.3087925331399928, 0.3087925331399928, 0.3087925331399928, 0.14929104651567537, 0.14929104651567537, 0.14929104651567537, 0.20923837727859695, 0.20923837727859695, 0.20923837727859695, 0.19550008263590302, 0.19550008263590302, 0.19550008263590302, 0.19590978834807826, 0.19590978834807826, 0.19590978834807826, 0.2011270027739649, 0.2011270027739649, 0.2011270027739649, 0.1917661619429173, 0.1917661619429173, 0.1917661619429173, 0.20320738353314438, 0.20320738353314438, 0.20320738353314438, 0.20739067225576957, 0.20739067225576957, 0.20739067225576957, 0.192164223305199, 0.192164223305199, 0.192164223305199, 0.7904197302067185, 0.7904197302067185, 0.7904197302067185, 0.1560302800743093, 0.1560302800743093, 0.1560302800743093, 0.16880973259353682, 0.16880973259353682, 0.16880973259353682, 0.7546043773816962, 0.7546043773816962, 0.7546043773816962, 0.20407093197173676, 0.20407093197173676, 0.20407093197173676, 0.15060218662852953, 0.15060218662852953, 0.15060218662852953, 0.1990924848260951, 0.1990924848260951, 0.1990924848260951, 0.18225285316236317, 0.18225285316236317, 0.18225285316236317, 0.18649759580646408, 0.18649759580646408, 0.18649759580646408, 0.07939426435424779, 0.07939426435424779, 0.07939426435424779, 0.08061394854275428, 0.08061394854275428, 0.08061394854275428, 0.11064559596821744, 0.11064559596821744, 0.11064559596821744]}, "mutation_prompt": null}
{"id": "d64a631e-aa2b-4f84-92d7-8a2a5ec2dd74", "solution": "import numpy as np\n\nclass QAPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 70\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-7\n        self.mutation_factor = 0.8\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.1 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QAPS", "description": "Quantum-Inspired Adaptive Particle Synergy (QAPS) utilizes enhanced stochastic selection and adaptive mutation for improved exploration and convergence.", "configspace": "", "generation": 34, "fitness": 0.2784163831043323, "feedback": "The algorithm QAPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6427389398904158, 0.6427389398904158, 0.6427389398904158, 0.6282392746426639, 0.6282392746426639, 0.6282392746426639, 0.6539903433520774, 0.6539903433520774, 0.6539903433520774, 0.14707892728556893, 0.14707892728556893, 0.14707892728556893, 0.040472608748796435, 0.040472608748796435, 0.040472608748796435, 0.09423124089568224, 0.09423124089568224, 0.09423124089568224, 0.1379168385794023, 0.1379168385794023, 0.1379168385794023, 0.13019950077562603, 0.13019950077562603, 0.13019950077562603, 0.12546174625055173, 0.12546174625055173, 0.12546174625055173, 0.10327083970978024, 0.10327083970978024, 0.10327083970978024, 0.10647392869678263, 0.10647392869678263, 0.10647392869678263, 0.07531625205925863, 0.07531625205925863, 0.07531625205925863, 0.9703315563543242, 0.9703315563543242, 0.9703315563543242, 0.9073246677848206, 0.9073246677848206, 0.9073246677848206, 0.9824678715261677, 0.9824678715261677, 0.9824678715261677, 0.38650356375928363, 0.38650356375928363, 0.38650356375928363, 0.3697297491837822, 0.3697297491837822, 0.3697297491837822, 0.3902876641462458, 0.3902876641462458, 0.3902876641462458, 0.21303061801169842, 0.21303061801169842, 0.21303061801169842, 0.20685506552590593, 0.20685506552590593, 0.20685506552590593, 0.5701591349221597, 0.5701591349221597, 0.5701591349221597, 0.17817693567753923, 0.17817693567753923, 0.17817693567753923, 0.092310563966572, 0.092310563966572, 0.092310563966572, 0.1828535835498657, 0.1828535835498657, 0.1828535835498657, 0.4610361857909442, 0.4610361857909442, 0.4610361857909442, 0.17075474815140423, 0.17075474815140423, 0.17075474815140423, 0.28159086195161553, 0.28159086195161553, 0.28159086195161553, 0.047670549826903885, 0.047670549826903885, 0.047670549826903885, 0.14875886725001186, 0.14875886725001186, 0.14875886725001186, 0.23313614022619122, 0.23313614022619122, 0.23313614022619122, 0.2996780367504669, 0.2996780367504669, 0.2996780367504669, 0.16881932090602692, 0.16881932090602692, 0.16881932090602692, 0.2506870207481807, 0.2506870207481807, 0.2506870207481807, 0.031382018464603756, 0.031382018464603756, 0.031382018464603756, 0.15546026402629032, 0.15546026402629032, 0.15546026402629032, 0.06503813320196117, 0.06503813320196117, 0.06503813320196117, 0.19316469544193082, 0.19316469544193082, 0.19316469544193082, 0.17793408863366567, 0.17793408863366567, 0.17793408863366567, 0.0960460361627643, 0.0960460361627643, 0.0960460361627643, 0.5119757576268605, 0.5119757576268605, 0.5119757576268605, 0.5404421892443639, 0.5404421892443639, 0.5404421892443639, 0.5273802718876288, 0.5273802718876288, 0.5273802718876288, 0.11768926761195653, 0.11768926761195653, 0.11768926761195653, 0.11853776816607275, 0.11853776816607275, 0.11853776816607275, 0.12303952058123302, 0.12303952058123302, 0.12303952058123302, 0.21243796945993298, 0.21243796945993298, 0.21243796945993298, 0.18648919581993273, 0.18648919581993273, 0.18648919581993273, 0.214241652332538, 0.214241652332538, 0.214241652332538, 0.35840829793403806, 0.35840829793403806, 0.35840829793403806, 0.3186123700924346, 0.3186123700924346, 0.3186123700924346, 0.33180066002100106, 0.33180066002100106, 0.33180066002100106, 0.16361930970288907, 0.16361930970288907, 0.16361930970288907, 0.20037750612204386, 0.20037750612204386, 0.20037750612204386, 0.1591995760489342, 0.1591995760489342, 0.1591995760489342, 0.20551477998453282, 0.20551477998453282, 0.20551477998453282, 0.2266265067990495, 0.2266265067990495, 0.2266265067990495, 0.2100437519997116, 0.2100437519997116, 0.2100437519997116, 0.1849029610865648, 0.1849029610865648, 0.1849029610865648, 0.20650242935045315, 0.20650242935045315, 0.20650242935045315, 0.17465766778736325, 0.17465766778736325, 0.17465766778736325, 0.8058377322558596, 0.8058377322558596, 0.8058377322558596, 0.7311810796667433, 0.7311810796667433, 0.7311810796667433, 0.19446778806775789, 0.19446778806775789, 0.19446778806775789, 0.6809216215898156, 0.6809216215898156, 0.6809216215898156, 0.2044015956982672, 0.2044015956982672, 0.2044015956982672, 0.1529215440707723, 0.1529215440707723, 0.1529215440707723, 0.18645688816126293, 0.18645688816126293, 0.18645688816126293, 0.2116629836633196, 0.2116629836633196, 0.2116629836633196, 0.2038007955709048, 0.2038007955709048, 0.2038007955709048, 0.09955256386566924, 0.09955256386566924, 0.09955256386566924, 0.07995775802537664, 0.07995775802537664, 0.07995775802537664, 0.08573944038870829, 0.08573944038870829, 0.08573944038870829]}, "mutation_prompt": null}
{"id": "092bd105-7ca6-4b61-8fab-fef378b98b00", "solution": "import numpy as np\n\nclass HyQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.25 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "HyQDE", "description": "Hybrid Quantum-Inspired Differential Evolution (HyQDE) synergizes quantum perturbations with adaptive differential evolution strategies to optimize performance.", "configspace": "", "generation": 35, "fitness": 0.2996795293906417, "feedback": "The algorithm HyQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6844847337267571, 0.6844847337267571, 0.6844847337267571, 0.6394965380728275, 0.6394965380728275, 0.6394965380728275, 0.6651381073496343, 0.6651381073496343, 0.6651381073496343, 0.07942486099419788, 0.07942486099419788, 0.07942486099419788, 0.05776848866566764, 0.05776848866566764, 0.05776848866566764, 0.043032628880117385, 0.043032628880117385, 0.043032628880117385, 0.11208416493248041, 0.11208416493248041, 0.11208416493248041, 0.10240863871510153, 0.10240863871510153, 0.10240863871510153, 0.12461093035167525, 0.12461093035167525, 0.12461093035167525, 0.10739882207750928, 0.10739882207750928, 0.10739882207750928, 0.10753175686133931, 0.10753175686133931, 0.10753175686133931, 0.09965749705355098, 0.09965749705355098, 0.09965749705355098, 0.9720469134987735, 0.9720469134987735, 0.9720469134987735, 0.9747931783665004, 0.9747931783665004, 0.9747931783665004, 0.9868776580173438, 0.9868776580173438, 0.9868776580173438, 0.3875566217927954, 0.3875566217927954, 0.3875566217927954, 0.3925550975505908, 0.3925550975505908, 0.3925550975505908, 0.40463052244832876, 0.40463052244832876, 0.40463052244832876, 0.6150722221847772, 0.6150722221847772, 0.6150722221847772, 0.642835224409488, 0.642835224409488, 0.642835224409488, 0.6879653562267343, 0.6879653562267343, 0.6879653562267343, 0.3170383459542172, 0.3170383459542172, 0.3170383459542172, 0.12200877354523432, 0.12200877354523432, 0.12200877354523432, 0.21114358622592788, 0.21114358622592788, 0.21114358622592788, 0.27475237322761836, 0.27475237322761836, 0.27475237322761836, 0.21403063296316993, 0.21403063296316993, 0.21403063296316993, 0.11516261218383639, 0.11516261218383639, 0.11516261218383639, 0.12141824022770564, 0.12141824022770564, 0.12141824022770564, 0.2644799288195231, 0.2644799288195231, 0.2644799288195231, 0.23786478003971157, 0.23786478003971157, 0.23786478003971157, 0.37668177785857193, 0.37668177785857193, 0.37668177785857193, 0.36801062890448066, 0.36801062890448066, 0.36801062890448066, 0.3676126600058338, 0.3676126600058338, 0.3676126600058338, 0.033149112800415215, 0.033149112800415215, 0.033149112800415215, 0.23753101399962462, 0.23753101399962462, 0.23753101399962462, 0.13047599669760335, 0.13047599669760335, 0.13047599669760335, 0.1915035564627975, 0.1915035564627975, 0.1915035564627975, 0.21301443708599732, 0.21301443708599732, 0.21301443708599732, 0.15743294050654166, 0.15743294050654166, 0.15743294050654166, 0.5771573578017017, 0.5771573578017017, 0.5771573578017017, 0.556762045074439, 0.556762045074439, 0.556762045074439, 0.6062926123795838, 0.6062926123795838, 0.6062926123795838, 0.09691207973638216, 0.09691207973638216, 0.09691207973638216, 0.13129136623995363, 0.13129136623995363, 0.13129136623995363, 0.13493740319174008, 0.13493740319174008, 0.13493740319174008, 0.1737318629106701, 0.1737318629106701, 0.1737318629106701, 0.2888147394380066, 0.2888147394380066, 0.2888147394380066, 0.23216472445031244, 0.23216472445031244, 0.23216472445031244, 0.35308654289781227, 0.35308654289781227, 0.35308654289781227, 0.3232276256047859, 0.3232276256047859, 0.3232276256047859, 0.39338100915085017, 0.39338100915085017, 0.39338100915085017, 0.12522686366520008, 0.12522686366520008, 0.12522686366520008, 0.22060089385955262, 0.22060089385955262, 0.22060089385955262, 0.1293235124394625, 0.1293235124394625, 0.1293235124394625, 0.2103266139411354, 0.2103266139411354, 0.2103266139411354, 0.20624742472848934, 0.20624742472848934, 0.20624742472848934, 0.20013420774007762, 0.20013420774007762, 0.20013420774007762, 0.19975872362562042, 0.19975872362562042, 0.19975872362562042, 0.22567003272141806, 0.22567003272141806, 0.22567003272141806, 0.19135544396889792, 0.19135544396889792, 0.19135544396889792, 0.843848196924065, 0.843848196924065, 0.843848196924065, 0.15668661597433386, 0.15668661597433386, 0.15668661597433386, 0.1684226022589932, 0.1684226022589932, 0.1684226022589932, 0.7724993043786264, 0.7724993043786264, 0.7724993043786264, 0.206675230777972, 0.206675230777972, 0.206675230777972, 0.15327281754936917, 0.15327281754936917, 0.15327281754936917, 0.18837448277237867, 0.18837448277237867, 0.18837448277237867, 0.18809342768586446, 0.18809342768586446, 0.18809342768586446, 0.191169679145065, 0.191169679145065, 0.191169679145065, 0.0795884247093569, 0.0795884247093569, 0.0795884247093569, 0.08750405908101078, 0.08750405908101078, 0.08750405908101078, 0.12370682961807522, 0.12370682961807522, 0.12370682961807522]}, "mutation_prompt": null}
{"id": "2fca325f-5f09-4a32-92ce-76c5a2454eeb", "solution": "import numpy as np\n\nclass QSHO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.04, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.3 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QSHO", "description": "Quantum-Swarm Hybrid Optimization (QSHO) integrates quantum-inspired perturbations with a dynamic swarm intelligence adaptation for enhanced precision and convergence.", "configspace": "", "generation": 36, "fitness": 0.29101478621409943, "feedback": "The algorithm QSHO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6740163862850386, 0.6740163862850386, 0.6740163862850386, 0.669786801563274, 0.669786801563274, 0.669786801563274, 0.6966372444391922, 0.6966372444391922, 0.6966372444391922, 0.16911794472360486, 0.16911794472360486, 0.16911794472360486, 0.13935893877588423, 0.13935893877588423, 0.13935893877588423, 0.03682347031477762, 0.03682347031477762, 0.03682347031477762, 0.12388756095017017, 0.12388756095017017, 0.12388756095017017, 0.09246228953626834, 0.09246228953626834, 0.09246228953626834, 0.08841907323261244, 0.08841907323261244, 0.08841907323261244, 0.09855116430346589, 0.09855116430346589, 0.09855116430346589, 0.0953728378209806, 0.0953728378209806, 0.0953728378209806, 0.11356195589690032, 0.11356195589690032, 0.11356195589690032, 0.9735153351917853, 0.9735153351917853, 0.9735153351917853, 0.9749056249909057, 0.9749056249909057, 0.9749056249909057, 0.9869125032126892, 0.9869125032126892, 0.9869125032126892, 0.37650241822743846, 0.37650241822743846, 0.37650241822743846, 0.41184100122123013, 0.41184100122123013, 0.41184100122123013, 0.36948982194562197, 0.36948982194562197, 0.36948982194562197, 0.6522203453337421, 0.6522203453337421, 0.6522203453337421, 0.600192038882074, 0.600192038882074, 0.600192038882074, 0.6936444253190124, 0.6936444253190124, 0.6936444253190124, 0.1412543474442478, 0.1412543474442478, 0.1412543474442478, 0.1742116651711516, 0.1742116651711516, 0.1742116651711516, 0.32502130723916367, 0.32502130723916367, 0.32502130723916367, 0.3275398970267477, 0.3275398970267477, 0.3275398970267477, 0.16218603304768853, 0.16218603304768853, 0.16218603304768853, 0.16878780320185527, 0.16878780320185527, 0.16878780320185527, 0.050277593856542846, 0.050277593856542846, 0.050277593856542846, 0.3559305962990845, 0.3559305962990845, 0.3559305962990845, 0.241363366200263, 0.241363366200263, 0.241363366200263, 0.33091838658994455, 0.33091838658994455, 0.33091838658994455, 0.05340496448096743, 0.05340496448096743, 0.05340496448096743, 0.3059568168325444, 0.3059568168325444, 0.3059568168325444, 0.0374060444556531, 0.0374060444556531, 0.0374060444556531, 0.0535091283176824, 0.0535091283176824, 0.0535091283176824, 0.07178904949500098, 0.07178904949500098, 0.07178904949500098, 0.10894361548225351, 0.10894361548225351, 0.10894361548225351, 0.18364104506487178, 0.18364104506487178, 0.18364104506487178, 0.1802062604694944, 0.1802062604694944, 0.1802062604694944, 0.5820707310905497, 0.5820707310905497, 0.5820707310905497, 0.5195628361644591, 0.5195628361644591, 0.5195628361644591, 0.5486289912817999, 0.5486289912817999, 0.5486289912817999, 0.14501775829064123, 0.14501775829064123, 0.14501775829064123, 0.11532655310487283, 0.11532655310487283, 0.11532655310487283, 0.08384817749052198, 0.08384817749052198, 0.08384817749052198, 0.23005945757418655, 0.23005945757418655, 0.23005945757418655, 0.24271241792712028, 0.24271241792712028, 0.24271241792712028, 0.18430573677366224, 0.18430573677366224, 0.18430573677366224, 0.355704669376664, 0.355704669376664, 0.355704669376664, 0.3746130967379988, 0.3746130967379988, 0.3746130967379988, 0.3611814333257959, 0.3611814333257959, 0.3611814333257959, 0.17492118335491014, 0.17492118335491014, 0.17492118335491014, 0.21566135665943142, 0.21566135665943142, 0.21566135665943142, 0.14565518442971492, 0.14565518442971492, 0.14565518442971492, 0.23571270913541487, 0.23571270913541487, 0.23571270913541487, 0.2187908899915454, 0.2187908899915454, 0.2187908899915454, 0.20072455888321106, 0.20072455888321106, 0.20072455888321106, 0.2039351006018565, 0.2039351006018565, 0.2039351006018565, 0.2000460546118783, 0.2000460546118783, 0.2000460546118783, 0.1965800115237507, 0.1965800115237507, 0.1965800115237507, 0.8353561452931018, 0.8353561452931018, 0.8353561452931018, 0.15594298646402038, 0.15594298646402038, 0.15594298646402038, 0.16892720077063494, 0.16892720077063494, 0.16892720077063494, 0.7052365055093809, 0.7052365055093809, 0.7052365055093809, 0.20725472178582915, 0.20725472178582915, 0.20725472178582915, 0.1675110728196907, 0.1675110728196907, 0.1675110728196907, 0.2001928204303688, 0.2001928204303688, 0.2001928204303688, 0.1824437431089413, 0.1824437431089413, 0.1824437431089413, 0.20622449357738393, 0.20622449357738393, 0.20622449357738393, 0.09438163185277137, 0.09438163185277137, 0.09438163185277137, 0.07857874167980172, 0.07857874167980172, 0.07857874167980172, 0.10638853295141981, 0.10638853295141981, 0.10638853295141981]}, "mutation_prompt": null}
{"id": "3b2197d2-f427-418c-b98f-6d6f598ce779", "solution": "import numpy as np\n\nclass QEASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.15 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEASPlus", "description": "Quantum-Enhanced Adaptive Strategy (QEAS+) leverages quantum perturbations with dynamically tuned parameters and selective stochastic acceptance for improved optimization.", "configspace": "", "generation": 37, "fitness": 0.32372154365771694, "feedback": "The algorithm QEASPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7395950826954695, 0.7395950826954695, 0.7395950826954695, 0.7273531150154857, 0.7273531150154857, 0.7273531150154857, 0.7389613347799024, 0.7389613347799024, 0.7389613347799024, 0.19480278307234178, 0.19480278307234178, 0.19480278307234178, 0.19822910156369944, 0.19822910156369944, 0.19822910156369944, 0.07565643018702539, 0.07565643018702539, 0.07565643018702539, 0.11742889911328525, 0.11742889911328525, 0.11742889911328525, 0.10259081780303947, 0.10259081780303947, 0.10259081780303947, 0.10622464057605352, 0.10622464057605352, 0.10622464057605352, 0.12860815454589158, 0.12860815454589158, 0.12860815454589158, 0.09575873285949732, 0.09575873285949732, 0.09575873285949732, 0.057676168042231635, 0.057676168042231635, 0.057676168042231635, 0.9737604778030137, 0.9737604778030137, 0.9737604778030137, 0.974637596650036, 0.974637596650036, 0.974637596650036, 0.9868867267814853, 0.9868867267814853, 0.9868867267814853, 0.46825423737439165, 0.46825423737439165, 0.46825423737439165, 0.4410189910473844, 0.4410189910473844, 0.4410189910473844, 0.5406098761863241, 0.5406098761863241, 0.5406098761863241, 0.7708419506050742, 0.7708419506050742, 0.7708419506050742, 0.6896310366118488, 0.6896310366118488, 0.6896310366118488, 0.21050078141480666, 0.21050078141480666, 0.21050078141480666, 0.33685425977878103, 0.33685425977878103, 0.33685425977878103, 0.49499336653218884, 0.49499336653218884, 0.49499336653218884, 0.3643136229576739, 0.3643136229576739, 0.3643136229576739, 0.19565824352138295, 0.19565824352138295, 0.19565824352138295, 0.25968574751021845, 0.25968574751021845, 0.25968574751021845, 0.24242816868884687, 0.24242816868884687, 0.24242816868884687, 0.099747645350028, 0.099747645350028, 0.099747645350028, 0.04449359383707674, 0.04449359383707674, 0.04449359383707674, 0.3268000855410209, 0.3268000855410209, 0.3268000855410209, 0.522453534200928, 0.522453534200928, 0.522453534200928, 0.16546232691113927, 0.16546232691113927, 0.16546232691113927, 0.30278810399993206, 0.30278810399993206, 0.30278810399993206, 0.04200586569639653, 0.04200586569639653, 0.04200586569639653, 0.12847259683733903, 0.12847259683733903, 0.12847259683733903, 0.07801080297718199, 0.07801080297718199, 0.07801080297718199, 0.30282988376222697, 0.30282988376222697, 0.30282988376222697, 0.27987751337419187, 0.27987751337419187, 0.27987751337419187, 0.25854110758886095, 0.25854110758886095, 0.25854110758886095, 0.6686115113088185, 0.6686115113088185, 0.6686115113088185, 0.6440491062847234, 0.6440491062847234, 0.6440491062847234, 0.6147173378802863, 0.6147173378802863, 0.6147173378802863, 0.15212718628646638, 0.15212718628646638, 0.15212718628646638, 0.1302311836975636, 0.1302311836975636, 0.1302311836975636, 0.07565992835969315, 0.07565992835969315, 0.07565992835969315, 0.4362341182389078, 0.4362341182389078, 0.4362341182389078, 0.23111098058117063, 0.23111098058117063, 0.23111098058117063, 0.35017415771715, 0.35017415771715, 0.35017415771715, 0.3058713501665623, 0.3058713501665623, 0.3058713501665623, 0.4309731998320946, 0.4309731998320946, 0.4309731998320946, 0.3970027535465782, 0.3970027535465782, 0.3970027535465782, 0.1679367432298805, 0.1679367432298805, 0.1679367432298805, 0.17024970937780182, 0.17024970937780182, 0.17024970937780182, 0.14382302285206383, 0.14382302285206383, 0.14382302285206383, 0.24909727508707213, 0.24909727508707213, 0.24909727508707213, 0.2181547844091707, 0.2181547844091707, 0.2181547844091707, 0.23209826003932243, 0.23209826003932243, 0.23209826003932243, 0.19584850257960873, 0.19584850257960873, 0.19584850257960873, 0.19087827223300868, 0.19087827223300868, 0.19087827223300868, 0.2089781203335236, 0.2089781203335236, 0.2089781203335236, 0.8771251704138595, 0.8771251704138595, 0.8771251704138595, 0.15591914093188675, 0.15591914093188675, 0.15591914093188675, 0.16876591301174104, 0.16876591301174104, 0.16876591301174104, 0.7930125251974148, 0.7930125251974148, 0.7930125251974148, 0.2084113980107266, 0.2084113980107266, 0.2084113980107266, 0.16720453067964536, 0.16720453067964536, 0.16720453067964536, 0.2117212380237785, 0.2117212380237785, 0.2117212380237785, 0.19700479088037215, 0.19700479088037215, 0.19700479088037215, 0.21878822816885868, 0.21878822816885868, 0.21878822816885868, 0.08826953500923895, 0.08826953500923895, 0.08826953500923895, 0.10379732886750748, 0.10379732886750748, 0.10379732886750748, 0.11966043632542045, 0.11966043632542045, 0.11966043632542045]}, "mutation_prompt": null}
{"id": "7f99d7c7-7041-44cb-8adf-00a44acedcac", "solution": "import numpy as np\n\nclass QLASPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.9\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_scale = np.random.uniform(0, (upper_bound - lower_bound) * 0.1, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_scale * np.random.standard_cauchy((self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget)**2)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget)**2)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.3 * (1 - (evaluations / self.budget)**1.5)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlusPlus", "description": "Quantum-Leveraged Adaptive Strategy Plus Plus (QLAS++) refines optimization with hierarchical quantum perturbations, dynamic parameter adjustments, and advanced stochastic acceptance.", "configspace": "", "generation": 38, "fitness": 0.259454823048292, "feedback": "The algorithm QLASPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.5845265290126127, 0.5845265290126127, 0.5845265290126127, 0.6027906304971244, 0.6027906304971244, 0.6027906304971244, 0.5923352275750711, 0.5923352275750711, 0.5923352275750711, 0.14042600422934925, 0.14042600422934925, 0.14042600422934925, 0.08250576885376848, 0.08250576885376848, 0.08250576885376848, 0.03075775529292568, 0.03075775529292568, 0.03075775529292568, 0.10907575316953988, 0.10907575316953988, 0.10907575316953988, 0.12048449248694526, 0.12048449248694526, 0.12048449248694526, 0.11206890162120775, 0.11206890162120775, 0.11206890162120775, 0.12535928948462882, 0.12535928948462882, 0.12535928948462882, 0.09533964430169506, 0.09533964430169506, 0.09533964430169506, 0.09811310135361839, 0.09811310135361839, 0.09811310135361839, 0.9734740598110773, 0.9734740598110773, 0.9734740598110773, 0.9742718714043638, 0.9742718714043638, 0.9742718714043638, 0.9717876329259862, 0.9717876329259862, 0.9717876329259862, 0.3337410468091845, 0.3337410468091845, 0.3337410468091845, 0.3216860749138807, 0.3216860749138807, 0.3216860749138807, 0.33082522374526036, 0.33082522374526036, 0.33082522374526036, 0.6327547102915337, 0.6327547102915337, 0.6327547102915337, 0.24849892823445285, 0.24849892823445285, 0.24849892823445285, 0.6903565197307004, 0.6903565197307004, 0.6903565197307004, 0.26588417160928035, 0.26588417160928035, 0.26588417160928035, 0.13914575225329318, 0.13914575225329318, 0.13914575225329318, 0.30557142468455045, 0.30557142468455045, 0.30557142468455045, 0.09070367657206302, 0.09070367657206302, 0.09070367657206302, 0.10380389458046879, 0.10380389458046879, 0.10380389458046879, 0.15191658027638022, 0.15191658027638022, 0.15191658027638022, 0.047488622988715035, 0.047488622988715035, 0.047488622988715035, 0.011100230242673259, 0.011100230242673259, 0.011100230242673259, 0.0976929303114934, 0.0976929303114934, 0.0976929303114934, 0.17407453823827745, 0.17407453823827745, 0.17407453823827745, 0.06301814127114591, 0.06301814127114591, 0.06301814127114591, 0.050475467972451726, 0.050475467972451726, 0.050475467972451726, 0.028910495286607496, 0.028910495286607496, 0.028910495286607496, 0.044324347962974575, 0.044324347962974575, 0.044324347962974575, 0.048423468006745685, 0.048423468006745685, 0.048423468006745685, 0.14953379764159214, 0.14953379764159214, 0.14953379764159214, 0.034934482249132315, 0.034934482249132315, 0.034934482249132315, 0.14705991379477268, 0.14705991379477268, 0.14705991379477268, 0.47954122053115233, 0.47954122053115233, 0.47954122053115233, 0.47777036719403587, 0.47777036719403587, 0.47777036719403587, 0.4756830040148976, 0.4756830040148976, 0.4756830040148976, 0.11930667595850719, 0.11930667595850719, 0.11930667595850719, 0.0929501606417229, 0.0929501606417229, 0.0929501606417229, 0.12679697543520774, 0.12679697543520774, 0.12679697543520774, 0.17105428857155236, 0.17105428857155236, 0.17105428857155236, 0.18095395415853022, 0.18095395415853022, 0.18095395415853022, 0.2011845116427433, 0.2011845116427433, 0.2011845116427433, 0.35088389097532224, 0.35088389097532224, 0.35088389097532224, 0.33355379331325785, 0.33355379331325785, 0.33355379331325785, 0.27394409527609664, 0.27394409527609664, 0.27394409527609664, 0.13898773702352085, 0.13898773702352085, 0.13898773702352085, 0.2660592227498876, 0.2660592227498876, 0.2660592227498876, 0.15530998307348198, 0.15530998307348198, 0.15530998307348198, 0.2231865557131789, 0.2231865557131789, 0.2231865557131789, 0.21064506122036386, 0.21064506122036386, 0.21064506122036386, 0.1989681159091552, 0.1989681159091552, 0.1989681159091552, 0.2313686605988693, 0.2313686605988693, 0.2313686605988693, 0.18961909552922218, 0.18961909552922218, 0.18961909552922218, 0.190214090109593, 0.190214090109593, 0.190214090109593, 0.8147405043393123, 0.8147405043393123, 0.8147405043393123, 0.16626450910797574, 0.16626450910797574, 0.16626450910797574, 0.16713395035040246, 0.16713395035040246, 0.16713395035040246, 0.696230853312041, 0.696230853312041, 0.696230853312041, 0.6456565294186987, 0.6456565294186987, 0.6456565294186987, 0.15277921056014387, 0.15277921056014387, 0.15277921056014387, 0.19887905059972055, 0.19887905059972055, 0.19887905059972055, 0.1928687874299737, 0.1928687874299737, 0.1928687874299737, 0.18070817728550936, 0.18070817728550936, 0.18070817728550936, 0.07953011044552427, 0.07953011044552427, 0.07953011044552427, 0.07899855439360326, 0.07899855439360326, 0.07899855439360326, 0.09373446090627369, 0.09373446090627369, 0.09373446090627369]}, "mutation_prompt": null}
{"id": "fa58a611-2f00-4f2f-b9f4-4a5d1251b4d2", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "50077cf5-7d6f-4301-b6f4-beee9abde36a", "solution": "import numpy as np\n\nclass QLASPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.2 * (1 - (evaluations / self.budget))\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS+) enhances optimization via quantum-inspired perturbations with refined adaptive parameters and stochastic acceptance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7205919758314117, 0.7205919758314117, 0.7205919758314117, 0.710500946029381, 0.710500946029381, 0.710500946029381, 0.7025233650491302, 0.7025233650491302, 0.7025233650491302, 0.13713714463701976, 0.13713714463701976, 0.13713714463701976, 0.20178526871035096, 0.20178526871035096, 0.20178526871035096, 0.12228455950737827, 0.12228455950737827, 0.12228455950737827, 0.14204018792814455, 0.14204018792814455, 0.14204018792814455, 0.13219592888974563, 0.13219592888974563, 0.13219592888974563, 0.14535779684870553, 0.14535779684870553, 0.14535779684870553, 0.1156930186016556, 0.1156930186016556, 0.1156930186016556, 0.15628660175454823, 0.15628660175454823, 0.15628660175454823, 0.11053314783545898, 0.11053314783545898, 0.11053314783545898, 0.9704135055181518, 0.9704135055181518, 0.9704135055181518, 0.9850296684090414, 0.9850296684090414, 0.9850296684090414, 0.9858453146079548, 0.9858453146079548, 0.9858453146079548, 0.45876264442511305, 0.45876264442511305, 0.45876264442511305, 0.4516098593770831, 0.4516098593770831, 0.4516098593770831, 0.40707423271436183, 0.40707423271436183, 0.40707423271436183, 0.7064075257989432, 0.7064075257989432, 0.7064075257989432, 0.2650043570702678, 0.2650043570702678, 0.2650043570702678, 0.744834470146241, 0.744834470146241, 0.744834470146241, 0.17095231867475325, 0.17095231867475325, 0.17095231867475325, 0.216824350486143, 0.216824350486143, 0.216824350486143, 0.15325562198822795, 0.15325562198822795, 0.15325562198822795, 0.17694455060963377, 0.17694455060963377, 0.17694455060963377, 0.2824085792465475, 0.2824085792465475, 0.2824085792465475, 0.40332503107601747, 0.40332503107601747, 0.40332503107601747, 0.4374608242605188, 0.4374608242605188, 0.4374608242605188, 0.29618658569137846, 0.29618658569137846, 0.29618658569137846, 0.3136724518679871, 0.3136724518679871, 0.3136724518679871, 0.46697375860218215, 0.46697375860218215, 0.46697375860218215, 0.45758640468619693, 0.45758640468619693, 0.45758640468619693, 0.49776269630473813, 0.49776269630473813, 0.49776269630473813, 0.03942819599510927, 0.03942819599510927, 0.03942819599510927, 0.06224516204964603, 0.06224516204964603, 0.06224516204964603, 0.0705879544545791, 0.0705879544545791, 0.0705879544545791, 0.23078604276267545, 0.23078604276267545, 0.23078604276267545, 0.23475998737381365, 0.23475998737381365, 0.23475998737381365, 0.26916371657578897, 0.26916371657578897, 0.26916371657578897, 0.6177886196262163, 0.6177886196262163, 0.6177886196262163, 0.6303743284438272, 0.6303743284438272, 0.6303743284438272, 0.5966843689505288, 0.5966843689505288, 0.5966843689505288, 0.16001949767709556, 0.16001949767709556, 0.16001949767709556, 0.11730203710857312, 0.11730203710857312, 0.11730203710857312, 0.09030002855069452, 0.09030002855069452, 0.09030002855069452, 0.2881067451686413, 0.2881067451686413, 0.2881067451686413, 0.21129398540863953, 0.21129398540863953, 0.21129398540863953, 0.5416649846831476, 0.5416649846831476, 0.5416649846831476, 0.2905394258352407, 0.2905394258352407, 0.2905394258352407, 0.24812654899042996, 0.24812654899042996, 0.24812654899042996, 0.34896487765176776, 0.34896487765176776, 0.34896487765176776, 0.2549502295563266, 0.2549502295563266, 0.2549502295563266, 0.1742649350150698, 0.1742649350150698, 0.1742649350150698, 0.23395475676504063, 0.23395475676504063, 0.23395475676504063, 0.2603525250138914, 0.2603525250138914, 0.2603525250138914, 0.20400955613927396, 0.20400955613927396, 0.20400955613927396, 0.21984162725722967, 0.21984162725722967, 0.21984162725722967, 0.2353410627258522, 0.2353410627258522, 0.2353410627258522, 0.20936985825846954, 0.20936985825846954, 0.20936985825846954, 0.23564522856539116, 0.23564522856539116, 0.23564522856539116, 0.8709597254100554, 0.8709597254100554, 0.8709597254100554, 0.8214497911723366, 0.8214497911723366, 0.8214497911723366, 0.16580279011607546, 0.16580279011607546, 0.16580279011607546, 0.8076649465339402, 0.8076649465339402, 0.8076649465339402, 0.20273974022982832, 0.20273974022982832, 0.20273974022982832, 0.15245932565623765, 0.15245932565623765, 0.15245932565623765, 0.20386900584405143, 0.20386900584405143, 0.20386900584405143, 0.1987625352077247, 0.1987625352077247, 0.1987625352077247, 0.19509894997835941, 0.19509894997835941, 0.19509894997835941, 0.08865067809907845, 0.08865067809907845, 0.08865067809907845, 0.09670701489645295, 0.09670701489645295, 0.09670701489645295, 0.11177400377084146, 0.11177400377084146, 0.11177400377084146]}, "mutation_prompt": null}
{"id": "45a82417-58b3-450b-961a-1eaced280796", "solution": "import numpy as np\n\nclass QLASPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted to slightly enhance exploitation\n        self.c2 = 1.7  # Adjusted for better exploration\n        self.inertia_weight = 0.7  # Increased for more consistent velocity updates\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85  # Reduced for finer mutation control\n        self.crossover_rate_base = 0.6  # Lower base rate for more varied crossover\n        self.crossover_rate_max = 0.95  # Higher max crossover rate for intensified mid-late search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.04, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.25 * (1 - (evaluations / self.budget))  # Increased acceptance probability\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QLASPlusPlus", "description": "Quantum-Leveraged Adaptive Strategy (QLAS++) improves global search by incorporating quantum-inspired perturbations with dynamic adaptive parameters and enhanced stochastic acceptance.", "configspace": "", "generation": 41, "fitness": 0.28907083320724736, "feedback": "The algorithm QLASPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.6726565234262089, 0.6726565234262089, 0.6726565234262089, 0.6750240575002169, 0.6750240575002169, 0.6750240575002169, 0.6672065159300036, 0.6672065159300036, 0.6672065159300036, 0.2528681319574968, 0.2528681319574968, 0.2528681319574968, 0.09871861433843909, 0.09871861433843909, 0.09871861433843909, 0.14804692644296502, 0.14804692644296502, 0.14804692644296502, 0.11191430051357343, 0.11191430051357343, 0.11191430051357343, 0.10376206324982473, 0.10376206324982473, 0.10376206324982473, 0.1199474254896633, 0.1199474254896633, 0.1199474254896633, 0.10500731334092284, 0.10500731334092284, 0.10500731334092284, 0.08969670050294698, 0.08969670050294698, 0.08969670050294698, 0.1016149868304781, 0.1016149868304781, 0.1016149868304781, 0.9719887629181596, 0.9719887629181596, 0.9719887629181596, 0.9740981443909482, 0.9740981443909482, 0.9740981443909482, 0.9868883032454009, 0.9868883032454009, 0.9868883032454009, 0.35785638311828916, 0.35785638311828916, 0.35785638311828916, 0.4141034901091044, 0.4141034901091044, 0.4141034901091044, 0.42362176337977353, 0.42362176337977353, 0.42362176337977353, 0.644074407620645, 0.644074407620645, 0.644074407620645, 0.5617685579228762, 0.5617685579228762, 0.5617685579228762, 0.6796516115263291, 0.6796516115263291, 0.6796516115263291, 0.3083540902482952, 0.3083540902482952, 0.3083540902482952, 0.12007302622448901, 0.12007302622448901, 0.12007302622448901, 0.18776599442813435, 0.18776599442813435, 0.18776599442813435, 0.29426730552462677, 0.29426730552462677, 0.29426730552462677, 0.18459847340185964, 0.18459847340185964, 0.18459847340185964, 0.22204042703731885, 0.22204042703731885, 0.22204042703731885, 0.05003928572183891, 0.05003928572183891, 0.05003928572183891, 0.08200013208933832, 0.08200013208933832, 0.08200013208933832, 0.2111000951567239, 0.2111000951567239, 0.2111000951567239, 0.2828487795393224, 0.2828487795393224, 0.2828487795393224, 0.2053344225951812, 0.2053344225951812, 0.2053344225951812, 0.10783679100669141, 0.10783679100669141, 0.10783679100669141, 0.030094758564399693, 0.030094758564399693, 0.030094758564399693, 0.1428037409634758, 0.1428037409634758, 0.1428037409634758, 0.07942280872307672, 0.07942280872307672, 0.07942280872307672, 0.2316454315156481, 0.2316454315156481, 0.2316454315156481, 0.2482857785536321, 0.2482857785536321, 0.2482857785536321, 0.16824667109415514, 0.16824667109415514, 0.16824667109415514, 0.5363363657358291, 0.5363363657358291, 0.5363363657358291, 0.5976810685054519, 0.5976810685054519, 0.5976810685054519, 0.5380672959551405, 0.5380672959551405, 0.5380672959551405, 0.11026459441043968, 0.11026459441043968, 0.11026459441043968, 0.09891479452917373, 0.09891479452917373, 0.09891479452917373, 0.10321240719171032, 0.10321240719171032, 0.10321240719171032, 0.19546697868579965, 0.19546697868579965, 0.19546697868579965, 0.25822129191257637, 0.25822129191257637, 0.25822129191257637, 0.17426793167604004, 0.17426793167604004, 0.17426793167604004, 0.35094846515018807, 0.35094846515018807, 0.35094846515018807, 0.34044187778334767, 0.34044187778334767, 0.34044187778334767, 0.2963955613957101, 0.2963955613957101, 0.2963955613957101, 0.17386551461586208, 0.17386551461586208, 0.17386551461586208, 0.20502309005453212, 0.20502309005453212, 0.20502309005453212, 0.15895720897322096, 0.15895720897322096, 0.15895720897322096, 0.20188355835749183, 0.20188355835749183, 0.20188355835749183, 0.2005950657011628, 0.2005950657011628, 0.2005950657011628, 0.18913198973730372, 0.18913198973730372, 0.18913198973730372, 0.2242688011313958, 0.2242688011313958, 0.2242688011313958, 0.19395720018213847, 0.19395720018213847, 0.19395720018213847, 0.2054315676344245, 0.2054315676344245, 0.2054315676344245, 0.826731622172898, 0.826731622172898, 0.826731622172898, 0.15619281711185995, 0.15619281711185995, 0.15619281711185995, 0.16883085451721125, 0.16883085451721125, 0.16883085451721125, 0.7611007562757255, 0.7611007562757255, 0.7611007562757255, 0.20606173859043198, 0.20606173859043198, 0.20606173859043198, 0.16627960954577592, 0.16627960954577592, 0.16627960954577592, 0.18564745357003754, 0.18564745357003754, 0.18564745357003754, 0.18089782141833088, 0.18089782141833088, 0.18089782141833088, 0.19963352221581532, 0.19963352221581532, 0.19963352221581532, 0.09285741165278594, 0.09285741165278594, 0.09285741165278594, 0.0844229450352657, 0.0844229450352657, 0.0844229450352657, 0.11383781335426102, 0.11383781335426102, 0.11383781335426102]}, "mutation_prompt": null}
{"id": "62b9bcf4-a669-4902-9d1a-8af399193258", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 42, "fitness": 0.33772252774660505, "feedback": "The algorithm QEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "890a54e5-14d8-4448-8bde-d365f4aa441b", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "4bf96b92-9b80-488f-8c66-c94e57f4729a", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "7a60d0c5-84e0-4e07-a552-d7b2c197c503", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "b0fd1cfc-5b71-4931-a910-bf421aa07b28", "solution": "import numpy as np\n\nclass QIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.04, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QIADE", "description": "Quantum-Inspired Adaptive Differential Evolution (QIADE) combines quantum-inspired perturbations with adaptive step sizes and enhanced differential evolution strategies for robust optimization.", "configspace": "", "generation": 45, "fitness": 0.31385073033878247, "feedback": "The algorithm QIADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7126940076719905, 0.7126940076719905, 0.7126940076719905, 0.6769497842228938, 0.6769497842228938, 0.6769497842228938, 0.7222424934337788, 0.7222424934337788, 0.7222424934337788, 0.03373938509607255, 0.03373938509607255, 0.03373938509607255, 0.29530480734837905, 0.29530480734837905, 0.29530480734837905, 0.3625777546535148, 0.3625777546535148, 0.3625777546535148, 0.10738373099473664, 0.10738373099473664, 0.10738373099473664, 0.11428355204754337, 0.11428355204754337, 0.11428355204754337, 0.09250234615420272, 0.09250234615420272, 0.09250234615420272, 0.11046583343118477, 0.11046583343118477, 0.11046583343118477, 0.07725129008741038, 0.07725129008741038, 0.07725129008741038, 0.08360355330790825, 0.08360355330790825, 0.08360355330790825, 0.9743526044123016, 0.9743526044123016, 0.9743526044123016, 0.9752112382422289, 0.9752112382422289, 0.9752112382422289, 0.9868910218621741, 0.9868910218621741, 0.9868910218621741, 0.3961796003081347, 0.3961796003081347, 0.3961796003081347, 0.40401073449962865, 0.40401073449962865, 0.40401073449962865, 0.48908439266234405, 0.48908439266234405, 0.48908439266234405, 0.7565244360588226, 0.7565244360588226, 0.7565244360588226, 0.6473775197003424, 0.6473775197003424, 0.6473775197003424, 0.7415540787393042, 0.7415540787393042, 0.7415540787393042, 0.2235519136315759, 0.2235519136315759, 0.2235519136315759, 0.24825854657591895, 0.24825854657591895, 0.24825854657591895, 0.20322991399170276, 0.20322991399170276, 0.20322991399170276, 0.1368250106078771, 0.1368250106078771, 0.1368250106078771, 0.18939791863416655, 0.18939791863416655, 0.18939791863416655, 0.237324368281842, 0.237324368281842, 0.237324368281842, 0.1456437359817775, 0.1456437359817775, 0.1456437359817775, 0.253327766363163, 0.253327766363163, 0.253327766363163, 0.2889699124855094, 0.2889699124855094, 0.2889699124855094, 0.35741633186957955, 0.35741633186957955, 0.35741633186957955, 0.15817664882499916, 0.15817664882499916, 0.15817664882499916, 0.2745085164383, 0.2745085164383, 0.2745085164383, 0.03513871906331989, 0.03513871906331989, 0.03513871906331989, 0.2023098380027657, 0.2023098380027657, 0.2023098380027657, 0.17277774628567333, 0.17277774628567333, 0.17277774628567333, 0.2712460199784271, 0.2712460199784271, 0.2712460199784271, 0.2945639666584461, 0.2945639666584461, 0.2945639666584461, 0.13436927657576014, 0.13436927657576014, 0.13436927657576014, 0.6087243963015658, 0.6087243963015658, 0.6087243963015658, 0.6185397090812434, 0.6185397090812434, 0.6185397090812434, 0.5901582486989715, 0.5901582486989715, 0.5901582486989715, 0.0983381829314871, 0.0983381829314871, 0.0983381829314871, 0.132620899481659, 0.132620899481659, 0.132620899481659, 0.14639249258870202, 0.14639249258870202, 0.14639249258870202, 0.2349728933339552, 0.2349728933339552, 0.2349728933339552, 0.3242175205112727, 0.3242175205112727, 0.3242175205112727, 0.2232873768573378, 0.2232873768573378, 0.2232873768573378, 0.25368695798893015, 0.25368695798893015, 0.25368695798893015, 0.3657921594833796, 0.3657921594833796, 0.3657921594833796, 0.25482000753868217, 0.25482000753868217, 0.25482000753868217, 0.2706294273756902, 0.2706294273756902, 0.2706294273756902, 0.2073473729055012, 0.2073473729055012, 0.2073473729055012, 0.2021125581351727, 0.2021125581351727, 0.2021125581351727, 0.2376478833666068, 0.2376478833666068, 0.2376478833666068, 0.1945805503247129, 0.1945805503247129, 0.1945805503247129, 0.1961767622964642, 0.1961767622964642, 0.1961767622964642, 0.21099905965171295, 0.21099905965171295, 0.21099905965171295, 0.20934909543184343, 0.20934909543184343, 0.20934909543184343, 0.1941793339722505, 0.1941793339722505, 0.1941793339722505, 0.8477145043075831, 0.8477145043075831, 0.8477145043075831, 0.1560347168273134, 0.1560347168273134, 0.1560347168273134, 0.16891758033753868, 0.16891758033753868, 0.16891758033753868, 0.7944223468740362, 0.7944223468740362, 0.7944223468740362, 0.20675214693693922, 0.20675214693693922, 0.20675214693693922, 0.1665904628925602, 0.1665904628925602, 0.1665904628925602, 0.173281027044922, 0.173281027044922, 0.173281027044922, 0.2111196658663983, 0.2111196658663983, 0.2111196658663983, 0.19924466790757545, 0.19924466790757545, 0.19924466790757545, 0.09103548701759989, 0.09103548701759989, 0.09103548701759989, 0.08910943789359516, 0.08910943789359516, 0.08910943789359516, 0.1312373370434352, 0.1312373370434352, 0.1312373370434352]}, "mutation_prompt": null}
{"id": "29018d7a-c30d-4581-8289-1681b4a9e3b3", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "17a58c46-8f4b-478c-a6d0-0b57e6f6919a", "solution": "import numpy as np\n\nclass AQPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.inertia_weight = 0.7298\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.rand(self.population_size, self.dim) * (upper_bound - lower_bound)\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.normal(0, 0.1, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * (upper_bound - lower_bound)\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQPSO", "description": "Adaptive Quantum Particle Swarm Optimization (AQPSO) integrates dynamic quantum perturbations and swarm intelligence with adaptive parameter tuning for robust optimization.", "configspace": "", "generation": 47, "fitness": 0.27539020637906964, "feedback": "The algorithm AQPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6082694145798372, 0.6082694145798372, 0.6082694145798372, 0.6210160017702597, 0.6210160017702597, 0.6210160017702597, 0.6506791209918821, 0.6506791209918821, 0.6506791209918821, 0.11954905726547038, 0.11954905726547038, 0.11954905726547038, 0.040422973788977856, 0.040422973788977856, 0.040422973788977856, 0.038469291985586684, 0.038469291985586684, 0.038469291985586684, 0.1095357765592404, 0.1095357765592404, 0.1095357765592404, 0.09531422754124319, 0.09531422754124319, 0.09531422754124319, 0.13389259247356622, 0.13389259247356622, 0.13389259247356622, 0.10912470476912894, 0.10912470476912894, 0.10912470476912894, 0.09079908840425854, 0.09079908840425854, 0.09079908840425854, 0.10697277478055167, 0.10697277478055167, 0.10697277478055167, 0.9873304828888807, 0.9873304828888807, 0.9873304828888807, 0.9747273027137676, 0.9747273027137676, 0.9747273027137676, 0.9489585698960955, 0.9489585698960955, 0.9489585698960955, 0.29335008137899254, 0.29335008137899254, 0.29335008137899254, 0.38381814235815037, 0.38381814235815037, 0.38381814235815037, 0.32305078335874604, 0.32305078335874604, 0.32305078335874604, 0.6916549290300887, 0.6916549290300887, 0.6916549290300887, 0.6226470826340249, 0.6226470826340249, 0.6226470826340249, 0.6187914831746405, 0.6187914831746405, 0.6187914831746405, 0.1874362864019119, 0.1874362864019119, 0.1874362864019119, 0.08407546779521946, 0.08407546779521946, 0.08407546779521946, 0.1321227691401604, 0.1321227691401604, 0.1321227691401604, 0.17121624823512904, 0.17121624823512904, 0.17121624823512904, 0.14268708154714316, 0.14268708154714316, 0.14268708154714316, 0.16208956326307855, 0.16208956326307855, 0.16208956326307855, 0.08618964350694369, 0.08618964350694369, 0.08618964350694369, 0.08617420271332321, 0.08617420271332321, 0.08617420271332321, 0.1887361466833103, 0.1887361466833103, 0.1887361466833103, 0.22726377077870008, 0.22726377077870008, 0.22726377077870008, 0.1656531063957677, 0.1656531063957677, 0.1656531063957677, 0.16203557041009076, 0.16203557041009076, 0.16203557041009076, 0.03181034138433003, 0.03181034138433003, 0.03181034138433003, 0.15160317957665048, 0.15160317957665048, 0.15160317957665048, 0.07011244994548049, 0.07011244994548049, 0.07011244994548049, 0.14983277191439315, 0.14983277191439315, 0.14983277191439315, 0.18428450168844768, 0.18428450168844768, 0.18428450168844768, 0.10087470775425578, 0.10087470775425578, 0.10087470775425578, 0.5107715654800138, 0.5107715654800138, 0.5107715654800138, 0.5143846104992176, 0.5143846104992176, 0.5143846104992176, 0.5062122062927594, 0.5062122062927594, 0.5062122062927594, 0.12335898867232575, 0.12335898867232575, 0.12335898867232575, 0.11325407494361317, 0.11325407494361317, 0.11325407494361317, 0.1299715616018552, 0.1299715616018552, 0.1299715616018552, 0.179647963804489, 0.179647963804489, 0.179647963804489, 0.3161682468575475, 0.3161682468575475, 0.3161682468575475, 0.142055931706065, 0.142055931706065, 0.142055931706065, 0.29835974874057114, 0.29835974874057114, 0.29835974874057114, 0.26692483106319254, 0.26692483106319254, 0.26692483106319254, 0.3214452973634544, 0.3214452973634544, 0.3214452973634544, 0.27229608379324644, 0.27229608379324644, 0.27229608379324644, 0.2813799707862772, 0.2813799707862772, 0.2813799707862772, 0.2094750821119905, 0.2094750821119905, 0.2094750821119905, 0.20123511035878416, 0.20123511035878416, 0.20123511035878416, 0.2253608388322217, 0.2253608388322217, 0.2253608388322217, 0.19632501286999338, 0.19632501286999338, 0.19632501286999338, 0.1801026709653386, 0.1801026709653386, 0.1801026709653386, 0.18897003832464787, 0.18897003832464787, 0.18897003832464787, 0.18539495138797757, 0.18539495138797757, 0.18539495138797757, 0.7515033973800702, 0.7515033973800702, 0.7515033973800702, 0.17311361253777646, 0.17311361253777646, 0.17311361253777646, 0.1649111720670493, 0.1649111720670493, 0.1649111720670493, 0.6300261970030618, 0.6300261970030618, 0.6300261970030618, 0.16288543271468248, 0.16288543271468248, 0.16288543271468248, 0.6804845151304337, 0.6804845151304337, 0.6804845151304337, 0.175949734044903, 0.175949734044903, 0.175949734044903, 0.1867027776506801, 0.1867027776506801, 0.1867027776506801, 0.2165737419739895, 0.2165737419739895, 0.2165737419739895, 0.08459598225754938, 0.08459598225754938, 0.08459598225754938, 0.10521690570850772, 0.10521690570850772, 0.10521690570850772, 0.08046491289100033, 0.08046491289100033, 0.08046491289100033]}, "mutation_prompt": null}
{"id": "17eb5e0f-952f-44ba-b352-67dd99bf0a3b", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "2cf253f8-4593-459c-9e7d-011f7183e092", "solution": "import numpy as np\n\nclass QAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50  # Adjusted for better exploration\n        self.c1 = 1.5  # Adjusted for more balanced convergence\n        self.c2 = 1.5  # Balanced exploration and exploitation\n        self.inertia_weight = 0.6  # Slightly higher for initial exploration\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # Slightly higher for diversity\n        self.crossover_rate_base = 0.55  # Lower for more cautious crossover\n        self.crossover_rate_max = 0.9  # Fine-tuned for balance\n        self.local_search_rate = 0.1  # Introduced local search rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.normal(0, 1, (self.population_size, self.dim))  # Initialized with random velocities\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)  # Linearly decreasing\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_rate:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Small local search\n                    candidate = population[i] + perturbation\n                    candidate = np.clip(candidate, lower_bound, upper_bound)\n                    candidate_value = func(candidate)\n                    if candidate_value < personal_best_values[i]:\n                        personal_best_values[i] = candidate_value\n                        personal_best[i] = candidate\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QAMS", "description": "Quantum Adaptive Memetic Strategy (QAMS) integrates quantum perturbations with adaptive memetic search and dynamic strategy selection for efficient optimization.", "configspace": "", "generation": 49, "fitness": 0.30442077450667676, "feedback": "The algorithm QAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7607674265943164, 0.7607674265943164, 0.7607674265943164, 0.750163096943265, 0.750163096943265, 0.750163096943265, 0.7528715960712209, 0.7528715960712209, 0.7528715960712209, 0.17689628163497106, 0.17689628163497106, 0.17689628163497106, 0.2601127276989931, 0.2601127276989931, 0.2601127276989931, 0.1479395246490116, 0.1479395246490116, 0.1479395246490116, 0.11427187259865745, 0.11427187259865745, 0.11427187259865745, 0.0817869520683836, 0.0817869520683836, 0.0817869520683836, 0.12660685125800997, 0.12660685125800997, 0.12660685125800997, 0.11077744006145662, 0.11077744006145662, 0.11077744006145662, 0.08983400051887891, 0.08983400051887891, 0.08983400051887891, 0.1201934423965122, 0.1201934423965122, 0.1201934423965122, 0.9762130214894532, 0.9762130214894532, 0.9762130214894532, 0.9770650023653569, 0.9770650023653569, 0.9770650023653569, 0.9659525209643813, 0.9659525209643813, 0.9659525209643813, 0.48589778910638837, 0.48589778910638837, 0.48589778910638837, 0.41548907334038865, 0.41548907334038865, 0.41548907334038865, 0.45110533915848094, 0.45110533915848094, 0.45110533915848094, 0.8023595217005439, 0.8023595217005439, 0.8023595217005439, 0.2413630233709636, 0.2413630233709636, 0.2413630233709636, 0.6678440027894115, 0.6678440027894115, 0.6678440027894115, 0.28461704199827065, 0.28461704199827065, 0.28461704199827065, 0.12233016414388598, 0.12233016414388598, 0.12233016414388598, 0.2363094735066652, 0.2363094735066652, 0.2363094735066652, 0.4296234104990544, 0.4296234104990544, 0.4296234104990544, 0.19854451465107803, 0.19854451465107803, 0.19854451465107803, 0.309950722556385, 0.309950722556385, 0.309950722556385, 0.11132197815206113, 0.11132197815206113, 0.11132197815206113, 0.02762495030014378, 0.02762495030014378, 0.02762495030014378, 0.07362218887549321, 0.07362218887549321, 0.07362218887549321, 0.5127499976752234, 0.5127499976752234, 0.5127499976752234, 0.18153038163390134, 0.18153038163390134, 0.18153038163390134, 0.2840657808477296, 0.2840657808477296, 0.2840657808477296, 0.039397942284163934, 0.039397942284163934, 0.039397942284163934, 0.20406270300084484, 0.20406270300084484, 0.20406270300084484, 0.056938499373579865, 0.056938499373579865, 0.056938499373579865, 0.2413661434377128, 0.2413661434377128, 0.2413661434377128, 0.26635914059345955, 0.26635914059345955, 0.26635914059345955, 0.05223875851918014, 0.05223875851918014, 0.05223875851918014, 0.5454695107936474, 0.5454695107936474, 0.5454695107936474, 0.6473811466987391, 0.6473811466987391, 0.6473811466987391, 0.5932940558254971, 0.5932940558254971, 0.5932940558254971, 0.13256236573281988, 0.13256236573281988, 0.13256236573281988, 0.0836071849027703, 0.0836071849027703, 0.0836071849027703, 0.07208503558556711, 0.07208503558556711, 0.07208503558556711, 0.2598167772717971, 0.2598167772717971, 0.2598167772717971, 0.15482830851685814, 0.15482830851685814, 0.15482830851685814, 0.18753951835951865, 0.18753951835951865, 0.18753951835951865, 0.4322499146648662, 0.4322499146648662, 0.4322499146648662, 0.3787438730851833, 0.3787438730851833, 0.3787438730851833, 0.3276035546548898, 0.3276035546548898, 0.3276035546548898, 0.18123810281047026, 0.18123810281047026, 0.18123810281047026, 0.2263658642600932, 0.2263658642600932, 0.2263658642600932, 0.13933598260641133, 0.13933598260641133, 0.13933598260641133, 0.2577785697520024, 0.2577785697520024, 0.2577785697520024, 0.19570294330565063, 0.19570294330565063, 0.19570294330565063, 0.20097074634230228, 0.20097074634230228, 0.20097074634230228, 0.22960240188076753, 0.22960240188076753, 0.22960240188076753, 0.19563692598295201, 0.19563692598295201, 0.19563692598295201, 0.18609326110332058, 0.18609326110332058, 0.18609326110332058, 0.8521202166162545, 0.8521202166162545, 0.8521202166162545, 0.1566926248999102, 0.1566926248999102, 0.1566926248999102, 0.1695721631206607, 0.1695721631206607, 0.1695721631206607, 0.8234135989884857, 0.8234135989884857, 0.8234135989884857, 0.16763347940807793, 0.16763347940807793, 0.16763347940807793, 0.12695426307073487, 0.12695426307073487, 0.12695426307073487, 0.19512798673489906, 0.19512798673489906, 0.19512798673489906, 0.19264519311426542, 0.19264519311426542, 0.19264519311426542, 0.19691931671678975, 0.19691931671678975, 0.19691931671678975, 0.11295671997646128, 0.11295671997646128, 0.11295671997646128, 0.08009863030438469, 0.08009863030438469, 0.08009863030438469, 0.1080912285658, 0.1080912285658, 0.1080912285658]}, "mutation_prompt": null}
{"id": "08448dd7-595d-4871-8e14-80eee56d13f1", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "32fce39f-f9ee-4b52-bd42-263243622db0", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "db52565c-7db1-482b-8e88-f12df0b44074", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5  # Increased cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.inertia_weight = 0.6  # Slightly higher inertia\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.crossover_rate_base = 0.65  # Higher base crossover rate\n        self.crossover_rate_max = 0.9  # Slightly reduced max crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.04, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.cos(np.pi * evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - np.sin(np.pi * evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) with Adaptive Mutation and Dynamic Inertia, leveraging quantum-inspired perturbations and stochastic acceptance for global optimization.", "configspace": "", "generation": 52, "fitness": 0.28749451110349866, "feedback": "The algorithm QEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7180828700170315, 0.7180828700170315, 0.7180828700170315, 0.7191754385536792, 0.7191754385536792, 0.7191754385536792, 0.7437623736186199, 0.7437623736186199, 0.7437623736186199, 0.20949886439245624, 0.20949886439245624, 0.20949886439245624, 0.10065768893090865, 0.10065768893090865, 0.10065768893090865, 0.09807546348426477, 0.09807546348426477, 0.09807546348426477, 0.1071864650227512, 0.1071864650227512, 0.1071864650227512, 0.11024868621570239, 0.11024868621570239, 0.11024868621570239, 0.10410330699097992, 0.10410330699097992, 0.10410330699097992, 0.10325084686637442, 0.10325084686637442, 0.10325084686637442, 0.11316046948404546, 0.11316046948404546, 0.11316046948404546, 0.07544680890807198, 0.07544680890807198, 0.07544680890807198, 0.9700557401402388, 0.9700557401402388, 0.9700557401402388, 0.9849915410138202, 0.9849915410138202, 0.9849915410138202, 0.9765371093192088, 0.9765371093192088, 0.9765371093192088, 0.4486260858156623, 0.4486260858156623, 0.4486260858156623, 0.41221044327303313, 0.41221044327303313, 0.41221044327303313, 0.40139774932542505, 0.40139774932542505, 0.40139774932542505, 0.21863543759182402, 0.21863543759182402, 0.21863543759182402, 0.18759610215617528, 0.18759610215617528, 0.18759610215617528, 0.7671514149266385, 0.7671514149266385, 0.7671514149266385, 0.1920651360780118, 0.1920651360780118, 0.1920651360780118, 0.12797002665089097, 0.12797002665089097, 0.12797002665089097, 0.15375708202539973, 0.15375708202539973, 0.15375708202539973, 0.3579510368271708, 0.3579510368271708, 0.3579510368271708, 0.15366659765341117, 0.15366659765341117, 0.15366659765341117, 0.18130623283051395, 0.18130623283051395, 0.18130623283051395, 0.05397353709577768, 0.05397353709577768, 0.05397353709577768, 0.07655016313933738, 0.07655016313933738, 0.07655016313933738, 0.011683607065186008, 0.011683607065186008, 0.011683607065186008, 0.16982328551341086, 0.16982328551341086, 0.16982328551341086, 0.23440863010744906, 0.23440863010744906, 0.23440863010744906, 0.37567408852762285, 0.37567408852762285, 0.37567408852762285, 0.039092389113300485, 0.039092389113300485, 0.039092389113300485, 0.0635185376740035, 0.0635185376740035, 0.0635185376740035, 0.18881323433834896, 0.18881323433834896, 0.18881323433834896, 0.1569074497078271, 0.1569074497078271, 0.1569074497078271, 0.2099636724598215, 0.2099636724598215, 0.2099636724598215, 0.17869136203064573, 0.17869136203064573, 0.17869136203064573, 0.5642916849568984, 0.5642916849568984, 0.5642916849568984, 0.5114947318960609, 0.5114947318960609, 0.5114947318960609, 0.6361735164086612, 0.6361735164086612, 0.6361735164086612, 0.13814567389264976, 0.13814567389264976, 0.13814567389264976, 0.062307617423627226, 0.062307617423627226, 0.062307617423627226, 0.13027613251423031, 0.13027613251423031, 0.13027613251423031, 0.1968321353930529, 0.1968321353930529, 0.1968321353930529, 0.2669106176136875, 0.2669106176136875, 0.2669106176136875, 0.17501222548701878, 0.17501222548701878, 0.17501222548701878, 0.3753352012143675, 0.3753352012143675, 0.3753352012143675, 0.2560862942902842, 0.2560862942902842, 0.2560862942902842, 0.2163464962219026, 0.2163464962219026, 0.2163464962219026, 0.17322753932468182, 0.17322753932468182, 0.17322753932468182, 0.20813322439813797, 0.20813322439813797, 0.20813322439813797, 0.1345945449917164, 0.1345945449917164, 0.1345945449917164, 0.22896861276414215, 0.22896861276414215, 0.22896861276414215, 0.233952523578293, 0.233952523578293, 0.233952523578293, 0.19387537178939318, 0.19387537178939318, 0.19387537178939318, 0.24844681845442396, 0.24844681845442396, 0.24844681845442396, 0.19347259631336333, 0.19347259631336333, 0.19347259631336333, 0.1913666529221587, 0.1913666529221587, 0.1913666529221587, 0.8505642663597794, 0.8505642663597794, 0.8505642663597794, 0.8187530449603159, 0.8187530449603159, 0.8187530449603159, 0.166836306002335, 0.166836306002335, 0.166836306002335, 0.7963901196635823, 0.7963901196635823, 0.7963901196635823, 0.20371204675048404, 0.20371204675048404, 0.20371204675048404, 0.15357810429480956, 0.15357810429480956, 0.15357810429480956, 0.19168692378015562, 0.19168692378015562, 0.19168692378015562, 0.20375602885082067, 0.20375602885082067, 0.20375602885082067, 0.19225014988971023, 0.19225014988971023, 0.19225014988971023, 0.08930060798029393, 0.08930060798029393, 0.08930060798029393, 0.08782622364231318, 0.08782622364231318, 0.08782622364231318, 0.11403379054351137, 0.11403379054351137, 0.11403379054351137]}, "mutation_prompt": null}
{"id": "f523686d-86c1-49ad-9c09-c14d29b30300", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "d198dfc2-2114-462e-8329-872484a008d9", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "a97d0b04-56ca-47d7-8c26-ce40ac6a18d9", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "620f6210-e378-445a-96dc-499f1b09da34", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "e3bf0dc8-4dc9-486f-b333-30620112a793", "solution": "import numpy as np\n\nclass AQEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-0.5 * evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.15 * np.sin(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQEGS", "description": "Adaptive Quantum-Enhanced Gradient Strategy (AQEGS) combines quantum-inspired perturbations with dynamic velocity updates, stochastic acceptance, and adaptive crossover for diverse exploration and efficient convergence.", "configspace": "", "generation": 57, "fitness": 0.3065385848401365, "feedback": "The algorithm AQEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6819729037836868, 0.6819729037836868, 0.6819729037836868, 0.6875278538938125, 0.6875278538938125, 0.6875278538938125, 0.7399423085249389, 0.7399423085249389, 0.7399423085249389, 0.15034273762028716, 0.15034273762028716, 0.15034273762028716, 0.20742308533794818, 0.20742308533794818, 0.20742308533794818, 0.24515761144106463, 0.24515761144106463, 0.24515761144106463, 0.10451239977091187, 0.10451239977091187, 0.10451239977091187, 0.11793126962011424, 0.11793126962011424, 0.11793126962011424, 0.11152199659559991, 0.11152199659559991, 0.11152199659559991, 0.0935348013898345, 0.0935348013898345, 0.0935348013898345, 0.101917720717985, 0.101917720717985, 0.101917720717985, 0.09995363978084482, 0.09995363978084482, 0.09995363978084482, 0.9631659277588838, 0.9631659277588838, 0.9631659277588838, 0.9850454629519844, 0.9850454629519844, 0.9850454629519844, 0.9858536197200622, 0.9858536197200622, 0.9858536197200622, 0.3572034503260195, 0.3572034503260195, 0.3572034503260195, 0.44073545513287327, 0.44073545513287327, 0.44073545513287327, 0.4693548380277349, 0.4693548380277349, 0.4693548380277349, 0.6935652869285354, 0.6935652869285354, 0.6935652869285354, 0.15691009157790736, 0.15691009157790736, 0.15691009157790736, 0.7257860937550101, 0.7257860937550101, 0.7257860937550101, 0.2855059020112629, 0.2855059020112629, 0.2855059020112629, 0.335809324508336, 0.335809324508336, 0.335809324508336, 0.12386116386542434, 0.12386116386542434, 0.12386116386542434, 0.3660851678615239, 0.3660851678615239, 0.3660851678615239, 0.2870971033319487, 0.2870971033319487, 0.2870971033319487, 0.22603149042211035, 0.22603149042211035, 0.22603149042211035, 0.11639140998302355, 0.11639140998302355, 0.11639140998302355, 0.19279231841679356, 0.19279231841679356, 0.19279231841679356, 0.13970685437536212, 0.13970685437536212, 0.13970685437536212, 0.2923190778057284, 0.2923190778057284, 0.2923190778057284, 0.141771360359487, 0.141771360359487, 0.141771360359487, 0.33735141801081003, 0.33735141801081003, 0.33735141801081003, 0.03422920952225117, 0.03422920952225117, 0.03422920952225117, 0.05655291204602142, 0.05655291204602142, 0.05655291204602142, 0.11564787491959361, 0.11564787491959361, 0.11564787491959361, 0.21331956167121435, 0.21331956167121435, 0.21331956167121435, 0.2713099607467727, 0.2713099607467727, 0.2713099607467727, 0.24937784860694978, 0.24937784860694978, 0.24937784860694978, 0.6219966533381545, 0.6219966533381545, 0.6219966533381545, 0.5492715791947402, 0.5492715791947402, 0.5492715791947402, 0.564790523866005, 0.564790523866005, 0.564790523866005, 0.13259654105883567, 0.13259654105883567, 0.13259654105883567, 0.10796120423217326, 0.10796120423217326, 0.10796120423217326, 0.10475241616222863, 0.10475241616222863, 0.10475241616222863, 0.4943383833231164, 0.4943383833231164, 0.4943383833231164, 0.17445399894080438, 0.17445399894080438, 0.17445399894080438, 0.22272707323528906, 0.22272707323528906, 0.22272707323528906, 0.37772583752664435, 0.37772583752664435, 0.37772583752664435, 0.358784033400085, 0.358784033400085, 0.358784033400085, 0.3568762744541756, 0.3568762744541756, 0.3568762744541756, 0.14707983181395956, 0.14707983181395956, 0.14707983181395956, 0.30332593180833, 0.30332593180833, 0.30332593180833, 0.19745699609361933, 0.19745699609361933, 0.19745699609361933, 0.24978605517707897, 0.24978605517707897, 0.24978605517707897, 0.2032503750136717, 0.2032503750136717, 0.2032503750136717, 0.21580732037168116, 0.21580732037168116, 0.21580732037168116, 0.19828546354297716, 0.19828546354297716, 0.19828546354297716, 0.20976704339595043, 0.20976704339595043, 0.20976704339595043, 0.23151246275820858, 0.23151246275820858, 0.23151246275820858, 0.8620065288715072, 0.8620065288715072, 0.8620065288715072, 0.16038289042669807, 0.16038289042669807, 0.16038289042669807, 0.16546986381504725, 0.16546986381504725, 0.16546986381504725, 0.7445018542300821, 0.7445018542300821, 0.7445018542300821, 0.20629614112146077, 0.20629614112146077, 0.20629614112146077, 0.15266134004953513, 0.15266134004953513, 0.15266134004953513, 0.1921895726480507, 0.1921895726480507, 0.1921895726480507, 0.1911182962497544, 0.1911182962497544, 0.1911182962497544, 0.17986136429802935, 0.17986136429802935, 0.17986136429802935, 0.10321358800585456, 0.10321358800585456, 0.10321358800585456, 0.10436357414690978, 0.10436357414690978, 0.10436357414690978, 0.08164858279851539, 0.08164858279851539, 0.08164858279851539]}, "mutation_prompt": null}
{"id": "3ea19358-6963-45b0-a3f3-70a8af7346de", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            oscillating_step = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + oscillating_step * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - np.sin(np.pi * evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.25 * np.cos(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) with adaptive mutation and oscillating inertia to enhance exploration and exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.2936108321419974, "feedback": "The algorithm QEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7465996822172494, 0.7465996822172494, 0.7465996822172494, 0.7504466472925964, 0.7504466472925964, 0.7504466472925964, 0.7480012651603709, 0.7480012651603709, 0.7480012651603709, 0.02916977046841962, 0.02916977046841962, 0.02916977046841962, 0.09419007287905279, 0.09419007287905279, 0.09419007287905279, 0.13501453745404013, 0.13501453745404013, 0.13501453745404013, 0.11986815504551707, 0.11986815504551707, 0.11986815504551707, 0.10009472796928454, 0.10009472796928454, 0.10009472796928454, 0.1156798553783237, 0.1156798553783237, 0.1156798553783237, 0.12283632042457271, 0.12283632042457271, 0.12283632042457271, 0.10169017908585831, 0.10169017908585831, 0.10169017908585831, 0.10801694032020082, 0.10801694032020082, 0.10801694032020082, 0.9741729997333002, 0.9741729997333002, 0.9741729997333002, 0.9837544591949645, 0.9837544591949645, 0.9837544591949645, 0.9868907676188652, 0.9868907676188652, 0.9868907676188652, 0.48608407870714077, 0.48608407870714077, 0.48608407870714077, 0.46057656198777697, 0.46057656198777697, 0.46057656198777697, 0.5021787351749961, 0.5021787351749961, 0.5021787351749961, 0.306407502486559, 0.306407502486559, 0.306407502486559, 0.7745203726728396, 0.7745203726728396, 0.7745203726728396, 0.3612146047812197, 0.3612146047812197, 0.3612146047812197, 0.21200197653041042, 0.21200197653041042, 0.21200197653041042, 0.14794477182424925, 0.14794477182424925, 0.14794477182424925, 0.21681717400913036, 0.21681717400913036, 0.21681717400913036, 0.2712919050003708, 0.2712919050003708, 0.2712919050003708, 0.1277507344778498, 0.1277507344778498, 0.1277507344778498, 0.12307552978778791, 0.12307552978778791, 0.12307552978778791, 0.1513001248596213, 0.1513001248596213, 0.1513001248596213, 0.015050860084016349, 0.015050860084016349, 0.015050860084016349, 0.03805336309861507, 0.03805336309861507, 0.03805336309861507, 0.2242787198066627, 0.2242787198066627, 0.2242787198066627, 0.28154630129661484, 0.28154630129661484, 0.28154630129661484, 0.1564983927105541, 0.1564983927105541, 0.1564983927105541, 0.038804688852156155, 0.038804688852156155, 0.038804688852156155, 0.08225708058533987, 0.08225708058533987, 0.08225708058533987, 0.09337710271978339, 0.09337710271978339, 0.09337710271978339, 0.2162645342374484, 0.2162645342374484, 0.2162645342374484, 0.29382198396892856, 0.29382198396892856, 0.29382198396892856, 0.14483299534011473, 0.14483299534011473, 0.14483299534011473, 0.621424709054715, 0.621424709054715, 0.621424709054715, 0.642313907315263, 0.642313907315263, 0.642313907315263, 0.604943981587533, 0.604943981587533, 0.604943981587533, 0.1275107081901493, 0.1275107081901493, 0.1275107081901493, 0.1171132412857554, 0.1171132412857554, 0.1171132412857554, 0.11071588899106333, 0.11071588899106333, 0.11071588899106333, 0.22384239217670931, 0.22384239217670931, 0.22384239217670931, 0.41909849495102247, 0.41909849495102247, 0.41909849495102247, 0.18984320064340432, 0.18984320064340432, 0.18984320064340432, 0.31468869881327954, 0.31468869881327954, 0.31468869881327954, 0.3278555850553836, 0.3278555850553836, 0.3278555850553836, 0.3630875564688103, 0.3630875564688103, 0.3630875564688103, 0.1423672023152205, 0.1423672023152205, 0.1423672023152205, 0.21271422116307304, 0.21271422116307304, 0.21271422116307304, 0.29535005433771055, 0.29535005433771055, 0.29535005433771055, 0.23731036175279752, 0.23731036175279752, 0.23731036175279752, 0.19337024413169013, 0.19337024413169013, 0.19337024413169013, 0.19502273765358913, 0.19502273765358913, 0.19502273765358913, 0.1873385093699892, 0.1873385093699892, 0.1873385093699892, 0.2052365104738637, 0.2052365104738637, 0.2052365104738637, 0.19923567175867907, 0.19923567175867907, 0.19923567175867907, 0.8549924948645984, 0.8549924948645984, 0.8549924948645984, 0.16213006254142692, 0.16213006254142692, 0.16213006254142692, 0.16799791505332617, 0.16799791505332617, 0.16799791505332617, 0.8336568207605609, 0.8336568207605609, 0.8336568207605609, 0.20570485994275034, 0.20570485994275034, 0.20570485994275034, 0.16426773458067145, 0.16426773458067145, 0.16426773458067145, 0.2202181446942476, 0.2202181446942476, 0.2202181446942476, 0.2348931547900116, 0.2348931547900116, 0.2348931547900116, 0.2076527355122646, 0.2076527355122646, 0.2076527355122646, 0.1080767278009318, 0.1080767278009318, 0.1080767278009318, 0.09809847151429008, 0.09809847151429008, 0.09809847151429008, 0.1095304394362292, 0.1095304394362292, 0.1095304394362292]}, "mutation_prompt": null}
{"id": "23d2cd6a-4b8c-4360-bf14-1d0ba56e8fe1", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "9664fda6-d43c-458f-8595-ed5b40433423", "solution": "import numpy as np\n\nclass QDAS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.2\n        self.c2 = 1.8\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.55\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.15 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QDAS", "description": "Quantum-Driven Adaptive Strategy (QDAS) leverages dynamic quantum-driven variations with adaptive velocity and strategic mutation acceptance.", "configspace": "", "generation": 60, "fitness": 0.3128150718021114, "feedback": "The algorithm QDAS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7068374054691428, 0.7068374054691428, 0.7068374054691428, 0.7188559073492118, 0.7188559073492118, 0.7188559073492118, 0.7114216740657118, 0.7114216740657118, 0.7114216740657118, 0.20079457119418131, 0.20079457119418131, 0.20079457119418131, 0.3148211509379083, 0.3148211509379083, 0.3148211509379083, 0.0646918406161241, 0.0646918406161241, 0.0646918406161241, 0.12235493665609942, 0.12235493665609942, 0.12235493665609942, 0.09134145626404166, 0.09134145626404166, 0.09134145626404166, 0.11165340320780981, 0.11165340320780981, 0.11165340320780981, 0.10784552912219825, 0.10784552912219825, 0.10784552912219825, 0.1075650335798175, 0.1075650335798175, 0.1075650335798175, 0.11037187335054932, 0.11037187335054932, 0.11037187335054932, 0.9738825919603606, 0.9738825919603606, 0.9738825919603606, 0.9851134286479962, 0.9851134286479962, 0.9851134286479962, 0.9859648360437634, 0.9859648360437634, 0.9859648360437634, 0.4559323335310351, 0.4559323335310351, 0.4559323335310351, 0.3751941462474295, 0.3751941462474295, 0.3751941462474295, 0.5023400711317361, 0.5023400711317361, 0.5023400711317361, 0.7304889855913188, 0.7304889855913188, 0.7304889855913188, 0.5878075374161502, 0.5878075374161502, 0.5878075374161502, 0.5915996475146437, 0.5915996475146437, 0.5915996475146437, 0.12487052320997138, 0.12487052320997138, 0.12487052320997138, 0.4143527756082098, 0.4143527756082098, 0.4143527756082098, 0.12280428868637083, 0.12280428868637083, 0.12280428868637083, 0.2742257963684518, 0.2742257963684518, 0.2742257963684518, 0.3545490317976242, 0.3545490317976242, 0.3545490317976242, 0.3811844987181583, 0.3811844987181583, 0.3811844987181583, 0.14535193605600416, 0.14535193605600416, 0.14535193605600416, 0.11615953196216267, 0.11615953196216267, 0.11615953196216267, 0.2634471283882861, 0.2634471283882861, 0.2634471283882861, 0.23432069988533277, 0.23432069988533277, 0.23432069988533277, 0.3213923521012151, 0.3213923521012151, 0.3213923521012151, 0.3572094991817828, 0.3572094991817828, 0.3572094991817828, 0.03720164047229102, 0.03720164047229102, 0.03720164047229102, 0.059176218222130594, 0.059176218222130594, 0.059176218222130594, 0.06809483468344057, 0.06809483468344057, 0.06809483468344057, 0.21312320648731575, 0.21312320648731575, 0.21312320648731575, 0.23294465555122557, 0.23294465555122557, 0.23294465555122557, 0.2593981002253932, 0.2593981002253932, 0.2593981002253932, 0.5786521052041955, 0.5786521052041955, 0.5786521052041955, 0.6127196515998374, 0.6127196515998374, 0.6127196515998374, 0.6008032976581947, 0.6008032976581947, 0.6008032976581947, 0.10682813717833217, 0.10682813717833217, 0.10682813717833217, 0.1296513747394582, 0.1296513747394582, 0.1296513747394582, 0.1176789905150677, 0.1176789905150677, 0.1176789905150677, 0.22467811138397498, 0.22467811138397498, 0.22467811138397498, 0.30500087261102526, 0.30500087261102526, 0.30500087261102526, 0.19827300870999665, 0.19827300870999665, 0.19827300870999665, 0.34889169833217337, 0.34889169833217337, 0.34889169833217337, 0.35412272782163, 0.35412272782163, 0.35412272782163, 0.20958274758741346, 0.20958274758741346, 0.20958274758741346, 0.33048743535089176, 0.33048743535089176, 0.33048743535089176, 0.21312138142364745, 0.21312138142364745, 0.21312138142364745, 0.23149639869015193, 0.23149639869015193, 0.23149639869015193, 0.20806917282852833, 0.20806917282852833, 0.20806917282852833, 0.2148208889463583, 0.2148208889463583, 0.2148208889463583, 0.23058193659217452, 0.23058193659217452, 0.23058193659217452, 0.18945650328748198, 0.18945650328748198, 0.18945650328748198, 0.19799481195325996, 0.19799481195325996, 0.19799481195325996, 0.18455711684163767, 0.18455711684163767, 0.18455711684163767, 0.8784608088608634, 0.8784608088608634, 0.8784608088608634, 0.15611889930471212, 0.15611889930471212, 0.15611889930471212, 0.16786987233323147, 0.16786987233323147, 0.16786987233323147, 0.7530897599380877, 0.7530897599380877, 0.7530897599380877, 0.20797351161713806, 0.20797351161713806, 0.20797351161713806, 0.1641988203701531, 0.1641988203701531, 0.1641988203701531, 0.1846394121370678, 0.1846394121370678, 0.1846394121370678, 0.1842370627959865, 0.1842370627959865, 0.1842370627959865, 0.2202397360923649, 0.2202397360923649, 0.2202397360923649, 0.09925946817880271, 0.09925946817880271, 0.09925946817880271, 0.0769001362681514, 0.0769001362681514, 0.0769001362681514, 0.10554423509743227, 0.10554423509743227, 0.10554423509743227]}, "mutation_prompt": null}
{"id": "877b5d1d-99dc-4ed3-af2d-a9d371a24aea", "solution": "import numpy as np\n\nclass QIDH:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.4\n        self.mutation_factor = 0.9\n        self.harmony_memory_rate = 0.95\n        self.perturbation_rate = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            harmony_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            harmony_values = np.array([func(ind) for ind in harmony_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if harmony_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = harmony_values[i]\n                    personal_best[i] = harmony_population[i]\n                    if harmony_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.harmony_memory_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget:\n                        mutant_fitness = func(mutant)\n                        if mutant_fitness < personal_best_values[i]:\n                            population[i] = mutant\n                            personal_best[i] = mutant\n                            personal_best_values[i] = mutant_fitness\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.15 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QIDH", "description": "Quantum-Inspired Dynamic Harmony (QIDH) enhances global exploration using adaptive quantum perturbations and dynamic harmony search principles for robust optimization.", "configspace": "", "generation": 61, "fitness": 0.33597564351347453, "feedback": "The algorithm QIDH got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7913445863322908, 0.7913445863322908, 0.7913445863322908, 0.7716356868675243, 0.7716356868675243, 0.7716356868675243, 0.7905146380301964, 0.7905146380301964, 0.7905146380301964, 0.2964702834444758, 0.2964702834444758, 0.2964702834444758, 0.049741724371248686, 0.049741724371248686, 0.049741724371248686, 0.5029275231483765, 0.5029275231483765, 0.5029275231483765, 0.11853053500609678, 0.11853053500609678, 0.11853053500609678, 0.13620397679023422, 0.13620397679023422, 0.13620397679023422, 0.12567976541480563, 0.12567976541480563, 0.12567976541480563, 0.082366179172916, 0.082366179172916, 0.082366179172916, 0.08796753892097042, 0.08796753892097042, 0.08796753892097042, 0.10291083021625669, 0.10291083021625669, 0.10291083021625669, 0.9628974383832566, 0.9628974383832566, 0.9628974383832566, 0.9757761585825192, 0.9757761585825192, 0.9757761585825192, 0.976510806424473, 0.976510806424473, 0.976510806424473, 0.5108459166997954, 0.5108459166997954, 0.5108459166997954, 0.5612673296538946, 0.5612673296538946, 0.5612673296538946, 0.46845813515706247, 0.46845813515706247, 0.46845813515706247, 0.7937091505863877, 0.7937091505863877, 0.7937091505863877, 0.1589679254719495, 0.1589679254719495, 0.1589679254719495, 0.2710002814142719, 0.2710002814142719, 0.2710002814142719, 0.24715533438502735, 0.24715533438502735, 0.24715533438502735, 0.2814605883464204, 0.2814605883464204, 0.2814605883464204, 0.24609315816061916, 0.24609315816061916, 0.24609315816061916, 0.15086561228057593, 0.15086561228057593, 0.15086561228057593, 0.49182440424798035, 0.49182440424798035, 0.49182440424798035, 0.12911637050237945, 0.12911637050237945, 0.12911637050237945, 0.18095508836428076, 0.18095508836428076, 0.18095508836428076, 0.13548669313251394, 0.13548669313251394, 0.13548669313251394, 0.5423740981313911, 0.5423740981313911, 0.5423740981313911, 0.382938606896028, 0.382938606896028, 0.382938606896028, 0.5465931344286108, 0.5465931344286108, 0.5465931344286108, 0.13408288075818853, 0.13408288075818853, 0.13408288075818853, 0.052881973826969464, 0.052881973826969464, 0.052881973826969464, 0.3599183710968715, 0.3599183710968715, 0.3599183710968715, 0.17156855253740055, 0.17156855253740055, 0.17156855253740055, 0.29181658833353996, 0.29181658833353996, 0.29181658833353996, 0.3463667434347252, 0.3463667434347252, 0.3463667434347252, 0.25730394747231167, 0.25730394747231167, 0.25730394747231167, 0.7343104828975611, 0.7343104828975611, 0.7343104828975611, 0.7136806764765954, 0.7136806764765954, 0.7136806764765954, 0.7280267938067534, 0.7280267938067534, 0.7280267938067534, 0.13799199745721746, 0.13799199745721746, 0.13799199745721746, 0.13657655741624808, 0.13657655741624808, 0.13657655741624808, 0.11277206167444387, 0.11277206167444387, 0.11277206167444387, 0.18703224952275366, 0.18703224952275366, 0.18703224952275366, 0.22558879448244074, 0.22558879448244074, 0.22558879448244074, 0.22082199730664087, 0.22082199730664087, 0.22082199730664087, 0.43804026184870704, 0.43804026184870704, 0.43804026184870704, 0.45892065100813206, 0.45892065100813206, 0.45892065100813206, 0.4153588218568087, 0.4153588218568087, 0.4153588218568087, 0.23615765300102887, 0.23615765300102887, 0.23615765300102887, 0.28359050710114464, 0.28359050710114464, 0.28359050710114464, 0.13684463230622423, 0.13684463230622423, 0.13684463230622423, 0.229048921188725, 0.229048921188725, 0.229048921188725, 0.21678969738961518, 0.21678969738961518, 0.21678969738961518, 0.20840192275297864, 0.20840192275297864, 0.20840192275297864, 0.20117197839117384, 0.20117197839117384, 0.20117197839117384, 0.1950384838619923, 0.1950384838619923, 0.1950384838619923, 0.18136859718528608, 0.18136859718528608, 0.18136859718528608, 0.8810946625525471, 0.8810946625525471, 0.8810946625525471, 0.15642894729465684, 0.15642894729465684, 0.15642894729465684, 0.1686213215764636, 0.1686213215764636, 0.1686213215764636, 0.8592796313189872, 0.8592796313189872, 0.8592796313189872, 0.1639093200276045, 0.1639093200276045, 0.1639093200276045, 0.15307458998834533, 0.15307458998834533, 0.15307458998834533, 0.20244469817749255, 0.20244469817749255, 0.20244469817749255, 0.18151625467470978, 0.18151625467470978, 0.18151625467470978, 0.17978761574757796, 0.17978761574757796, 0.17978761574757796, 0.10458053446411741, 0.10458053446411741, 0.10458053446411741, 0.16379390221255397, 0.16379390221255397, 0.16379390221255397, 0.09365255957780172, 0.09365255957780172, 0.09365255957780172]}, "mutation_prompt": null}
{"id": "c624fa32-e78e-4ae8-b76c-2524586e5ae4", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "0270632a-6c3c-445b-bf40-6464e1f1d026", "solution": "import numpy as np\n\nclass AQ_PES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQ_PES", "description": "Adaptive Quantum-Perturbated Evolutionary Strategy (AQ-PES) integrates dynamic quantum perturbations with a dual-gradient adaptive strategy for robust optimization.", "configspace": "", "generation": 63, "fitness": 0.32714020722234227, "feedback": "The algorithm AQ_PES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6957634567907687, 0.6957634567907687, 0.6957634567907687, 0.6480561199551119, 0.6480561199551119, 0.6480561199551119, 0.6830742121669833, 0.6830742121669833, 0.6830742121669833, 0.23998939458749702, 0.23998939458749702, 0.23998939458749702, 0.20236104103913743, 0.20236104103913743, 0.20236104103913743, 0.1581712378818222, 0.1581712378818222, 0.1581712378818222, 0.10784317733880322, 0.10784317733880322, 0.10784317733880322, 0.11916891037997701, 0.11916891037997701, 0.11916891037997701, 0.11874754043011948, 0.11874754043011948, 0.11874754043011948, 0.07256878583965976, 0.07256878583965976, 0.07256878583965976, 0.08667822724747754, 0.08667822724747754, 0.08667822724747754, 0.07829049183551173, 0.07829049183551173, 0.07829049183551173, 0.9696642964993908, 0.9696642964993908, 0.9696642964993908, 0.9839556981519065, 0.9839556981519065, 0.9839556981519065, 0.9804655697494739, 0.9804655697494739, 0.9804655697494739, 0.3951477433179589, 0.3951477433179589, 0.3951477433179589, 0.4220536093502606, 0.4220536093502606, 0.4220536093502606, 0.3774073053464727, 0.3774073053464727, 0.3774073053464727, 0.6426167578893988, 0.6426167578893988, 0.6426167578893988, 0.1586723534428789, 0.1586723534428789, 0.1586723534428789, 0.6735730665188777, 0.6735730665188777, 0.6735730665188777, 0.25482457655714275, 0.25482457655714275, 0.25482457655714275, 0.19283714016974973, 0.19283714016974973, 0.19283714016974973, 0.20149874842213256, 0.20149874842213256, 0.20149874842213256, 0.24995020307459992, 0.24995020307459992, 0.24995020307459992, 0.32422081888301313, 0.32422081888301313, 0.32422081888301313, 0.44168829153558886, 0.44168829153558886, 0.44168829153558886, 0.09374531358228855, 0.09374531358228855, 0.09374531358228855, 0.13947160471589903, 0.13947160471589903, 0.13947160471589903, 0.1635620400313852, 0.1635620400313852, 0.1635620400313852, 0.2303302181437683, 0.2303302181437683, 0.2303302181437683, 0.2727399711848195, 0.2727399711848195, 0.2727399711848195, 0.3862210033375265, 0.3862210033375265, 0.3862210033375265, 0.03566284277462495, 0.03566284277462495, 0.03566284277462495, 0.05580671740850829, 0.05580671740850829, 0.05580671740850829, 0.20245729752438257, 0.20245729752438257, 0.20245729752438257, 0.16545297883091004, 0.16545297883091004, 0.16545297883091004, 0.24267468904947198, 0.24267468904947198, 0.24267468904947198, 0.24772418030055787, 0.24772418030055787, 0.24772418030055787, 0.5872531037823698, 0.5872531037823698, 0.5872531037823698, 0.5550593666262431, 0.5550593666262431, 0.5550593666262431, 0.5715389352102779, 0.5715389352102779, 0.5715389352102779, 0.11041139445259118, 0.11041139445259118, 0.11041139445259118, 0.11349457928708584, 0.11349457928708584, 0.11349457928708584, 0.1026646817791469, 0.1026646817791469, 0.1026646817791469, 0.2327675122593933, 0.2327675122593933, 0.2327675122593933, 0.38430258521140837, 0.38430258521140837, 0.38430258521140837, 0.25440204512320286, 0.25440204512320286, 0.25440204512320286, 0.36861254506240704, 0.36861254506240704, 0.36861254506240704, 0.39496758198165294, 0.39496758198165294, 0.39496758198165294, 0.3682438170220961, 0.3682438170220961, 0.3682438170220961, 0.1587654184508207, 0.1587654184508207, 0.1587654184508207, 0.29076499687502355, 0.29076499687502355, 0.29076499687502355, 0.18772068232671713, 0.18772068232671713, 0.18772068232671713, 0.21447632444898268, 0.21447632444898268, 0.21447632444898268, 0.23585901165742518, 0.23585901165742518, 0.23585901165742518, 0.2275575875360758, 0.2275575875360758, 0.2275575875360758, 0.4367025451117059, 0.4367025451117059, 0.4367025451117059, 0.2086620813708142, 0.2086620813708142, 0.2086620813708142, 0.4695676025486538, 0.4695676025486538, 0.4695676025486538, 0.8395181104766349, 0.8395181104766349, 0.8395181104766349, 0.7323612209248576, 0.7323612209248576, 0.7323612209248576, 0.7051236506547149, 0.7051236506547149, 0.7051236506547149, 0.760786645145435, 0.760786645145435, 0.760786645145435, 0.20539182670616885, 0.20539182670616885, 0.20539182670616885, 0.15147375240494598, 0.15147375240494598, 0.15147375240494598, 0.21687682785217544, 0.21687682785217544, 0.21687682785217544, 0.194746233957923, 0.194746233957923, 0.194746233957923, 0.19676206884877967, 0.19676206884877967, 0.19676206884877967, 0.0988910618492238, 0.0988910618492238, 0.0988910618492238, 0.1431838030974012, 0.1431838030974012, 0.1431838030974012, 0.12004768868042903, 0.12004768868042903, 0.12004768868042903]}, "mutation_prompt": null}
{"id": "b94bfc81-6631-48fb-916d-5988f5bf3876", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "defb0b4a-6379-4c4b-a70c-7bb6198805f7", "solution": "import numpy as np\n\nclass QAIA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QAIA", "description": "Quantum-Adaptive Inertia Algorithm (QAIA) integrates quantum-inspired perturbations with adaptive inertia and strategic mutation for dynamic exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.33690072229788876, "feedback": "The algorithm QAIA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7454266445985043, 0.7454266445985043, 0.7454266445985043, 0.7239994671950206, 0.7239994671950206, 0.7239994671950206, 0.7522883807471188, 0.7522883807471188, 0.7522883807471188, 0.15402857442579665, 0.15402857442579665, 0.15402857442579665, 0.45579264582096357, 0.45579264582096357, 0.45579264582096357, 0.2326806159863839, 0.2326806159863839, 0.2326806159863839, 0.10031636328262461, 0.10031636328262461, 0.10031636328262461, 0.1077435175655106, 0.1077435175655106, 0.1077435175655106, 0.10390818007490688, 0.10390818007490688, 0.10390818007490688, 0.09173673271330518, 0.09173673271330518, 0.09173673271330518, 0.12632014837297723, 0.12632014837297723, 0.12632014837297723, 0.09904584633863689, 0.09904584633863689, 0.09904584633863689, 0.9738379727870564, 0.9738379727870564, 0.9738379727870564, 0.9752203357567807, 0.9752203357567807, 0.9752203357567807, 0.9868894254017256, 0.9868894254017256, 0.9868894254017256, 0.47141912231978667, 0.47141912231978667, 0.47141912231978667, 0.4517308589550043, 0.4517308589550043, 0.4517308589550043, 0.45468812299133277, 0.45468812299133277, 0.45468812299133277, 0.7196839885496317, 0.7196839885496317, 0.7196839885496317, 0.6928190682001428, 0.6928190682001428, 0.6928190682001428, 0.8000998975022311, 0.8000998975022311, 0.8000998975022311, 0.12121094305078461, 0.12121094305078461, 0.12121094305078461, 0.3785698683301102, 0.3785698683301102, 0.3785698683301102, 0.14088566573201933, 0.14088566573201933, 0.14088566573201933, 0.14811245255422378, 0.14811245255422378, 0.14811245255422378, 0.47284325063629784, 0.47284325063629784, 0.47284325063629784, 0.47191800912657067, 0.47191800912657067, 0.47191800912657067, 0.06366822560969554, 0.06366822560969554, 0.06366822560969554, 0.2623027744749259, 0.2623027744749259, 0.2623027744749259, 0.4386586273568138, 0.4386586273568138, 0.4386586273568138, 0.545273027491211, 0.545273027491211, 0.545273027491211, 0.2593136706141258, 0.2593136706141258, 0.2593136706141258, 0.1917573182882506, 0.1917573182882506, 0.1917573182882506, 0.040800993136244856, 0.040800993136244856, 0.040800993136244856, 0.15495056587773015, 0.15495056587773015, 0.15495056587773015, 0.14293898310668796, 0.14293898310668796, 0.14293898310668796, 0.30059533858010223, 0.30059533858010223, 0.30059533858010223, 0.2703234965643865, 0.2703234965643865, 0.2703234965643865, 0.27023633852737095, 0.27023633852737095, 0.27023633852737095, 0.6170077599547354, 0.6170077599547354, 0.6170077599547354, 0.6446885531891036, 0.6446885531891036, 0.6446885531891036, 0.6176097333698178, 0.6176097333698178, 0.6176097333698178, 0.1506443897985097, 0.1506443897985097, 0.1506443897985097, 0.09340914494513075, 0.09340914494513075, 0.09340914494513075, 0.10387505872440583, 0.10387505872440583, 0.10387505872440583, 0.1445766424146061, 0.1445766424146061, 0.1445766424146061, 0.354353837397531, 0.354353837397531, 0.354353837397531, 0.1933933717079599, 0.1933933717079599, 0.1933933717079599, 0.3826483349239439, 0.3826483349239439, 0.3826483349239439, 0.3518458633805973, 0.3518458633805973, 0.3518458633805973, 0.3524246726562189, 0.3524246726562189, 0.3524246726562189, 0.18232726687683165, 0.18232726687683165, 0.18232726687683165, 0.2341873253361888, 0.2341873253361888, 0.2341873253361888, 0.3811646044037218, 0.3811646044037218, 0.3811646044037218, 0.19401093692003268, 0.19401093692003268, 0.19401093692003268, 0.21724502083180464, 0.21724502083180464, 0.21724502083180464, 0.2303163967255636, 0.2303163967255636, 0.2303163967255636, 0.1956604155528645, 0.1956604155528645, 0.1956604155528645, 0.2114975952651027, 0.2114975952651027, 0.2114975952651027, 0.23703556334976505, 0.23703556334976505, 0.23703556334976505, 0.8794247976869527, 0.8794247976869527, 0.8794247976869527, 0.15654169827695974, 0.15654169827695974, 0.15654169827695974, 0.16871176535704435, 0.16871176535704435, 0.16871176535704435, 0.8072932692719534, 0.8072932692719534, 0.8072932692719534, 0.20684383292817532, 0.20684383292817532, 0.20684383292817532, 0.16580225038590657, 0.16580225038590657, 0.16580225038590657, 0.19214728828923888, 0.19214728828923888, 0.19214728828923888, 0.20560560938581407, 0.20560560938581407, 0.20560560938581407, 0.17414798592986314, 0.17414798592986314, 0.17414798592986314, 0.10367820543006367, 0.10367820543006367, 0.10367820543006367, 0.10162946096072134, 0.10162946096072134, 0.10162946096072134, 0.11106789517787019, 0.11106789517787019, 0.11106789517787019]}, "mutation_prompt": null}
{"id": "523d6997-29bd-4ca8-b7d3-8446514cd9d9", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "3cdf38d3-7655-4866-93b0-199fae633258", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "bb071488-766e-40fb-852c-2f79ce8820f8", "solution": "import numpy as np\n\nclass EQPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.1 * np.cos(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "EQPS", "description": "Evolutionary Quantum Perturbation Strategy (EQPS) integrates evolutionary dynamics with quantum-inspired perturbations, adaptive velocity, and stochastic acceptance.", "configspace": "", "generation": 68, "fitness": 0.31493680798544077, "feedback": "The algorithm EQPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.703610893081664, 0.703610893081664, 0.703610893081664, 0.6913065041556385, 0.6913065041556385, 0.6913065041556385, 0.7293469160086616, 0.7293469160086616, 0.7293469160086616, 0.06894307700358071, 0.06894307700358071, 0.06894307700358071, 0.03777884246781582, 0.03777884246781582, 0.03777884246781582, 0.33975403167012364, 0.33975403167012364, 0.33975403167012364, 0.13471479400669373, 0.13471479400669373, 0.13471479400669373, 0.12401789654809925, 0.12401789654809925, 0.12401789654809925, 0.13078814362142344, 0.13078814362142344, 0.13078814362142344, 0.08065104388164746, 0.08065104388164746, 0.08065104388164746, 0.12988883809469987, 0.12988883809469987, 0.12988883809469987, 0.10458270574174144, 0.10458270574174144, 0.10458270574174144, 0.955465000967981, 0.955465000967981, 0.955465000967981, 0.9773477191539315, 0.9773477191539315, 0.9773477191539315, 0.9672021538968356, 0.9672021538968356, 0.9672021538968356, 0.41170973073305783, 0.41170973073305783, 0.41170973073305783, 0.433171883933145, 0.433171883933145, 0.433171883933145, 0.42801672926709877, 0.42801672926709877, 0.42801672926709877, 0.7066936338531618, 0.7066936338531618, 0.7066936338531618, 0.7219974708021188, 0.7219974708021188, 0.7219974708021188, 0.6951293850358322, 0.6951293850358322, 0.6951293850358322, 0.12267197289794185, 0.12267197289794185, 0.12267197289794185, 0.36641082917782486, 0.36641082917782486, 0.36641082917782486, 0.3785908665518414, 0.3785908665518414, 0.3785908665518414, 0.2813542105724819, 0.2813542105724819, 0.2813542105724819, 0.19643523113915917, 0.19643523113915917, 0.19643523113915917, 0.14018175112618392, 0.14018175112618392, 0.14018175112618392, 0.04638388090191625, 0.04638388090191625, 0.04638388090191625, 0.013606826984616016, 0.013606826984616016, 0.013606826984616016, 0.2291398196412291, 0.2291398196412291, 0.2291398196412291, 0.3410864072968224, 0.3410864072968224, 0.3410864072968224, 0.4234107612082789, 0.4234107612082789, 0.4234107612082789, 0.2890985172912436, 0.2890985172912436, 0.2890985172912436, 0.04326674352723969, 0.04326674352723969, 0.04326674352723969, 0.1146497704292142, 0.1146497704292142, 0.1146497704292142, 0.12621223671205384, 0.12621223671205384, 0.12621223671205384, 0.2069324674787878, 0.2069324674787878, 0.2069324674787878, 0.20628281146968375, 0.20628281146968375, 0.20628281146968375, 0.2826367636893623, 0.2826367636893623, 0.2826367636893623, 0.5988610525066324, 0.5988610525066324, 0.5988610525066324, 0.6159456973564568, 0.6159456973564568, 0.6159456973564568, 0.6085080850098854, 0.6085080850098854, 0.6085080850098854, 0.1298697753864908, 0.1298697753864908, 0.1298697753864908, 0.0729269116223853, 0.0729269116223853, 0.0729269116223853, 0.0940399616263159, 0.0940399616263159, 0.0940399616263159, 0.2290263767404428, 0.2290263767404428, 0.2290263767404428, 0.3277524548110814, 0.3277524548110814, 0.3277524548110814, 0.2548833800300576, 0.2548833800300576, 0.2548833800300576, 0.3409425119509839, 0.3409425119509839, 0.3409425119509839, 0.3780982189080252, 0.3780982189080252, 0.3780982189080252, 0.43376719254560525, 0.43376719254560525, 0.43376719254560525, 0.11654716971902657, 0.11654716971902657, 0.11654716971902657, 0.2114346238572169, 0.2114346238572169, 0.2114346238572169, 0.13704982188917603, 0.13704982188917603, 0.13704982188917603, 0.24432633742491172, 0.24432633742491172, 0.24432633742491172, 0.21756328127668823, 0.21756328127668823, 0.21756328127668823, 0.20311440939592562, 0.20311440939592562, 0.20311440939592562, 0.20456809190930803, 0.20456809190930803, 0.20456809190930803, 0.2146442665382079, 0.2146442665382079, 0.2146442665382079, 0.5025744587505234, 0.5025744587505234, 0.5025744587505234, 0.8452021983091391, 0.8452021983091391, 0.8452021983091391, 0.15546823771508367, 0.15546823771508367, 0.15546823771508367, 0.16531322473851373, 0.16531322473851373, 0.16531322473851373, 0.7268381903525192, 0.7268381903525192, 0.7268381903525192, 0.20830329622959598, 0.20830329622959598, 0.20830329622959598, 0.1596750348422067, 0.1596750348422067, 0.1596750348422067, 0.2029562580850648, 0.2029562580850648, 0.2029562580850648, 0.19334020489301962, 0.19334020489301962, 0.19334020489301962, 0.1865713773767893, 0.1865713773767893, 0.1865713773767893, 0.09684210878576704, 0.09684210878576704, 0.09684210878576704, 0.09625485787571941, 0.09625485787571941, 0.09625485787571941, 0.12177184447213463, 0.12177184447213463, 0.12177184447213463]}, "mutation_prompt": null}
{"id": "fb34ef5b-4619-4656-82f1-212c25e5090d", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "62cbbcb0-11b3-4b49-8ae6-23b3d3bf4b09", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "cd0da8f5-cb89-468a-9f8c-69ae354487e9", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "43796ec1-afba-4810-bba7-9b2cf3091451", "solution": "import numpy as np\n\nclass QEDS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.6\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEDS", "description": "Quantum-Enhanced Dynamic Swarming (QEDS) leverages adaptive quantum perturbations and dynamic swarm movements with strategic mutation and crossover adjustments.", "configspace": "", "generation": 72, "fitness": 0.32608931318303386, "feedback": "The algorithm QEDS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7183085118551034, 0.7183085118551034, 0.7183085118551034, 0.6959574823368755, 0.6959574823368755, 0.6959574823368755, 0.7320891977188537, 0.7320891977188537, 0.7320891977188537, 0.19819623636745387, 0.19819623636745387, 0.19819623636745387, 0.12668692839087203, 0.12668692839087203, 0.12668692839087203, 0.041556805258396556, 0.041556805258396556, 0.041556805258396556, 0.1352780074615375, 0.1352780074615375, 0.1352780074615375, 0.11834138389984505, 0.11834138389984505, 0.11834138389984505, 0.3192524935464063, 0.3192524935464063, 0.3192524935464063, 0.08315346908851806, 0.08315346908851806, 0.08315346908851806, 0.0876077676229795, 0.0876077676229795, 0.0876077676229795, 0.0913330235543115, 0.0913330235543115, 0.0913330235543115, 0.9685910369551947, 0.9685910369551947, 0.9685910369551947, 0.9849856820501692, 0.9849856820501692, 0.9849856820501692, 0.9791839368767576, 0.9791839368767576, 0.9791839368767576, 0.44034569642464694, 0.44034569642464694, 0.44034569642464694, 0.48119709266403576, 0.48119709266403576, 0.48119709266403576, 0.39218720753912617, 0.39218720753912617, 0.39218720753912617, 0.8175770079289719, 0.8175770079289719, 0.8175770079289719, 0.6406638036445758, 0.6406638036445758, 0.6406638036445758, 0.7257945675511771, 0.7257945675511771, 0.7257945675511771, 0.12452854413663683, 0.12452854413663683, 0.12452854413663683, 0.25212962874656997, 0.25212962874656997, 0.25212962874656997, 0.12429801358860004, 0.12429801358860004, 0.12429801358860004, 0.3893455212104202, 0.3893455212104202, 0.3893455212104202, 0.22529783399512593, 0.22529783399512593, 0.22529783399512593, 0.3681959688340296, 0.3681959688340296, 0.3681959688340296, 0.37303643017170307, 0.37303643017170307, 0.37303643017170307, 0.19032092441614978, 0.19032092441614978, 0.19032092441614978, 0.1159323825300913, 0.1159323825300913, 0.1159323825300913, 0.4173452768886501, 0.4173452768886501, 0.4173452768886501, 0.4022039013365024, 0.4022039013365024, 0.4022039013365024, 0.14485440498367297, 0.14485440498367297, 0.14485440498367297, 0.04899351269083929, 0.04899351269083929, 0.04899351269083929, 0.05762257582385244, 0.05762257582385244, 0.05762257582385244, 0.17022373743622643, 0.17022373743622643, 0.17022373743622643, 0.23415504365663353, 0.23415504365663353, 0.23415504365663353, 0.2351174224990804, 0.2351174224990804, 0.2351174224990804, 0.27356059246306297, 0.27356059246306297, 0.27356059246306297, 0.6560279717932662, 0.6560279717932662, 0.6560279717932662, 0.5953032518532526, 0.5953032518532526, 0.5953032518532526, 0.6167251369055444, 0.6167251369055444, 0.6167251369055444, 0.10371776065090144, 0.10371776065090144, 0.10371776065090144, 0.11770607842055147, 0.11770607842055147, 0.11770607842055147, 0.09964861133879765, 0.09964861133879765, 0.09964861133879765, 0.20745990087914157, 0.20745990087914157, 0.20745990087914157, 0.2722072879634787, 0.2722072879634787, 0.2722072879634787, 0.25334865184953204, 0.25334865184953204, 0.25334865184953204, 0.38018192901867065, 0.38018192901867065, 0.38018192901867065, 0.34132072696745397, 0.34132072696745397, 0.34132072696745397, 0.27497655155824785, 0.27497655155824785, 0.27497655155824785, 0.1461070026065534, 0.1461070026065534, 0.1461070026065534, 0.20650467691171093, 0.20650467691171093, 0.20650467691171093, 0.19875037612155433, 0.19875037612155433, 0.19875037612155433, 0.21816297215915992, 0.21816297215915992, 0.21816297215915992, 0.21334252000306142, 0.21334252000306142, 0.21334252000306142, 0.19253378089839068, 0.19253378089839068, 0.19253378089839068, 0.19357347058454066, 0.19357347058454066, 0.19357347058454066, 0.2111833879496603, 0.2111833879496603, 0.2111833879496603, 0.2318181886541033, 0.2318181886541033, 0.2318181886541033, 0.8553044137607693, 0.8553044137607693, 0.8553044137607693, 0.8378686574009868, 0.8378686574009868, 0.8378686574009868, 0.16741857558202589, 0.16741857558202589, 0.16741857558202589, 0.7679611789250832, 0.7679611789250832, 0.7679611789250832, 0.20611860139870108, 0.20611860139870108, 0.20611860139870108, 0.15345472615859967, 0.15345472615859967, 0.15345472615859967, 0.19677276155532275, 0.19677276155532275, 0.19677276155532275, 0.1850427077309923, 0.1850427077309923, 0.1850427077309923, 0.19366991653309673, 0.19366991653309673, 0.19366991653309673, 0.0928310114404598, 0.0928310114404598, 0.0928310114404598, 0.07252853982677321, 0.07252853982677321, 0.07252853982677321, 0.09341016963439908, 0.09341016963439908, 0.09341016963439908]}, "mutation_prompt": null}
{"id": "4c5adc2e-9a08-43d3-9516-c544cb953e74", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "9e415670-28d1-4df0-bc4b-8b47adffd228", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "bbbce902-7669-4381-bfcf-143ac0dd6dfe", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "1d12312a-cd59-4f06-b1f6-1f5e4c54ffb2", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "74f5e6b7-14e4-41f6-9171-daabd5c70dc1", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "a2cd8d62-c01c-4612-a8af-27abbd3f0cb3", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "7a9ed9b4-11bd-4e8b-814c-7e59fe968438", "solution": "import numpy as np\n\nclass AQPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.7\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.cos(np.pi * evaluations / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (personal_best[indices[0]] +\n                                       self.mutation_factor * (personal_best[indices[1]] - personal_best[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.35 + 0.3 * np.cos(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQPS", "description": "Adaptive Quantum Perturbation Strategy (AQPS) refines population dynamics with adaptive probabilistic selection, dynamic velocity scaling, and enhanced crossover mechanisms for diverse exploration and exploitation.", "configspace": "", "generation": 79, "fitness": 0.2920072587179155, "feedback": "The algorithm AQPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.621577758706906, 0.621577758706906, 0.621577758706906, 0.5849974392014534, 0.5849974392014534, 0.5849974392014534, 0.5627534291498346, 0.5627534291498346, 0.5627534291498346, 0.17349777285549461, 0.17349777285549461, 0.17349777285549461, 0.1989311389534848, 0.1989311389534848, 0.1989311389534848, 0.15744897160164695, 0.15744897160164695, 0.15744897160164695, 0.12113001112151911, 0.12113001112151911, 0.12113001112151911, 0.14870500317446345, 0.14870500317446345, 0.14870500317446345, 0.14969866089604078, 0.14969866089604078, 0.14969866089604078, 0.10085092160088427, 0.10085092160088427, 0.10085092160088427, 0.10605296808465425, 0.10605296808465425, 0.10605296808465425, 0.10191201017847684, 0.10191201017847684, 0.10191201017847684, 0.9686423011236656, 0.9686423011236656, 0.9686423011236656, 0.9542916785347882, 0.9542916785347882, 0.9542916785347882, 0.9267810771361614, 0.9267810771361614, 0.9267810771361614, 0.34364446563019124, 0.34364446563019124, 0.34364446563019124, 0.3258978400427207, 0.3258978400427207, 0.3258978400427207, 0.32219466242177075, 0.32219466242177075, 0.32219466242177075, 0.697745547898301, 0.697745547898301, 0.697745547898301, 0.5439153700314603, 0.5439153700314603, 0.5439153700314603, 0.7095697350531196, 0.7095697350531196, 0.7095697350531196, 0.18270230027813572, 0.18270230027813572, 0.18270230027813572, 0.23801286044405734, 0.23801286044405734, 0.23801286044405734, 0.23593955710944492, 0.23593955710944492, 0.23593955710944492, 0.21361981648231687, 0.21361981648231687, 0.21361981648231687, 0.20909482219628395, 0.20909482219628395, 0.20909482219628395, 0.15819356612663482, 0.15819356612663482, 0.15819356612663482, 0.07318282737785453, 0.07318282737785453, 0.07318282737785453, 0.16155843436292927, 0.16155843436292927, 0.16155843436292927, 0.16019654529913951, 0.16019654529913951, 0.16019654529913951, 0.24060952884038755, 0.24060952884038755, 0.24060952884038755, 0.31004756789202226, 0.31004756789202226, 0.31004756789202226, 0.2779981800864242, 0.2779981800864242, 0.2779981800864242, 0.07992872010616758, 0.07992872010616758, 0.07992872010616758, 0.14938295473806484, 0.14938295473806484, 0.14938295473806484, 0.07054877678487104, 0.07054877678487104, 0.07054877678487104, 0.20005197706460942, 0.20005197706460942, 0.20005197706460942, 0.16148516901957033, 0.16148516901957033, 0.16148516901957033, 0.2042828232200573, 0.2042828232200573, 0.2042828232200573, 0.5038245151447537, 0.5038245151447537, 0.5038245151447537, 0.4872179187092168, 0.4872179187092168, 0.4872179187092168, 0.4840348043848357, 0.4840348043848357, 0.4840348043848357, 0.110221048534201, 0.110221048534201, 0.110221048534201, 0.117161631412946, 0.117161631412946, 0.117161631412946, 0.13226326488926698, 0.13226326488926698, 0.13226326488926698, 0.2355766656686017, 0.2355766656686017, 0.2355766656686017, 0.2772932686198777, 0.2772932686198777, 0.2772932686198777, 0.1540046406214478, 0.1540046406214478, 0.1540046406214478, 0.33055379971380616, 0.33055379971380616, 0.33055379971380616, 0.3265922111325007, 0.3265922111325007, 0.3265922111325007, 0.3404887994234431, 0.3404887994234431, 0.3404887994234431, 0.26999685282257346, 0.26999685282257346, 0.26999685282257346, 0.2725562378404417, 0.2725562378404417, 0.2725562378404417, 0.2764021064890684, 0.2764021064890684, 0.2764021064890684, 0.21709174253748242, 0.21709174253748242, 0.21709174253748242, 0.2033260352255013, 0.2033260352255013, 0.2033260352255013, 0.19119746599607657, 0.19119746599607657, 0.19119746599607657, 0.3016223566087104, 0.3016223566087104, 0.3016223566087104, 0.2003555349685665, 0.2003555349685665, 0.2003555349685665, 0.21666701446586334, 0.21666701446586334, 0.21666701446586334, 0.8649486293313073, 0.8649486293313073, 0.8649486293313073, 0.16301683672569, 0.16301683672569, 0.16301683672569, 0.16842667298134406, 0.16842667298134406, 0.16842667298134406, 0.7514500763508242, 0.7514500763508242, 0.7514500763508242, 0.20417852683380977, 0.20417852683380977, 0.20417852683380977, 0.20007561588799783, 0.20007561588799783, 0.20007561588799783, 0.19670857536262543, 0.19670857536262543, 0.19670857536262543, 0.18768519748820967, 0.18768519748820967, 0.18768519748820967, 0.19327062353441093, 0.19327062353441093, 0.19327062353441093, 0.09928328373840489, 0.09928328373840489, 0.09928328373840489, 0.08699373737524752, 0.08699373737524752, 0.08699373737524752, 0.11296174604485709, 0.11296174604485709, 0.11296174604485709]}, "mutation_prompt": null}
{"id": "91286e67-6c4e-49ac-afc9-5d1416d65aae", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "a3256180-153e-4a7b-8a99-1b5b954b35dc", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.7  # Increased inertia_weight for better exploration\n        self.epsilon = 1e-8\n        self.mutation_factor_base = 0.85\n        self.mutation_factor_max = 0.9  # Added dynamic mutation factor\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - evaluations / self.budget)  # Modified inertia weight decay\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                mutation_factor = self.mutation_factor_base + (self.mutation_factor_max - self.mutation_factor_base) * (evaluations / self.budget) ** 2  # Use quadratic scaling for mutation factor\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) with adaptive mutation and dynamic velocity tuning enhances exploration-exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.30289152806289416, "feedback": "The algorithm QEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6862416530474944, 0.6862416530474944, 0.6862416530474944, 0.643891497602104, 0.643891497602104, 0.643891497602104, 0.6819960493397226, 0.6819960493397226, 0.6819960493397226, 0.31508490161861014, 0.31508490161861014, 0.31508490161861014, 0.19955935080018028, 0.19955935080018028, 0.19955935080018028, 0.31339621075697766, 0.31339621075697766, 0.31339621075697766, 0.1260432700571067, 0.1260432700571067, 0.1260432700571067, 0.11194374286805797, 0.11194374286805797, 0.11194374286805797, 0.10513277700594803, 0.10513277700594803, 0.10513277700594803, 0.10920180607618946, 0.10920180607618946, 0.10920180607618946, 0.09891658616248566, 0.09891658616248566, 0.09891658616248566, 0.11178974172489398, 0.11178974172489398, 0.11178974172489398, 0.9736200374960716, 0.9736200374960716, 0.9736200374960716, 0.9758792477019747, 0.9758792477019747, 0.9758792477019747, 0.9868872291690053, 0.9868872291690053, 0.9868872291690053, 0.4391209480652325, 0.4391209480652325, 0.4391209480652325, 0.3817803375882177, 0.3817803375882177, 0.3817803375882177, 0.4615540609657708, 0.4615540609657708, 0.4615540609657708, 0.7196999374805272, 0.7196999374805272, 0.7196999374805272, 0.21363773983620427, 0.21363773983620427, 0.21363773983620427, 0.7561364783640661, 0.7561364783640661, 0.7561364783640661, 0.20601429709373686, 0.20601429709373686, 0.20601429709373686, 0.30977140019057015, 0.30977140019057015, 0.30977140019057015, 0.2787252394993266, 0.2787252394993266, 0.2787252394993266, 0.24317486490849582, 0.24317486490849582, 0.24317486490849582, 0.18854083327706983, 0.18854083327706983, 0.18854083327706983, 0.2947902110165088, 0.2947902110165088, 0.2947902110165088, 0.03978643009134919, 0.03978643009134919, 0.03978643009134919, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15360648048348324, 0.15360648048348324, 0.15360648048348324, 0.3105995517303154, 0.3105995517303154, 0.3105995517303154, 0.1865373809901114, 0.1865373809901114, 0.1865373809901114, 0.09778122526681432, 0.09778122526681432, 0.09778122526681432, 0.04177696190903002, 0.04177696190903002, 0.04177696190903002, 0.056500029034960764, 0.056500029034960764, 0.056500029034960764, 0.1935337692378185, 0.1935337692378185, 0.1935337692378185, 0.21021838977798335, 0.21021838977798335, 0.21021838977798335, 0.2054187134272194, 0.2054187134272194, 0.2054187134272194, 0.27186000004756306, 0.27186000004756306, 0.27186000004756306, 0.5770205896608158, 0.5770205896608158, 0.5770205896608158, 0.5979286865078457, 0.5979286865078457, 0.5979286865078457, 0.5568240605517812, 0.5568240605517812, 0.5568240605517812, 0.15353712469009917, 0.15353712469009917, 0.15353712469009917, 0.16034444592925357, 0.16034444592925357, 0.16034444592925357, 0.08844827828636115, 0.08844827828636115, 0.08844827828636115, 0.46437375482275356, 0.46437375482275356, 0.46437375482275356, 0.172517928353909, 0.172517928353909, 0.172517928353909, 0.2726077984642097, 0.2726077984642097, 0.2726077984642097, 0.40640527289987016, 0.40640527289987016, 0.40640527289987016, 0.3506594474208824, 0.3506594474208824, 0.3506594474208824, 0.37057385086790595, 0.37057385086790595, 0.37057385086790595, 0.15411205002385653, 0.15411205002385653, 0.15411205002385653, 0.19701429693552874, 0.19701429693552874, 0.19701429693552874, 0.20469310230580573, 0.20469310230580573, 0.20469310230580573, 0.19696538968274657, 0.19696538968274657, 0.19696538968274657, 0.23883784286049636, 0.23883784286049636, 0.23883784286049636, 0.20338198746204839, 0.20338198746204839, 0.20338198746204839, 0.2191845827612846, 0.2191845827612846, 0.2191845827612846, 0.18678824129352734, 0.18678824129352734, 0.18678824129352734, 0.18659538601256254, 0.18659538601256254, 0.18659538601256254, 0.8223569694138078, 0.8223569694138078, 0.8223569694138078, 0.15685951759477046, 0.15685951759477046, 0.15685951759477046, 0.1687339898206781, 0.1687339898206781, 0.1687339898206781, 0.7674731315016896, 0.7674731315016896, 0.7674731315016896, 0.20890189025847905, 0.20890189025847905, 0.20890189025847905, 0.16536920494665575, 0.16536920494665575, 0.16536920494665575, 0.17580140677234013, 0.17580140677234013, 0.17580140677234013, 0.19400184237589524, 0.19400184237589524, 0.19400184237589524, 0.20354345102815896, 0.20354345102815896, 0.20354345102815896, 0.08756069047369563, 0.08756069047369563, 0.08756069047369563, 0.09282721034619057, 0.09282721034619057, 0.09282721034619057, 0.10569721649327546, 0.10569721649327546, 0.10569721649327546]}, "mutation_prompt": null}
{"id": "49e1b240-fc75-4ce7-bedb-7a0f50fc0347", "solution": "import numpy as np\n\nclass HQEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.65\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "HQEGS", "description": "Hybrid Quantum and Evolutionary Gradient Strategy (HQEGS) integrates quantum-inspired adaptations with dynamic evolutionary processes for robust optimization.", "configspace": "", "generation": 82, "fitness": 0.2851112578154424, "feedback": "The algorithm HQEGS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6553833365871939, 0.6553833365871939, 0.6553833365871939, 0.6532310388763432, 0.6532310388763432, 0.6532310388763432, 0.6712368043005512, 0.6712368043005512, 0.6712368043005512, 0.08027191879250728, 0.08027191879250728, 0.08027191879250728, 0.19339510696087758, 0.19339510696087758, 0.19339510696087758, 0.1138826602552172, 0.1138826602552172, 0.1138826602552172, 0.08890242513238023, 0.08890242513238023, 0.08890242513238023, 0.11475108623504782, 0.11475108623504782, 0.11475108623504782, 0.12203784775201132, 0.12203784775201132, 0.12203784775201132, 0.08587898911647496, 0.08587898911647496, 0.08587898911647496, 0.103437824604514, 0.103437824604514, 0.103437824604514, 0.10528587414292434, 0.10528587414292434, 0.10528587414292434, 0.9711059780270221, 0.9711059780270221, 0.9711059780270221, 0.9849856820501692, 0.9849856820501692, 0.9849856820501692, 0.9800452501847947, 0.9800452501847947, 0.9800452501847947, 0.4054181638423815, 0.4054181638423815, 0.4054181638423815, 0.35290549409885286, 0.35290549409885286, 0.35290549409885286, 0.367977785059192, 0.367977785059192, 0.367977785059192, 0.7181152980100142, 0.7181152980100142, 0.7181152980100142, 0.18622354374758188, 0.18622354374758188, 0.18622354374758188, 0.2545641424070051, 0.2545641424070051, 0.2545641424070051, 0.1223630437087293, 0.1223630437087293, 0.1223630437087293, 0.2908090133362864, 0.2908090133362864, 0.2908090133362864, 0.1204283350442914, 0.1204283350442914, 0.1204283350442914, 0.11994099697534133, 0.11994099697534133, 0.11994099697534133, 0.1840167132122913, 0.1840167132122913, 0.1840167132122913, 0.3223075876536675, 0.3223075876536675, 0.3223075876536675, 0.05592413642399674, 0.05592413642399674, 0.05592413642399674, 0.12491107670205925, 0.12491107670205925, 0.12491107670205925, 0.09108944854686218, 0.09108944854686218, 0.09108944854686218, 0.4060127656994975, 0.4060127656994975, 0.4060127656994975, 0.21472917011004033, 0.21472917011004033, 0.21472917011004033, 0.30646836353214646, 0.30646836353214646, 0.30646836353214646, 0.040923771614692295, 0.040923771614692295, 0.040923771614692295, 0.046332197469914904, 0.046332197469914904, 0.046332197469914904, 0.13073851970960026, 0.13073851970960026, 0.13073851970960026, 0.1706282864220009, 0.1706282864220009, 0.1706282864220009, 0.20714596335210422, 0.20714596335210422, 0.20714596335210422, 0.23647781308161053, 0.23647781308161053, 0.23647781308161053, 0.5429106284258987, 0.5429106284258987, 0.5429106284258987, 0.5945967122123572, 0.5945967122123572, 0.5945967122123572, 0.5306420824110392, 0.5306420824110392, 0.5306420824110392, 0.12561063232895198, 0.12561063232895198, 0.12561063232895198, 0.1112533281878968, 0.1112533281878968, 0.1112533281878968, 0.10055126514498314, 0.10055126514498314, 0.10055126514498314, 0.16525980417527097, 0.16525980417527097, 0.16525980417527097, 0.2027771494637084, 0.2027771494637084, 0.2027771494637084, 0.37804553160444143, 0.37804553160444143, 0.37804553160444143, 0.3646765212597045, 0.3646765212597045, 0.3646765212597045, 0.3461894889476783, 0.3461894889476783, 0.3461894889476783, 0.20181224292617606, 0.20181224292617606, 0.20181224292617606, 0.1639310230559755, 0.1639310230559755, 0.1639310230559755, 0.21428633376722306, 0.21428633376722306, 0.21428633376722306, 0.2207113151690171, 0.2207113151690171, 0.2207113151690171, 0.19852523995761306, 0.19852523995761306, 0.19852523995761306, 0.22173944160153292, 0.22173944160153292, 0.22173944160153292, 0.17573433618447776, 0.17573433618447776, 0.17573433618447776, 0.1876391763883809, 0.1876391763883809, 0.1876391763883809, 0.20960106230244824, 0.20960106230244824, 0.20960106230244824, 0.20331754677435565, 0.20331754677435565, 0.20331754677435565, 0.8264306298362787, 0.8264306298362787, 0.8264306298362787, 0.7665589908177675, 0.7665589908177675, 0.7665589908177675, 0.16657220404992168, 0.16657220404992168, 0.16657220404992168, 0.7069515214786306, 0.7069515214786306, 0.7069515214786306, 0.20575838480245778, 0.20575838480245778, 0.20575838480245778, 0.15386794764548872, 0.15386794764548872, 0.15386794764548872, 0.17965759665728143, 0.17965759665728143, 0.17965759665728143, 0.2112699456128514, 0.2112699456128514, 0.2112699456128514, 0.18798553410798102, 0.18798553410798102, 0.18798553410798102, 0.08029618954284601, 0.08029618954284601, 0.08029618954284601, 0.08044145718917439, 0.08044145718917439, 0.08044145718917439, 0.10212584590385287, 0.10212584590385287, 0.10212584590385287]}, "mutation_prompt": null}
{"id": "a742b306-68a7-4887-a62f-f3fdddc713a1", "solution": "import numpy as np\n\nclass AQIH:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.5\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight / (1 + 0.1 * (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 (1 - (evaluations / self.budget)**2)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.25 * np.cos(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQIH", "description": "Adaptive Quantum-Inspired Hybrid (AQIH) integrates random adaptive mutations, quantum perturbations, and hybridized search strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.272886601447183, "feedback": "The algorithm AQIH got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.5862716466011308, 0.5862716466011308, 0.5862716466011308, 0.5680100202561746, 0.5680100202561746, 0.5680100202561746, 0.5769344614169498, 0.5769344614169498, 0.5769344614169498, 0.1504600907466751, 0.1504600907466751, 0.1504600907466751, 0.07506171399842587, 0.07506171399842587, 0.07506171399842587, 0.08952997309821109, 0.08952997309821109, 0.08952997309821109, 0.13043780925547266, 0.13043780925547266, 0.13043780925547266, 0.12704773573382622, 0.12704773573382622, 0.12704773573382622, 0.10296813378604674, 0.10296813378604674, 0.10296813378604674, 0.10006743519700045, 0.10006743519700045, 0.10006743519700045, 0.10050740776569689, 0.10050740776569689, 0.10050740776569689, 0.06699604305034812, 0.06699604305034812, 0.06699604305034812, 0.9714777843905874, 0.9714777843905874, 0.9714777843905874, 0.9839556981519065, 0.9839556981519065, 0.9839556981519065, 0.9798652458937348, 0.9798652458937348, 0.9798652458937348, 0.31651102544642806, 0.31651102544642806, 0.31651102544642806, 0.29945217523923917, 0.29945217523923917, 0.29945217523923917, 0.3745988114804273, 0.3745988114804273, 0.3745988114804273, 0.5929545551868409, 0.5929545551868409, 0.5929545551868409, 0.3136656758630805, 0.3136656758630805, 0.3136656758630805, 0.5737721637828637, 0.5737721637828637, 0.5737721637828637, 0.2212420787969276, 0.2212420787969276, 0.2212420787969276, 0.1756489667345491, 0.1756489667345491, 0.1756489667345491, 0.14891772824946126, 0.14891772824946126, 0.14891772824946126, 0.24074909714932258, 0.24074909714932258, 0.24074909714932258, 0.20200916890657594, 0.20200916890657594, 0.20200916890657594, 0.19605269602253161, 0.19605269602253161, 0.19605269602253161, 0.03951764571413785, 0.03951764571413785, 0.03951764571413785, 0.042850508322845204, 0.042850508322845204, 0.042850508322845204, 0.06402766914355851, 0.06402766914355851, 0.06402766914355851, 0.13678396396712744, 0.13678396396712744, 0.13678396396712744, 0.2306430333871976, 0.2306430333871976, 0.2306430333871976, 0.23502538406348417, 0.23502538406348417, 0.23502538406348417, 0.024825264276529202, 0.024825264276529202, 0.024825264276529202, 0.04769150112816589, 0.04769150112816589, 0.04769150112816589, 0.09640015945934632, 0.09640015945934632, 0.09640015945934632, 0.11895632501045617, 0.11895632501045617, 0.11895632501045617, 0.13482036761831584, 0.13482036761831584, 0.13482036761831584, 0.19677138630927238, 0.19677138630927238, 0.19677138630927238, 0.5001072544520988, 0.5001072544520988, 0.5001072544520988, 0.4680911068628637, 0.4680911068628637, 0.4680911068628637, 0.46343844047336746, 0.46343844047336746, 0.46343844047336746, 0.11654227672708317, 0.11654227672708317, 0.11654227672708317, 0.09658108796641796, 0.09658108796641796, 0.09658108796641796, 0.13171843390636784, 0.13171843390636784, 0.13171843390636784, 0.3582777916053549, 0.3582777916053549, 0.3582777916053549, 0.2548221553950655, 0.2548221553950655, 0.2548221553950655, 0.33061317952451574, 0.33061317952451574, 0.33061317952451574, 0.329266197377712, 0.329266197377712, 0.329266197377712, 0.3083703577972601, 0.3083703577972601, 0.3083703577972601, 0.22986418247901252, 0.22986418247901252, 0.22986418247901252, 0.26183120437960017, 0.26183120437960017, 0.26183120437960017, 0.27059869424698546, 0.27059869424698546, 0.27059869424698546, 0.1370178501094279, 0.1370178501094279, 0.1370178501094279, 0.18752915855643182, 0.18752915855643182, 0.18752915855643182, 0.20979332120535388, 0.20979332120535388, 0.20979332120535388, 0.20427404808321115, 0.20427404808321115, 0.20427404808321115, 0.21975692947198056, 0.21975692947198056, 0.21975692947198056, 0.18499441533371175, 0.18499441533371175, 0.18499441533371175, 0.1902447132321875, 0.1902447132321875, 0.1902447132321875, 0.8011688456000814, 0.8011688456000814, 0.8011688456000814, 0.6990208613305342, 0.6990208613305342, 0.6990208613305342, 0.16756197487809987, 0.16756197487809987, 0.16756197487809987, 0.6681991937843914, 0.6681991937843914, 0.6681991937843914, 0.20618525409784616, 0.20618525409784616, 0.20618525409784616, 0.15161711202414008, 0.15161711202414008, 0.15161711202414008, 0.1896879813181206, 0.1896879813181206, 0.1896879813181206, 0.17121819598855037, 0.17121819598855037, 0.17121819598855037, 0.18419060754629601, 0.18419060754629601, 0.18419060754629601, 0.0877731136723291, 0.0877731136723291, 0.0877731136723291, 0.11513159058795586, 0.11513159058795586, 0.11513159058795586, 0.11886922358195229, 0.11886922358195229, 0.11886922358195229]}, "mutation_prompt": null}
{"id": "b36ae3bc-3851-49fc-b3d0-457fd4a076a1", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "2090b3fe-c288-4d1b-84aa-54a9e483c099", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "9b7e41b7-e86a-4055-a785-688dbc2ddc2b", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "c553b8ef-97fc-41a1-8d63-252b56445475", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "ebcc1f15-eced-49a3-a8c5-dd097cc5f814", "solution": "import numpy as np\n\nclass AQSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.5\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.cos(np.pi * evaluations / self.budget)\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.25 * np.sin(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "AQSO", "description": "Adaptive Quantum Swarm Optimization (AQSO) leverages quantum perturbations with dynamic velocity adjustment and adaptive mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.30585509989040277, "feedback": "The algorithm AQSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6914208013373, 0.6914208013373, 0.6914208013373, 0.6792713402446235, 0.6792713402446235, 0.6792713402446235, 0.6807646006409702, 0.6807646006409702, 0.6807646006409702, 0.09729968526778443, 0.09729968526778443, 0.09729968526778443, 0.26110063776265746, 0.26110063776265746, 0.26110063776265746, 0.40235719691455996, 0.40235719691455996, 0.40235719691455996, 0.13098861459611721, 0.13098861459611721, 0.13098861459611721, 0.13536866542393322, 0.13536866542393322, 0.13536866542393322, 0.1165306004090817, 0.1165306004090817, 0.1165306004090817, 0.12611700764437084, 0.12611700764437084, 0.12611700764437084, 0.09741368989110577, 0.09741368989110577, 0.09741368989110577, 0.09769606805112285, 0.09769606805112285, 0.09769606805112285, 0.9748446356672518, 0.9748446356672518, 0.9748446356672518, 0.9751607672509266, 0.9751607672509266, 0.9751607672509266, 0.9654675064419169, 0.9654675064419169, 0.9654675064419169, 0.44662708871074486, 0.44662708871074486, 0.44662708871074486, 0.38283354009935666, 0.38283354009935666, 0.38283354009935666, 0.3766598847568299, 0.3766598847568299, 0.3766598847568299, 0.2641327038962207, 0.2641327038962207, 0.2641327038962207, 0.7757818728605534, 0.7757818728605534, 0.7757818728605534, 0.21739372336390805, 0.21739372336390805, 0.21739372336390805, 0.42968666473316774, 0.42968666473316774, 0.42968666473316774, 0.22549128532569018, 0.22549128532569018, 0.22549128532569018, 0.19883807872666126, 0.19883807872666126, 0.19883807872666126, 0.14235861732879385, 0.14235861732879385, 0.14235861732879385, 0.3124609842644138, 0.3124609842644138, 0.3124609842644138, 0.13456477093849084, 0.13456477093849084, 0.13456477093849084, 0.07154113912125526, 0.07154113912125526, 0.07154113912125526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0687204972440626, 0.0687204972440626, 0.0687204972440626, 0.30881550904689803, 0.30881550904689803, 0.30881550904689803, 0.08650387220484679, 0.08650387220484679, 0.08650387220484679, 0.33060036310302965, 0.33060036310302965, 0.33060036310302965, 0.03500820912499636, 0.03500820912499636, 0.03500820912499636, 0.09868569175619701, 0.09868569175619701, 0.09868569175619701, 0.078049405851084, 0.078049405851084, 0.078049405851084, 0.18088654854858788, 0.18088654854858788, 0.18088654854858788, 0.2513715757513387, 0.2513715757513387, 0.2513715757513387, 0.13380586617817225, 0.13380586617817225, 0.13380586617817225, 0.5266093473772885, 0.5266093473772885, 0.5266093473772885, 0.5470931058605355, 0.5470931058605355, 0.5470931058605355, 0.5145815108887282, 0.5145815108887282, 0.5145815108887282, 0.10904976693557178, 0.10904976693557178, 0.10904976693557178, 0.13319332771967352, 0.13319332771967352, 0.13319332771967352, 0.1364068544719721, 0.1364068544719721, 0.1364068544719721, 0.38908238106802584, 0.38908238106802584, 0.38908238106802584, 0.3257664259059807, 0.3257664259059807, 0.3257664259059807, 0.2603261637959158, 0.2603261637959158, 0.2603261637959158, 0.3653213086393122, 0.3653213086393122, 0.3653213086393122, 0.25587806584423056, 0.25587806584423056, 0.25587806584423056, 0.3557589805364424, 0.3557589805364424, 0.3557589805364424, 0.19179398445078522, 0.19179398445078522, 0.19179398445078522, 0.2237530579576965, 0.2237530579576965, 0.2237530579576965, 0.234080316064047, 0.234080316064047, 0.234080316064047, 0.19552812328311442, 0.19552812328311442, 0.19552812328311442, 0.23043947953034405, 0.23043947953034405, 0.23043947953034405, 0.229123157451408, 0.229123157451408, 0.229123157451408, 0.1986674140605812, 0.1986674140605812, 0.1986674140605812, 0.20010130613874522, 0.20010130613874522, 0.20010130613874522, 0.2130666522914927, 0.2130666522914927, 0.2130666522914927, 0.8281565255218342, 0.8281565255218342, 0.8281565255218342, 0.15488127369756244, 0.15488127369756244, 0.15488127369756244, 0.7501198122878916, 0.7501198122878916, 0.7501198122878916, 0.7709046301167406, 0.7709046301167406, 0.7709046301167406, 0.7113352193253755, 0.7113352193253755, 0.7113352193253755, 0.1525591125915745, 0.1525591125915745, 0.1525591125915745, 0.18015353874656215, 0.18015353874656215, 0.18015353874656215, 0.19483014777869812, 0.19483014777869812, 0.19483014777869812, 0.18715379551910505, 0.18715379551910505, 0.18715379551910505, 0.08986245366870282, 0.08986245366870282, 0.08986245366870282, 0.09044259401973509, 0.09044259401973509, 0.09044259401973509, 0.09282764808430455, 0.09282764808430455, 0.09282764808430455]}, "mutation_prompt": null}
{"id": "b7defe3e-61db-4b00-9370-ad863187f520", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "d02f5b02-57a2-4a3c-9bfb-5ba360ec1587", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "2e6eeacd-c593-4109-9608-aae2cc02c53d", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "143a01f7-fc33-4282-95ae-e671686ec61b", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "ca5c9715-5773-4644-a6c5-4754d5add3cb", "solution": "import numpy as np\n\nclass EQIPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 80  # Slightly increased population size for better exploration\n        self.c1 = 1.5  # Adjusted cognitive coefficient for better convergence\n        self.c2 = 1.5  # Adjusted social coefficient for balanced exploration\n        self.inertia_weight = 0.7  # Increased inertia to maintain velocity\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # Enhanced mutation factor for diversity\n        self.crossover_rate_base = 0.7  # Higher base crossover rate\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))  # Increased quantum step size\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.25 * np.sin(np.pi * evaluations / self.budget)  # Modified acceptance probability for better control\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "EQIPSO", "description": "Evolutionary Quantum-Inspired Particle Swarm Optimization (EQIPSO) integrates dynamic inertia, adaptive mutation, and probabilistic acceptance in a hybrid quantum-inspired and evolutionary framework.", "configspace": "", "generation": 93, "fitness": 0.2692198798388726, "feedback": "The algorithm EQIPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6136718940259109, 0.6136718940259109, 0.6136718940259109, 0.5920854152482622, 0.5920854152482622, 0.5920854152482622, 0.6008005275355732, 0.6008005275355732, 0.6008005275355732, 0.17592486010592112, 0.17592486010592112, 0.17592486010592112, 0.02571293305071576, 0.02571293305071576, 0.02571293305071576, 0.025820701575625882, 0.025820701575625882, 0.025820701575625882, 0.11317241650532472, 0.11317241650532472, 0.11317241650532472, 0.11677077854092621, 0.11677077854092621, 0.11677077854092621, 0.12940113538164788, 0.12940113538164788, 0.12940113538164788, 0.09107572279895249, 0.09107572279895249, 0.09107572279895249, 0.06868062080103188, 0.06868062080103188, 0.06868062080103188, 0.09651182276015846, 0.09651182276015846, 0.09651182276015846, 0.9649597560989606, 0.9649597560989606, 0.9649597560989606, 0.9134510155222884, 0.9134510155222884, 0.9134510155222884, 0.9826256588636626, 0.9826256588636626, 0.9826256588636626, 0.34180974074594006, 0.34180974074594006, 0.34180974074594006, 0.3253470490253251, 0.3253470490253251, 0.3253470490253251, 0.3162002861285863, 0.3162002861285863, 0.3162002861285863, 0.5722846724877542, 0.5722846724877542, 0.5722846724877542, 0.6565084881281847, 0.6565084881281847, 0.6565084881281847, 0.5812726378294047, 0.5812726378294047, 0.5812726378294047, 0.17582046103690752, 0.17582046103690752, 0.17582046103690752, 0.22934428446859534, 0.22934428446859534, 0.22934428446859534, 0.19935875903017553, 0.19935875903017553, 0.19935875903017553, 0.19690149651295297, 0.19690149651295297, 0.19690149651295297, 0.21389609441336843, 0.21389609441336843, 0.21389609441336843, 0.16837316220840004, 0.16837316220840004, 0.16837316220840004, 0.05528598299343557, 0.05528598299343557, 0.05528598299343557, 0.13688056709481045, 0.13688056709481045, 0.13688056709481045, 0.16939416237407245, 0.16939416237407245, 0.16939416237407245, 0.1517700589014197, 0.1517700589014197, 0.1517700589014197, 0.14359268815573067, 0.14359268815573067, 0.14359268815573067, 0.1489085559715988, 0.1489085559715988, 0.1489085559715988, 0.07942819792714495, 0.07942819792714495, 0.07942819792714495, 0.041060577604523085, 0.041060577604523085, 0.041060577604523085, 0.046686149140269806, 0.046686149140269806, 0.046686149140269806, 0.17453666892736386, 0.17453666892736386, 0.17453666892736386, 0.14702643389995118, 0.14702643389995118, 0.14702643389995118, 0.08421324144357545, 0.08421324144357545, 0.08421324144357545, 0.4981178393698651, 0.4981178393698651, 0.4981178393698651, 0.46080821651134396, 0.46080821651134396, 0.46080821651134396, 0.5054932411728656, 0.5054932411728656, 0.5054932411728656, 0.10129319972351625, 0.10129319972351625, 0.10129319972351625, 0.11549207146707308, 0.11549207146707308, 0.11549207146707308, 0.10247025004142574, 0.10247025004142574, 0.10247025004142574, 0.2111219782493695, 0.2111219782493695, 0.2111219782493695, 0.28188028769972295, 0.28188028769972295, 0.28188028769972295, 0.19356267769911284, 0.19356267769911284, 0.19356267769911284, 0.359777526346133, 0.359777526346133, 0.359777526346133, 0.33515237267777853, 0.33515237267777853, 0.33515237267777853, 0.25072622845230386, 0.25072622845230386, 0.25072622845230386, 0.2665837562478306, 0.2665837562478306, 0.2665837562478306, 0.2640558766872452, 0.2640558766872452, 0.2640558766872452, 0.2633305881834286, 0.2633305881834286, 0.2633305881834286, 0.21300340232686055, 0.21300340232686055, 0.21300340232686055, 0.1890406501552131, 0.1890406501552131, 0.1890406501552131, 0.2069996735393015, 0.2069996735393015, 0.2069996735393015, 0.20846922442720894, 0.20846922442720894, 0.20846922442720894, 0.2166399241873055, 0.2166399241873055, 0.2166399241873055, 0.21859958748107788, 0.21859958748107788, 0.21859958748107788, 0.7789094689840106, 0.7789094689840106, 0.7789094689840106, 0.15545809109854802, 0.15545809109854802, 0.15545809109854802, 0.19051898990593763, 0.19051898990593763, 0.19051898990593763, 0.7275241779014914, 0.7275241779014914, 0.7275241779014914, 0.20562627241400666, 0.20562627241400666, 0.20562627241400666, 0.15104122831834688, 0.15104122831834688, 0.15104122831834688, 0.17704106424277233, 0.17704106424277233, 0.17704106424277233, 0.19837857215100851, 0.19837857215100851, 0.19837857215100851, 0.18649348886662054, 0.18649348886662054, 0.18649348886662054, 0.0853152669743038, 0.0853152669743038, 0.0853152669743038, 0.11525552781681803, 0.11525552781681803, 0.11525552781681803, 0.08308495181452635, 0.08308495181452635, 0.08308495181452635]}, "mutation_prompt": null}
{"id": "89250b05-06b7-435f-9d4d-9d250fd58567", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "caa9645f-bdaa-4885-bbd2-4c6f8896caa4", "solution": "import numpy as np\n\nclass QIDPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.inertia_weight = 0.7\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9\n        self.crossover_rate_base = 0.5\n        self.crossover_rate_max = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.02, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / (2 * self.budget))\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.4 + 0.25 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QIDPO", "description": "Quantum-Infused Dynamic Particle Optimization (QIDPO) leverages adaptive quantum-inspired updates with inertia adjustment and probabilistic mutation for robust exploration and exploitation.", "configspace": "", "generation": 95, "fitness": 0.27902119463839103, "feedback": "The algorithm QIDPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.6520855209956422, 0.6520855209956422, 0.6520855209956422, 0.6525726372270397, 0.6525726372270397, 0.6525726372270397, 0.6249437810924456, 0.6249437810924456, 0.6249437810924456, 0.19305557693350694, 0.19305557693350694, 0.19305557693350694, 0.16773707136690752, 0.16773707136690752, 0.16773707136690752, 0.1458258659293169, 0.1458258659293169, 0.1458258659293169, 0.1013146963464906, 0.1013146963464906, 0.1013146963464906, 0.08480238089897718, 0.08480238089897718, 0.08480238089897718, 0.14943560317858628, 0.14943560317858628, 0.14943560317858628, 0.10784988115472371, 0.10784988115472371, 0.10784988115472371, 0.10792412756963554, 0.10792412756963554, 0.10792412756963554, 0.06772009672970125, 0.06772009672970125, 0.06772009672970125, 0.9706495862628279, 0.9706495862628279, 0.9706495862628279, 0.9850454629519844, 0.9850454629519844, 0.9850454629519844, 0.9858536197200622, 0.9858536197200622, 0.9858536197200622, 0.3192302962635728, 0.3192302962635728, 0.3192302962635728, 0.3684763968137841, 0.3684763968137841, 0.3684763968137841, 0.40126852571709537, 0.40126852571709537, 0.40126852571709537, 0.642693544317331, 0.642693544317331, 0.642693544317331, 0.6156835907044411, 0.6156835907044411, 0.6156835907044411, 0.5844512500974213, 0.5844512500974213, 0.5844512500974213, 0.2348901311714604, 0.2348901311714604, 0.2348901311714604, 0.12856311629590234, 0.12856311629590234, 0.12856311629590234, 0.12156888401408872, 0.12156888401408872, 0.12156888401408872, 0.12579240166655004, 0.12579240166655004, 0.12579240166655004, 0.22853756993552266, 0.22853756993552266, 0.22853756993552266, 0.17541771926959848, 0.17541771926959848, 0.17541771926959848, 0.08155094790229034, 0.08155094790229034, 0.08155094790229034, 0.021165865097166336, 0.021165865097166336, 0.021165865097166336, 0.10972504200603672, 0.10972504200603672, 0.10972504200603672, 0.23050874191433102, 0.23050874191433102, 0.23050874191433102, 0.09534410373997504, 0.09534410373997504, 0.09534410373997504, 0.29695276961862604, 0.29695276961862604, 0.29695276961862604, 0.031945469375832314, 0.031945469375832314, 0.031945469375832314, 0.05471666103671036, 0.05471666103671036, 0.05471666103671036, 0.07259278065025332, 0.07259278065025332, 0.07259278065025332, 0.1774698570783907, 0.1774698570783907, 0.1774698570783907, 0.23804409450177555, 0.23804409450177555, 0.23804409450177555, 0.22434395638445814, 0.22434395638445814, 0.22434395638445814, 0.5203724714737428, 0.5203724714737428, 0.5203724714737428, 0.5022224567558811, 0.5022224567558811, 0.5022224567558811, 0.5049721807962361, 0.5049721807962361, 0.5049721807962361, 0.1399718757785755, 0.1399718757785755, 0.1399718757785755, 0.10234867214143961, 0.10234867214143961, 0.10234867214143961, 0.13804116528168486, 0.13804116528168486, 0.13804116528168486, 0.1580737500238223, 0.1580737500238223, 0.1580737500238223, 0.17827189475476501, 0.17827189475476501, 0.17827189475476501, 0.2787276477507121, 0.2787276477507121, 0.2787276477507121, 0.3613560495605116, 0.3613560495605116, 0.3613560495605116, 0.36182089054674293, 0.36182089054674293, 0.36182089054674293, 0.3416956572119243, 0.3416956572119243, 0.3416956572119243, 0.1406788220604872, 0.1406788220604872, 0.1406788220604872, 0.283249635911348, 0.283249635911348, 0.283249635911348, 0.13369133912636788, 0.13369133912636788, 0.13369133912636788, 0.2154688223647886, 0.2154688223647886, 0.2154688223647886, 0.22238066056052452, 0.22238066056052452, 0.22238066056052452, 0.2001211060268463, 0.2001211060268463, 0.2001211060268463, 0.20728895614153897, 0.20728895614153897, 0.20728895614153897, 0.20142665811987304, 0.20142665811987304, 0.20142665811987304, 0.19595704410839065, 0.19595704410839065, 0.19595704410839065, 0.824924665395949, 0.824924665395949, 0.824924665395949, 0.20417206335535087, 0.20417206335535087, 0.20417206335535087, 0.1653303295067502, 0.1653303295067502, 0.1653303295067502, 0.7610457010941665, 0.7610457010941665, 0.7610457010941665, 0.2049114472057708, 0.2049114472057708, 0.2049114472057708, 0.15217483439730783, 0.15217483439730783, 0.15217483439730783, 0.17653330404726608, 0.17653330404726608, 0.17653330404726608, 0.1719276260471494, 0.1719276260471494, 0.1719276260471494, 0.17532411472945097, 0.17532411472945097, 0.17532411472945097, 0.09154973017788248, 0.09154973017788248, 0.09154973017788248, 0.09811244291247878, 0.09811244291247878, 0.09811244291247878, 0.09763237466796382, 0.09763237466796382, 0.09763237466796382]}, "mutation_prompt": null}
{"id": "350ae439-2291-4e98-9fe3-f7fced8fd67e", "solution": "import numpy as np\n\nclass QEGS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3\n        self.c2 = 1.7\n        self.inertia_weight = 0.5\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85\n        self.crossover_rate_base = 0.6\n        self.crossover_rate_max = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.03, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_weight_dynamic = self.inertia_weight * np.exp(-evaluations / self.budget)\n                velocities[i] = (inertia_weight_dynamic * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.45 + 0.2 * np.sin(np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGS", "description": "Quantum-Enhanced Gradient Strategy (QEGS) utilizes quantum-inspired perturbations with adaptive gradient-inspired adjustments and strategic acceptance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7681111736205957, 0.7681111736205957, 0.7681111736205957, 0.7180492442088526, 0.7180492442088526, 0.7180492442088526, 0.7399249237876189, 0.7399249237876189, 0.7399249237876189, 0.11204292807984495, 0.11204292807984495, 0.11204292807984495, 0.27949661869318543, 0.27949661869318543, 0.27949661869318543, 0.413100596731255, 0.413100596731255, 0.413100596731255, 0.12728719086018458, 0.12728719086018458, 0.12728719086018458, 0.09786806898127853, 0.09786806898127853, 0.09786806898127853, 0.12988425031449224, 0.12988425031449224, 0.12988425031449224, 0.09933872966383406, 0.09933872966383406, 0.09933872966383406, 0.07843442171226456, 0.07843442171226456, 0.07843442171226456, 0.05324012702329406, 0.05324012702329406, 0.05324012702329406, 0.9731763691099462, 0.9731763691099462, 0.9731763691099462, 0.9752420491766939, 0.9752420491766939, 0.9752420491766939, 0.986887228823154, 0.986887228823154, 0.986887228823154, 0.4843516170922103, 0.4843516170922103, 0.4843516170922103, 0.3775416984519192, 0.3775416984519192, 0.3775416984519192, 0.49496802852250765, 0.49496802852250765, 0.49496802852250765, 0.78146007851285, 0.78146007851285, 0.78146007851285, 0.2501607168127462, 0.2501607168127462, 0.2501607168127462, 0.787908672505466, 0.787908672505466, 0.787908672505466, 0.39178664668757535, 0.39178664668757535, 0.39178664668757535, 0.5510131327910585, 0.5510131327910585, 0.5510131327910585, 0.3560794536101577, 0.3560794536101577, 0.3560794536101577, 0.12487190868021714, 0.12487190868021714, 0.12487190868021714, 0.4018540723298105, 0.4018540723298105, 0.4018540723298105, 0.3752240955075594, 0.3752240955075594, 0.3752240955075594, 0.39986411372840136, 0.39986411372840136, 0.39986411372840136, 0.1334727482416299, 0.1334727482416299, 0.1334727482416299, 0.4251912531559515, 0.4251912531559515, 0.4251912531559515, 0.46535452558731927, 0.46535452558731927, 0.46535452558731927, 0.3538279270915279, 0.3538279270915279, 0.3538279270915279, 0.35031651384908735, 0.35031651384908735, 0.35031651384908735, 0.04806003643955392, 0.04806003643955392, 0.04806003643955392, 0.10548378987819562, 0.10548378987819562, 0.10548378987819562, 0.08171640747105391, 0.08171640747105391, 0.08171640747105391, 0.24997060302299157, 0.24997060302299157, 0.24997060302299157, 0.3103116269607348, 0.3103116269607348, 0.3103116269607348, 0.2766181434434375, 0.2766181434434375, 0.2766181434434375, 0.6381722595065195, 0.6381722595065195, 0.6381722595065195, 0.6443734612480017, 0.6443734612480017, 0.6443734612480017, 0.5731112353853647, 0.5731112353853647, 0.5731112353853647, 0.15599714113841967, 0.15599714113841967, 0.15599714113841967, 0.14137524263833, 0.14137524263833, 0.14137524263833, 0.09238759262617113, 0.09238759262617113, 0.09238759262617113, 0.19395889723607673, 0.19395889723607673, 0.19395889723607673, 0.30633893022094427, 0.30633893022094427, 0.30633893022094427, 0.20526663817668944, 0.20526663817668944, 0.20526663817668944, 0.4514573384576359, 0.4514573384576359, 0.4514573384576359, 0.2688554453718207, 0.2688554453718207, 0.2688554453718207, 0.3311585974046547, 0.3311585974046547, 0.3311585974046547, 0.15517637909267612, 0.15517637909267612, 0.15517637909267612, 0.19412258524790904, 0.19412258524790904, 0.19412258524790904, 0.3539577172416555, 0.3539577172416555, 0.3539577172416555, 0.20933211625664316, 0.20933211625664316, 0.20933211625664316, 0.20383793653128812, 0.20383793653128812, 0.20383793653128812, 0.22354894175600282, 0.22354894175600282, 0.22354894175600282, 0.19592035416292763, 0.19592035416292763, 0.19592035416292763, 0.2022154622756781, 0.2022154622756781, 0.2022154622756781, 0.2144072379989449, 0.2144072379989449, 0.2144072379989449, 0.8519994880239402, 0.8519994880239402, 0.8519994880239402, 0.15678603873955055, 0.15678603873955055, 0.15678603873955055, 0.16878163601120344, 0.16878163601120344, 0.16878163601120344, 0.8223297471696919, 0.8223297471696919, 0.8223297471696919, 0.20846471825911916, 0.20846471825911916, 0.20846471825911916, 0.16678307837135176, 0.16678307837135176, 0.16678307837135176, 0.186645341965614, 0.186645341965614, 0.186645341965614, 0.1940096916027444, 0.1940096916027444, 0.1940096916027444, 0.19844352413274513, 0.19844352413274513, 0.19844352413274513, 0.08272884404883007, 0.08272884404883007, 0.08272884404883007, 0.09200706412550774, 0.09200706412550774, 0.09200706412550774, 0.10257958417045776, 0.10257958417045776, 0.10257958417045776]}, "mutation_prompt": null}
{"id": "b1d0d1e5-38f8-4739-8293-f301a65e92a8", "solution": "import numpy as np\n\nclass QEGSPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.4  # Slightly adjusted for more exploration\n        self.c2 = 1.6  # Slightly adjusted for more convergence\n        self.inertia_weight = 0.4  # Adjusted for more dynamic behavior\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.9  # Slightly increased to enhance diversity\n        self.crossover_rate_base = 0.55  # Slightly adjusted for exploration\n        self.crossover_rate_max = 0.9  # Slightly adjusted for convergence\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.04, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + 0.15 * np.sin(np.pi * evaluations / self.budget)  # Adjusted acceptance probability\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGSPlus", "description": "Quantum-Enhanced Gradient Strategy (QEGS+) integrates dynamic quantum-inspired perturbations with adaptive velocity updates and stochastic acceptance criteria for enhanced exploration.", "configspace": "", "generation": 97, "fitness": 0.35176874527779634, "feedback": "The algorithm QEGSPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "62b9bcf4-a669-4902-9d1a-8af399193258", "metadata": {"aucs": [0.7608386500872217, 0.7608386500872217, 0.7608386500872217, 0.7800785495127057, 0.7800785495127057, 0.7800785495127057, 0.7333613562954493, 0.7333613562954493, 0.7333613562954493, 0.28422377209290073, 0.28422377209290073, 0.28422377209290073, 0.19715663442577647, 0.19715663442577647, 0.19715663442577647, 0.08755555330616516, 0.08755555330616516, 0.08755555330616516, 0.11699586776558246, 0.11699586776558246, 0.11699586776558246, 0.11023425176679869, 0.11023425176679869, 0.11023425176679869, 0.08115938126282107, 0.08115938126282107, 0.08115938126282107, 0.10214115673227586, 0.10214115673227586, 0.10214115673227586, 0.08760966293247441, 0.08760966293247441, 0.08760966293247441, 0.1034750720264328, 0.1034750720264328, 0.1034750720264328, 0.9625888162331684, 0.9625888162331684, 0.9625888162331684, 0.9850343783860639, 0.9850343783860639, 0.9850343783860639, 0.9858478370455406, 0.9858478370455406, 0.9858478370455406, 0.4709839368978229, 0.4709839368978229, 0.4709839368978229, 0.47646945982101285, 0.47646945982101285, 0.47646945982101285, 0.5004660584392824, 0.5004660584392824, 0.5004660584392824, 0.7699992306941771, 0.7699992306941771, 0.7699992306941771, 0.21951573665593882, 0.21951573665593882, 0.21951573665593882, 0.8019097244066921, 0.8019097244066921, 0.8019097244066921, 0.3140399466598438, 0.3140399466598438, 0.3140399466598438, 0.37510994791023344, 0.37510994791023344, 0.37510994791023344, 0.3118917130545735, 0.3118917130545735, 0.3118917130545735, 0.12704875663989168, 0.12704875663989168, 0.12704875663989168, 0.33996986501267656, 0.33996986501267656, 0.33996986501267656, 0.3999762817759992, 0.3999762817759992, 0.3999762817759992, 0.23802066382445053, 0.23802066382445053, 0.23802066382445053, 0.4020085432847672, 0.4020085432847672, 0.4020085432847672, 0.3291630625201929, 0.3291630625201929, 0.3291630625201929, 0.4465797033150699, 0.4465797033150699, 0.4465797033150699, 0.35642877632125636, 0.35642877632125636, 0.35642877632125636, 0.4841253387649068, 0.4841253387649068, 0.4841253387649068, 0.07287580023886275, 0.07287580023886275, 0.07287580023886275, 0.09463845469970511, 0.09463845469970511, 0.09463845469970511, 0.1628844654994902, 0.1628844654994902, 0.1628844654994902, 0.32687923708874, 0.32687923708874, 0.32687923708874, 0.2669850428760795, 0.2669850428760795, 0.2669850428760795, 0.29977886261226205, 0.29977886261226205, 0.29977886261226205, 0.6631700960391751, 0.6631700960391751, 0.6631700960391751, 0.6290106234653723, 0.6290106234653723, 0.6290106234653723, 0.6019587241545962, 0.6019587241545962, 0.6019587241545962, 0.11634089898260247, 0.11634089898260247, 0.11634089898260247, 0.0833889465423805, 0.0833889465423805, 0.0833889465423805, 0.10393052248639345, 0.10393052248639345, 0.10393052248639345, 0.2876824272403069, 0.2876824272403069, 0.2876824272403069, 0.48556161240425944, 0.48556161240425944, 0.48556161240425944, 0.20307131987202043, 0.20307131987202043, 0.20307131987202043, 0.47808622286941105, 0.47808622286941105, 0.47808622286941105, 0.3839658590161936, 0.3839658590161936, 0.3839658590161936, 0.4270686174748436, 0.4270686174748436, 0.4270686174748436, 0.1602424547927852, 0.1602424547927852, 0.1602424547927852, 0.20234030317779939, 0.20234030317779939, 0.20234030317779939, 0.2055484642115757, 0.2055484642115757, 0.2055484642115757, 0.2172077544164377, 0.2172077544164377, 0.2172077544164377, 0.20344781684650948, 0.20344781684650948, 0.20344781684650948, 0.2137988130052476, 0.2137988130052476, 0.2137988130052476, 0.21995344102575154, 0.21995344102575154, 0.21995344102575154, 0.20861385777012642, 0.20861385777012642, 0.20861385777012642, 0.1898275337238059, 0.1898275337238059, 0.1898275337238059, 0.8785121934945214, 0.8785121934945214, 0.8785121934945214, 0.8602358303842665, 0.8602358303842665, 0.8602358303842665, 0.1678534028503893, 0.1678534028503893, 0.1678534028503893, 0.8390351236197372, 0.8390351236197372, 0.8390351236197372, 0.206614591276575, 0.206614591276575, 0.206614591276575, 0.1656208261730644, 0.1656208261730644, 0.1656208261730644, 0.17644091941301177, 0.17644091941301177, 0.17644091941301177, 0.21859031572238208, 0.21859031572238208, 0.21859031572238208, 0.2120864154556623, 0.2120864154556623, 0.2120864154556623, 0.09608708689134693, 0.09608708689134693, 0.09608708689134693, 0.0967734927229732, 0.0967734927229732, 0.0967734927229732, 0.159233603594506, 0.159233603594506, 0.159233603594506]}, "mutation_prompt": null}
{"id": "a34a5630-5c70-4c45-80ea-c24bc9ba5dca", "solution": "import numpy as np\n\nclass QEGSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3  # Slightly reduced for balancing exploration\n        self.c2 = 1.7  # Slightly increased for faster convergence\n        self.inertia_weight = 0.5  # Adjusted for more dynamic behavior\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.95  # Further increased to enhance diversity\n        self.crossover_rate_base = 0.6  # Slightly increased for diversity\n        self.crossover_rate_max = 0.85  # Slightly decreased for balance\n        self.adaptive_acceptance_factor = 0.2  # Adaptive factor for acceptance probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.5 + self.adaptive_acceptance_factor * np.sin(2 * np.pi * evaluations / self.budget)\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGSPlusPlus", "description": "Quantum-Enhanced Gradient Strategy (QEGS++) integrates dynamic quantum perturbations with adaptive velocity updates and adaptive stochastic acceptance criteria for improved exploration and convergence.", "configspace": "", "generation": 98, "fitness": 0.3194281178871715, "feedback": "The algorithm QEGSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b1d0d1e5-38f8-4739-8293-f301a65e92a8", "metadata": {"aucs": [0.7374676394405317, 0.7374676394405317, 0.7374676394405317, 0.6823316391516674, 0.6823316391516674, 0.6823316391516674, 0.7124728160768599, 0.7124728160768599, 0.7124728160768599, 0.2555601122325276, 0.2555601122325276, 0.2555601122325276, 0.05015301299844954, 0.05015301299844954, 0.05015301299844954, 0.3169553901173914, 0.3169553901173914, 0.3169553901173914, 0.1378843456688179, 0.1378843456688179, 0.1378843456688179, 0.10157184883299719, 0.10157184883299719, 0.10157184883299719, 0.13063352850450083, 0.13063352850450083, 0.13063352850450083, 0.08327541094381163, 0.08327541094381163, 0.08327541094381163, 0.13754511307374107, 0.13754511307374107, 0.13754511307374107, 0.16441283478700075, 0.16441283478700075, 0.16441283478700075, 0.9741710396930525, 0.9741710396930525, 0.9741710396930525, 0.9843791631777344, 0.9843791631777344, 0.9843791631777344, 0.9859086720913458, 0.9859086720913458, 0.9859086720913458, 0.42923618343041425, 0.42923618343041425, 0.42923618343041425, 0.4494888399670389, 0.4494888399670389, 0.4494888399670389, 0.4008405792079083, 0.4008405792079083, 0.4008405792079083, 0.7061424536381223, 0.7061424536381223, 0.7061424536381223, 0.7499338918043148, 0.7499338918043148, 0.7499338918043148, 0.6702096196799832, 0.6702096196799832, 0.6702096196799832, 0.31287206711887516, 0.31287206711887516, 0.31287206711887516, 0.27822041925392693, 0.27822041925392693, 0.27822041925392693, 0.3222225140737224, 0.3222225140737224, 0.3222225140737224, 0.38912404215483865, 0.38912404215483865, 0.38912404215483865, 0.3865815314475092, 0.3865815314475092, 0.3865815314475092, 0.3116383172069266, 0.3116383172069266, 0.3116383172069266, 0.07549083323185601, 0.07549083323185601, 0.07549083323185601, 0.01509792401195753, 0.01509792401195753, 0.01509792401195753, 0.18814590563097788, 0.18814590563097788, 0.18814590563097788, 0.33270744828363896, 0.33270744828363896, 0.33270744828363896, 0.372988714608095, 0.372988714608095, 0.372988714608095, 0.35782568637767287, 0.35782568637767287, 0.35782568637767287, 0.051362082048167945, 0.051362082048167945, 0.051362082048167945, 0.13261520958337403, 0.13261520958337403, 0.13261520958337403, 0.08861316481918202, 0.08861316481918202, 0.08861316481918202, 0.24056364206606906, 0.24056364206606906, 0.24056364206606906, 0.2641976760120921, 0.2641976760120921, 0.2641976760120921, 0.20994177084267007, 0.20994177084267007, 0.20994177084267007, 0.6340583642867399, 0.6340583642867399, 0.6340583642867399, 0.6154150191177259, 0.6154150191177259, 0.6154150191177259, 0.585765343781781, 0.585765343781781, 0.585765343781781, 0.11237938677635706, 0.11237938677635706, 0.11237938677635706, 0.12551099027252877, 0.12551099027252877, 0.12551099027252877, 0.12051834402532513, 0.12051834402532513, 0.12051834402532513, 0.20964309421716076, 0.20964309421716076, 0.20964309421716076, 0.21444896550063564, 0.21444896550063564, 0.21444896550063564, 0.25879980081501985, 0.25879980081501985, 0.25879980081501985, 0.35565854167580224, 0.35565854167580224, 0.35565854167580224, 0.32357011934427204, 0.32357011934427204, 0.32357011934427204, 0.3377235127390479, 0.3377235127390479, 0.3377235127390479, 0.11617647657849572, 0.11617647657849572, 0.11617647657849572, 0.1804980315433169, 0.1804980315433169, 0.1804980315433169, 0.2062033901852356, 0.2062033901852356, 0.2062033901852356, 0.2408104923572162, 0.2408104923572162, 0.2408104923572162, 0.17466862988835674, 0.17466862988835674, 0.17466862988835674, 0.19948497155349743, 0.19948497155349743, 0.19948497155349743, 0.18667865886251234, 0.18667865886251234, 0.18667865886251234, 0.19394363829178718, 0.19394363829178718, 0.19394363829178718, 0.2032245309937294, 0.2032245309937294, 0.2032245309937294, 0.8716870661829134, 0.8716870661829134, 0.8716870661829134, 0.15740387838847492, 0.15740387838847492, 0.15740387838847492, 0.16897593293230329, 0.16897593293230329, 0.16897593293230329, 0.8185677759522196, 0.8185677759522196, 0.8185677759522196, 0.2039802371803433, 0.2039802371803433, 0.2039802371803433, 0.1525847794722095, 0.1525847794722095, 0.1525847794722095, 0.18142081017742895, 0.18142081017742895, 0.18142081017742895, 0.19207982498766818, 0.19207982498766818, 0.19207982498766818, 0.1707785833030281, 0.1707785833030281, 0.1707785833030281, 0.10095488039572154, 0.10095488039572154, 0.10095488039572154, 0.09213872155535285, 0.09213872155535285, 0.09213872155535285, 0.10228861125237676, 0.10228861125237676, 0.10228861125237676]}, "mutation_prompt": null}
{"id": "0de477e1-2f09-45ed-8bda-3e96fb66bc36", "solution": "import numpy as np\n\nclass QEGSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 60\n        self.c1 = 1.3  # Adjusted for slightly more exploration\n        self.c2 = 1.7  # Adjusted for slightly more convergence\n        self.inertia_weight = 0.5  # Enhanced for more adaptive behavior\n        self.epsilon = 1e-8\n        self.mutation_factor = 0.85  # Adjusted to maintain diversity\n        self.crossover_rate_base = 0.6  # Adjusted for improved exploration\n        self.crossover_rate_max = 0.88  # Adjusted for better convergence\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lower_bound, upper_bound = self.bounds\n        population = np.random.uniform(lower_bound, upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = np.copy(population)\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            quantum_step_size = np.random.uniform(0, (upper_bound - lower_bound) * 0.05, (self.population_size, self.dim))\n            quantum_population = population + quantum_step_size * np.random.normal(0, 1, (self.population_size, self.dim))\n\n            quantum_values = np.array([func(ind) for ind in quantum_population])\n            evaluations += self.population_size\n            if evaluations > self.budget:\n                break\n\n            for i in range(self.population_size):\n                if quantum_values[i] < personal_best_values[i]:\n                    personal_best_values[i] = quantum_values[i]\n                    personal_best[i] = quantum_population[i]\n                    if quantum_values[i] < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n\n            population = np.clip(population, lower_bound, upper_bound)\n\n            for i in range(self.population_size):\n                crossover_rate = self.crossover_rate_base + (self.crossover_rate_max - self.crossover_rate_base) * \\\n                                 np.sqrt(1 - (evaluations / self.budget))\n                if np.random.rand() < crossover_rate:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    mutation_vector = (population[indices[0]] +\n                                       self.mutation_factor * (population[indices[1]] - population[indices[2]]))\n                    mutant = np.clip(mutation_vector, lower_bound, upper_bound)\n                    if evaluations < self.budget and func(mutant) < personal_best_values[i]:\n                        population[i] = mutant\n                        personal_best[i] = mutant\n                        evaluations += 1\n\n            for i in range(self.population_size):\n                if evaluations < self.budget:\n                    acceptance_prob = 0.55 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Enhanced acceptance probability\n                    if np.random.rand() < acceptance_prob:\n                        fitness = func(population[i])\n                        evaluations += 1\n                        if fitness < personal_best_values[i]:\n                            personal_best_values[i] = fitness\n                            personal_best[i] = population[i]\n                        if fitness < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[i]\n                else:\n                    break\n\n        return global_best", "name": "QEGSPlusPlus", "description": "Quantum-Enhanced Gradient Strategy (QEGS++) incorporates adaptive quantum step modulation and enhanced crossover dynamics for robust convergence.", "configspace": "", "generation": 99, "fitness": 0.3153931006490974, "feedback": "The algorithm QEGSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b1d0d1e5-38f8-4739-8293-f301a65e92a8", "metadata": {"aucs": [0.7321508840428741, 0.7321508840428741, 0.7321508840428741, 0.7079757324197978, 0.7079757324197978, 0.7079757324197978, 0.7457797672827386, 0.7457797672827386, 0.7457797672827386, 0.19389710830151274, 0.19389710830151274, 0.19389710830151274, 0.05195726387407573, 0.05195726387407573, 0.05195726387407573, 0.1587490053429481, 0.1587490053429481, 0.1587490053429481, 0.1445272508018779, 0.1445272508018779, 0.1445272508018779, 0.10352536702114234, 0.10352536702114234, 0.10352536702114234, 0.11934760697748548, 0.11934760697748548, 0.11934760697748548, 0.12933315774534826, 0.12933315774534826, 0.12933315774534826, 0.11770364650784015, 0.11770364650784015, 0.11770364650784015, 0.12803499792166873, 0.12803499792166873, 0.12803499792166873, 0.9658204206221249, 0.9658204206221249, 0.9658204206221249, 0.9850707443574009, 0.9850707443574009, 0.9850707443574009, 0.9766005865223245, 0.9766005865223245, 0.9766005865223245, 0.3927338653826373, 0.3927338653826373, 0.3927338653826373, 0.435627421453587, 0.435627421453587, 0.435627421453587, 0.47083471011205824, 0.47083471011205824, 0.47083471011205824, 0.7561088656040686, 0.7561088656040686, 0.7561088656040686, 0.2063613310439283, 0.2063613310439283, 0.2063613310439283, 0.2252324570025438, 0.2252324570025438, 0.2252324570025438, 0.12438221978814568, 0.12438221978814568, 0.12438221978814568, 0.32002274736061265, 0.32002274736061265, 0.32002274736061265, 0.1600778579257447, 0.1600778579257447, 0.1600778579257447, 0.1795456934315831, 0.1795456934315831, 0.1795456934315831, 0.39046075054999374, 0.39046075054999374, 0.39046075054999374, 0.21667506537435788, 0.21667506537435788, 0.21667506537435788, 0.3989613301202921, 0.3989613301202921, 0.3989613301202921, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22049250721069924, 0.22049250721069924, 0.22049250721069924, 0.3199932832565183, 0.3199932832565183, 0.3199932832565183, 0.3856177824416879, 0.3856177824416879, 0.3856177824416879, 0.2997017640849884, 0.2997017640849884, 0.2997017640849884, 0.053106744122220384, 0.053106744122220384, 0.053106744122220384, 0.06668306480932895, 0.06668306480932895, 0.06668306480932895, 0.15954177988210194, 0.15954177988210194, 0.15954177988210194, 0.18321823859646358, 0.18321823859646358, 0.18321823859646358, 0.1923399560478981, 0.1923399560478981, 0.1923399560478981, 0.173413276457676, 0.173413276457676, 0.173413276457676, 0.6411620698382852, 0.6411620698382852, 0.6411620698382852, 0.5816546690724647, 0.5816546690724647, 0.5816546690724647, 0.5808104798054738, 0.5808104798054738, 0.5808104798054738, 0.08773678836072762, 0.08773678836072762, 0.08773678836072762, 0.07429597171644531, 0.07429597171644531, 0.07429597171644531, 0.10204003648022486, 0.10204003648022486, 0.10204003648022486, 0.19412964586085812, 0.19412964586085812, 0.19412964586085812, 0.4763145376918404, 0.4763145376918404, 0.4763145376918404, 0.5287675536259113, 0.5287675536259113, 0.5287675536259113, 0.317172318932638, 0.317172318932638, 0.317172318932638, 0.23861240918705084, 0.23861240918705084, 0.23861240918705084, 0.3749958318729848, 0.3749958318729848, 0.3749958318729848, 0.16828393787911478, 0.16828393787911478, 0.16828393787911478, 0.18141352046111903, 0.18141352046111903, 0.18141352046111903, 0.22342026672164128, 0.22342026672164128, 0.22342026672164128, 0.21030971013825095, 0.21030971013825095, 0.21030971013825095, 0.18995686406061885, 0.18995686406061885, 0.18995686406061885, 0.2131751315735737, 0.2131751315735737, 0.2131751315735737, 0.2124427867326686, 0.2124427867326686, 0.2124427867326686, 0.2409633048140679, 0.2409633048140679, 0.2409633048140679, 0.3425410890238585, 0.3425410890238585, 0.3425410890238585, 0.8621995575304374, 0.8621995575304374, 0.8621995575304374, 0.8241563169646813, 0.8241563169646813, 0.8241563169646813, 0.16766554657557842, 0.16766554657557842, 0.16766554657557842, 0.8067746114103076, 0.8067746114103076, 0.8067746114103076, 0.2068050634171128, 0.2068050634171128, 0.2068050634171128, 0.1664069419781279, 0.1664069419781279, 0.1664069419781279, 0.17689706037467967, 0.17689706037467967, 0.17689706037467967, 0.225245255054616, 0.225245255054616, 0.225245255054616, 0.18003126037357264, 0.18003126037357264, 0.18003126037357264, 0.09873074725794029, 0.09873074725794029, 0.09873074725794029, 0.09603705549240404, 0.09603705549240404, 0.09603705549240404, 0.12544865465544075, 0.12544865465544075, 0.12544865465544075]}, "mutation_prompt": null}
