{"id": "2abd7ec1-9427-4728-938b-7532e21da6f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.history_success_rate = []\n        \n    def scale_parameters(self):\n        if len(self.history_success_rate) >= 10:\n            avg_success = np.mean(self.history_success_rate[-10:])\n            self.mutation_factor = 0.7 + 0.3 * avg_success\n            self.crossover_prob = 0.6 + 0.3 * avg_success\n\n    def local_search(self, best_individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.scale_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Success-Based Parameter Adaptation and Local Search", "configspace": "", "generation": 0, "fitness": 0.2375542009133057, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6494062813107516, 0.6593170916643867, 0.606783965572822, 0.640443480791675, 0.657220767895196, 0.6653573331925142, 0.674257542530332, 0.6702361419815293, 0.6633460241639619, 0.3628893940604979, 0.3561358959808284, 0.37909973952810394, 0.4012668104279462, 0.377533229445564, 0.3886483192146738, 0.4096901654145997, 0.3931327404440651, 0.39334932228562525, 0.13418890830786623, 0.12707996827903867, 0.13978588147606863, 0.1268942789485722, 0.11842106971482957, 0.1404994181931576, 0.1342887406088863, 0.13117968516917466, 0.11906384254099356, 0.12489414863913972, 0.12351151542615413, 0.11784095084751256, 0.12266784528019803, 0.1260724198255463, 0.11407502552245974, 0.1211902556683212, 0.11621783582849676, 0.12990141972196323, 0.9522962358061844, 0.9560453701654431, 0.9632552435087681, 0.9481310209739819, 0.9328907551243865, 0.9207951140270698, 0.9539605728110132, 0.9549206541397596, 0.9657048715668958, 0.2616114457283393, 0.2598774170928627, 0.22895230399701527, 0.2758758356265263, 0.25413268228250896, 0.2718626644518567, 0.24123183664934955, 0.2587244893680968, 0.24903095282063958, 0.2715614544844501, 0.2818664793562823, 0.2835155966809041, 0.2876122189538107, 0.2669109677279671, 0.27234678759882247, 0.309973989411527, 0.3758576902614331, 0.34212508033569866, 0.16324606806970077, 0.14816765024231304, 0.15487690427707224, 0.15194141324499355, 0.20454333385868428, 0.14541950866164133, 0.14519691785321098, 0.1529843590515375, 0.14972847356028318, 0.11757494775549349, 0.11634772543965033, 0.158430189252588, 0.14355681486093197, 0.17313728822872254, 0.15382557353028437, 0.14960968357881188, 0.12695245702496327, 0.13595728837747645, 0.003106041747222066, 9.999999999998899e-05, 0.0015630649243199013, 0.002662087720907036, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010883410703287355, 9.999999999998899e-05, 9.999999999998899e-05, 0.07177276485987205, 0.0651988652761365, 0.06346545299059492, 0.05721661694115521, 0.07025143319918858, 0.06447582762573889, 0.13062543906434332, 0.10194586997325972, 0.09767878463519664, 0.0004200115007697569, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008764585072220665, 0.017373342479114373, 0.009558516043565723, 0.11825343909112307, 0.08607681337321194, 0.09775689091282858, 0.11395921254867958, 0.11978590394483091, 0.09991307192307464, 0.08941695142803474, 0.09550109094268044, 0.12245764139908166, 0.4355265172151701, 0.44492953303745264, 0.42520695605457337, 0.4261323121045083, 0.45602921274073804, 0.41909022592705136, 0.4423361480441408, 0.4304052232997073, 0.4249077295750492, 0.11180779878488434, 0.10729694600154449, 0.13025659933405842, 0.12318260799335423, 0.10869578549947057, 0.1319414731173736, 0.09255246959724173, 0.1035717250675896, 0.10104781176204503, 0.22693255769806409, 0.16863811343863566, 0.13877652677769314, 0.1657542949586035, 0.1346239854007668, 0.2214671308899926, 0.2151626956499303, 0.1498198883759072, 0.14046699133027774, 0.25724023667819274, 0.2643380361697688, 0.26035807686504997, 0.254646936458783, 0.2497701310922399, 0.26109772755253136, 0.2776067286373396, 0.2752372985610615, 0.301699870702552, 0.19528614616340834, 0.1797239272855904, 0.19678460239780593, 0.2054211636148442, 0.17581635085390412, 0.19244372854579017, 0.21282929608745393, 0.19844155486729198, 0.19873620171472994, 0.19535969003326914, 0.17991599258696334, 0.19791175509164316, 0.19798923824075243, 0.17617369730949428, 0.18201917119958477, 0.1948474668669784, 0.17824752201834548, 0.19205663210761825, 0.2401563356774271, 0.1944613785268, 0.20879770439587186, 0.22230292924020534, 0.22964175476303716, 0.19679550699600046, 0.2073976118467059, 0.17765308614405817, 0.18924907671152125, 0.3350011431210659, 0.21820145515867662, 0.21536754914005452, 0.49781091763826235, 0.5026315738644935, 0.27232056621476586, 0.4120949389277412, 0.19905202053490367, 0.3864590796682581, 0.1921169220454717, 0.23037296350460246, 0.34667152145077396, 0.21806592665337654, 0.18454526075204003, 0.18889577621538933, 0.20579279000609663, 0.3516743283984052, 0.2597613879431, 0.17606686226267665, 0.19240805932708083, 0.20451322015502715, 0.18265581685767707, 0.18342067145306307, 0.17619501018831052, 0.18825199736224518, 0.18178081612059582, 0.1995066492773846, 0.06981468273536118, 0.08023363946115347, 0.0740410381346448, 0.06974989526315001, 0.07755296931620836, 0.07625192239953027, 0.07120071449268839, 0.07773004489204216, 0.06662972481139784]}, "mutation_prompt": null}
{"id": "ce948dac-156f-43fb-b5a5-f0be3b9839fe", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.history_success_rate = []\n        self.inertia_weight = 0.5\n        self.personal_best_positions = None\n        self.global_best_position = None\n\n    def scale_parameters(self):\n        if len(self.history_success_rate) >= 10:\n            avg_success = np.mean(self.history_success_rate[-10:])\n            self.mutation_factor = 0.5 + 0.4 * avg_success\n            self.crossover_prob = 0.5 + 0.4 * avg_success\n            self.inertia_weight = 0.4 + 0.3 * avg_success\n\n    def local_search(self, best_individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def initialize_pso(self, population):\n        self.personal_best_positions = np.copy(population)\n        self.global_best_position = population[np.argmin([func(ind) for ind in population])]\n\n    def update_pso(self, population, velocities, personal_best_values):\n        for i, individual in enumerate(population):\n            r1, r2 = np.random.rand(2)\n            velocities[i] = (self.inertia_weight * velocities[i] +\n                             r1 * (self.personal_best_positions[i] - individual) +\n                             r2 * (self.global_best_position - individual))\n            population[i] = np.clip(individual + velocities[i], self.lower_bound, self.upper_bound)\n            fitness_value = func(individual)\n            if fitness_value < personal_best_values[i]:\n                self.personal_best_positions[i] = individual\n                personal_best_values[i] = fitness_value\n                if fitness_value < func(self.global_best_position):\n                    self.global_best_position = individual\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        personal_best_values = np.copy(fitness)\n        budget_used = self.population_size\n\n        self.initialize_pso(population)\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.scale_parameters()\n\n            # PSO update\n            self.update_pso(population, velocities, personal_best_values)\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization with Adaptive Parameter Control and Local Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "2abd7ec1-9427-4728-938b-7532e21da6f9", "metadata": {}, "mutation_prompt": null}
{"id": "fa831771-fc58-4527-ad15-61139073820b", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85\n        self.crossover_prob = 0.9\n        self.history_success_rate = []\n        self.qgate_rotation = 0.01\n        \n    def scale_parameters(self):\n        if len(self.history_success_rate) >= 10:\n            avg_success = np.mean(self.history_success_rate[-10:])\n            self.mutation_factor = 0.7 + 0.3 * avg_success\n            self.crossover_prob = 0.7 + 0.2 * avg_success\n\n    def quantum_inspired_mutation(self, a, b, c):\n        delta = self.qgate_rotation * np.random.normal(0, 1, self.dim)\n        return np.clip(a + self.mutation_factor * (b - c) + delta, self.lower_bound, self.upper_bound)\n\n    def local_search(self, best_individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = self.quantum_inspired_mutation(a, b, c)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.scale_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution integrates quantum principles to enhance diversity and convergence speed.", "configspace": "", "generation": 2, "fitness": 0.23113195417262877, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "2abd7ec1-9427-4728-938b-7532e21da6f9", "metadata": {"aucs": [0.5314994493791527, 0.5413205407722388, 0.5380556737649576, 0.5582722017246965, 0.5391274712992813, 0.541755614689783, 0.5534930612717593, 0.539617569297798, 0.5545897613729118, 0.19599430167349752, 0.2127831534272704, 0.17179511279088533, 0.19838064895846497, 0.20991357018023438, 0.19558962136536528, 0.1987583946384579, 0.2061552770477969, 0.17985410990630102, 0.11438505307013147, 0.11274031672905571, 0.1208647238487951, 0.12027484409943534, 0.13070499209933784, 0.13163015642961495, 0.12000548796486021, 0.1276625908362966, 0.11742101057401633, 0.12107735558553756, 0.11415443101146971, 0.11802706880542702, 0.1029704715091222, 0.1144147453782074, 0.10535668917137953, 0.11273451460236161, 0.10531213960479524, 0.10689956258421984, 0.9723589943581991, 0.9426990421281443, 0.9338108531056251, 0.9521459360664829, 0.9403823442288425, 0.9273959907086999, 0.9680041527553416, 0.9423831666188799, 0.9519941796618013, 0.280346688241057, 0.27748258672782733, 0.2614483143199453, 0.2654475310748199, 0.24818500903603646, 0.27240106555570553, 0.274332910451335, 0.26633010619636266, 0.2697042265433769, 0.3683112052819987, 0.2933753443849444, 0.35644189555973294, 0.44678274328006207, 0.4145780413655986, 0.4647233148393327, 0.34323405582318534, 0.4476067410322334, 0.3231185967333223, 0.1998581358412117, 0.16703398206233488, 0.16206474333298138, 0.18749424900763756, 0.15562165296968344, 0.15678651325385562, 0.17154966681930783, 0.1751753074103244, 0.1853764181443993, 0.10729312047832318, 0.11215232767323213, 0.1775535877431561, 0.1913608431508519, 0.16323786926420147, 0.18378479855459973, 0.14754313185807388, 0.15050934570033037, 0.174944584674686, 0.019427306598670313, 0.01709326899732755, 0.009967048963456904, 0.024159260094559043, 0.0037263925647348373, 0.012652709264516449, 0.016613506866328898, 0.012945652262158047, 0.018692045270823243, 0.13606685014541708, 0.1366650281322942, 0.10709369068983832, 0.1000781701669965, 0.0803023477988265, 0.11650827047510814, 0.09591989392299016, 0.11313625049485987, 0.14434849316653475, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010705608692708202, 9.999999999998899e-05, 0.00038738949563010827, 9.999999999998899e-05, 0.006282753200362423, 0.0012861022224548435, 0.005643840915413034, 0.10953660557639433, 0.10359549224833031, 0.10158693945547803, 0.12375854013678111, 0.1110583521548022, 0.12391223383932315, 0.11972566497111892, 0.1074571125471433, 0.10043952632484432, 0.4134338017638264, 0.4249729537554888, 0.4318342556766689, 0.4439765459882272, 0.4259124963358776, 0.4357292691373086, 0.4290136170415957, 0.42421253677733384, 0.43444660154352444, 0.10229124337088014, 0.10155543658766497, 0.12275985648007082, 0.11523725640295379, 0.09663951547066951, 0.1558706926905994, 0.08408124428601516, 0.09377530262624278, 0.11540635662347054, 0.22896041172917203, 0.15263707287898565, 0.15499996594224563, 0.14056414956646968, 0.17058458730086135, 0.2072412703050942, 0.18932234105261847, 0.13599653595756023, 0.1457842905776644, 0.27222228174494545, 0.2711773704548145, 0.2890682463461197, 0.2628333905429652, 0.24513250589375235, 0.2558347778076072, 0.2929815715153249, 0.30610104735287147, 0.30009784231048575, 0.209726888670964, 0.20843772675154804, 0.19321570050499204, 0.18331535845634628, 0.17899405920483447, 0.20381982587826597, 0.21358463370996728, 0.20874311939307288, 0.21606518853227807, 0.1855321618701007, 0.180661900068549, 0.18621105548454353, 0.1826564092234234, 0.20162470581785918, 0.1808785265038133, 0.20119997417966728, 0.18011415155161226, 0.19541934412683892, 0.18907182147855728, 0.18617544872796088, 0.2168078761960064, 0.1885797393091535, 0.20195855082589986, 0.18914252521018293, 0.1906678128084882, 0.19388168973481013, 0.21025816199863012, 0.47436797964344657, 0.22549533658798726, 0.6754833863931078, 0.18996508073475982, 0.19607363642937015, 0.2791979722896054, 0.19695726541473835, 0.20600726486591892, 0.2678054757717545, 0.3912616623272992, 0.19890151052909, 0.19923222006475239, 0.34437985011167016, 0.22281072662018364, 0.18843090008833474, 0.34027764622116474, 0.1922173759863447, 0.3577747885777237, 0.17709264559652949, 0.1863420559737079, 0.18611706472301393, 0.18604753276461072, 0.1781343263439641, 0.17375860505035667, 0.18117674863063526, 0.18815319353622229, 0.18734467689805345, 0.07324110036250386, 0.07635540862682488, 0.07247356409663719, 0.07443078215539245, 0.06891712505828074, 0.06824136658287971, 0.07835681280078788, 0.0788280920198291, 0.07392362203819647]}, "mutation_prompt": null}
{"id": "783ed0f2-ad5f-45a8-9308-4b9f08acc3be", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.history_success_rate = []\n        \n    def scale_parameters(self):\n        if len(self.history_success_rate) >= 10:\n            avg_success = np.mean(self.history_success_rate[-10:])\n            self.mutation_factor = 0.6 + 0.4 * avg_success\n            self.crossover_prob = 0.5 + 0.5 * avg_success\n\n    def dynamic_local_search(self, best_individual):\n        step_size = 0.05 + 0.15 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.scale_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.dynamic_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Adaptive Mutation and Crossover Using Success History and Dynamic Local Search.", "configspace": "", "generation": 3, "fitness": 0.24579934197702322, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "2abd7ec1-9427-4728-938b-7532e21da6f9", "metadata": {"aucs": [0.6798343669176974, 0.6724188940441718, 0.6673098395369593, 0.6962120546830705, 0.6881760323067747, 0.7029546895051615, 0.6746452144290791, 0.6814991905139776, 0.7035253298413142, 0.43593420871429744, 0.4548639956171394, 0.4198439119819567, 0.43039129295328915, 0.43059835579393435, 0.43369209139087983, 0.45279592410316327, 0.43181113243369795, 0.47258465286206575, 0.18694143234912686, 0.15661678526121925, 0.22335046112149592, 0.18146068186304487, 0.17095311965476068, 0.17884678843625168, 0.17018430209079105, 0.2037962263165749, 0.13728895798892804, 0.15882253782340372, 0.14895057262963107, 0.1745754939855516, 0.16752086115757192, 0.13289172717711484, 0.1389443140191956, 0.17562685500075148, 0.1346689199376604, 0.1409172498998541, 0.9656827939502298, 0.9616762693627305, 0.9600386558816513, 0.9371244400142602, 0.9569368935864802, 0.919265678002962, 0.9340141061715546, 0.962798950900517, 0.9420838911907661, 0.24275478315696308, 0.28560775990026266, 0.24889548644905946, 0.2811062087276527, 0.24783005039761796, 0.261978919258406, 0.2541783109876463, 0.2845739309918782, 0.26320174613590985, 0.2398431858677934, 0.24959453472397775, 0.24652691904327917, 0.27404546594587587, 0.27903896600722866, 0.27891120497311594, 0.2589429364100627, 0.2890622984739555, 0.29397726999487783, 0.14739502217766132, 0.1521872807677821, 0.14998436196432718, 0.1444672734266622, 0.19713621790611557, 0.13950095640904003, 0.17363982918642762, 0.16298536748997816, 0.16674755187554258, 0.1252868845378209, 0.12470449871298317, 0.1704858191831108, 0.15462624925516988, 0.15452501988787248, 0.1554647266504804, 0.1500657044542466, 0.1459955099096738, 0.1443929200963081, 9.999999999998899e-05, 9.999999999998899e-05, 0.04319305431523679, 9.999999999998899e-05, 0.003963347556051322, 9.999999999998899e-05, 0.006115333758637487, 0.0056716571693193885, 9.999999999998899e-05, 0.07692090001450436, 0.0958779983534499, 0.06676598066143435, 0.0758291293995661, 0.06679124277833814, 0.07022433617521184, 0.10186023066408034, 0.07346638837374064, 0.13007485258786633, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015387662235381128, 0.002059500987785734, 9.999999999998899e-05, 9.999999999998899e-05, 0.10824896294807118, 0.09480227460768909, 0.09807375533925111, 0.09062961503446076, 0.1042001992743522, 0.12230151935098454, 0.11379718939522554, 0.08932868363261748, 0.10038322973434954, 0.4350154694399655, 0.4473570823403151, 0.42844670768158855, 0.4364905686964916, 0.42557833755735963, 0.42726745987571546, 0.4743133164682455, 0.435018844650479, 0.44317329408232586, 0.10299027681990025, 0.11738530905172662, 0.11052308889717422, 0.11622188573652015, 0.09311061136691601, 0.09536667072146243, 0.0875115117001729, 0.08344379640348376, 0.0932495864688424, 0.17165362424404196, 0.16452978903122062, 0.140927542982345, 0.146766135336439, 0.19531157730343607, 0.25960619771135685, 0.16721698685876185, 0.1567442496607202, 0.18716630917411392, 0.2783300237512697, 0.2546748322387655, 0.27078531656847027, 0.27179829883173545, 0.2593599686070821, 0.2443314731596744, 0.31266324975236803, 0.29848248734047, 0.3099349289483896, 0.19254321735799074, 0.20550614821565183, 0.19851503492461875, 0.1938938531255222, 0.17599796498436793, 0.18302498693341662, 0.21320543073283438, 0.21555605258710597, 0.20465658362415684, 0.19010126680401185, 0.16907884747089152, 0.16838697985492035, 0.20231754245775124, 0.18150348717885068, 0.20560108786723796, 0.19193403604630033, 0.1758113556679458, 0.1816988362132268, 0.2066946265953592, 0.20246925422136974, 0.2249389214409303, 0.22328630797752935, 0.24345621301270048, 0.24124528844936188, 0.20451249791797887, 0.2334281469027495, 0.19755114861265088, 0.39066169781424764, 0.17049787277179151, 0.24206287674321714, 0.3005845919201908, 0.3908329139986466, 0.36882468960263615, 0.48303682864993247, 0.3017430555898798, 0.18598782660258562, 0.512883935787599, 0.19907884400730946, 0.31363033120518247, 0.2214557931441593, 0.23949292022517754, 0.23708512486648237, 0.3185120310673577, 0.3259471598245084, 0.20544546164574362, 0.18468223491164637, 0.1983262361253273, 0.17907646278633238, 0.18477728623804113, 0.17690458037297907, 0.1733197094731389, 0.18160694972003144, 0.19466762889284794, 0.18609652879674188, 0.07663516378126445, 0.08444864949880426, 0.07547949360944473, 0.0728834110269021, 0.08473717820111648, 0.08652252810695649, 0.08067148276684166, 0.07341050052134179, 0.0730876010167496]}, "mutation_prompt": null}
{"id": "b77c8357-ac91-49f3-b260-71259faee390", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor_base = 0.5  # Base mutation factor\n        self.mutation_factor = self.mutation_factor_base\n        self.crossover_prob = 0.9\n        self.history_success_rate = []\n        \n    def scale_parameters(self):\n        if len(self.history_success_rate) >= 10:\n            avg_success = np.mean(self.history_success_rate[-10:])\n            self.mutation_factor = self.mutation_factor_base + 0.5 * avg_success  # Dynamic mutation\n            self.crossover_prob = 0.4 + 0.6 * avg_success  # Dynamic crossover\n\n    def focused_local_search(self, best_individual):\n        step_size = 0.02 + 0.18 * np.random.rand()  # Adjusted step size for focused search\n        perturbation = np.random.normal(0, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.scale_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.focused_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Control and Focused Local Exploitation.", "configspace": "", "generation": 4, "fitness": 0.21716472749779997, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "783ed0f2-ad5f-45a8-9308-4b9f08acc3be", "metadata": {"aucs": [0.574056200374571, 0.5718870925337078, 0.5919336140542616, 0.5953315987385333, 0.5767710926396574, 0.5741097440432382, 0.566763508602575, 0.5936677130566602, 0.5692985618545787, 0.26661017376688856, 0.2923438099317641, 0.25185788348041926, 0.2798718527435643, 0.2517679637438447, 0.2730424850387233, 0.29312871306398525, 0.2642125767042247, 0.28982488587899247, 0.15470611386131716, 0.14205925577121703, 0.15648120446757452, 0.16459926128469538, 0.15389529538946412, 0.14907543093358255, 0.154208858595416, 0.13896611887247623, 0.13559942965045213, 0.12905503192031598, 0.12095799500032678, 0.1215840086594091, 0.1362024799361654, 0.1237130939985438, 0.118560961566886, 0.13327841272408003, 0.11783154558002751, 0.12136636020914593, 0.9091738365935476, 0.899158918090081, 0.9374262297888094, 0.9500698095667057, 0.9032416527571788, 0.9514983326810711, 0.9471185262687811, 0.9134117765707591, 0.9303658601738808, 0.2181191198634227, 0.2054007088047607, 0.18380431322193647, 0.19676911507005923, 0.2199887837352409, 0.20144486219973468, 0.21958799177818278, 0.20164403313588486, 0.20106846931054356, 0.2041245363779799, 0.2173074468594962, 0.18463906448146128, 0.2651238110891686, 0.2629377466639289, 0.22865889204213308, 0.2781284030719352, 0.2651039864961141, 0.246435307212024, 0.14452807500809106, 0.13378665080650864, 0.10667282009391199, 0.12644685723473137, 0.12608617531983324, 0.12495741279901063, 0.13868976947716616, 0.1304046364504713, 0.15969883534151197, 0.11292830256559339, 0.11915519551597009, 0.12374663009160525, 0.12796462806127307, 0.1475494905958542, 0.1420390605554518, 0.13529354487367962, 0.11559862171168311, 0.1346739047381238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0708617288429455, 0.07614270533816014, 0.07811474011460884, 0.0726623361431108, 0.07139747716345135, 0.04667251499980518, 0.1028765078702174, 0.08570170653035225, 0.08065101595552537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06837584006581998, 0.08880730832678307, 0.08316289961466705, 0.0834996138853783, 0.10320141218055945, 0.07487843958254103, 0.08524934641737403, 0.08395646136163337, 0.09115787913626461, 0.40015220399232854, 0.4133090065372568, 0.41147137680511126, 0.4131181615080205, 0.40282229412225556, 0.3925231375364071, 0.399069847450661, 0.391976121319373, 0.4053478037196304, 0.09641813260229026, 0.09656796710858329, 0.12127701069489427, 0.0947132011865216, 0.0914994193050217, 0.11453745617839073, 0.08780146209112649, 0.10689433160962702, 0.0980235916827289, 0.14374348588221963, 0.16271953519642013, 0.2561449277878389, 0.15523202628508204, 0.1762638516726429, 0.16375174570968865, 0.14726232097264458, 0.168434440360006, 0.15837929560883945, 0.24224858581527664, 0.24635291849064556, 0.2508770464780913, 0.23607757176880717, 0.24406513302957533, 0.245404386117844, 0.25315075900796025, 0.2778089640212512, 0.23760087858025414, 0.16386319783233305, 0.17415572955608694, 0.16823052611995304, 0.1758997132607597, 0.19225042364251343, 0.18601209523324025, 0.16874644370237568, 0.19270919845921786, 0.171524254805415, 0.16793786520561205, 0.1975659339215997, 0.1949345418208901, 0.19229048236639756, 0.19579175099427304, 0.17781710844131016, 0.1787254007834841, 0.18667037071415093, 0.199539306774014, 0.1921951272031568, 0.1936451900492624, 0.19500831274139785, 0.20233232671296986, 0.19438811329471484, 0.1944828394458189, 0.20171393586927067, 0.20767883401540432, 0.1930096858242546, 0.1717030866196132, 0.2437220640077823, 0.314253350620301, 0.43563704842671636, 0.33389797124241205, 0.33016192796247446, 0.22308780549907425, 0.26779932047434085, 0.45768989519812986, 0.30001230498904075, 0.1879657557776322, 0.2485604487100982, 0.2202387113614277, 0.1737282539962589, 0.18320432509567586, 0.251821185502613, 0.29812029832761633, 0.2373341156194071, 0.18477263376786845, 0.1701384313883203, 0.1885080754203461, 0.18242003511689464, 0.17898855752169351, 0.19567455290136626, 0.19811894237174943, 0.20036061408169903, 0.1917100485731137, 0.07554736996288047, 0.0847167618168343, 0.0743344925169871, 0.07254500255771057, 0.07475263620364825, 0.06949723379389183, 0.08117460210599825, 0.08066543912087332, 0.07279632650133261]}, "mutation_prompt": null}
{"id": "ec521bb1-440c-461d-bd98-cec6d7882148", "solution": "import numpy as np\n\nclass StochasticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.4 + 0.6 * recent_success\n\n    def focused_local_search(self, best_individual):\n        step_size = 0.03 + 0.1 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.focused_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "StochasticDifferentialEvolution", "description": "Stochastic Differential Evolution with Adaptive Mutation and Crossover rates, enhanced by Limited Memory Success Tracking and Focused Local Exploration.", "configspace": "", "generation": 5, "fitness": 0.2635053940489718, "feedback": "The algorithm StochasticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "783ed0f2-ad5f-45a8-9308-4b9f08acc3be", "metadata": {"aucs": [0.7336614139565465, 0.7125700241254005, 0.7320967177862933, 0.7435345984348871, 0.728992617627003, 0.738820249626102, 0.7228093669692741, 0.7405397847915038, 0.746530711509839, 0.5019917880748969, 0.5111292044523326, 0.5012636586762805, 0.48504034423351994, 0.5113979989721904, 0.5140739000296073, 0.5140898581283698, 0.5286829133694508, 0.5264687748033898, 0.28502236153719107, 0.30835998407835274, 0.3021957919650753, 0.28864178524131545, 0.2889221228012149, 0.31318462867056673, 0.26699598024959303, 0.2822249395648295, 0.3083570731095707, 0.17536769074458192, 0.20485841966625096, 0.262126307123261, 0.18297860315149939, 0.22601419418874868, 0.23536561476049, 0.23489616605892882, 0.21447882855309397, 0.21903204746581517, 0.9275711196085006, 0.9382275246022953, 0.9475776842508975, 0.9437358867422716, 0.9393261984497633, 0.9195079220406734, 0.9197244888156757, 0.9215118286565245, 0.9141564256231414, 0.27737702615438387, 0.25376106440248825, 0.27865582166314284, 0.2918055348947828, 0.3069352970697209, 0.2793554306614595, 0.2780749284843732, 0.2510376590541291, 0.2918350288215046, 0.25407477986341687, 0.26456331915625675, 0.26032634810564714, 0.24717768223889858, 0.4628475551389146, 0.27706998493689916, 0.3713869478644677, 0.24061334538651946, 0.2836896325355689, 0.16174816349579046, 0.1771350463218443, 0.1712386218271662, 0.15630954083661108, 0.2090631923226448, 0.18625347603781484, 0.18556648067384063, 0.15393607219787753, 0.15640649078930036, 0.13803109994129714, 0.13186141697152598, 0.14411080299780876, 0.177059937945379, 0.15215751384970733, 0.1370163733657399, 0.14000446951414214, 0.19507933999126936, 0.1321194862687538, 0.013616712685851629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013184001851499483, 9.999999999998899e-05, 0.001394939714217669, 0.0007913056305984822, 9.999999999998899e-05, 0.08838586732333242, 0.05540485923881644, 0.10069295224700148, 0.07700485143951175, 0.0809247269478407, 0.06441567072198318, 0.11166886216527894, 0.08344785829954071, 0.07674673116512476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004959518441821853, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011268428308527367, 0.0038684648951410328, 0.007897821608737976, 0.11710946139811207, 0.11061150959283839, 0.0964121637932609, 0.11524819270975728, 0.11286419104438106, 0.12020444366554517, 0.11586780137831099, 0.10143800785514578, 0.10793283308846369, 0.4587485110082249, 0.4494026787583757, 0.44116047733690156, 0.4852438629809561, 0.44800381185881244, 0.45877909194490785, 0.46368653104356883, 0.4529698197780073, 0.45286421235082097, 0.10576129045967342, 0.12016770733318516, 0.10470333031036627, 0.10864619812661436, 0.10246940512640046, 0.11630058259427456, 0.14460928146720975, 0.11650017106169253, 0.10986889410629541, 0.1877818129544807, 0.1850319604573447, 0.22632777589654574, 0.16604709645830695, 0.19922144239252737, 0.15639255836460475, 0.22569232637248593, 0.2992538381287986, 0.17744720474970377, 0.27273517638751454, 0.2719537473016581, 0.26788656516633913, 0.2686020322957513, 0.2796167149126152, 0.24693620574487662, 0.3111269936222475, 0.32556398635463313, 0.3338515555006396, 0.18541710347241047, 0.19088895924358984, 0.20379246278670293, 0.1934239784550531, 0.18874245290516278, 0.21288070374258095, 0.19461214631558754, 0.2167186053701644, 0.21822030857074692, 0.1976652503027947, 0.18954316868021837, 0.18753143244989756, 0.1828979221529453, 0.1805699156872772, 0.19241792209689323, 0.20455991016220576, 0.190718007398619, 0.21688242367696875, 0.27081513670195967, 0.20810612128814343, 0.24617751226292073, 0.26284327541355446, 0.2501253510530469, 0.2271118258911461, 0.23244060535088562, 0.26176792602473364, 0.275816504449782, 0.38809746517532884, 0.18925089061842426, 0.2109986626212591, 0.4257530918336194, 0.1893319914861511, 0.4117382705692092, 0.3211503592337315, 0.17670259252285414, 0.5585412830864032, 0.3097864847879114, 0.19570917588543302, 0.1982860870026778, 0.2130290910306104, 0.1628557654846371, 0.25220338137250786, 0.302406545711287, 0.26385002524073176, 0.34894507953012255, 0.18891511920229975, 0.1817168187955166, 0.19007505638197142, 0.1829158962596662, 0.17885515672216168, 0.19569759780708607, 0.2027920782609095, 0.19559852953351342, 0.1990046330592954, 0.0781188514280804, 0.09050772933789919, 0.07899700428475642, 0.07725887840234613, 0.07904026714175183, 0.081228449048794, 0.08983226787389631, 0.07934222026905957, 0.09249508982793397]}, "mutation_prompt": null}
{"id": "0ecb71e2-3458-4682-a4ab-1d408c60b0c0", "solution": "import numpy as np\n\nclass StochasticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.4 + 0.6 * recent_success\n\n    def focused_local_search(self, best_individual):\n        step_size = 0.03 + 0.1 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.focused_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "StochasticDifferentialEvolution", "description": "Stochastic Differential Evolution with Adaptive Mutation and Crossover rates, enhanced by Limited Memory Success Tracking and Focused Local Exploration.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec521bb1-440c-461d-bd98-cec6d7882148", "metadata": {"aucs": [0.7336614139565465, 0.7125700241254005, 0.7320967177862933, 0.7435345984348871, 0.728992617627003, 0.738820249626102, 0.7228093669692741, 0.7405397847915038, 0.746530711509839, 0.5019917880748969, 0.5111292044523326, 0.5012636586762805, 0.48504034423351994, 0.5113979989721904, 0.5140739000296073, 0.5140898581283698, 0.5286829133694508, 0.5264687748033898, 0.28502236153719107, 0.30835998407835274, 0.3021957919650753, 0.28864178524131545, 0.2889221228012149, 0.31318462867056673, 0.26699598024959303, 0.2822249395648295, 0.3083570731095707, 0.17536769074458192, 0.20485841966625096, 0.262126307123261, 0.18297860315149939, 0.22601419418874868, 0.23536561476049, 0.23489616605892882, 0.21447882855309397, 0.21903204746581517, 0.9275711196085006, 0.9382275246022953, 0.9475776842508975, 0.9437358867422716, 0.9393261984497633, 0.9195079220406734, 0.9197244888156757, 0.9215118286565245, 0.9141564256231414, 0.27737702615438387, 0.25376106440248825, 0.27865582166314284, 0.2918055348947828, 0.3069352970697209, 0.2793554306614595, 0.2780749284843732, 0.2510376590541291, 0.2918350288215046, 0.25407477986341687, 0.26456331915625675, 0.26032634810564714, 0.24717768223889858, 0.4628475551389146, 0.27706998493689916, 0.3713869478644677, 0.24061334538651946, 0.2836896325355689, 0.16174816349579046, 0.1771350463218443, 0.1712386218271662, 0.15630954083661108, 0.2090631923226448, 0.18625347603781484, 0.18556648067384063, 0.15393607219787753, 0.15640649078930036, 0.13803109994129714, 0.13186141697152598, 0.14411080299780876, 0.177059937945379, 0.15215751384970733, 0.1370163733657399, 0.14000446951414214, 0.19507933999126936, 0.1321194862687538, 0.013616712685851629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013184001851499483, 9.999999999998899e-05, 0.001394939714217669, 0.0007913056305984822, 9.999999999998899e-05, 0.08838586732333242, 0.05540485923881644, 0.10069295224700148, 0.07700485143951175, 0.0809247269478407, 0.06441567072198318, 0.11166886216527894, 0.08344785829954071, 0.07674673116512476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004959518441821853, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011268428308527367, 0.0038684648951410328, 0.007897821608737976, 0.11710946139811207, 0.11061150959283839, 0.0964121637932609, 0.11524819270975728, 0.11286419104438106, 0.12020444366554517, 0.11586780137831099, 0.10143800785514578, 0.10793283308846369, 0.4587485110082249, 0.4494026787583757, 0.44116047733690156, 0.4852438629809561, 0.44800381185881244, 0.45877909194490785, 0.46368653104356883, 0.4529698197780073, 0.45286421235082097, 0.10576129045967342, 0.12016770733318516, 0.10470333031036627, 0.10864619812661436, 0.10246940512640046, 0.11630058259427456, 0.14460928146720975, 0.11650017106169253, 0.10986889410629541, 0.1877818129544807, 0.1850319604573447, 0.22632777589654574, 0.16604709645830695, 0.19922144239252737, 0.15639255836460475, 0.22569232637248593, 0.2992538381287986, 0.17744720474970377, 0.27273517638751454, 0.2719537473016581, 0.26788656516633913, 0.2686020322957513, 0.2796167149126152, 0.24693620574487662, 0.3111269936222475, 0.32556398635463313, 0.3338515555006396, 0.18541710347241047, 0.19088895924358984, 0.20379246278670293, 0.1934239784550531, 0.18874245290516278, 0.21288070374258095, 0.19461214631558754, 0.2167186053701644, 0.21822030857074692, 0.1976652503027947, 0.18954316868021837, 0.18753143244989756, 0.1828979221529453, 0.1805699156872772, 0.19241792209689323, 0.20455991016220576, 0.190718007398619, 0.21688242367696875, 0.27081513670195967, 0.20810612128814343, 0.24617751226292073, 0.26284327541355446, 0.2501253510530469, 0.2271118258911461, 0.23244060535088562, 0.26176792602473364, 0.275816504449782, 0.38809746517532884, 0.18925089061842426, 0.2109986626212591, 0.4257530918336194, 0.1893319914861511, 0.4117382705692092, 0.3211503592337315, 0.17670259252285414, 0.5585412830864032, 0.3097864847879114, 0.19570917588543302, 0.1982860870026778, 0.2130290910306104, 0.1628557654846371, 0.25220338137250786, 0.302406545711287, 0.26385002524073176, 0.34894507953012255, 0.18891511920229975, 0.1817168187955166, 0.19007505638197142, 0.1829158962596662, 0.17885515672216168, 0.19569759780708607, 0.2027920782609095, 0.19559852953351342, 0.1990046330592954, 0.0781188514280804, 0.09050772933789919, 0.07899700428475642, 0.07725887840234613, 0.07904026714175183, 0.081228449048794, 0.08983226787389631, 0.07934222026905957, 0.09249508982793397]}, "mutation_prompt": null}
{"id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 7, "fitness": 0.30605345210622253, "feedback": "The algorithm AdaptiveStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "ec521bb1-440c-461d-bd98-cec6d7882148", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "c1305bd8-831d-4319-9c82-2605ffea64ad", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "f3290b82-7b28-49ce-a935-69430fc82959", "solution": "import numpy as np\n\nclass EnhancedAdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, 8 * dim)  # Reduced initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Increased crossover probability\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 15)  # Adjusted rescale budget\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.4 + 0.4 * recent_success  # Further adaptive mutation\n            self.crossover_prob = 0.4 + 0.6 * recent_success  # Further adaptive crossover\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.03 + 0.1 * np.random.rand()  # Modified step size range\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def introduce_diversity(self, population):\n        if len(self.history_success_rate) > 10 and np.mean(self.history_success_rate[-10:]) < 0.2:\n            num_replacements = max(1, self.population_size // 5)\n            for _ in range(num_replacements):\n                idx = np.random.randint(0, self.population_size)\n                population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return population\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 8 == 0 and self.population_size > 5:  # More frequent resizing\n            self.population_size = max(5, int(0.85 * self.population_size))  # Increased reduction rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n            population = self.introduce_diversity(population)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveStochasticDE", "description": "Enhanced Adaptive Stochastic DE with Strategic Diversity Introduction and Adaptive Mutation for Robust Optimization.", "configspace": "", "generation": 9, "fitness": 0.14892727162644515, "feedback": "The algorithm EnhancedAdaptiveStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.21866998485631484, 0.2863183973425496, 0.36662056345133665, 0.2592673028725805, 0.18522752825486655, 0.2167094429362323, 0.3304182248194657, 0.3391018004862497, 0.383101297994049, 9.999999999998899e-05, 0.01719788040488235, 0.04616374243079702, 9.999999999998899e-05, 0.05553564383080789, 0.13000651278210607, 0.012017180433336994, 9.999999999998899e-05, 9.999999999998899e-05, 0.1055628853631615, 0.06180737691308513, 0.0783540968229276, 0.0630664520393579, 0.07307290442378567, 0.08887068915613094, 0.07454630649065108, 0.11176126703203859, 0.14291661445799653, 0.052994444468295154, 0.05611597628156251, 0.06177388687958896, 0.08799111626086209, 0.06180141316540955, 0.07819177441820646, 0.1216224370218113, 0.0833965619863164, 0.050587793589190744, 0.9429758199023082, 0.9503781102074642, 0.9529431859531633, 0.9539431314676698, 0.9441805286375008, 0.9543396821139235, 0.9328527139224786, 0.9593099172853825, 0.9534305067780475, 0.10314981646161325, 0.0790380419942801, 0.09992804043009962, 0.08978521725095612, 0.11797957020960148, 0.06967035277625278, 0.10085518993931675, 0.08081075366563417, 0.0919037881747139, 0.13721384207348386, 0.16828291863023803, 0.1592437204285232, 0.15245230166703894, 0.11435651286095239, 0.17092961907547777, 0.16563951247067255, 0.12365410091782791, 0.1319345997082082, 0.03316255086923359, 0.033954723300692824, 0.03736987792429258, 0.041058530044674635, 0.04474219855494466, 0.10583477419156773, 0.08324079046076949, 0.09139111855638149, 0.034958013399551624, 0.015026967745456976, 0.031075344769642688, 0.008427919278301665, 0.037526246315725986, 0.05326673287219241, 0.042491654719119976, 0.013603052289196449, 0.10299671192040716, 0.08059090574936267, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05951666951888834, 0.06914941750596992, 0.07390424978042431, 0.05601674806500212, 0.05942811642881407, 0.09139492823415918, 0.0730008326104229, 0.05868956835833927, 0.061696221378225724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00604283693398644, 0.0010816990053350573, 9.999999999998899e-05, 0.014755190815809338, 0.02402201910695767, 0.016818290241694345, 0.018454140235955152, 0.010596808371968969, 0.046697194358866545, 0.21294681695693307, 0.20479883838505075, 0.2038719449543216, 0.21595626141117985, 0.285896022285712, 0.2837604386007544, 0.3524623131885065, 0.21244486380761696, 0.22647761657424348, 0.06297937108051188, 0.05756680746561904, 0.11739994281256316, 0.06821117439533841, 0.07352349878247022, 0.06250592214436346, 0.06839364243582091, 0.07222583225477608, 0.06345170695222002, 0.1654412313931889, 0.15279024791147078, 0.15911528205505998, 0.14017910930252642, 0.14649027879768417, 0.1496445878528535, 0.15378089806601203, 0.15322643899847443, 0.1476981587894134, 0.18302592745615964, 0.18936088261740025, 0.19247924056079457, 0.18589343718617224, 0.17568145121996126, 0.16798212090949638, 0.17972324318118138, 0.1883116713685844, 0.16389794735358065, 0.15308329891605843, 0.11774460876229875, 0.12814226906888193, 0.12324516708725763, 0.11779901133259152, 0.13615072618427826, 0.10820557758896121, 0.14221473810818464, 0.10861206327575401, 0.14209646073294535, 0.1548937630118562, 0.16056901001420087, 0.15511856430763726, 0.18799410939941275, 0.17880590155645804, 0.15029022221189248, 0.153709153950495, 0.22511257886091318, 0.18114914309437313, 0.15921601847610067, 0.17084937116865617, 0.169680828121063, 0.19097045519762523, 0.1659841698343656, 0.1608294908972292, 0.17186885483915815, 0.20063634452013956, 0.16626540637078868, 0.16939515665131, 0.16645491476413554, 0.16307667512082336, 0.16443279806175926, 0.2264779662297618, 0.16592238788989866, 0.1575159818632248, 0.16223827260434742, 0.17859795916215537, 0.22221758167228467, 0.17454458197046263, 0.19535052183881152, 0.22071850229479983, 0.19464637756724834, 0.191368862426757, 0.12558733225604268, 0.19290216097129442, 0.1788755299078102, 0.19795539112824456, 0.18546195978248636, 0.20617224926457633, 0.186157723942588, 0.1799284173937855, 0.186990386527362, 0.1729604685949716, 0.20026948938505762, 0.05263480697454925, 0.053051892196635864, 0.053502179193853916, 0.06095590383697691, 0.05745835724896786, 0.051909454469698524, 0.09181781319897708, 0.07243877313186076, 0.051215326809918804]}, "mutation_prompt": null}
{"id": "7241ba05-376f-4ac5-88ad-246a8eecf7bb", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "827cc204-a316-4607-b628-850f72a410ce", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "13908b11-357e-4a76-af9b-112b02d17e8f", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "82bab93d-02e3-4a83-ae9f-9eda3f8457dd", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "c981b694-4c4d-45ad-8d84-a6653e70daec", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "8f9789f5-d60d-4af3-83bf-ae2f52a4f1e4", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "580805bd-b596-4df1-9d26-294bab5b5483", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "ada96983-187d-4162-bbb2-4fafa84ecd70", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "2ab3abf1-b2cf-4987-8816-c0dc3ec28358", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "ea7cf409-7e10-471a-9391-f835811156a3", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "8719cd6c-143f-4676-aed3-2f834d25b610", "solution": "import numpy as np\n\nclass AdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.rescale_budget = max(100, budget // 20)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.3 + 0.7 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.05 + 0.08 * np.random.rand()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        direction = np.random.choice([-1, 1], self.dim)\n        candidate = np.clip(best_individual + direction * perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveStochasticDE", "description": "Adaptive Stochastic Differential Evolution with Dynamic Population Resizing and Hybrid Local Search for improved convergence and efficiency.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.8119854441542543, 0.8141505080792043, 0.8314230651267834, 0.8186572901912886, 0.8182568328523041, 0.8198871028185699, 0.8330974578179804, 0.8248721522160518, 0.8281601933503906, 0.6982626086024548, 0.7223748904636521, 0.7228854115476941, 0.6782895644384848, 0.6784465059997742, 0.7286944945830861, 0.730589886817971, 0.7280732513949191, 0.7207702500475883, 0.45826723693161575, 0.6891111010579911, 0.3476553741240064, 0.5363116767229544, 0.42743574527043027, 0.4725573335375559, 0.592048901759537, 0.678046301445909, 0.5174711322645198, 0.3705552584611208, 0.17297149169864556, 0.31626350998762387, 0.16563358623069102, 0.1669876836345895, 0.6013387940113923, 0.1434900765302688, 0.16549686563400667, 0.17236244829492953, 0.9385077079489379, 0.9400817394147353, 0.9452317082659256, 0.9443263672070277, 0.9237483543025267, 0.9375016746001773, 0.9377572931473209, 0.9279270578685682, 0.938582396510982, 0.3498161848096918, 0.3607737153807423, 0.34568686331280174, 0.3295035580403525, 0.30838491526701484, 0.3219294575132069, 0.3305696767701275, 0.34727536698016137, 0.3345247840013431, 0.6140836453979648, 0.22760134788095132, 0.19402751895802073, 0.6360152628531088, 0.20291508121845814, 0.31831188489575457, 0.3241176964436996, 0.22144054050090145, 0.6544002634536791, 0.18519266708691107, 0.15434181762625176, 0.20898421649822763, 0.18251822021971287, 0.2073693752438458, 0.17440282610600621, 0.1649668708620866, 0.2650966724052446, 0.18554751981406292, 0.17625638396206234, 0.14914558487150464, 0.11708391529014406, 0.15663398293622455, 0.19144601798362904, 0.23352322293199645, 0.14490331759377895, 0.1629286418896121, 0.18237919551538617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01977283636037408, 0.015238715046179796, 0.023552912631557232, 0.08632863116994538, 0.06144117979732533, 0.14116995602028037, 0.07111455666090327, 0.059829983421598065, 0.057754247582250895, 0.06238068404214303, 0.08907273018113737, 0.1259819970808459, 0.05065721897208386, 0.04321610920405494, 0.025179707697132847, 9.999999999998899e-05, 0.029195628240237914, 0.010977918599624381, 0.01862276515739536, 0.06270918382808666, 0.005680170346351265, 0.15108409020710223, 0.142997642501149, 0.12764929488594445, 0.12961587721130075, 0.13910104942520152, 0.19513718261295832, 0.12281767766633833, 0.12136097107918431, 0.14073115254350976, 0.5518490111305374, 0.5490443547335943, 0.49707759575935406, 0.5277189066060941, 0.4906124797864727, 0.4880744921657876, 0.4786275708843234, 0.5165763260329295, 0.5023672820943147, 0.1558122897402907, 0.12230537829098043, 0.10749913486629792, 0.13041826209857066, 0.1382036281277631, 0.11364970277851028, 0.11855662113235865, 0.10390106114811237, 0.14666378666739788, 0.24846487480290014, 0.2628854560282826, 0.17494810825806417, 0.1607925006067651, 0.24327369173026236, 0.19838136155309483, 0.19215418061888756, 0.18935601495892374, 0.18103016754523338, 0.32637413283766104, 0.2758279926055164, 0.34800002729260937, 0.32070693662022187, 0.2967258521492162, 0.3703872976375233, 0.35783391344395576, 0.3908287926991886, 0.3959253532604413, 0.21136189764337276, 0.23036175220748045, 0.24103888371699855, 0.21945634277104087, 0.2096980898923394, 0.20726503663293827, 0.26323700440766873, 0.23065666200402157, 0.20469055899223765, 0.20472893081162913, 0.2163936201939608, 0.19284001204520884, 0.21385278883302294, 0.1997737407854081, 0.20139817572028962, 0.21887672448449447, 0.18128535438349613, 0.2017787319362616, 0.2966311032467486, 0.4047616585741717, 0.2130352844719695, 0.24482410427217938, 0.3560398793473508, 0.22997962697522534, 0.23246612596305005, 0.40739244959648346, 0.23555018048588905, 0.18090714146690712, 0.19649485540907763, 0.1925544399347281, 0.5468457040218075, 0.2601309908644722, 0.22032782238707016, 0.48025574531039805, 0.313548372276212, 0.35377775617548013, 0.28033879251301985, 0.3009747300816463, 0.43541464588168965, 0.18345923333482683, 0.21463117938508658, 0.225539470941704, 0.19998654356609058, 0.5349117888490156, 0.20164860518801464, 0.1815407716065809, 0.18225860153628926, 0.1855555901114586, 0.18222958388559196, 0.19608932634916998, 0.18008308444442778, 0.19321006610636104, 0.17712283796283623, 0.18732292324881084, 0.09447081808276947, 0.07924690311723492, 0.06903988704073016, 0.08020295762870988, 0.08915580520986188, 0.08290616680411844, 0.08431052950012274, 0.0875851106281681, 0.07952160495289151]}, "mutation_prompt": null}
{"id": "97c124ee-b628-4edb-871d-4084beffee72", "solution": "import numpy as np\n\nclass EnhancedAdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.75\n        self.history_success_rate = []\n        self.rescale_budget = max(150, budget // 15)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.6 + 0.2 * recent_success\n            self.crossover_prob = 0.4 + 0.6 * recent_success\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.04 + 0.1 * np.random.rand() * np.random.choice([1, -1], p=[0.35, 0.65])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 15 == 0 and self.population_size > 7:\n            self.population_size = max(7, int(0.85 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveStochasticDE", "description": "Enhanced Adaptive Stochastic Differential Evolution with Probabilistic Step-Size Control and Adaptive Mutation for Robust Optimization.", "configspace": "", "generation": 21, "fitness": 0.3500663349716821, "feedback": "The algorithm EnhancedAdaptiveStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "f73ea79d-8ea1-4081-9dd9-a89332f1ae10", "metadata": {"aucs": [0.7967277007965373, 0.7715952409173862, 0.7832412469164772, 0.7934855520170975, 0.7892979108676805, 0.7930952893255132, 0.7867995730337709, 0.7827154641469767, 0.791556264018766, 0.6692427098142265, 0.6758857761733115, 0.6766451935956084, 0.6667728686258367, 0.6754257454648058, 0.6868993442978539, 0.6722324364346538, 0.6661085176370327, 0.6652533321653922, 0.6132372814023729, 0.6233336683536556, 0.6291416656540215, 0.6308684707312335, 0.6161555398175115, 0.6130767914765544, 0.6381822486968968, 0.6148191928437932, 0.6147645587879096, 0.6061293579524454, 0.6184246693364515, 0.5065215554816136, 0.5785043334669014, 0.15783560318162748, 0.58461043057499, 0.48332915627952766, 0.6169899651318298, 0.615469987558606, 0.9428978316819778, 0.9646762788086972, 0.9380975033330107, 0.9270665646441967, 0.946346991399402, 0.9525290806919128, 0.9455813205335909, 0.9645143424725395, 0.9524037861148361, 0.46907576380264504, 0.49583497870328463, 0.3328035081575679, 0.5897517154562615, 0.5144441631420111, 0.5613485412129997, 0.5426914639300414, 0.3889569457600631, 0.455575751266201, 0.37978205586694536, 0.2924526638385335, 0.201401327712884, 0.3242501200649849, 0.5233447772934953, 0.5120590328065187, 0.4309502183917123, 0.5886733894823393, 0.5250758930306181, 0.16040144034479764, 0.21735682319146465, 0.18409823023598892, 0.15919805727281688, 0.21710056875191763, 0.17909770984672946, 0.26138210411414087, 0.19569127182262547, 0.21873595811760738, 0.1649008053430584, 0.15666880959688856, 0.13894013839562047, 0.15649694568272843, 0.16994719400780778, 0.22037562635655794, 0.15324337073299343, 0.15683918910976258, 0.17631253218048037, 0.00433482498909199, 0.014875907346947548, 0.023402474803525752, 9.999999999998899e-05, 9.999999999998899e-05, 0.0064267594293669905, 0.019441997320352122, 0.02981451927648726, 0.029450140705275407, 0.0484869791496545, 0.0707108041899206, 0.07861708830248137, 0.08894784948177226, 0.05306136479645851, 0.06542033519497237, 0.1484556612776562, 0.14909517611427547, 0.1565621434378338, 0.0611605430464468, 0.03582462340052117, 0.07142000745166877, 0.057464217413064955, 0.062335653878409, 0.07021422981170888, 0.09913463999322725, 0.11029391713355197, 0.05662499914439434, 0.20566409267992403, 0.14599993687750834, 0.14833574227501356, 0.18482839454720856, 0.19431189515782044, 0.15913500800230373, 0.12708513807039068, 0.16129389823648965, 0.13021017422585246, 0.4939768155300218, 0.535988909162084, 0.5180958819010422, 0.4862849940973276, 0.5199985501995149, 0.5271388696948676, 0.516286034629873, 0.5376837232369269, 0.5717625191537123, 0.14800738806652403, 0.1382601252241491, 0.12578722598071979, 0.12064613718456352, 0.11664069709487301, 0.13359860838039528, 0.13101022098548676, 0.1438530858132735, 0.11798832524713998, 0.20315513088266235, 0.17518862775622457, 0.1900978789475748, 0.21817054475945885, 0.1704934525534827, 0.24457376443015377, 0.25493886432667345, 0.198902173812872, 0.1445280600788994, 0.3562170166254288, 0.32481027977869326, 0.37802710068862044, 0.31676661071588297, 0.34845814671118713, 0.35494976724070115, 0.5525626481613313, 0.41523335221527924, 0.5199185414652758, 0.2138422243101945, 0.24117422258942134, 0.2129718145652757, 0.2333385502786116, 0.22258918423225382, 0.2333939272244383, 0.24730481215037148, 0.2492034813007622, 0.26151557161314276, 0.18944958556264035, 0.20543699267810167, 0.19286251141096877, 0.20758611327382281, 0.20067675629492276, 0.1935323328506019, 0.2343718181798362, 0.2310194514349334, 0.2103210185183665, 0.5075229996393156, 0.419228525915206, 0.5491157119991377, 0.6160216750641816, 0.47373216478405455, 0.23834516653216453, 0.5735599533120856, 0.5156891578809086, 0.5834873912691765, 0.18146976786982227, 0.2303881016210434, 0.5536456248286235, 0.6116133602211724, 0.6301972395365734, 0.2716129887556885, 0.6667444200415378, 0.634534949566032, 0.3312526795992844, 0.2999541055920135, 0.19835125364536343, 0.24123344046784434, 0.35590928860139726, 0.44731794239211675, 0.22067541381010292, 0.2707590400003662, 0.36776861392700355, 0.2002079849996956, 0.1931282915397745, 0.21056722476965872, 0.20165808790725048, 0.20042267117821477, 0.2281428720967753, 0.19302902926142262, 0.22286369543760143, 0.18141982533684686, 0.2000359477382887, 0.09154954677907268, 0.09624674156891433, 0.09723393848180839, 0.08466333406135695, 0.08845391084049281, 0.09361994919951211, 0.1162879399093667, 0.08395595576606352, 0.08773142409574297]}, "mutation_prompt": null}
{"id": "880d3287-653c-470a-b0f2-08d429e2ed16", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.history_success_rate = []\n        self.entropy_factor = 0.1\n        self.rescale_budget = max(100, budget // 20)\n\n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.5 + 0.5 * recent_success\n            self.entropy_factor = 0.05 + 0.1 * recent_success\n\n    def quantum_mutation(self, individual):\n        q_mutation = self.entropy_factor * (np.random.rand(self.dim) - 0.5)\n        candidate = np.clip(individual + q_mutation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 20 == 0 and self.population_size > 5:\n            self.population_size = max(5, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.quantum_mutation(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Parameters and Entropy-Based Mutation Strategy for Enhanced Convergence.", "configspace": "", "generation": 22, "fitness": 0.34626584268874483, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "97c124ee-b628-4edb-871d-4084beffee72", "metadata": {"aucs": [0.8390648619262291, 0.8359973126311451, 0.8406044902489457, 0.8376936404858881, 0.8404437000673681, 0.8393619167489478, 0.8391290786384471, 0.8346198128168095, 0.8282672804494275, 0.7337035215527705, 0.7411004138566204, 0.7466574221592515, 0.7426678111570464, 0.7446892121197515, 0.7402079881039639, 0.7341230786761401, 0.7460966454729712, 0.7448530792230962, 0.17066959077395127, 0.6980223218599897, 0.7014000240332948, 0.4172225304828775, 0.33482370246342275, 0.575607426638228, 0.6953243260658108, 0.2578790383546239, 0.3654171079165932, 0.17127606415922436, 0.16484433103197194, 0.16625433405034107, 0.1677863111787552, 0.16635040126284806, 0.44183833712262743, 0.41105076563650955, 0.1427120815810904, 0.1688865105706493, 0.9514372187784711, 0.9674721494835942, 0.9727017668464233, 0.9630353518442742, 0.9369208698194653, 0.9351074300596777, 0.9509746676642633, 0.9609338819889878, 0.9554879647589145, 0.39070610373516623, 0.41459338258783796, 0.3909089523643432, 0.44105308300484747, 0.37667943940273896, 0.4492607236539513, 0.3905969405857894, 0.4244490872468739, 0.39120216971049504, 0.7379313098563969, 0.34909254944962687, 0.34309887767891, 0.33233906096144494, 0.7084562383426474, 0.7239255755172687, 0.22726783678812001, 0.7284014684829281, 0.3485471794198486, 0.20124212611557468, 0.17104879953180374, 0.1819341224596036, 0.34577333130621934, 0.17951616268921355, 0.18123227965284427, 0.18458073442774425, 0.21510697317527727, 0.19428821138083718, 0.17219677640931608, 0.16699531260145906, 0.18185213181298432, 0.16512710847244072, 0.16293716513853673, 0.248631319971796, 0.16829404012342764, 0.1781698687493768, 0.1981352921589572, 0.12586956288447348, 0.014731476968675605, 0.0035949987138992334, 0.09272924569156205, 0.007618597872680266, 0.04207423755485595, 0.06182437557504494, 0.009435929607369165, 0.1140254605853348, 0.12424546156731353, 0.0858928870219301, 0.1501523926974363, 0.1011597576069837, 0.15332326008468244, 0.03521815198820366, 0.1350494028361583, 0.21816572769577924, 0.1347484285846654, 0.1573371721897946, 0.07340320673549572, 0.12104794965991883, 0.06829727942443353, 0.09610093577761458, 0.10841550754735385, 0.18841854899184673, 0.03511248655898236, 0.1651735872071447, 0.15226279349438698, 0.2681356274258446, 0.20138751768832075, 0.1800013064652698, 0.17797478179940351, 0.2741213013239433, 0.2504284208363948, 0.18357767337613207, 0.20618155710186614, 0.558340572655414, 0.5330044788822506, 0.5115729798700772, 0.5547851545477303, 0.5255486812697663, 0.4882589243529243, 0.5413533447668677, 0.5184200886216979, 0.538538614583898, 0.11164498919070487, 0.15267112905739688, 0.14662848377277693, 0.14021227963785365, 0.137753368151197, 0.15398399081184522, 0.10613760359764635, 0.15230892544108698, 0.12083181741074, 0.22228495750663735, 0.29238320919159955, 0.17509531848863302, 0.22477988370071256, 0.24515181732990265, 0.1583392853919693, 0.20948630102003807, 0.17718142417749916, 0.21411633019079035, 0.3949714958072522, 0.3701499165842437, 0.40559762021360035, 0.41312813677655835, 0.3416454267774498, 0.40073948417512606, 0.49752145189185326, 0.41710580159658905, 0.412238719601821, 0.2631383939760672, 0.27649769634234067, 0.24120978875826626, 0.252543858549629, 0.2804960107111387, 0.28977938644396295, 0.25333872814800906, 0.29247686081294944, 0.2702091963299885, 0.21215014320248982, 0.2323732873763661, 0.21032360799362426, 0.1878274313913174, 0.19768749369537353, 0.195453867602561, 0.21784048325482186, 0.20565183762895156, 0.21231210252872834, 0.3292544557583561, 0.23459050202800946, 0.3862538377655548, 0.34184517800556713, 0.3895999478346788, 0.2294183246186663, 0.4731549762366831, 0.4207010868631029, 0.23878026804117536, 0.6898927152844159, 0.701601835797488, 0.6985421170037205, 0.743372832482788, 0.41928005155862924, 0.7534427513734828, 0.7427780085301929, 0.20132315493597086, 0.17687781332229968, 0.5449443033013575, 0.19968298812486707, 0.31302096160585247, 0.20233645528959454, 0.18779335060236002, 0.19791136389596609, 0.49359810138494276, 0.532685625084716, 0.202341392520755, 0.20143993997157483, 0.20978968637733164, 0.20305930557541318, 0.2024838931710009, 0.20385025383171473, 0.19237252496100787, 0.20193338036261788, 0.2027263425659951, 0.2136860270230707, 0.09070085763630309, 0.09548718723159233, 0.09545812266817244, 0.10243790762164973, 0.09844856167711591, 0.08657283831444584, 0.09403864285483177, 0.10406215586046297, 0.09110129515311471]}, "mutation_prompt": null}
{"id": "70d9c8dc-6eb7-4b20-95ad-82513caea91d", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.75\n        self.history_success_rate = []\n        self.rescale_budget = max(150, budget // 15)\n        \n    def adapt_parameters(self):\n        if len(self.history_success_rate) >= 5:\n            recent_success = np.mean(self.history_success_rate[-5:])\n            self.mutation_factor = 0.6 + 0.3 * recent_success  # Adjust mutation factor range\n            self.crossover_prob = 0.3 + 0.7 * recent_success  # Adjust crossover probability range\n\n    def hybrid_local_search(self, best_individual):\n        step_size = 0.04 + 0.12 * np.random.rand() * np.random.choice([1, -1], p=[0.35, 0.65])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_resizing(self, generation):\n        if generation % 10 == 0 and self.population_size > 7:  # More frequent resizing\n            self.population_size = max(7, int(0.9 * self.population_size))  # Slightly less aggressive reduction\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_resizing(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.history_success_rate.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.history_success_rate.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            local_candidate = self.hybrid_local_search(population[best_idx])\n            local_fitness = func(local_candidate)\n            budget_used += 1\n\n            if local_fitness < fitness[best_idx]:\n                population[best_idx] = local_candidate\n                fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticAdaptiveStochasticDE", "description": "Probabilistic Adaptive Stochastic Differential Evolution with Dynamic Parameter Adjustments and Population Management", "configspace": "", "generation": 23, "fitness": 0.3352423046509375, "feedback": "The algorithm ProbabilisticAdaptiveStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "97c124ee-b628-4edb-871d-4084beffee72", "metadata": {"aucs": [0.7861581006108873, 0.7609668026282589, 0.7855899598843492, 0.7775772953931073, 0.7780197069928495, 0.7805698914689364, 0.7714038993392744, 0.7754047246466885, 0.7823154468815015, 0.6479086638867952, 0.6448240211089641, 0.6432130207489777, 0.6399208769150566, 0.6396115367200221, 0.6497818447853785, 0.649870203727962, 0.6556827047029181, 0.6566275926265771, 0.6021779971224602, 0.6198774834498406, 0.6189070823422743, 0.6287000401438092, 0.5999170720916116, 0.5982884448697661, 0.5724309495576969, 0.5922962739051114, 0.6291066381312935, 0.5925770731368303, 0.5881039512946121, 0.5772265061790184, 0.5939096805528098, 0.577147149156836, 0.15949903311733304, 0.5804032005993749, 0.3729542299063573, 0.544935372928861, 0.9458511568443357, 0.9363123457342286, 0.9602783359458593, 0.9550208588379673, 0.9434739956658915, 0.955481391792381, 0.9419102826241542, 0.9569431695037468, 0.9660929942980946, 0.4076599080093104, 0.538042204381066, 0.3555532582857913, 0.520846966038347, 0.5027581276816795, 0.4787946602729105, 0.4368307262313499, 0.403189951701456, 0.3920492510909952, 0.52224871904391, 0.4025556274991289, 0.41397180729652683, 0.6135446919129615, 0.26840898226189436, 0.2749289965292584, 0.25569414608677987, 0.3296861409217954, 0.29194371934501373, 0.17069930710471104, 0.26817321769258573, 0.2071757447446565, 0.15736669137459536, 0.2058415921819572, 0.1817312631452479, 0.18681776617325174, 0.18978312092494787, 0.29220270262824233, 0.15565682179830997, 0.12601681018329725, 0.1393870763545617, 0.16481528773629583, 0.1833074815711343, 0.1571426824007145, 0.1339688148982484, 0.15835396555468473, 0.3141917200333395, 0.01708739506255097, 9.999999999998899e-05, 0.0003598798833051031, 9.999999999998899e-05, 0.048213765031432376, 0.06602352382816457, 0.010941837185172165, 9.999999999998899e-05, 9.999999999998899e-05, 0.0719143566878423, 0.06801800571120653, 0.05314681503200169, 0.05808981567895011, 0.09992190677545709, 0.05474267252424381, 0.12629992272337653, 0.07024288160914205, 0.07512058261195509, 0.05593575775218418, 0.10303551226288632, 0.07938906295640369, 0.06266779326172112, 0.04995954494201815, 0.07009328487240851, 0.08344516053311946, 0.08307416209523089, 0.07966092931741464, 0.12698050434449815, 0.15138667874281841, 0.1496160283453879, 0.13736626287318354, 0.16988693872281746, 0.16354110570376945, 0.1629058946515337, 0.1273680352975094, 0.15274990923609144, 0.5198125209882132, 0.4753860743433914, 0.49698100334004813, 0.4582923003226299, 0.46902349776273355, 0.4496179416443703, 0.49700794271670723, 0.49830973359637487, 0.492484257245572, 0.1388261669698715, 0.10527005209200246, 0.10082945876005855, 0.12852939785566742, 0.10144443860960073, 0.11279891444338153, 0.1323421509885102, 0.09991023047933634, 0.11597032128882123, 0.23217645060731973, 0.18241283991313673, 0.18536328619255005, 0.17097578200517838, 0.2398099060097646, 0.21846979417782808, 0.17566163403811075, 0.24411859798025415, 0.211761840030124, 0.2597029046218219, 0.3222267196352744, 0.3008660309976877, 0.30940395509966545, 0.25361990300683024, 0.34235675015414413, 0.38793892904971117, 0.4007928788196067, 0.3955139732630413, 0.21050156649943097, 0.2299955030664157, 0.1806862014364602, 0.17749494743157324, 0.17369073383243394, 0.1926327891948879, 0.20910480969146805, 0.2193887956092756, 0.20562659901853053, 0.21067581733507235, 0.1981646575611663, 0.2025906205212351, 0.21739659152420965, 0.2088171898379374, 0.22128687451272844, 0.2004688451297636, 0.20196703320949105, 0.20482336001483714, 0.6056282209127404, 0.23680736870537633, 0.389775431558821, 0.5189361415638937, 0.40594046866273215, 0.5227830821314501, 0.4880029837862576, 0.5244813851098306, 0.3850084909265469, 0.47947993591487725, 0.21360449837205564, 0.5581248366207383, 0.6505879691571463, 0.18672187152915742, 0.6112238092097256, 0.5604592922486802, 0.5623882278542229, 0.16913932330368897, 0.22361579617177507, 0.380920917858229, 0.3318240532306562, 0.2031035669566621, 0.3377046969803891, 0.1876664876838844, 0.4472129483773357, 0.25881568263917165, 0.38332207410267616, 0.20191167310368552, 0.21043498776460556, 0.19460127289676177, 0.2019060704720419, 0.20608484518589476, 0.20365552298008693, 0.20894894074657155, 0.1973873108382307, 0.2138771847144224, 0.08296408200861494, 0.09673199493946649, 0.08831005867937913, 0.09683001048797102, 0.08899533574094531, 0.08012019967757222, 0.09057721433142907, 0.08144766363677225, 0.08675748020525664]}, "mutation_prompt": null}
{"id": "11e92252-38a0-4647-9dcb-76d8b996a254", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.7\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.5 + 0.4 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.02 + 0.08 * np.random.rand() * np.random.choice([1, -1], p=[0.4, 0.6])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 7:\n            self.population_size = max(7, int(0.9 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedMultiStrategyDE", "description": "Enhanced Multi-Strategy Differential Evolution with Adaptive Mutation and Step-Sizing for Improved Convergence.", "configspace": "", "generation": 24, "fitness": 0.36255197108695064, "feedback": "The algorithm EnhancedMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "97c124ee-b628-4edb-871d-4084beffee72", "metadata": {"aucs": [0.8238537887688258, 0.8216019680281568, 0.8284989492703256, 0.8285470039639075, 0.8277244301116793, 0.8300737815017081, 0.8279907408968109, 0.8183085127120668, 0.8223301044332649, 0.7300806478368236, 0.7226427202025991, 0.7298106474858143, 0.7244521373347528, 0.7261671096806743, 0.7131231161631066, 0.7279555733675771, 0.7335258048047063, 0.7343187878462464, 0.6798777101789435, 0.6843555290911021, 0.6699286112056531, 0.6753507194843571, 0.6796554105411534, 0.45470754861164375, 0.6802715559297875, 0.5539395145751858, 0.657689739641881, 0.16557951250625902, 0.166542921876087, 0.4171040508211432, 0.16762822101353503, 0.5590635897630961, 0.16949320453737604, 0.5950001857838052, 0.5221317424212633, 0.32941705274994315, 0.9185422783861503, 0.9732997388627295, 0.9307609666131702, 0.9510395874786371, 0.9389970966345198, 0.9589337228168463, 0.9167944013229218, 0.9365087518605498, 0.9554102591499377, 0.37051041380402006, 0.39455615541850697, 0.43640376288681504, 0.49383013952742927, 0.4586682962714467, 0.5005721232156041, 0.40745548404266196, 0.4647676134101386, 0.4513421680848819, 0.5565097749562863, 0.7302085857943745, 0.7194014541192612, 0.678058816567831, 0.7417470365886131, 0.6749524295406923, 0.22541203693957856, 0.3522314191146533, 0.34263606062230434, 0.2400982074011222, 0.1834084097544859, 0.18810887616532468, 0.19181074795294406, 0.19730419220379414, 0.18802980995376928, 0.19603570469348974, 0.18814318633555038, 0.16806706245606673, 0.14578262030919964, 0.1656067261888351, 0.1714863819462782, 0.14999757787621615, 0.18522357208154216, 0.19698526741386224, 0.18029920056824777, 0.1777420221065944, 0.16281106010082658, 0.1019190806267447, 9.999999999998899e-05, 0.10287097073877682, 0.01986186284931646, 0.0012800651013962216, 0.017953546238516194, 0.04323045365615541, 0.0948281679589642, 0.09305085278551828, 0.09345532430709969, 0.08048258413230436, 0.11832302040569487, 0.18224898217905172, 0.12999837457602914, 0.0782414540288997, 0.22265149849656773, 0.08410594999309706, 0.09114203628108952, 0.14409296532146854, 0.09818785247216855, 0.09851729458331249, 0.17636301351278783, 0.1547044216669956, 0.07536476446540363, 0.10782402005884817, 0.16560809956475442, 0.12694556797664047, 0.206119295292005, 0.23905530292158805, 0.1951605522533043, 0.2635822552398166, 0.20844899658399885, 0.21804212025910574, 0.19334962821299995, 0.21857866997855135, 0.23936116183125788, 0.5873831620295038, 0.48751160304406793, 0.5847005269735459, 0.5507875237552573, 0.621617673825989, 0.6231641822027446, 0.5297540057038954, 0.5672339081396551, 0.5620238183359787, 0.11598092014522643, 0.12458487448184019, 0.12073315849840416, 0.1284375490827412, 0.1289981688623666, 0.11658887223266434, 0.14485284171353174, 0.10980698546172296, 0.13979712504472586, 0.1683966577646645, 0.17882345040931724, 0.20807981563301492, 0.21863680577664102, 0.16897574007834515, 0.1753589970132522, 0.17959719660908735, 0.16863886628695124, 0.20174738508731194, 0.3649454588559714, 0.5139087724709104, 0.4951643933623805, 0.5613960683727137, 0.3733387946315453, 0.3783839069897782, 0.5073689834244033, 0.4275199775904762, 0.6632526261656949, 0.26253773156881965, 0.2601948573055496, 0.3315448968187079, 0.22558948319856376, 0.27539203993945804, 0.22320788252380042, 0.251267465924105, 0.29535572765727025, 0.33231302583968036, 0.2325027627397418, 0.21129663801083431, 0.2152301316733749, 0.20687955337617836, 0.208650478797208, 0.21398147331980577, 0.2016077807465122, 0.19692468936570018, 0.2127104432161846, 0.569668239453117, 0.5963979275275468, 0.48352507888726903, 0.4004524580799166, 0.5377828472638715, 0.47052279664392704, 0.22901841298087489, 0.634360892037283, 0.21396807666490325, 0.700970424901388, 0.5911051184285341, 0.15487908280494667, 0.7054590568888048, 0.18911301257116864, 0.2644769282418671, 0.6006144311376149, 0.25107200924256445, 0.7174592388785681, 0.2798355592234312, 0.19760100748492682, 0.1994750778792802, 0.19658877789009221, 0.3057319521513535, 0.2890877300383392, 0.20595749258551155, 0.1980805428235961, 0.6341850035354653, 0.1941350564797446, 0.2032437165913057, 0.21198131147026222, 0.20517678455158606, 0.20033826052513792, 0.21035159959851013, 0.22756499685468023, 0.2194798508200443, 0.2018120690258175, 0.07467812798290774, 0.0978413017722638, 0.09190588468318561, 0.0899725686542806, 0.09611011938571246, 0.0873879548628016, 0.09517996910030613, 0.09398049023543631, 0.0977346066331749]}, "mutation_prompt": null}
{"id": "eca1572b-8c2b-4b96-a312-3dffa8cbdf17", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.6\n        self.success_rate_history = []\n        self.rescale_interval = max(80, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.4 + 0.5 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.01 + 0.07 * np.random.rand() * np.random.choice([1, -1], p=[0.5, 0.5])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 10:\n            self.population_size = max(10, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Elite Local Search and Dynamic Population Strategy.", "configspace": "", "generation": 25, "fitness": 0.36990087623409607, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "11e92252-38a0-4647-9dcb-76d8b996a254", "metadata": {"aucs": [0.8629136326291073, 0.8675851747888046, 0.8638623664659273, 0.8645485999987834, 0.8649751169941234, 0.8727596007372616, 0.8682187355494919, 0.8619867717797071, 0.8622619675515995, 0.7989979647430894, 0.7986331770850925, 0.7915824057612001, 0.7934886510536503, 0.7889040025263965, 0.7963957458166144, 0.8053680588994645, 0.7994650997322353, 0.7917101656874821, 0.7561186236085542, 0.7477143561653785, 0.7655281388580185, 0.7573200055199439, 0.7590132787089915, 0.7645448279694007, 0.7612715725311934, 0.7588031915333481, 0.7518267124752579, 0.1488574116174245, 0.7375096755851187, 0.17300916864836113, 0.17469892371181905, 0.17367009828100965, 0.6532260264064338, 0.15151862790588344, 0.7295765537946675, 0.1720961206051106, 0.9523666580559377, 0.9630888295159363, 0.946806176944485, 0.9350920031888879, 0.9504722936970538, 0.9471436742688476, 0.9488621287447088, 0.953176930305242, 0.9527162973671295, 0.7243035526250344, 0.5189338711755868, 0.6709632318235441, 0.5564686264022609, 0.4662346778428621, 0.6114145085374127, 0.6309800668701449, 0.565994336443747, 0.6191592705399861, 0.6338021555322749, 0.3307640364569481, 0.3283887463953047, 0.6013357918334736, 0.2144045128047285, 0.570701386788994, 0.7560168798977982, 0.7848378811367234, 0.75003119760896, 0.2046156717249097, 0.3635311651940618, 0.21686437475134523, 0.1228153373507912, 0.18650719095413903, 0.11911839220038656, 0.2041577750806386, 0.179297438820886, 0.30689598732924994, 0.17664256113853627, 0.19082749598492632, 0.26302933519417593, 0.1897041230618356, 0.18974612325654994, 0.16609252786296236, 0.1756301506209922, 0.17880860440131907, 0.177134987506817, 0.06274097352803487, 0.05372129522162927, 0.006812207706412998, 0.05096371808340938, 0.017717150619165456, 0.024946627205958638, 0.015876264146183705, 0.015390149561447797, 0.008329809190292359, 0.10826984159702857, 0.09647208834498766, 0.10884180621456963, 0.06538926549344126, 0.06406235380496239, 0.04928730356509636, 0.2094931403188146, 0.16555229284609818, 0.11720732602623829, 0.06311560243425518, 0.06188204417941057, 0.08541669020233444, 0.06457748397604846, 0.08191603985342955, 0.04337391606228025, 0.08861093716255086, 0.062303481564036756, 0.04170587413001725, 0.1797310246205931, 0.18420951540708097, 0.15602654920514247, 0.24534283853569272, 0.2477859703686811, 0.20573730957692038, 0.1557415019133357, 0.16554435551274527, 0.15948521190484077, 0.5358531092383043, 0.6167610469576237, 0.5954235832116097, 0.5680020095254168, 0.5183560630953918, 0.5574428484606543, 0.537863921544646, 0.572727018747343, 0.5508788840591645, 0.1256913335193256, 0.13241831411331728, 0.12666962196235743, 0.1148107765244969, 0.14339073722499196, 0.14491720059402147, 0.20649847026660062, 0.14615701226058986, 0.14253142369778093, 0.1690232112367649, 0.19606284049260714, 0.2323029396438464, 0.16234745660612226, 0.1552076912491801, 0.17656569419717194, 0.17294454068194265, 0.18121915396974353, 0.2540441097959951, 0.3125002153209091, 0.3294660514487139, 0.37231093502716217, 0.41274865732990407, 0.35321388767389483, 0.42487896253816904, 0.5319437706250826, 0.6345224045776519, 0.4558668907959962, 0.2429636916849659, 0.249365645520079, 0.2939509591077759, 0.2380247870804908, 0.2489341296995441, 0.2043099492317012, 0.3270147848568974, 0.28632574659922283, 0.2897087373780146, 0.19592903295607533, 0.20591028895461472, 0.2183486459860725, 0.22766748891976496, 0.2034521217979891, 0.22783917385481567, 0.20709155745678054, 0.2128454982541823, 0.19752509038016708, 0.6798959988573293, 0.6603740396280227, 0.6116959411716487, 0.2399336096104665, 0.23221587951700706, 0.6939387415886544, 0.5762665582688612, 0.6958251971078002, 0.40324905351443663, 0.1866922672405964, 0.19171157979207087, 0.7019900986948004, 0.6072904532462047, 0.19027339503102858, 0.17547638158370715, 0.17261042761235457, 0.48638604024451904, 0.15807558292907342, 0.5402407877785529, 0.19885611412229065, 0.39174153786626276, 0.19754239947173546, 0.16350465504013845, 0.19667985077140193, 0.20369276432361305, 0.45899531471746935, 0.20406403507671944, 0.19231715363361468, 0.20836106332173154, 0.19412964488979867, 0.1923745825751606, 0.20218246119440675, 0.20078567616500287, 0.19267637829306772, 0.18917237156617317, 0.22046040959742885, 0.08709569287549968, 0.07888440016158127, 0.10199190698833716, 0.09755813247969658, 0.10223179057679099, 0.09228211497976901, 0.08829556125937199, 0.08491200538301202, 0.0934696208362571]}, "mutation_prompt": null}
{"id": "583b0cc4-fde5-4c96-b6ee-043156cbe87a", "solution": "import numpy as np\n\nclass AdaptiveReinforcedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.7\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.6 + 0.3 * recent_success\n            self.crossover_prob = 0.5 + 0.4 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.02 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveReinforcedDE", "description": "Adaptive Differential Evolution with Reinforced Exploration and Stochastic Local Refinement.", "configspace": "", "generation": 26, "fitness": 0.381973918285547, "feedback": "The algorithm AdaptiveReinforcedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "eca1572b-8c2b-4b96-a312-3dffa8cbdf17", "metadata": {"aucs": [0.8670893874980088, 0.8746952250009601, 0.8782925071579823, 0.8847158994256534, 0.8859451886687467, 0.8828526645334875, 0.8757148121449922, 0.8761143404326663, 0.8763970056656796, 0.8067320005529512, 0.8003847214252165, 0.7990535165793682, 0.7837382398828655, 0.8073457747581173, 0.8003833309635173, 0.7997819073721347, 0.7919773110530755, 0.805054397918362, 0.713891147314857, 0.7416458046384191, 0.17833820842293457, 0.7270231676932545, 0.18135580850118316, 0.6905750442739569, 0.7402871629532038, 0.7388446771160545, 0.7299446192372396, 0.6787702862494086, 0.6710435101829981, 0.17484652807209278, 0.6886761402255326, 0.6363332135700266, 0.6970815307151255, 0.17729635753559925, 0.6776139738970046, 0.14724863327861482, 0.9629568253928353, 0.9457007660720415, 0.9654513048201917, 0.9666982536684728, 0.9791161572759792, 0.9699074429245097, 0.9748904104506926, 0.9675009671816774, 0.9707047288297209, 0.6314754863452958, 0.6666960407350344, 0.6599508119777686, 0.6491628816980877, 0.6671946525275203, 0.6363260922757481, 0.6243713327442275, 0.6138535969756795, 0.5938609301342107, 0.3591513499405753, 0.6757464165487719, 0.610403108021955, 0.5513384669867818, 0.2083735582467643, 0.7031372174766868, 0.61766904496807, 0.6386329251511034, 0.6978930079981247, 0.3687372090140417, 0.22324844341412042, 0.2141409287535957, 0.19610497635494195, 0.1839504027346528, 0.18948318254802476, 0.20732680646220003, 0.3121364084995414, 0.23668177125772238, 0.18888187331604078, 0.13181110652731443, 0.1721287136829871, 0.18558593718116823, 0.2163318844303972, 0.2471136494136622, 0.17620176133782262, 0.24989998890480658, 0.2432849968680615, 0.05934803311609371, 0.0618728828603593, 0.02800115974535078, 0.04043246909184239, 0.031261362713297935, 0.03049943235759378, 0.021584065210487835, 0.057691877453385665, 0.0637810344779085, 0.09571725027925226, 0.09720311195131415, 0.15346026896942966, 0.14182429902805704, 0.12465200733006054, 0.07871688080880324, 0.1965121272086675, 0.15287154575076944, 0.20500303116764318, 0.07715892410711023, 0.10012727443014247, 0.034054570848177756, 0.059392599423605086, 0.058216317650855, 0.03437303526811997, 0.053177457098437464, 0.15548355706538786, 0.11163510737865945, 0.19237166314564935, 0.18441759228295151, 0.18897633931313995, 0.22455019194494008, 0.2216692665941533, 0.2173823754111891, 0.20660853436815874, 0.19479356254187363, 0.2072253948534366, 0.5899061523735517, 0.5897998633546986, 0.584735195779744, 0.5553147759655678, 0.5624370829716213, 0.607184583718249, 0.6051822730990317, 0.5547891043074636, 0.5791184421069597, 0.13484208025868316, 0.1165125642324758, 0.13570442962720153, 0.21275912408060882, 0.11636016685809025, 0.14230560355209565, 0.11738040347415679, 0.13390372593006172, 0.12031798304638797, 0.15257414470338304, 0.18367952494909023, 0.21242116318469273, 0.17407739329845207, 0.1850440410414229, 0.1714482614615478, 0.19689233775869697, 0.2055821265881259, 0.1654132108527545, 0.36964125666308123, 0.3843411689025452, 0.4176515842322662, 0.4091297570319823, 0.36267866436985285, 0.360027657429445, 0.5030365185735182, 0.536672099451391, 0.4430995245873186, 0.28137679210302535, 0.2609531916058031, 0.21698006455974383, 0.2152067198867429, 0.23260928732042174, 0.24785906245768896, 0.3142273946466678, 0.30175289875570455, 0.27867184318195715, 0.1769721868251367, 0.21209002628521634, 0.23179183461252928, 0.224357589438115, 0.19307412744101238, 0.18485250715894663, 0.2035008780586982, 0.19352496251567552, 0.19598137452571351, 0.49984063406526524, 0.5144749925722092, 0.6194776638056527, 0.25231505489866635, 0.5684586968752656, 0.6439852912456595, 0.5929150565681671, 0.22960770908854833, 0.2421350282365251, 0.16636787357185312, 0.1787370481447027, 0.17381245372771081, 0.8091660184729158, 0.19256188233077498, 0.6074752399072061, 0.670114107426025, 0.49225503860529296, 0.1710594064339953, 0.1654042068925059, 0.5925666583808145, 0.674835816736873, 0.1954478093002311, 0.6199554526095545, 0.20320117124221837, 0.6622251811941178, 0.2097269185362537, 0.20799825373687086, 0.1861641106704537, 0.20560671962765387, 0.20550734390773207, 0.18916847769622414, 0.18545913863514374, 0.1918934756499725, 0.20261421227756615, 0.19445674290085257, 0.20684134692713696, 0.09680742073193194, 0.09387109830421936, 0.09760353064982641, 0.1028571107515519, 0.08667285006833758, 0.08877339059838218, 0.08755635169645992, 0.08399771082708163, 0.08630345572950904]}, "mutation_prompt": null}
{"id": "4944ff87-502c-4d8b-9895-f2b6d87e92cb", "solution": "import numpy as np\n\nclass ProbabilisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = max(50, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.4 + 0.5 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.03 + 0.04 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.normal(0, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticDifferentialEvolution", "description": "Probabilistic Differential Evolution with Enhanced Adaptive Rescaling and Strategic Local Exploration.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "583b0cc4-fde5-4c96-b6ee-043156cbe87a", "metadata": {}, "mutation_prompt": null}
{"id": "e1b3cd80-e3ce-417c-ad53-9e0f360721a8", "solution": "import numpy as np\n\nclass MultiStageAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.6\n        self.success_rate_history = []\n        self.rescale_interval = max(150, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.4 + 0.5 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.01 + 0.06 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 10:\n            self.population_size = max(10, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MultiStageAdaptiveDE", "description": "Multi-Stage Adaptive Differential Evolution with Dynamic Local Search and Feedback-Controlled Parameters.", "configspace": "", "generation": 28, "fitness": 0.3605428709690602, "feedback": "The algorithm MultiStageAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "583b0cc4-fde5-4c96-b6ee-043156cbe87a", "metadata": {"aucs": [0.8660017115580138, 0.8557694222898418, 0.8690029702486591, 0.8625571362446015, 0.8644869911242978, 0.865288653848, 0.864764478165845, 0.8642124264862183, 0.8636493812461774, 0.7959279927343765, 0.8028518742096402, 0.8014002147201993, 0.790335323617311, 0.7916354761028527, 0.797229399500586, 0.8025058751762699, 0.8015567665194605, 0.8053589975389916, 0.7346751968184162, 0.7435431000988122, 0.7581123877258539, 0.17502274331459344, 0.17302391816819795, 0.7277383279879839, 0.17614982899620535, 0.7555032025103672, 0.7719694365549975, 0.17068264023346313, 0.7290326132704419, 0.17319439338213782, 0.17495258797233804, 0.14922064799060375, 0.17472533297230852, 0.74840870302991, 0.14854921838674162, 0.12398063638192014, 0.9459242743342653, 0.9631731332607802, 0.9533196987673347, 0.9200178528343829, 0.9506236596059797, 0.9576610099217255, 0.9576429822947177, 0.9525415185786527, 0.9547935535687028, 0.4671199409824097, 0.6294609176059494, 0.6454741656877256, 0.5818997842179199, 0.658791253995932, 0.38904725355902203, 0.6312862835320008, 0.6107162765011807, 0.4482133309253472, 0.5487654987051227, 0.5810574819444334, 0.622467418777864, 0.4367715093979354, 0.5325438138296952, 0.6377499020675581, 0.702746523483427, 0.7260454519033839, 0.6915554161627548, 0.19790517004826047, 0.17966300390037448, 0.1590198995325074, 0.2600217122393702, 0.11840094665150769, 0.2953365694878086, 0.1883723222462944, 0.35406142570954713, 0.23278579268249466, 0.3171664383964926, 0.16722066910584632, 0.16369345693628, 0.17563785126423703, 0.17276860101193836, 0.27402491399793305, 0.19092334464680494, 0.19515970876436395, 0.18729267778926229, 0.03242614414449796, 0.02824649903035803, 0.026938543599734244, 0.07277322333933056, 0.05939536337549545, 0.054603715505646466, 0.032880939232081574, 0.03816993342613495, 0.0013651220604080638, 0.12386331171025744, 0.12321098278290588, 0.09848553839432939, 0.07193933168927902, 0.07529802854424361, 0.10154104320834123, 0.153579921578625, 0.11668281286295445, 0.10538293372261343, 0.06919807410953749, 0.06814074319155938, 0.10419794566637264, 0.06805164026564181, 0.0851881220347035, 0.08738204344728007, 0.08268701289040559, 0.06930339459665169, 0.15330862028190573, 0.1819332119956404, 0.1615649316499197, 0.16430406706579237, 0.24621744105124677, 0.22680753854330193, 0.23993705443358726, 0.1356734019441621, 0.1644231263494903, 0.1722178741985897, 0.5352568925000067, 0.5743291073381616, 0.5812385753846768, 0.6178144208653074, 0.5838518006976601, 0.5372404121342724, 0.5519828875496762, 0.5825086178300088, 0.5329757379725408, 0.12811553225329897, 0.14700174496343643, 0.10900756159891667, 0.10849348996478803, 0.1350795459125509, 0.13262784708301767, 0.13440886909193883, 0.13203661499795982, 0.2643098449146515, 0.1702039206427105, 0.15351379022659295, 0.16070791287320885, 0.21812594611656855, 0.23991948076874092, 0.1827472999752756, 0.23269000320185718, 0.15872820405063826, 0.17050329802003905, 0.4433511970933779, 0.3403961002151893, 0.4121356096690426, 0.345626665126162, 0.4435574763210468, 0.45775411324071447, 0.6255191498993895, 0.6176778432742454, 0.6009681746044856, 0.25765849730490265, 0.2111337968289153, 0.23411724561783842, 0.23612687532130816, 0.21095534354750212, 0.2366519639448892, 0.3309214155876079, 0.28135853491709284, 0.23700343333103668, 0.24677842325268184, 0.22881741130894384, 0.18689387484313535, 0.2631902005283768, 0.25836232792948444, 0.2149279084894663, 0.2962598762403976, 0.189196643624154, 0.24008426353308843, 0.23841124935532654, 0.21938923264239685, 0.23759890663961847, 0.6406063288314665, 0.5912748640650516, 0.5613979246274284, 0.23792453151463955, 0.2139499060350738, 0.6511148739065895, 0.1836331829061617, 0.19007180618333164, 0.4690279478609951, 0.7414094644839639, 0.28604118008153456, 0.19696168421290672, 0.4848907831487417, 0.38266361945460003, 0.1827933909572248, 0.3666001046596844, 0.2048863984133703, 0.5524665625318896, 0.19511297516789416, 0.20141859186222688, 0.19688624551239686, 0.20463513543100864, 0.22694659458539101, 0.38276884569883096, 0.20235824060884355, 0.18884410545120922, 0.2189419199854905, 0.18721118728014485, 0.2006150091892036, 0.19933328463834354, 0.21028569753342619, 0.20766734796335884, 0.20225165013049828, 0.09106651208029648, 0.09547828151254012, 0.08782664327725886, 0.08857630995185117, 0.08541828885068592, 0.08478616042294074, 0.09035661990340849, 0.0897852976632636, 0.08552746767431274]}, "mutation_prompt": null}
{"id": "c03853ce-27da-4cb4-a0eb-e8b3dc1e9b6f", "solution": "import numpy as np\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.6\n        self.success_rate_history = []\n        self.adaptation_interval = max(80, budget // 8)\n    \n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 6:\n            recent_success = np.mean(self.success_rate_history[-6:])\n            self.mutation_factor = 0.65 + 0.35 * recent_success\n            self.crossover_prob = 0.55 + 0.35 * recent_success\n    \n    def quantum_local_search(self, best_individual):\n        quantum_step = 0.03 + 0.04 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.normal(0, quantum_step, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 12 == 0 and self.population_size > 12:\n            self.population_size = max(12, int(0.75 * self.population_size))\n    \n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n                \n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                local_candidate = self.quantum_local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridQuantumDE", "description": "Hybridized Differential Evolution with Dynamic Parameter Adaptation and Quantum-inspired Local Search.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "583b0cc4-fde5-4c96-b6ee-043156cbe87a", "metadata": {}, "mutation_prompt": null}
{"id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "solution": "import numpy as np\n\nclass EnhancedReinforcedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = max(150, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.3 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.03 + 0.04 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.65 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedReinforcedDE", "description": "Enhanced Adaptive Differential Evolution leveraging Dynamic Local Search and Adaptive Parameter Tuning to balance exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.3977431242705483, "feedback": "The algorithm EnhancedReinforcedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "583b0cc4-fde5-4c96-b6ee-043156cbe87a", "metadata": {"aucs": [0.8692841248967936, 0.8599452050742991, 0.8593192793917663, 0.8702407706646554, 0.8635107341268613, 0.8750990349257296, 0.8654868166060057, 0.8724104545671653, 0.8721080051584492, 0.7761875522042645, 0.7743836921330541, 0.7818309452111133, 0.7741828032018478, 0.7704064963031758, 0.7842198704019177, 0.7641932463559749, 0.7790268179770579, 0.7818874741538747, 0.1732543243862501, 0.6116998771082128, 0.6275612295435713, 0.6366992577902326, 0.6168271636683473, 0.5898183770121208, 0.17613072767513327, 0.6764076723915394, 0.6261450674186029, 0.16482900937672018, 0.16736833191495204, 0.1703884451853781, 0.46136832311726816, 0.1676705425322128, 0.5170427554525199, 0.17560594156578413, 0.16945328256933223, 0.15082111945539256, 0.9725647133092026, 0.9494383531761053, 0.9519023128967494, 0.9576425400813176, 0.9643697490568018, 0.9451398787286631, 0.9571397780656652, 0.9746076492439759, 0.9634278966770617, 0.6036129737122202, 0.6194668518698905, 0.6655472531074332, 0.6462845005168113, 0.6551826839969117, 0.6455622993777659, 0.6509764992188878, 0.6630406392552437, 0.5660099400971573, 0.8063254413840317, 0.7822577513307681, 0.7031783107673023, 0.7608474990418931, 0.7062266139669718, 0.7871932587421455, 0.777688830049609, 0.7983105953090284, 0.7188613322798083, 0.24280992360603237, 0.4062167182232429, 0.19489909420950813, 0.20847747551114604, 0.2130711846740604, 0.22144870268856431, 0.2512248064686795, 0.2335070890074824, 0.22142681348224857, 0.17073647543714943, 0.23251877859539738, 0.21296592747562149, 0.22927074252555857, 0.18153058593189209, 0.16982669144343254, 0.2297969648143089, 0.2527804393861194, 0.21591740219022015, 0.1803445205701133, 0.09935265115753589, 0.06848913749087693, 0.10404074364088867, 0.03836059480845566, 0.08015027439152256, 0.10585121319225765, 0.09787283049735729, 0.1259385665726599, 0.19921395638734596, 0.07951047650275234, 0.18823540447753062, 0.18630865424951593, 0.10211333842762105, 0.20820212575803065, 0.360811074780681, 0.3071904587510145, 0.21517032061860109, 0.09277258816982681, 0.06141604149834656, 0.09616076826087006, 0.11554286683210846, 0.059222313506151814, 0.14529897187215612, 0.10040419874986295, 0.1798461279200323, 0.10966166070206762, 0.21470507833301866, 0.22490574497017213, 0.19873998556752526, 0.2676600040909093, 0.2603029009473006, 0.28437574885760786, 0.23371892187032328, 0.2091502301219491, 0.22944832886122113, 0.6259775361678023, 0.5988615155056021, 0.6275296451888996, 0.6102488998171941, 0.6267464087681262, 0.6134470835323262, 0.5842397767478082, 0.5825998098206406, 0.6368249509748951, 0.13462056693281843, 0.12760584403978792, 0.11807888444157344, 0.13030752619467367, 0.10520821522525114, 0.14153761459380587, 0.1425636774466531, 0.1336034136576172, 0.13311588427863497, 0.21852343172841215, 0.16814780090126646, 0.19013198580098456, 0.16834128699541684, 0.16178075667414704, 0.16210343556613394, 0.1524938531420157, 0.14745802731162616, 0.28622907813271337, 0.5160180082286872, 0.4678294149790746, 0.46450873822675776, 0.4515750575288906, 0.4551525111503598, 0.4604553308298518, 0.5718400284119015, 0.5716484937787407, 0.5984834035224988, 0.2739303574660831, 0.314804539764851, 0.2803936795917096, 0.26102084972393036, 0.23182704794076792, 0.27291293239372505, 0.3250709007333771, 0.3566670939196408, 0.3748051408442491, 0.2129839580756776, 0.19866227813247062, 0.18095933022692534, 0.21151620289554374, 0.22539082788187492, 0.2209541240895383, 0.20958865810029292, 0.19983733373280044, 0.23290558837082276, 0.22791193078437155, 0.5427547260094492, 0.6358574095877214, 0.6793178905103714, 0.20655793522393784, 0.6125251066530171, 0.5322038775024237, 0.4690029553195464, 0.5746672677627498, 0.5183703576874997, 0.6038539067992421, 0.47369402412790396, 0.566358066768623, 0.6080764963928293, 0.7672848139166111, 0.6183722998559517, 0.6696109822027089, 0.7762773435375527, 0.7004613297753413, 0.20042645317621677, 0.19822426812837313, 0.2001527121173422, 0.20205906961813658, 0.4431572855742125, 0.6411125703339302, 0.2088197351917741, 0.20856100384413678, 0.20024150532466234, 0.186157159579309, 0.18207635670060873, 0.18259030641071883, 0.21812199318790093, 0.19215077595387497, 0.20389724409155086, 0.21153529449594466, 0.17376282322413716, 0.0802354748947568, 0.09372641023772799, 0.10347363288652245, 0.09023751582453754, 0.08276297058428939, 0.09301587953866142, 0.09898637012648537, 0.09236245973499224, 0.08690455525803664]}, "mutation_prompt": null}
{"id": "e9a4e3cc-9113-4419-84f5-c68c8cb213d0", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(150, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.35 * recent_success\n\n    def iterative_greedy_mutation(self, individual):\n        step_size = 0.03 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.iterative_greedy_mutation(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Iterative Greedy Mutation and Dynamic Population Resizing for enhanced exploration-exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.37634313791865676, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {"aucs": [0.8455960003936305, 0.8317023593667041, 0.8316554812211021, 0.8385859383801217, 0.8307902314165161, 0.8347016852497458, 0.8454629752650227, 0.8323994136987307, 0.8447730319407162, 0.73030077611551, 0.7214089274521426, 0.7228712440027939, 0.732266985874683, 0.7122552577116581, 0.7474176747995473, 0.7099073814028045, 0.7481473668788832, 0.7334066892359694, 0.5617869211120441, 0.5020126535397385, 0.5404957966348636, 0.522157688422116, 0.6368962568756702, 0.5244604662940012, 0.49963322655066356, 0.44305289552116023, 0.6019689673083428, 0.43833605823875876, 0.4476341338773512, 0.38163135744890786, 0.16729105645092535, 0.48178819444523335, 0.14855397229340428, 0.4754671089019775, 0.16782671487802814, 0.16791083460557565, 0.9650264544581427, 0.960926134913099, 0.9617523903467597, 0.9537033471357316, 0.9601533970165236, 0.9249552125889361, 0.9731598004259077, 0.9527996355195906, 0.9650835965524944, 0.5991226453746106, 0.5843238915700979, 0.5648572290587986, 0.5351179798648077, 0.5332631672991028, 0.5623446110536412, 0.5756741745303323, 0.5650170274864907, 0.5476930267374206, 0.7267989605895242, 0.6342033563634113, 0.6515674311770183, 0.8024684165802286, 0.6718833382083355, 0.661254381677498, 0.7320272719145194, 0.6741309832516097, 0.7210319039946601, 0.18333928787992615, 0.17992964862200111, 0.19387896978998653, 0.19514317218631094, 0.3178991832358693, 0.17265809710375957, 0.18467395033840817, 0.20862964138412365, 0.2576267619675404, 0.1760817422474371, 0.12676553822755865, 0.1946224625840406, 0.26808310518473355, 0.28300090238193, 0.15508987120029027, 0.21770974030230883, 0.18496856962844088, 0.21075729285521438, 0.10111522829657626, 0.11036656530684918, 0.12547192364833992, 0.1114357138149622, 0.08482812570148868, 0.08426969094917003, 0.10088945734620136, 0.06763840650778163, 0.08911986857198517, 0.2065521851133688, 0.19168644785860145, 0.18166649978590999, 0.16124704368347598, 0.13123936197075614, 0.156265742173601, 0.2265165437107065, 0.22654550108755633, 0.25272119256722714, 0.05281843974663625, 0.05602964067530569, 0.05867079981595302, 0.11016455522522905, 0.08322999719034163, 0.08029531030611592, 0.07719661998919636, 0.08984932810037571, 0.06420800440885888, 0.19685497672729002, 0.19404443321555143, 0.18014624476528684, 0.2487387250549975, 0.24444525369710524, 0.2560690132326916, 0.19560003311947927, 0.21984870126238332, 0.1854337703059088, 0.561562944544734, 0.5745747708557138, 0.5813719807860519, 0.5687274669836655, 0.5834212504542561, 0.5708179657332921, 0.596466433831121, 0.5823506821974329, 0.618893007790595, 0.11991970832682108, 0.11816334788441141, 0.1232656472112682, 0.1231539043890989, 0.1381923585315793, 0.1015425339182302, 0.14796321313187732, 0.1336193968920656, 0.144143929007995, 0.14371624306623854, 0.1928403889097674, 0.14948615158510015, 0.16481395634798102, 0.16444291145333478, 0.16393133655556358, 0.15617115232806977, 0.16892812480119535, 0.20679681797496063, 0.4738695989472924, 0.4193552872716916, 0.4325577038642726, 0.4321629192750831, 0.4326248323418971, 0.3811977265031581, 0.5090237133897033, 0.503434714966276, 0.505722064483815, 0.2797204168493522, 0.27367387832311163, 0.27089376903494167, 0.2663581763896019, 0.2417033839672249, 0.24374851457246172, 0.2982583734197001, 0.3432570419948986, 0.3169616088344924, 0.22737858003486566, 0.18819412053203055, 0.19746979709616885, 0.19669997766527592, 0.1813453678895256, 0.2195409760956848, 0.2275380698159737, 0.21485590508444496, 0.2056139662898515, 0.3288860464188579, 0.355052067819444, 0.4631995054305864, 0.39480916722218895, 0.49922600021800834, 0.45298657019132393, 0.4586048368869703, 0.31842624812911013, 0.4255312824306706, 0.6032839215574324, 0.7606219440851285, 0.6086092322886656, 0.7249430529854837, 0.18325839725481252, 0.6880459114234554, 0.6094879829803096, 0.19547644636938366, 0.16156593339745973, 0.4431513675864581, 0.7522636057608436, 0.1639720380235854, 0.19963970458428326, 0.4458294679261734, 0.3013826356543533, 0.2064615510197596, 0.645153798872681, 0.20742062000177153, 0.2047616439358415, 0.20244669925530934, 0.20548302600705037, 0.20415583983873464, 0.2190616417187935, 0.20617306145069259, 0.216433779827374, 0.19819667559772247, 0.19216042692820334, 0.09313064656479675, 0.07572126115177946, 0.07949618265944969, 0.08733508033878246, 0.09529416744425256, 0.09219671600485402, 0.0886354436250747, 0.0836968401380358, 0.08904043945121298]}, "mutation_prompt": null}
{"id": "c3c8f997-74cc-42f5-99a0-80038244270c", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(120, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 7:\n            recent_success = np.mean(self.success_rate_history[-7:])\n            self.mutation_factor = 0.6 + 0.3 * recent_success\n            self.crossover_prob = 0.7 + 0.2 * recent_success\n\n    def stochastic_gradient_mutation(self, individual):\n        step_size = 0.02 + 0.03 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(individual + perturbation * np.gradient(func(individual)), self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adaptive_population_rescaling(self, generation):\n        if generation % 6 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.adaptive_population_rescaling(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.stochastic_gradient_mutation(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Stochastic Gradient-Based Mutations and Adaptive Population Rescaling to enhance convergence speed and precision.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {}, "mutation_prompt": null}
{"id": "ed75969d-e1bd-43ec-bbcf-f87a51afe1db", "solution": "import numpy as np\n\nclass HybridGeneticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.mutation_rate = 0.2\n        self.cross_probability = 0.9\n\n    def crossover(self, parent1, parent2):\n        cross_points = np.random.rand(self.dim) < self.cross_probability\n        offspring = np.where(cross_points, parent1, parent2)\n        return offspring\n\n    def mutate(self, individual):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        random_changes = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        individual = np.where(mutation_mask, random_changes, individual)\n        return np.clip(individual, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = population[np.argmin(fitness)]\n        global_best_fitness = np.min(fitness)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_const * r1 * (personal_best[i] - population[i]) +\n                                 self.social_const * r2 * (global_best - population[i]))\n                candidate = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n\n                if candidate_fitness < personal_best_fitness[i]:\n                    personal_best[i] = candidate\n                    personal_best_fitness[i] = candidate_fitness\n\n                    if candidate_fitness < global_best_fitness:\n                        global_best = candidate\n                        global_best_fitness = candidate_fitness\n\n            # Apply genetic operations\n            new_population = []\n            for _ in range(self.population_size):\n                parents = np.random.choice(self.population_size, 2, replace=False)\n                offspring = self.crossover(personal_best[parents[0]], personal_best[parents[1]])\n                offspring = self.mutate(offspring)\n                new_population.append(offspring)\n\n            population = np.array(new_population)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += self.population_size\n\n            # Update personal and global best\n            for i in range(self.population_size):\n                if fitness[i] < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness[i]\n\n                    if fitness[i] < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness[i]\n\n        return global_best, global_best_fitness", "name": "HybridGeneticPSO", "description": "Hybrid Genetic Particle Swarm Optimization (HGPSO) combines genetic operators with particle swarming to enhance exploration and convergence.", "configspace": "", "generation": 33, "fitness": 0.18201011405387554, "feedback": "The algorithm HybridGeneticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {"aucs": [0.3437231665064572, 0.34007163532902973, 0.332700618263412, 0.3695468234958099, 0.32658302456168553, 0.3365200375947116, 0.367525225519972, 0.3227637747077211, 0.3246605353861042, 0.026816306452903005, 0.04377923548382712, 9.999999999998899e-05, 0.044258045271589386, 0.05213813713072524, 9.999999999998899e-05, 0.021541582448670105, 0.046703622861122285, 0.04610316737764841, 0.18604949001696036, 0.11997416128065885, 0.1418507679771328, 0.12190959484474861, 0.12859319420889292, 0.16042064845077764, 0.12763641768299516, 0.12339751139384958, 0.1310283530927231, 0.18962312687700011, 0.11777048222014164, 0.13331097338592302, 0.11317404619137483, 0.11067244521937625, 0.107165834319906, 0.12866606402883995, 0.10172173698445863, 0.10691835700637553, 0.9855005255644148, 0.9749311286338329, 0.9855434183775867, 0.9835313776148823, 0.9836083916376326, 0.9814687538919511, 0.9835131098846102, 0.9829767378039561, 0.9828883040081866, 0.17755189402303273, 0.16364742067041538, 0.15711947237697, 0.16311542039396498, 0.14698770862434063, 0.17073020197958777, 0.15083316362511245, 0.12677533382666784, 0.11727439446021959, 0.20979073476418608, 0.18696733542947608, 0.1998605129226344, 0.23245807766551374, 0.29356503766337594, 0.17421319207571306, 0.2134009349661269, 0.16798767084595545, 0.1943458840316541, 0.10451097112253627, 0.10428300988786354, 0.08894286763575676, 0.1363472201112822, 0.08830318887192168, 0.10594385313763854, 0.07511582254472793, 0.13434598506385775, 0.10284910054447516, 0.14417046950641965, 0.10377360283395687, 0.10898076573830406, 0.10018127688018863, 0.10841755927926078, 0.12222417710184619, 0.10360854348236881, 0.10795628320232209, 0.09667935296812846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056295490968192086, 0.024464691584781262, 0.10237243638989713, 0.07688938419702596, 0.018746834566241377, 0.060176093338294545, 0.027330711013207276, 0.03479181653149621, 0.06875351211609482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04299361407498947, 0.03855256932375828, 0.04260128034833577, 0.05702541996567323, 0.08776317164921033, 0.0618048511282141, 0.057317691842461715, 0.03650552649302885, 0.06105128347351707, 0.31114532877928935, 0.2918793836956729, 0.2911839109103457, 0.30831194283877816, 0.311061446087739, 0.31391646112146177, 0.3365282041549671, 0.34082780386896583, 0.3133900378060466, 0.07090443987807682, 0.08294544332493115, 0.08224784163562349, 0.07764692987670985, 0.07949772904274721, 0.07003079511653865, 0.09099255547434426, 0.08922187974448936, 0.09125904655038952, 0.1406705604797659, 0.15948463999587748, 0.16660395483698032, 0.19994205185439473, 0.23821901139875135, 0.1428285577246594, 0.17501131539699943, 0.13912736009789917, 0.1442200635485329, 0.21209507233632752, 0.21429039996399168, 0.22610263453905532, 0.21831036604383025, 0.21056356693363976, 0.24369843364255062, 0.22259786832811201, 0.24106231008042045, 0.23788182462973695, 0.16397059656343282, 0.1588103618497373, 0.1585656139482744, 0.1589308668464411, 0.14966189683101183, 0.17101606770112443, 0.1917182937478885, 0.21444962279732505, 0.16294425860061035, 0.17883700048531537, 0.18477531354125498, 0.19186529838603605, 0.20144890347642253, 0.17829722123848146, 0.18477947598963917, 0.17011142364166643, 0.19421031953122958, 0.18468674733675183, 0.18930046688131708, 0.21570645442351122, 0.22636507059373834, 0.2189215967271576, 0.19303929652940177, 0.1889277654072563, 0.2101203723060947, 0.23384100689941423, 0.1895942166375042, 0.3712918178164907, 0.14850538923152, 0.15700246123518102, 0.4269383862780157, 0.35862414421771016, 0.2673584701701399, 0.13560748050143012, 0.15556390782405483, 0.17123968470276163, 0.3434816404038916, 0.18191531910710856, 0.3833485390143774, 0.19313570469887387, 0.1649425740083087, 0.1662525563703544, 0.2012940444580188, 0.2047088510468832, 0.18475691726128096, 0.17785004518241598, 0.20568799008648309, 0.18194251680629936, 0.1927047359007994, 0.19282914400622653, 0.1763106734407196, 0.1835819643847143, 0.1875511286968835, 0.18270680700875241, 0.06379597867023401, 0.07136867580035289, 0.06912734145902955, 0.0580917220506475, 0.06643932922863227, 0.0635657661487441, 0.07010338960532592, 0.06441718416194908, 0.059570943743025184]}, "mutation_prompt": null}
{"id": "bb446677-ab13-47d0-9606-4d5e56b01172", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.4 + 0.5 * recent_success\n            self.crossover_prob = 0.5 + 0.4 * recent_success\n\n    def stochastic_local_search(self, best_individual):\n        step_size = 0.05 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.normal(0, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def adaptive_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.adaptive_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.stochastic_local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Stochastic Local Search to enhance performance using flexible mutation strategies and adaptive population control.", "configspace": "", "generation": 34, "fitness": 0.39146220996313474, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {"aucs": [0.8750775765637641, 0.8673550934411507, 0.8853510783920245, 0.8787352684180777, 0.8814824831882561, 0.8849317403103912, 0.8675445724851112, 0.8748210702535364, 0.8706219322126924, 0.7994275038505253, 0.7859103684999611, 0.8017303949638244, 0.7766425805324518, 0.7990979784589796, 0.78884626685948, 0.7725987284416524, 0.7894123067940945, 0.7848961629324115, 0.6412199427030691, 0.7062709160856456, 0.6511767638503748, 0.6098183877754147, 0.6734616930358697, 0.17910282864332328, 0.7391087853353786, 0.6760092287970041, 0.6631105381769198, 0.5894466974001253, 0.1739509746232698, 0.6525734313254574, 0.6701553017949369, 0.17365666805273372, 0.6592417673937719, 0.17528551692313832, 0.6124165527100467, 0.16990374293468724, 0.9656042902636652, 0.9702052912077982, 0.9588914137632568, 0.9531145674787522, 0.9604022145614997, 0.9608353813233893, 0.9864103551886346, 0.9412930659009761, 0.938288759453997, 0.6433139235465979, 0.6116095432670308, 0.6341721376861332, 0.636965032815471, 0.6505136145522852, 0.6689834627011264, 0.6121443061573251, 0.5868492201119363, 0.6117267625056154, 0.6914138925896879, 0.35514865808120044, 0.54140855869094, 0.3492314321598743, 0.7262957208483831, 0.6416558285687339, 0.6833627812917981, 0.6479107975281491, 0.7170976421746583, 0.3956695687508388, 0.20672062853570228, 0.16811240397553406, 0.18530407435949203, 0.18209474092032152, 0.22416757080813987, 0.19172698117800435, 0.2008066514135941, 0.1971404061433054, 0.17817069874830538, 0.0932508278549371, 0.18410170257991088, 0.16894094444559182, 0.2274586536245654, 0.170843898937727, 0.15929962284261, 0.1957525756080113, 0.24899516294784085, 0.05661598367869558, 0.006035696838954774, 0.07448592591151704, 0.06184036033052975, 0.0925515306350091, 0.017609882498589413, 0.013383299231763512, 0.05089731077083637, 0.04168041277429291, 0.16325934627829974, 0.1595656831343616, 0.12610374939623648, 0.1364911618513721, 0.060247609541018154, 0.11649394507121691, 0.16518546995689065, 0.16016878496728837, 0.23737741910436339, 0.03737282338088388, 0.07629181697489129, 0.08082332518304025, 0.08026124544976954, 0.061995803560692564, 0.08563790973668872, 0.10844827117559874, 0.08772046713501735, 0.08921884722518081, 0.1901814978915357, 0.17241527072575846, 0.17411507722962483, 0.2168896647594899, 0.2432206090444874, 0.23158410490711745, 0.17341887169715942, 0.19335642911375484, 0.1451838234107783, 0.5887091387350769, 0.5805637606559898, 0.6406887317005209, 0.5637789782307773, 0.6019801955215944, 0.5697408071613121, 0.6040018665887281, 0.5628007336280691, 0.5907254069556858, 0.12932061941866924, 0.14001356534709153, 0.13220942888330045, 0.11509221914130263, 0.1267040998854997, 0.14304329996157084, 0.120493363385207, 0.11169535706192546, 0.14905915681735094, 0.20271938076331708, 0.20819235216896026, 0.17700128528905568, 0.14817631769656547, 0.304106925762224, 0.2590616525035395, 0.3256190300933981, 0.2503966929452325, 0.16113250182576544, 0.5033021409503304, 0.3535029834120563, 0.38263570321216334, 0.4412318653631142, 0.429866607050843, 0.5021604713717208, 0.5906727794513407, 0.5183904430574662, 0.5701902460166932, 0.308005837745741, 0.2776397476575224, 0.26955465061439954, 0.2203572044538471, 0.2569348217633268, 0.2612052137798694, 0.29120039172144185, 0.3688500594408114, 0.3386567104645024, 0.2081658852637044, 0.1944406560724885, 0.24692615958005504, 0.20989645382311117, 0.24847915460733427, 0.211163853105945, 0.2052859479500948, 0.20397194161950416, 0.2452320187014374, 0.68599325275101, 0.6167241906723325, 0.6526679309452847, 0.5994628789155739, 0.5278621816354101, 0.638324620573939, 0.651904106431537, 0.6090264534874168, 0.24077691257625644, 0.48843766207928174, 0.619458922865372, 0.5196594169432354, 0.729879359794209, 0.19489564765263157, 0.16564553183956865, 0.39134694521562063, 0.6128206175878823, 0.37712995217318135, 0.165241853519822, 0.2296126301585688, 0.19740523587755998, 0.5906127487459933, 0.5332323199680136, 0.6671613258575807, 0.47235579181345033, 0.41644740326209007, 0.20946855756742278, 0.1954264205698515, 0.2025842942095213, 0.20454937694037634, 0.2251365621628566, 0.18367064872048, 0.19543307625773032, 0.20951347489811278, 0.18272922741548914, 0.1895940807893941, 0.0965560817048321, 0.08730611429096902, 0.08350086586058691, 0.08808523257247669, 0.09904091599732401, 0.08209376334140683, 0.08438890436187807, 0.08314811606496786, 0.0826508857643996]}, "mutation_prompt": null}
{"id": "2577bb28-a571-4f50-8718-ef865a724902", "solution": "import numpy as np\n\nclass ADEMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.7\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.4 + 0.5 * recent_success\n            self.crossover_prob = 0.5 + 0.4 * recent_success\n\n    def multi_strategy_local_search(self, best_individual):\n        step_size = 0.02 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        \n        if np.random.rand() < 0.5:\n            perturbation_2 = np.random.normal(0, step_size, self.dim)\n            candidate = np.clip(candidate + perturbation_2, self.lower_bound, self.upper_bound)\n        \n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                local_candidate = self.multi_strategy_local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADEMS", "description": "Adaptive Differential Evolution with Multi-Strategy Local Search (ADEMS) integrating hybrid perturbation techniques for diversified exploration and exploitation.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {}, "mutation_prompt": null}
{"id": "9c04bc4d-f975-48b8-8fc4-0a57937a9715", "solution": "import numpy as np\n\nclass EnhancedReinforcedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = max(150, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.3 * recent_success\n\n    def local_search(self, best_individual):\n        step_size = 0.02 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.70 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.50:\n                local_candidate = self.local_search(population[best_idx])\n                local_fitness = func(local_candidate)\n                budget_used += 1\n\n                if local_fitness < fitness[best_idx]:\n                    population[best_idx] = local_candidate\n                    fitness[best_idx] = local_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedReinforcedDE", "description": "Enhanced Adaptive Differential Evolution with Reinforcement Learning-based Parameter Adaptation and Dynamic Population Control.", "configspace": "", "generation": 36, "fitness": 0.3760855854638048, "feedback": "The algorithm EnhancedReinforcedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {"aucs": [0.8444813411147196, 0.8482516174682166, 0.8372361408073821, 0.8491870998327352, 0.8379846492661257, 0.8339140000582895, 0.8334842533676734, 0.8361068095454608, 0.8390011446442288, 0.7232175157203038, 0.7147505134179994, 0.7286629874265631, 0.7210219261065398, 0.7437107857392254, 0.745340948705415, 0.7156334063090823, 0.7260235826701424, 0.7198101591695153, 0.4880565413407162, 0.4940432771269697, 0.5481339607775833, 0.5643111829204706, 0.5424769867666135, 0.49060525036831093, 0.6143096929926444, 0.5610763814401082, 0.5693681534627317, 0.16147261741490382, 0.40824023891755046, 0.1675714148164723, 0.3488504317164597, 0.1519219781237089, 0.5433223564162415, 0.47006645614498543, 0.13169136108457247, 0.16778912619342157, 0.9299982537278482, 0.9707053695582045, 0.9211499531089888, 0.9647140634220326, 0.9377243363014914, 0.946410725394342, 0.9748354491139295, 0.9429211731922701, 0.9393334816074262, 0.5973944875680248, 0.5309410706620227, 0.5431353845208583, 0.572788128998025, 0.5471748050753675, 0.5581882231306154, 0.45974017433478653, 0.5387282935941253, 0.5386166209655244, 0.7425887514323004, 0.7366081237468021, 0.6552890230912789, 0.7895584706057295, 0.6233347065979515, 0.660491139812021, 0.7308964836778445, 0.7377671325443593, 0.7526029565159282, 0.27340448796181427, 0.21115048572521022, 0.18229442649118177, 0.18846115671240782, 0.22076598290054794, 0.20187008675657658, 0.294706383451631, 0.28704323160347933, 0.46133948362568256, 0.19629282233386325, 0.1799524120865339, 0.23960395508445964, 0.24879563133258553, 0.20304182134291937, 0.3494785160970604, 0.33376750520875786, 0.212385042976883, 0.22710503792031156, 0.07796051416663519, 0.08994024547550783, 0.09305870961098484, 0.060447740784113524, 0.07695028156485151, 0.13339065751301382, 0.07793560786562614, 0.09969528904163272, 0.0855726109292676, 0.17838977915177745, 0.1424422354917977, 0.2320686204334449, 0.16239103520282638, 0.194296916062083, 0.18058572184003974, 0.19595789076731007, 0.23528761040865087, 0.2392151011191247, 0.056550464645555576, 0.07431161083289084, 0.07684592462493489, 0.0701865762166266, 0.07707284478004128, 0.10909343729381415, 0.11499917652210556, 0.09342658074499344, 0.07638478120561054, 0.19704557883155172, 0.20696701328563694, 0.19622935275768616, 0.2308296035985854, 0.21961052805010361, 0.24028912533849256, 0.19935334625489987, 0.19752896719589064, 0.1918401489936884, 0.5903875680024477, 0.5825794851404873, 0.5631275686374149, 0.589444814803729, 0.5782412547604092, 0.5867205307097052, 0.6047177708744367, 0.5790302735928579, 0.5799350881148664, 0.16925532248416697, 0.1139163337411715, 0.12504290512997795, 0.11385364777195317, 0.14204968611478763, 0.12222255490312928, 0.12732032666985926, 0.12841602116865125, 0.10757687354499501, 0.1721447173227334, 0.1488109072618159, 0.1739031338057364, 0.16440927820544982, 0.15946013634491496, 0.18192736336132054, 0.203334724921159, 0.1783215523595305, 0.15751546019180207, 0.4014880403022737, 0.40746157548153494, 0.39799839365050693, 0.4115834026570794, 0.4067560426550577, 0.3838957695391132, 0.4822781150649037, 0.5044694025299172, 0.4715509221307307, 0.2482138533329905, 0.28757491507644994, 0.264158127072989, 0.269676672157914, 0.28556229606794437, 0.2515866983926087, 0.3078317655660199, 0.2995495370428254, 0.2867200707899319, 0.1939736371205394, 0.2198223423945881, 0.22631661374686984, 0.19941444112518658, 0.21429279879379115, 0.18439050554617498, 0.19636207026129238, 0.22872775494766795, 0.22631721856202136, 0.6011506016668757, 0.3846599353156145, 0.4953309582219423, 0.4180694291707848, 0.3253490974587403, 0.3603208945485471, 0.46289060861448283, 0.42674509415219364, 0.6437200069044544, 0.17252595473171572, 0.16818121286088228, 0.6310190971662262, 0.7510229970860942, 0.5437643705311124, 0.7033526064028828, 0.6576021040714507, 0.16170496475670004, 0.7071467736640912, 0.5948729936789858, 0.19826663299337854, 0.19979926250527147, 0.18628538255169413, 0.1924359955390349, 0.31681467642995376, 0.20613035878134478, 0.6915623438242847, 0.2076818268339955, 0.20308058516962713, 0.18316857461053426, 0.18171541122761747, 0.18719256177918076, 0.20330520706599597, 0.1787425626812319, 0.20606214928574418, 0.20730862667462702, 0.20155320993081427, 0.08878666343514519, 0.09199988447236263, 0.08661033077687663, 0.09389431607167642, 0.08833277166509945, 0.08800197496299511, 0.09465598960466581, 0.09110872601180342, 0.08854928243677729]}, "mutation_prompt": null}
{"id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.6 + 0.3 * recent_success\n            self.crossover_prob = 0.65 + 0.25 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.05 + 0.03 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Perturbation-based Intensification and Dynamic Control for Efficient Optimization.", "configspace": "", "generation": 37, "fitness": 0.4253051769601567, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "50e1eaf4-3308-4272-9b2a-9501d00bb630", "metadata": {"aucs": [0.866291334814319, 0.876888446071661, 0.8795594492956903, 0.8809653206905061, 0.8849510450530355, 0.8829354902176528, 0.8817933311771571, 0.8849069489408619, 0.8780241623056897, 0.8067774613799501, 0.8036087070783919, 0.8013463712090978, 0.7968781888297347, 0.7988043130443641, 0.8027324934943401, 0.7982428246050368, 0.8145072058867069, 0.7918260305551508, 0.15658489314448265, 0.7266980137574123, 0.6916897309442211, 0.6739111329910634, 0.6222102665035696, 0.634382096251501, 0.755900608731884, 0.6980687730537936, 0.6616272117263078, 0.13835131103613107, 0.17110117471090414, 0.6601527921460467, 0.172327408028925, 0.1377073862495687, 0.15076154191226343, 0.5828909510176649, 0.5786944055139518, 0.17493563635987808, 0.9400520345011582, 0.9631675686204882, 0.9434412072318441, 0.9611832863684322, 0.9571548826667352, 0.9606361022137143, 0.9864446030740283, 0.9558807365600487, 0.9751756914460956, 0.7259538123329039, 0.7116510323873172, 0.5408496891805699, 0.6946903275147556, 0.6791286039897704, 0.6767687343588482, 0.6553653366492456, 0.6676544821099402, 0.7016149095513635, 0.7461080462767503, 0.7783053962653578, 0.7020603998949484, 0.7791957022855345, 0.7531162590649793, 0.8213051511943571, 0.8039572591841215, 0.873767305098027, 0.7572907439810672, 0.29633910575638867, 0.21762411675097226, 0.41665878669958, 0.2684455576038217, 0.3087457365816948, 0.3421686492117819, 0.20239486155393938, 0.18276956395989796, 0.42652948752527875, 0.23746156989277556, 0.5693232980131369, 0.19991243066397957, 0.2306137216324472, 0.23632227795202543, 0.2606637441741929, 0.3060075380760392, 0.21313905139939082, 0.19642494724732873, 0.11246983422136636, 0.18263167457767515, 0.16089151615890673, 0.08729925104966318, 0.19366749649579296, 0.1781588278454408, 0.22411519887123976, 0.10780335402949281, 0.1452459238073589, 0.28296329827236777, 0.1436643967234097, 0.12388712441038696, 0.1556589942219545, 0.08962043687920718, 0.3192002352256762, 0.36312686898807356, 0.19891016596962918, 0.3026868621624571, 0.11885798764113664, 0.11164314906276818, 0.14609261480244118, 0.17647628719964537, 0.15383788936955312, 0.20110820510805583, 0.16658546247729755, 0.16445770878276267, 0.13183658093759765, 0.26167697056756867, 0.27578611011269427, 0.28275145678388824, 0.32922780694320386, 0.3438240945432077, 0.33295067647457355, 0.26173193626596003, 0.2814156524658562, 0.2668166548212314, 0.7179624040066424, 0.6994068164831024, 0.6368626221673171, 0.6484242155962527, 0.610275384376579, 0.6204978467562754, 0.6547281079720872, 0.628021554392245, 0.614519620364449, 0.14585385103608128, 0.16253340186778464, 0.15717546087762657, 0.13685519566614546, 0.11649010237101665, 0.13118807645398267, 0.11362512301696115, 0.15314591598723104, 0.10896998375106026, 0.15452861529071127, 0.22878088318890033, 0.21406081452125747, 0.1759930451752416, 0.15610577886523969, 0.22458755228892546, 0.163890145200575, 0.21169945853836258, 0.15713008060748002, 0.42744898284358146, 0.4485176011873808, 0.49078099097164885, 0.5239748402847553, 0.4433865154530219, 0.5682767110457159, 0.6180884035712932, 0.5906927839892886, 0.5885026317782419, 0.33723147346987303, 0.3401374049974749, 0.2728283270368961, 0.295801398452467, 0.3161480735961847, 0.3102517779611077, 0.35794859472095275, 0.3747501327230641, 0.2425146391597457, 0.21293149570685477, 0.19118798421332261, 0.1906210752682267, 0.18266182675013287, 0.1869567566487823, 0.19813660914453257, 0.20009719624000943, 0.22453012388212523, 0.19537876534052456, 0.6291331896238453, 0.6864128213598517, 0.6244519973988047, 0.680324314275104, 0.5792560828204902, 0.22416962314510347, 0.7081715314722747, 0.5249976550507409, 0.5315123199179626, 0.776058124494415, 0.8681952576484036, 0.15108643759299323, 0.7902292020362953, 0.19317031724306544, 0.8500874459429889, 0.804749788040587, 0.18836300058212596, 0.15683057909726905, 0.20204162357269106, 0.5295732108418867, 0.16317845779684303, 0.8135832216296759, 0.20296112059005578, 0.7778699260724178, 0.5111940525933885, 0.2023860041056278, 0.2093007269490328, 0.19640111186310494, 0.18622168312405785, 0.18933435710575774, 0.1831553314123291, 0.18429688052526483, 0.17299963211991431, 0.21387602630702263, 0.19067580202558643, 0.19427234229332302, 0.07986065385257135, 0.09220539541922868, 0.08767728415069576, 0.09579007433260434, 0.08453176292334086, 0.0883484665652664, 0.08005420569547061, 0.08087655501676494, 0.09138054181533084]}, "mutation_prompt": null}
{"id": "a1f9d630-4bda-48d6-8319-1076684c1feb", "solution": "import numpy as np\n\nclass AdaptiveMultiPerturbationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(50, budget // 15)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.3 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def stochastic_rescaling(self, generation):\n        if generation % self.rescale_interval == 0:\n            self.population_size = int(np.clip(self.population_size * np.random.uniform(0.7, 1.3), 10, 20 * self.dim))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.stochastic_rescaling(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMultiPerturbationDE", "description": "Adaptive Multi-Perturbation DE with Success-driven Intensification and Stochastic Rescaling for Enhanced Optimization.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 42 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 42 is out of bounds for axis 0 with size 40')", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {}, "mutation_prompt": null}
{"id": "f904c45f-80b6-4717-84bc-c22e9dadf248", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = budget // 8\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success  # more dynamic mutation\n            self.crossover_prob = 0.7 + 0.2 * recent_success  # adjust crossover\n\n    def intensification(self, best_individual):\n        step_size = 0.04 + 0.02 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.8 * self.population_size))\n\n    def elite_preservation(self, population, fitness):\n        elite_idx = np.argmin(fitness)\n        return population[elite_idx], fitness[elite_idx]\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_individual, best_fitness = self.elite_preservation(population, fitness)\n\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(best_individual)\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < best_fitness:\n                    best_individual = intense_candidate\n                    best_fitness = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        return best_individual, best_fitness", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation Control and Elite Preservation for Robust Optimization.", "configspace": "", "generation": 39, "fitness": 0.39171974269650534, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.8531034143536512, 0.8305415468958667, 0.8424504829777946, 0.8501409225826423, 0.8517949540077208, 0.855506020245998, 0.837470370882011, 0.849041657088048, 0.8378908296519565, 0.7383267620326854, 0.7358417404715345, 0.7429362416831576, 0.7425012629965106, 0.7484221665106487, 0.7430058506186088, 0.7435098528117163, 0.7248434056349751, 0.7466735402430058, 0.537327015941371, 0.6026237868183051, 0.5122571588876023, 0.5828058450785512, 0.4464140963289145, 0.5024209842403198, 0.5270078486151922, 0.5501212390620924, 0.5826236535642326, 0.159102207255575, 0.478140255630062, 0.47004160605274203, 0.3773481140434989, 0.16101412438985574, 0.1428815479678609, 0.1585977792414044, 0.16120948450269879, 0.5359705013487457, 0.9395047887706973, 0.9284999592124679, 0.9028744059165059, 0.9645475412756594, 0.9478257964146865, 0.9461407604251683, 0.9710675946753423, 0.9408693397836184, 0.97408827004012, 0.6538624865454467, 0.6363898082129775, 0.6247699292271195, 0.6439912068229088, 0.6425416360564351, 0.6351585506368154, 0.6293927988547924, 0.6349979785947754, 0.6395510498489585, 0.7782799274564802, 0.8030361400380901, 0.3614817148571845, 0.7847626437440144, 0.7791744670639456, 0.7670285002683923, 0.7569331843859084, 0.7584570882462218, 0.7778190893618233, 0.20675338556716527, 0.22097037763021277, 0.27312605826585645, 0.21865228087273403, 0.20318506760948507, 0.17135505765681558, 0.21471165522046687, 0.19287656300268996, 0.19197187339976152, 0.021113755431652836, 0.19789647254779308, 0.20096588197492937, 0.19816752118790604, 0.2958307529677632, 0.191798441582405, 0.1944868827660523, 0.19452574975507309, 0.20800874071922804, 0.12452623310798194, 0.224348597791435, 0.2861994630838942, 0.2923871962071284, 0.29610893666265803, 0.22679057091983645, 0.2747105451931977, 0.23557385854022628, 0.149535796244901, 0.46241348252099246, 0.29355204589384676, 0.1868528508865288, 0.3882431265274109, 0.34177132335823757, 0.19643000766736285, 0.32665683259672373, 0.3860539634659498, 0.19205333806906677, 0.08595770644652145, 0.09222212645570271, 0.18749113238324688, 0.1597360273702434, 0.1177056614091625, 0.16523803645587543, 0.13967114725536667, 0.123313958916756, 0.15116799237423406, 0.2486527371170092, 0.27463318788842483, 0.27094742387506876, 0.353237634401522, 0.31064402379997635, 0.3105399136509045, 0.26693981307396564, 0.2537811401804474, 0.27654887850086984, 0.631284013307747, 0.6293825502820858, 0.7029861857208461, 0.6502355564534574, 0.6125657833650326, 0.6723535803215439, 0.5782909741501732, 0.6161340916215077, 0.6064989416653194, 0.12124863574993738, 0.12405419952904773, 0.12756541796900223, 0.10386655108095433, 0.11738610461177956, 0.10142702058463204, 0.11415506120239294, 0.12350853789268201, 0.11930249236236179, 0.2130494857197478, 0.15030532113098705, 0.1531286987026308, 0.14692929828914236, 0.19352893117581504, 0.13905341028011275, 0.20879559342083598, 0.18860462202356265, 0.16001038469807916, 0.5358502805822631, 0.4859603662734373, 0.5112953065841462, 0.4282927143748815, 0.4906424638014586, 0.5255296441804003, 0.5435157413159017, 0.5780749749883884, 0.5958188311097371, 0.34484537585861963, 0.3090933534582019, 0.33237044499392954, 0.3081025149387717, 0.2825689651660368, 0.3206856709967586, 0.3740509991664257, 0.4018777490146498, 0.39025714319137583, 0.2015015828535598, 0.190247106864059, 0.18218097046074677, 0.19285794451021365, 0.1947714726218981, 0.18586718710797778, 0.19616900731718556, 0.19855920433985452, 0.23688852912630132, 0.5794032576786579, 0.48010590398142516, 0.21401419365485963, 0.26613168510227714, 0.533071781944878, 0.6026307092789858, 0.5807424359494332, 0.23698165247808123, 0.42621203946394204, 0.16868293661460798, 0.16096815619448612, 0.16846774053341795, 0.826204223373578, 0.1752255004913954, 0.18497495617080872, 0.15576560823372, 0.7749942934408223, 0.18735631475164116, 0.19949710029148515, 0.16486341551688344, 0.6397508690260068, 0.1619704034839733, 0.20150727011224767, 0.19035995239461767, 0.20694643573001315, 0.2023357855499105, 0.6810806229973505, 0.18348993777617928, 0.17718863782686933, 0.19379665734969453, 0.19906672482215193, 0.19479590937608282, 0.20600780615486114, 0.21529976249304317, 0.1897327238256551, 0.18726556822457474, 0.08337501391645163, 0.08904796890532884, 0.08529737778924229, 0.09036862741255647, 0.08755460355285505, 0.08919176188074995, 0.08414861184378464, 0.09349742931025962, 0.09457891119192186]}, "mutation_prompt": null}
{"id": "3f8e20c6-82e2-4dc8-be45-d6c3dadd6f18", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased initial population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Slightly higher mutation factor for exploration\n        self.crossover_prob = 0.85  # Adjusted crossover probability for better exploration-exploitation balance\n        self.success_rate_history = []\n        self.rescale_interval = max(120, budget // 8)  # Adapted rescale interval for better parameter adaptation\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success  # Adjusted mutation factor range\n            self.crossover_prob = 0.7 + 0.2 * recent_success  # Adjusted crossover probability range\n\n    def intensification(self, best_individual):\n        step_size = 0.07 + 0.02 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def diversification(self, population):\n        perturb = np.random.normal(0, 0.1, population.shape)\n        diversified_population = np.clip(population + perturb, self.lower_bound, self.upper_bound)\n        return diversified_population\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.8 * self.population_size))  # Adjusted population control strategy\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = self.diversification(np.array(new_population))  # Added diversification step\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:  # Adjusted compromise probability for intensification\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid Adaptive Differential Evolution with Exploitation Diversification and Adaptive Mutation for Superior Optimization Performance.", "configspace": "", "generation": 40, "fitness": 0.17322155553975166, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.32915516559893054, 0.3308370480537157, 0.3066783523554556, 0.3179678906196167, 0.31761357841857696, 0.3255343296237069, 0.3091564966154129, 0.3412318375373572, 0.3798965409394085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08766656938223494, 0.08697044065686554, 0.08762148622403199, 0.08165775352451476, 0.09824439660749396, 0.0779691403538596, 0.0880026666891548, 0.09322248850651527, 0.0835812662234775, 0.0853102843511313, 0.07220032641461316, 0.07412346318969198, 0.07985979056254777, 0.0764209280797784, 0.09535540531893916, 0.08223546257442538, 0.08161582782535692, 0.08034236548410023, 0.8911704757572988, 0.9460456742581925, 0.9124234828835008, 0.7778241639461343, 0.2416264330894674, 0.9254291883109894, 0.31444789096496684, 0.9167774983406591, 0.9286751869876386, 0.18599278270030428, 0.1936227553429023, 0.20106085149564001, 0.19437553078443404, 0.17499147591727582, 0.1874376683262926, 0.2113722312845584, 0.1739717793905795, 0.1712011002469972, 0.22608642618820718, 0.21093397842658979, 0.20094489305481833, 0.22498109845425474, 0.2234384380581007, 0.20062031236468347, 0.26825105208240707, 0.2135995035360615, 0.23590843446186993, 0.11699331717238348, 0.10121656374403809, 0.10855350285773491, 0.10958194748838213, 0.11355535274345474, 0.10279322881532371, 0.13489806244506763, 0.12229744775069862, 0.10381790901256538, 0.12924280357909668, 0.12013101721141395, 0.10670446766149466, 0.11481629231877233, 0.10797590230057141, 0.16841278413516758, 0.11727736039076042, 0.12559877703405742, 0.12037200669288739, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07388032852528581, 0.05312532686114191, 0.07604019408055795, 0.051386170646783635, 0.04482515214819982, 0.10959666747771968, 0.07258714867514104, 0.11629871098434563, 0.06820599432149743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05725240375887586, 0.08255017197562498, 0.043045444823686, 0.03951347871163979, 0.06040240973943656, 0.0466837077098029, 0.05589060908515131, 0.04011508413542875, 0.06275547293704042, 0.3576424745779233, 0.32928702860297154, 0.3104250984646054, 0.3733490987703558, 0.309279392440042, 0.32840098952900765, 0.3260455068236813, 0.30860662894921365, 0.30164336943016223, 0.0835543279416936, 0.09624895107723042, 0.08110346053726258, 0.0858028800828261, 0.08163857606181113, 0.07579747303068185, 0.08260529053066201, 0.0881177650631354, 0.11533629445304028, 0.129706575981816, 0.1626459809814702, 0.138272634096816, 0.14296048219781277, 0.1319572420029984, 0.1675908418773222, 0.13659262831663288, 0.15506729294303334, 0.14693160074350964, 0.25571287421611444, 0.2188145184928174, 0.23219075975478032, 0.25041618554942335, 0.22542712321092395, 0.2297442882804659, 0.23106157212028344, 0.22967020336485044, 0.21871382828464425, 0.1704948457637665, 0.16423249841358079, 0.17580949792742917, 0.15890059007158197, 0.16555932924139283, 0.1818161387083116, 0.18022788068161877, 0.1639936448278364, 0.16592393737273048, 0.18851553551489364, 0.1970168417741054, 0.19105610752702518, 0.18772631439015564, 0.1891939341393214, 0.19942496126183362, 0.21638366979318202, 0.19296040404732984, 0.19487109022416593, 0.183386382915375, 0.1739809595483368, 0.21382161774843722, 0.17581872670875542, 0.1788465705970126, 0.17814587588924402, 0.17574909376957226, 0.17276427776902115, 0.1841417364501513, 0.4578402301930852, 0.16258476737436522, 0.3028730008351901, 0.3827290216820103, 0.32116163078066584, 0.2746448899777879, 0.1663450447278727, 0.31039194010434645, 0.37015629940657524, 0.2487126726912171, 0.16826435133380524, 0.16312331898186405, 0.19303529550416965, 0.19358759513934132, 0.2534519968685962, 0.16024647841235218, 0.33277831652558176, 0.2023468340671255, 0.17828784880396764, 0.18032925402372257, 0.18050013889377348, 0.18315558644992802, 0.19404729046743818, 0.19858767732131466, 0.183375862505333, 0.19365077931797647, 0.19120633908398277, 0.0791593508567312, 0.07765052010137719, 0.08039134458093355, 0.07732737739004392, 0.07650753327179849, 0.07914899405839693, 0.07639283603335445, 0.07415036060713898, 0.0838146880180397]}, "mutation_prompt": null}
{"id": "e4ca97ab-615c-44b8-a3f5-0be22e7684ea", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 15)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.7 + 0.2 * recent_success\n\n    def survival_based_mutation(self, best_individual, generation):\n        step_size = 0.03 + 0.02 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 12 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.75 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                survival_candidate = self.survival_based_mutation(population[best_idx], generation)\n                survival_fitness = func(survival_candidate)\n                budget_used += 1\n\n                if survival_fitness < fitness[best_idx]:\n                    population[best_idx] = survival_candidate\n                    fitness[best_idx] = survival_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Parameter Control and Survival-Based Mutation Strategy for Robust Optimization.", "configspace": "", "generation": 41, "fitness": 0.411749394948762, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.8487852979033201, 0.8406941257898533, 0.8387112514355479, 0.8467857064822055, 0.8458592936451274, 0.8506373474011535, 0.8451756366479508, 0.8378907481710578, 0.8402057984418322, 0.7387427415666168, 0.7506235564669169, 0.7465022801359634, 0.7402781244942627, 0.7511344867574826, 0.7393860101686637, 0.7440662662736041, 0.7522220628515903, 0.7307994584042614, 0.5207540266019034, 0.5193265336833123, 0.47680792575191655, 0.5184382195306099, 0.5784421695472013, 0.16976649654672415, 0.5676356125465782, 0.5086156518914794, 0.6291229486942362, 0.4523109989629045, 0.16850255405000647, 0.529205432966833, 0.442127672894142, 0.1588184528625799, 0.4874513345568504, 0.1373174299592469, 0.5139839330973204, 0.16364095470754525, 0.9246223485336666, 0.949091272197499, 0.9296413598036396, 0.9109096154918971, 0.9150386871921069, 0.9416160496560481, 0.9362424346015795, 0.9641621060492495, 0.9475707140128828, 0.653132580006169, 0.6201081993022226, 0.6591556288771143, 0.6543017271144074, 0.6215703977501057, 0.6285130036784854, 0.6510303400246531, 0.6315084618573562, 0.6485798953694756, 0.7658332752624293, 0.7651034664921874, 0.7437440422135648, 0.7975519441197153, 0.8080290498182775, 0.7646191878801804, 0.8043454446499352, 0.7873865210636163, 0.8183575732379027, 0.2198635569820675, 0.19281637720198175, 0.331360622596204, 0.2607176817861899, 0.2716388490254684, 0.32230121261612543, 0.20825715304057213, 0.25380700244509646, 0.19927743034878542, 0.21028226782009185, 0.11055442086879341, 0.16893818531974725, 0.20994386309742552, 0.18492180385571122, 0.34631427568296036, 0.20348237052815132, 0.22404938603513813, 0.16191890768177875, 0.21351118359908183, 0.2463555132534535, 0.28010841511982054, 0.25658068588308747, 0.07057940552244746, 0.26047674060812653, 0.1416190978866474, 0.2283019687122987, 0.08815208423872478, 0.2763261972815768, 0.4374663833549055, 0.3841496109344412, 0.3454231522885741, 0.1016836129655645, 0.09982985379074072, 0.30505576959989744, 0.3366890820598357, 0.2677128091205695, 0.18662039183946688, 0.12214987708264657, 0.23265425352625035, 0.15642248999270925, 0.19808203829199333, 0.13214871000429806, 0.16997286642621734, 0.09548004687289535, 0.2053366171496389, 0.28840590224027196, 0.25872877990948917, 0.2578846133204711, 0.3645726841217757, 0.3288123207801281, 0.3189286412854415, 0.27040672442764846, 0.29294151480411257, 0.2764361663413665, 0.6219032120254688, 0.7081055109881536, 0.6995231541715454, 0.6628537581563456, 0.5864929437199164, 0.6320323708057463, 0.5925486556242687, 0.6795415891353949, 0.672357260272914, 0.13029525818676446, 0.1425996156152709, 0.11063841993856638, 0.09748074222635883, 0.11603763204562112, 0.12533087091673623, 0.19052745464592302, 0.1262932194986539, 0.12559818129781286, 0.13427996893106642, 0.17675302859942554, 0.22593016667158783, 0.23256376735108675, 0.16627674627747602, 0.209396495846353, 0.17200171928588193, 0.1608100565748113, 0.19462867720498667, 0.4811263925750562, 0.5054350837811996, 0.46696025532885455, 0.4934819090707492, 0.5315013078910025, 0.5548304144802912, 0.5698653187097018, 0.5945534172035559, 0.5681688880098684, 0.33272496206465874, 0.33269060440180076, 0.30891728078376723, 0.33820339115126774, 0.3709272577106991, 0.3644232534024501, 0.4139083147371895, 0.3646480404060173, 0.3802137470517061, 0.23521013813323066, 0.21782665138392154, 0.1885775378282839, 0.21105062482099268, 0.20792397883134528, 0.20435984700042786, 0.20832497190759003, 0.199716585994547, 0.2105372390787149, 0.5475910809546454, 0.5964330320089124, 0.6280355126813715, 0.5658006754878365, 0.4505488361625406, 0.5724099127833759, 0.47253715613364533, 0.46397657160018313, 0.5054333377376987, 0.16446736055550537, 0.6632656966481353, 0.17391942669004568, 0.18565424546283804, 0.7223482326153414, 0.6777355813826357, 0.5897498808487285, 0.7031859817731284, 0.18007069543974763, 0.16383365356812885, 0.20208186670760553, 0.6850253511136644, 0.2028877341914055, 0.1969877545975236, 0.707587945948303, 0.20152384660152645, 0.7539627548430774, 0.20753054073384336, 0.17855457309701783, 0.18405321020467935, 0.1994732255464251, 0.19367789278996983, 0.21010800982477362, 0.18128733339925407, 0.20658881774093973, 0.21578579384210572, 0.18235214079760675, 0.09034176774766367, 0.08873147547159566, 0.0791698876157394, 0.0960692726571617, 0.08395229266786175, 0.08962913695568964, 0.09761230154055078, 0.08067299399495265, 0.09733118830010279]}, "mutation_prompt": null}
{"id": "b53a1d3f-1b6e-40f3-b36e-651624c7b900", "solution": "import numpy as np\n\nclass MultiModalAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.dynamic_rescale_interval = max(100, budget // 8)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.6 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.3 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.04 + 0.04 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.65 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MultiModalAdaptiveDE", "description": "Multi-Modal Adaptive Differential Evolution with Dynamic Intensification and Parameter Self-Adjustment for Robust Black Box Optimization.", "configspace": "", "generation": 42, "fitness": 0.3735947320802952, "feedback": "The algorithm MultiModalAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.86654381735333, 0.8380706393019465, 0.8602759417631654, 0.8607985203573737, 0.8616498112334295, 0.8513485053966261, 0.849029262954083, 0.8578793130009922, 0.8508215424951554, 0.761353477400728, 0.7518126743367058, 0.7368372810536978, 0.7553766752438298, 0.7470908087175845, 0.7611646994004829, 0.7418365012132908, 0.7339890449277858, 0.7418064290897988, 0.17681517752367248, 0.6181534581659736, 0.48673267982192014, 0.5990171732905157, 0.16681796030937168, 0.6020280918484109, 0.6120506083459747, 0.48738069932493266, 0.4672902438513983, 0.16974991046189314, 0.16213782881597305, 0.5588124353774656, 0.15366576509041585, 0.48940744384638546, 0.5232490425354173, 0.5336899026683335, 0.5349937299024641, 0.16554722910539998, 0.9512625899016044, 0.9612447410847317, 0.9466256724130959, 0.9667353554908983, 0.9488192041756855, 0.9519049651813165, 0.9572255021712998, 0.9669994101085936, 0.9643462058907397, 0.576853544205574, 0.5384866530472125, 0.5613336498688064, 0.6068840451779083, 0.5565104132210337, 0.606495725033054, 0.593446541376897, 0.5782597888579379, 0.5680179385067005, 0.6819429783154178, 0.5618840336495332, 0.6689479881302363, 0.8275231973781818, 0.7349531174813129, 0.7156401762020144, 0.6143380705634276, 0.7241691317721033, 0.6710657719569671, 0.21185738496921735, 0.2697497435777203, 0.26250845619624197, 0.12568838240889157, 0.2239888594688999, 0.25267080433554234, 0.2610851363997997, 0.23838052086481576, 0.26432257622100575, 0.19529802003561958, 0.21121858717735864, 0.22749959543838527, 0.21217036597505456, 0.23488950626178218, 0.2955491402102274, 0.2348754906741014, 0.2378372299610616, 0.23272089648877026, 0.0818125066497245, 0.08713501540752144, 0.08941484906658004, 0.07471262458566252, 0.11346877622630969, 0.05561692046298172, 0.10490853093706543, 0.08364564633566096, 0.12519941247394417, 0.2025716077651052, 0.13327614795283693, 0.19065383534490477, 0.16924519706824526, 0.23253979305890216, 0.1340076968960664, 0.23725083958497328, 0.261115170167055, 0.2142089846312576, 0.04375892080682442, 0.03068548408010696, 0.07692635023775551, 0.0922180426100867, 0.048256990497640984, 0.040409017429523963, 0.13456504381867707, 0.10012786527047723, 0.05407447794975051, 0.17818539817350953, 0.17836042092115767, 0.1871102541616282, 0.22569537241914528, 0.24450743375660622, 0.2413219076900749, 0.205936464286137, 0.1583479389983775, 0.18746739921826372, 0.6062728082818192, 0.5746897651552378, 0.590429479596549, 0.5803504697666086, 0.5951808318320772, 0.581119143616951, 0.5997442902023269, 0.5735812685681788, 0.5840694539961966, 0.13994868413429418, 0.12022061404394191, 0.12279176178681828, 0.17281385882087286, 0.1443121430467318, 0.12686218788017267, 0.11249036364765175, 0.12189605453356145, 0.14359474366795044, 0.14982191518917787, 0.15845979678152466, 0.23454429855510506, 0.1728557618277884, 0.15033791482308878, 0.1945833277131057, 0.1999821288299256, 0.14965691856253072, 0.1425990103606839, 0.3883435348108758, 0.4184948955912736, 0.3746162981206621, 0.3980561267863878, 0.36414630251852387, 0.3875643084080742, 0.48670113657017655, 0.4952807864029666, 0.4863083739687698, 0.24397640327012515, 0.2621717392268659, 0.24134105336755352, 0.2402948332733048, 0.22694589202032056, 0.31201624682911455, 0.3189701932501915, 0.3477295146754863, 0.2932050037849133, 0.21508092429872694, 0.18339061891149244, 0.22001523862237493, 0.1953992046967179, 0.22396652391618266, 0.22179574430425164, 0.19706332406698157, 0.20334807188979453, 0.19488917505667536, 0.2321346539164063, 0.35266851964919155, 0.37356684883038316, 0.4163802755756111, 0.40657585670291396, 0.37342904741712624, 0.47204739350040703, 0.6342180463013831, 0.24285883975949696, 0.1779393679249046, 0.49916544725017364, 0.18838838233490673, 0.7341717420387275, 0.6258104133586748, 0.5318687623177096, 0.6817681849826508, 0.4392799914454881, 0.6997007316127843, 0.18915365964118314, 0.16669490839979317, 0.3897660518492442, 0.1977671355391578, 0.19690021998679264, 0.20382154539025188, 0.5102199590049326, 0.6726498243171003, 0.20795421900981914, 0.1835668878523642, 0.18774229354203475, 0.19437786924784373, 0.18397259088844886, 0.18942399670664067, 0.20182819931813456, 0.20113741354318382, 0.18291214248201737, 0.19212450359654765, 0.1037259053680426, 0.07969484758525747, 0.08874414829511057, 0.08541640113909232, 0.09059433133300154, 0.13595237281158612, 0.07902788931486271, 0.08357755217533758, 0.08323252193412922]}, "mutation_prompt": null}
{"id": "f7a5a008-f548-432c-9edd-8d76fdb8b8df", "solution": "import numpy as np\n\nclass MultiPopulationHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_populations = 3\n        self.population_size = 5 * dim\n        self.mutation_factor_base = 0.7\n        self.crossover_prob_base = 0.9\n        self.rescale_interval = max(100, budget // 10)\n        self.success_rate_history = [[] for _ in range(self.num_populations)]\n        \n    def adapt_parameters(self, population_id):\n        if len(self.success_rate_history[population_id]) >= 5:\n            recent_success = np.mean(self.success_rate_history[population_id][-5:])\n            mutation_factor = 0.6 + 0.3 * recent_success\n            crossover_prob = 0.65 + 0.25 * recent_success\n            return mutation_factor, crossover_prob\n        return self.mutation_factor_base, self.crossover_prob_base\n\n    def intensification(self, best_individual):\n        step_size = 0.05 + 0.03 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def __call__(self, func):\n        populations = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                       for _ in range(self.num_populations)]\n        fitnesses = [np.array([func(ind) for ind in pop]) for pop in populations]\n        budget_used = self.population_size * self.num_populations\n        generation = 0\n\n        while budget_used < self.budget:\n            for pop_id in range(self.num_populations):\n                mutation_factor, crossover_prob = self.adapt_parameters(pop_id)\n                pop, fit = populations[pop_id], fitnesses[pop_id]\n                new_population = []\n                new_fitness = []\n\n                for i in range(self.population_size):\n                    idxs = np.delete(np.arange(self.population_size), i)\n                    a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    cross_points = np.random.rand(self.dim) < crossover_prob\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial_vector = np.where(cross_points, mutant_vector, pop[i])\n                    trial_fitness = func(trial_vector)\n                    budget_used += 1\n\n                    if trial_fitness < fit[i]:\n                        new_population.append(trial_vector)\n                        new_fitness.append(trial_fitness)\n                        self.success_rate_history[pop_id].append(1)\n                    else:\n                        new_population.append(pop[i])\n                        new_fitness.append(fit[i])\n                        self.success_rate_history[pop_id].append(0)\n\n                    if budget_used >= self.budget:\n                        break\n\n                populations[pop_id] = np.array(new_population)\n                fitnesses[pop_id] = np.array(new_fitness)\n\n                best_idx = np.argmin(fitnesses[pop_id])\n                if budget_used < self.budget and np.random.rand() < 0.4:\n                    intense_candidate = self.intensification(populations[pop_id][best_idx])\n                    intense_fitness = func(intense_candidate)\n                    budget_used += 1\n\n                    if intense_fitness < fitnesses[pop_id][best_idx]:\n                        populations[pop_id][best_idx] = intense_candidate\n                        fitnesses[pop_id][best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_overall_idx = np.argmin([np.min(fit) for fit in fitnesses])\n        best_pop_idx = np.argmin(fitnesses[best_overall_idx])\n        return populations[best_overall_idx][best_pop_idx], fitnesses[best_overall_idx][best_pop_idx]", "name": "MultiPopulationHybridDE", "description": "Multi-Population Hybrid DE: Enhances Hybrid Adaptive DE with multi-population exploration and adaptive mutation strategies.", "configspace": "", "generation": 43, "fitness": 0.22067821034225485, "feedback": "The algorithm MultiPopulationHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.5490470296739014, 0.5834394422041589, 0.5516092689824242, 0.5454627298178991, 0.5568348320235021, 0.5869092649030493, 0.5464752051711285, 0.5864764250980447, 0.5453431579267272, 0.2706158052819526, 0.2636320545019426, 0.27980195424331045, 0.28156473519333336, 0.2600566542213565, 0.2681462363509316, 0.2882435183351808, 0.29488322740954853, 0.2547062331401204, 0.11576114455462738, 0.16060513234420015, 0.11743314413177997, 0.13613563679716023, 0.1328281049362502, 0.13836442280004013, 0.1069779129508337, 0.12001409135765462, 0.11996758328967538, 0.12203412081066323, 0.10692428886716776, 0.10926519274256319, 0.12866275837527574, 0.11398977459688198, 0.10464345587891088, 0.10713631024864168, 0.10643871854484732, 0.09811007301361074, 0.9152110269247722, 0.9460445329028778, 0.9223455746938568, 0.9537492252441531, 0.9259684006775037, 0.979304203900731, 0.9275792186016681, 0.9591495168278543, 0.9387122178242425, 0.21883965808956551, 0.23594837431188298, 0.21982947271964648, 0.2328307246180058, 0.21632997139555887, 0.23363851427518434, 0.21811049279494898, 0.24367838303760514, 0.22725555818558973, 0.26698747909411147, 0.25246603861199035, 0.26076915888010543, 0.3368862985617249, 0.2591297914712083, 0.27569108887550564, 0.26926833752020896, 0.2790379399168076, 0.2478564713778475, 0.15332209923286189, 0.18499803453719954, 0.13149517716879144, 0.15861889272200647, 0.15529183943998015, 0.14439134389404829, 0.1422245653110069, 0.1369441535969541, 0.13921422557967866, 0.11050609006039613, 0.10290074723983766, 0.14783756168245887, 0.1256339350378286, 0.13151798666516845, 0.13474596316507392, 0.14288550684749257, 0.15127530488324503, 0.13916167617570085, 0.017642447024757146, 0.01607225428861947, 0.009966804499275339, 0.013999606502920647, 0.039245978691450745, 0.0029571804656824963, 0.004997663527306018, 0.00761861136129649, 0.011678630767440135, 0.09482443454456957, 0.0863604803991258, 0.1302778099546955, 0.07452297056381574, 0.0838187467701953, 0.07851578217094435, 0.12337702316906884, 0.10965956463868665, 0.10910835881427483, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001572612753077962, 0.0001639164087823275, 0.004794623186890723, 9.999999999998899e-05, 9.999999999998899e-05, 0.005659334108956138, 0.0073740681321446955, 0.09423045991127132, 0.10150363234218107, 0.08617504604553383, 0.09983807696970892, 0.08571114249340883, 0.09690375596589473, 0.08301227349232776, 0.08942934643421863, 0.0986751439185638, 0.39673099862574146, 0.4138872066004501, 0.41763765560751054, 0.41390019059232686, 0.4065911999430354, 0.41682603101042026, 0.4334935217383974, 0.4072186328144135, 0.43260739623231115, 0.1000990054194979, 0.11987275718643364, 0.11679180504307973, 0.11368791834140357, 0.10424807992291096, 0.12081951246597111, 0.10018984735375958, 0.10652393288589868, 0.09730488247811331, 0.16655575969414693, 0.14558794748031634, 0.1526096139825035, 0.17398201044956496, 0.16391641597603268, 0.1673613803603281, 0.16024851726471334, 0.13502495245289425, 0.19993322969618232, 0.26630392599393315, 0.25421627898682086, 0.24215555600795657, 0.24230214433783248, 0.23139803966651684, 0.24725299519090693, 0.2843556031643829, 0.2727922735422329, 0.2672521083771632, 0.1861851524770204, 0.20425319620309823, 0.18403341214406643, 0.18992480026095637, 0.18635707849778416, 0.215897539558504, 0.1872002884105265, 0.21336772316778196, 0.19418344946544452, 0.1870471843030015, 0.18868053660449757, 0.191300511296421, 0.19784846837304082, 0.23584212278444694, 0.19068633116831457, 0.19512218438771134, 0.187408491828421, 0.21206695045234913, 0.18257981776522758, 0.1868776129710057, 0.18688042856227471, 0.17888014247519912, 0.19142147864816883, 0.20793704038967942, 0.19783458380403118, 0.19218899617544116, 0.19439330046817427, 0.24352299620802764, 0.2719210305758003, 0.28663155379570515, 0.32848235173798856, 0.2062694165139164, 0.28103385088697574, 0.2730598227990584, 0.16850174584658562, 0.20727211144442959, 0.33545062653191104, 0.19909002425093314, 0.23757540534510957, 0.1765975001529514, 0.1874510386139846, 0.19375968360742468, 0.25644931301255935, 0.40454326177148625, 0.2650219105295457, 0.18593255702941236, 0.18411712095646515, 0.20509223950229105, 0.18320124470917254, 0.193968639272171, 0.16916504085167394, 0.18543852051590515, 0.1887582261545191, 0.1934148489124694, 0.06794589803103901, 0.07437171879388027, 0.07326824260275189, 0.07407519568003917, 0.08080302527839633, 0.07910096952669643, 0.07494551444479403, 0.07345785306632646, 0.07592994131246322]}, "mutation_prompt": null}
{"id": "15c5159f-f8ac-4d06-a819-35760d96505e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.6 + 0.3 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.04 + 0.02 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Mutation and Adaptive Reinforcement Learning for Robust Global Optimization.", "configspace": "", "generation": 44, "fitness": 0.39701777453771153, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.8505457178607968, 0.8627136085290664, 0.8498974997459915, 0.8564704260584886, 0.842357699187755, 0.854182819565175, 0.8623441191655316, 0.8557977989347425, 0.8557972317222087, 0.7494890004746385, 0.754176479299609, 0.7586241196419664, 0.7415412181047085, 0.7608728149433467, 0.7652230659868786, 0.7729219078468431, 0.7699704716017255, 0.749280985531599, 0.6231853845817441, 0.6781987671002522, 0.6122492751947903, 0.6107259993757996, 0.6664218073440513, 0.6467227840978924, 0.578278949247834, 0.6162323416400581, 0.6015558181670445, 0.5553385668670265, 0.6034956061883536, 0.6059720146233714, 0.5379930729565209, 0.16776613370806825, 0.16279262454195775, 0.5383906422809295, 0.5671549705903964, 0.5601319238173632, 0.947837646471572, 0.9629250648653854, 0.9439792918277516, 0.9525569885519866, 0.9578897545551007, 0.9559696163082636, 0.9708247174895275, 0.9355890483303142, 0.9382105171090788, 0.6498537990865104, 0.5726499348305045, 0.6169079303420019, 0.6009502051461724, 0.6034083061245025, 0.637675026328244, 0.5728804308132005, 0.6324543058057044, 0.5130773283766106, 0.7930291506277669, 0.691583645204759, 0.6856846423744741, 0.7662943241066059, 0.7711889673549618, 0.7945241605062903, 0.7778484535027671, 0.8095777951317651, 0.7631558011400381, 0.1891805445374446, 0.1717002848446424, 0.19767984092811075, 0.1250688689664936, 0.17927622554751854, 0.18473922166927637, 0.21341600380425074, 0.19528904194968844, 0.18129530575516217, 0.2341064808631267, 0.136645649495846, 0.201199260141269, 0.20314021735099463, 0.15289166081789063, 0.1799999232229722, 0.180149231414526, 0.20020699534854858, 0.22938027432840147, 0.13177118421595935, 0.10187317710695276, 0.07922651495008903, 0.08212659719585824, 0.07640941194810347, 0.10737797549947115, 0.08544825132432599, 0.12851157155887993, 0.11883348558828888, 0.20377361320969412, 0.1806289147272221, 0.16608873717211392, 0.18735693672637066, 0.2047243988041072, 0.15323349320256985, 0.2447765918974879, 0.2423150833402985, 0.25811328621424956, 0.03789009305826352, 0.037809438331375844, 0.0932875182020867, 0.11315021386230051, 0.11358095884906794, 0.088496065598625, 0.13181152651831485, 0.131086927640511, 0.1272413788147061, 0.22431761547172369, 0.19527800052494915, 0.22002235710774398, 0.2510618649355566, 0.2333480919994263, 0.25426589018758683, 0.20321231427213526, 0.198647715780776, 0.1514590680265845, 0.5759161726092723, 0.6110570694968016, 0.6355028726224831, 0.5882813916131201, 0.5837134936899699, 0.6002223460439655, 0.6202515347615972, 0.60333537884467, 0.5927348691077279, 0.1365761450936538, 0.15413707570315704, 0.11381007774092322, 0.14728417116877623, 0.11610373797328699, 0.11958892030828205, 0.11071855893165417, 0.11973961229542696, 0.12963159354785692, 0.19169731598227047, 0.1560417905463113, 0.16914035056137888, 0.20340486977918226, 0.17203661367471412, 0.17168423463399174, 0.17473686318563308, 0.18134236715743868, 0.19511165848373735, 0.4418095614440505, 0.4690138602564784, 0.5157003921491429, 0.43223167878655544, 0.41422738570520035, 0.48008436998092696, 0.5367853228591082, 0.5115224538759986, 0.513334512845721, 0.2792598088597523, 0.2518168748993517, 0.28352546483688623, 0.2620417542143024, 0.2979460471703589, 0.26629325611557886, 0.37273501556674826, 0.3081675214560079, 0.3883054663863681, 0.19006552091039708, 0.21072512282391076, 0.2266645241160824, 0.19873798736353399, 0.21527716490422977, 0.21539605276144458, 0.20841354658129718, 0.21879100536175167, 0.22801613697287426, 0.6718722045479086, 0.3549137240476875, 0.5904077642978383, 0.5393276922878845, 0.6503986292658821, 0.5737219627569661, 0.4667796399821639, 0.27725143231148464, 0.4491049814970167, 0.15967342320500644, 0.17694846975759648, 0.6358102962182728, 0.8435506378006856, 0.20642871379547256, 0.661717655319559, 0.17893747427925277, 0.6709593858819276, 0.17420155558917816, 0.17305323707173903, 0.20111163574385604, 0.6090578640594556, 0.6580573015406277, 0.18864161074501185, 0.20255338042065374, 0.7348848661965925, 0.7132285161838854, 0.20724275182055207, 0.1815583788042724, 0.19103169507719864, 0.18074119502459285, 0.18185149455010152, 0.1896946398858479, 0.18878319713372482, 0.18737362065368102, 0.20040417938773047, 0.20355085053217936, 0.09744738601492153, 0.09511215538538631, 0.08734853688639743, 0.08818357453181669, 0.08540873118834191, 0.08305301300803547, 0.08125651477829254, 0.08694786003152644, 0.0883047621998263]}, "mutation_prompt": null}
{"id": "ae379449-d57c-4a97-aea2-f64c8495d10a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(80, budget // 12)\n    \n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            self.mutation_factor = 0.5 + 0.4 * recent_success\n            self.crossover_prob = 0.7 + 0.2 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.04 + 0.05 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def multi_layer_intensification(self, best_individual):\n        candidates = [self.intensification(best_individual) for _ in range(3)]\n        candidates_fitness = [func(c) for c in candidates]\n        return candidates[np.argmin(candidates_fitness)]\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.8 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:\n                intense_candidate = self.multi_layer_intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Multi-Layered Intensification and Adaptive Learning for Robust Optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {}, "mutation_prompt": null}
{"id": "7b90c4e3-1e32-4e8a-851d-7661d31c5bfa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = max(100, budget // 10)\n        self.diversity_threshold = 1e-5\n\n    def adapt_parameters(self):\n        success_rates = np.array(self.success_rate_history[-10:])\n        if len(success_rates) >= 10:\n            recent_success = np.mean(success_rates)\n            self.mutation_factor = 0.5 + 0.3 * recent_success\n            self.crossover_prob = 0.7 + 0.2 * recent_success\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.02 * np.random.rand() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def periodic_diversity_reinjection(self, population):\n        if len(population) > 15 and np.std(population) < self.diversity_threshold:\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n            population[:10] = new_individuals\n            self.success_rate_history.clear()\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.periodic_diversity_reinjection(population)\n            self.adapt_parameters()\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Self-Adaptive Parameters and Periodic Diversity Reinjection for Robust Optimization.", "configspace": "", "generation": 46, "fitness": 0.2898785908006716, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.7219487330598229, 0.7427504411957989, 0.7370139129318629, 0.7387945212543856, 0.7640932737243485, 0.7427133231289399, 0.7479236231073314, 0.728448434601799, 0.7589290673452236, 0.5496079306038131, 0.5318992186891365, 0.5061456688879058, 0.5352386162640366, 0.5069480804214193, 0.5557514349727728, 0.5426315541817449, 0.5433898373432493, 0.5145326216713899, 0.13128112199312836, 0.1501367396181882, 0.1720565026431028, 0.14272845281190405, 0.1493375999241463, 0.19452233151928078, 0.15151097245234468, 0.1401560547771924, 0.15228266059826823, 0.13293120548675674, 0.1315235921925001, 0.13152197062162685, 0.14169161175819223, 0.1388226659973636, 0.13993936044538913, 0.12381945643081038, 0.13448941307486417, 0.11722549046753572, 0.9092073360052378, 0.9276727144331572, 0.9397782135411462, 0.9178299171756393, 0.9412865906318374, 0.9181190993819018, 0.9241645388693167, 0.9637805631021417, 0.9353829814326572, 0.3465906089954649, 0.33827955458339287, 0.33425220152675117, 0.3755134828126381, 0.3202208019180305, 0.3233202461168764, 0.3708259746801206, 0.373335146444184, 0.3439478637929425, 0.504307037663455, 0.6608863874210695, 0.610443983889728, 0.5446123454976712, 0.6091743509331998, 0.5807906500597712, 0.540805994903998, 0.575571961260869, 0.5332856310098602, 0.16742012457410915, 0.17344336236791713, 0.1649753673438472, 0.19252881759222662, 0.17513068128189313, 0.18318009319100226, 0.1702820437257695, 0.2278060527037189, 0.16740415467976832, 0.16176379970331434, 0.1931127357962057, 0.16903893138824333, 0.18178475585970844, 0.15829563149518422, 0.17263358041818733, 0.1833193542089956, 0.19253444292745547, 0.16602513387639806, 0.07366347506898252, 0.07322721952223532, 0.0727940789260676, 0.09004650984465079, 0.0764850688913713, 0.04202037845282136, 0.06074124236757561, 0.05666105290427714, 0.06822533349156512, 0.15832284861761892, 0.17864209152115018, 0.16937335598290848, 0.17767667089274364, 0.15059206431652705, 0.14866049480586863, 0.2128873304047625, 0.21883982300543725, 0.22045102643942138, 0.054651472038859894, 0.017708738605942242, 0.014166866179731952, 0.03616801838888384, 0.024555606780026884, 0.03736856843677194, 0.03893357564282074, 0.041029906574498676, 0.060106111636967, 0.14383096969380382, 0.13957435739219104, 0.14132444590696436, 0.17895669135092718, 0.16603853673259383, 0.15962741113901135, 0.14420914078507863, 0.16089746097281898, 0.1560092081482668, 0.5304514176386431, 0.5115314016771091, 0.5028130134466839, 0.5214055361779345, 0.5087273306548071, 0.524365311440221, 0.4981392118239032, 0.496319154924578, 0.5189138410496579, 0.13975981425868755, 0.11476732137961354, 0.1437689310547039, 0.13167493811005915, 0.09833971232335803, 0.13932533626813215, 0.13052801799891367, 0.10800189195966081, 0.13712033938154744, 0.1600771363215967, 0.16526488389477967, 0.15522494204458048, 0.17469232695846204, 0.15528095267872655, 0.16802044957527473, 0.14858279015657994, 0.2215036306837027, 0.1653639220391071, 0.3166467139203162, 0.32976623546682526, 0.3299208761816631, 0.3346953734088972, 0.32667369555906745, 0.3199979793225689, 0.3667232317323931, 0.35745669010063075, 0.36255485812546107, 0.22403853377671856, 0.24244693843303378, 0.22527393994001466, 0.2485489524649288, 0.2304543812570714, 0.23009523483827266, 0.2457912990453648, 0.25567280559925176, 0.25577499500783474, 0.18594940926941017, 0.18749600317600545, 0.18365932169963883, 0.19666164261739838, 0.18799079268247632, 0.18895511539182552, 0.19242303566649221, 0.19903231677351452, 0.2171341586117007, 0.22097397241609606, 0.2183917715177378, 0.20402506545568455, 0.22934041180401343, 0.3135754454192895, 0.2755811763802968, 0.20695841553158, 0.2596132885226139, 0.24700606480412557, 0.23540034940401178, 0.536464311750374, 0.19988794253535347, 0.47769249324174756, 0.3182815075141081, 0.18339815185073804, 0.3543687357285581, 0.3950254833759578, 0.593265838399295, 0.34722562047176275, 0.19278874248013111, 0.19309754656330902, 0.48300662792486937, 0.21877119113971155, 0.20446922429908687, 0.20853938908463876, 0.5267155495235256, 0.2051344242017954, 0.1953185689274033, 0.18836074633950195, 0.210886386843112, 0.19837484197182187, 0.18306101942818986, 0.18692927940301718, 0.1725972648298837, 0.18816424115775232, 0.19483775419990257, 0.07799907101364845, 0.08216760972544923, 0.08357294575942975, 0.09006192720326434, 0.07457085545170017, 0.08279068684025936, 0.07949348336742768, 0.10926822972160277, 0.08125398415476481]}, "mutation_prompt": null}
{"id": "86e0ef8c-87f8-4097-bb77-8e2edd2b149d", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(80, budget // 8)\n        self.memory = np.zeros((5, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            base_factor = 0.6 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.0)\n            self.crossover_prob = np.clip(0.7 + 0.15 * recent_success + 0.05 * np.random.randn(), 0.5, 1.0)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.05 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 12 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.65 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.3:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdvancedAdaptiveDE", "description": "Advanced Adaptive Differential Evolution with Stochastic Parameters and Adaptive Memory for Enhanced Optimization Performance.", "configspace": "", "generation": 47, "fitness": 0.42675146295181066, "feedback": "The algorithm AdvancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "baf7cb1e-6cfc-4739-893c-26c0198397f9", "metadata": {"aucs": [0.8769510475503195, 0.8800861993398787, 0.8805356460607237, 0.8814462958960012, 0.8783209140624394, 0.8735328866194669, 0.8851789105316593, 0.8701111874503684, 0.872964853723555, 0.8092322802252394, 0.7927529862309077, 0.809557724475557, 0.7920291157052965, 0.8060277193214308, 0.8016816193349339, 0.7977509927457604, 0.8150440483573801, 0.8106035837472312, 0.6766010227257635, 0.630138279252914, 0.6186365452589904, 0.6020002516157914, 0.17819432485838893, 0.1787523166142868, 0.705663906751526, 0.6892466837688631, 0.6840136810414079, 0.16094073256194297, 0.1755831451543447, 0.6023291922734413, 0.4590512069923548, 0.1662192812689165, 0.13832903209962477, 0.13544986227258027, 0.5704608675149762, 0.1660498119671443, 0.9547501365019845, 0.955610676238214, 0.9647256278555668, 0.9646705396876556, 0.9548518151315817, 0.9599780448997707, 0.94476798790177, 0.9472053820906793, 0.9699041979497155, 0.7160447010335829, 0.699476977876285, 0.7289262518771433, 0.7240683834909543, 0.662711508062539, 0.7180928173069246, 0.7279956595054449, 0.6518639274866209, 0.6909577759183158, 0.7719900895300964, 0.7869243888985775, 0.7953271161831484, 0.7813946393096621, 0.7914927493815417, 0.8037412973445761, 0.8418894012244698, 0.8446583017887372, 0.7963593564407359, 0.2510248745124358, 0.3145844089756884, 0.3309935544603956, 0.2765256865648039, 0.13116280688755322, 0.4844746957086049, 0.21246241630357232, 0.24059683640304863, 0.20665581586717896, 0.28188748154583576, 0.12488428082296088, 0.18751527052975026, 0.2157780949451068, 0.26627747769438415, 0.394382886145927, 0.2084020900634047, 0.3128015203869928, 0.3533373523544405, 0.14701178778856794, 0.2868735341538968, 0.17518945138367636, 0.15585192464031283, 0.17045410029167285, 0.06164858766283865, 0.15708639803084312, 0.22771465139390867, 0.0943772202637736, 0.30065740232014593, 0.31717332434339174, 0.25681215161352755, 0.20026132446125955, 0.41762788787992666, 0.3073446237954055, 0.3512008315166175, 0.4166917038320339, 0.36568424114772347, 0.06751056032406633, 0.07392999071017947, 0.18907045942207057, 0.11938557050631748, 0.07512729854106837, 0.20483219834119393, 0.17663415834825646, 0.21597057594835145, 0.23705416337444885, 0.32294491028865435, 0.3002766476590527, 0.31582332797865786, 0.3366050267593329, 0.332283846161072, 0.29816865681999094, 0.3036515433296577, 0.2873557108319781, 0.2848830941107888, 0.7203212740152625, 0.6963900286040876, 0.6572256056059329, 0.7106809568602592, 0.7640157751912549, 0.6630889449121488, 0.6883620078593187, 0.6323380498647585, 0.7051806104298592, 0.14507980789462438, 0.11941873198300768, 0.13582811040324827, 0.15733045799718437, 0.10835913505921313, 0.1350160001024555, 0.11011459958564851, 0.13785871912042424, 0.13672028589872354, 0.20665836847499164, 0.23025711589651165, 0.2464001972388249, 0.21209488999488324, 0.22955311614495766, 0.20202697076083176, 0.3243661001544198, 0.16984734688893988, 0.22404874593209356, 0.46886702367392374, 0.5594502316638041, 0.4966143890949227, 0.5403422469969721, 0.6136686219808072, 0.4619748108505829, 0.6727482040806392, 0.6606448769104829, 0.6350924646800473, 0.339337691057072, 0.3264232898063849, 0.36938386580860993, 0.3571006573084463, 0.3342854850382503, 0.3696211579413896, 0.36610850679983764, 0.26731359724327, 0.3853804008005809, 0.19509207884336843, 0.19565196455815592, 0.21866002023011588, 0.2174714415849729, 0.2116106088808154, 0.23213288603528615, 0.22222888997207768, 0.20045628529313864, 0.21417707205600378, 0.5631802905174119, 0.2356829593333748, 0.2312453378654361, 0.5476530943147213, 0.5706676795188165, 0.5827291707833433, 0.5523205791251287, 0.5429964938868328, 0.6360504197135264, 0.1695643697031477, 0.7683066807641741, 0.8245454036377351, 0.8265772627480416, 0.818297040943663, 0.18404351453215329, 0.17989371675026122, 0.1841082185789923, 0.2065775845154586, 0.7727939285056109, 0.20415360695600315, 0.16276237463086163, 0.6962932582067978, 0.20199102489691045, 0.6972142859217103, 0.15343924845683465, 0.20761240817191506, 0.20831094953295415, 0.1762376794296182, 0.193407803684999, 0.19721483530109418, 0.2000551483102686, 0.18057755098990802, 0.19433345906730826, 0.18106625704964718, 0.20004735963639186, 0.1854581615768014, 0.09523457587250506, 0.0921579322774736, 0.07989067430214492, 0.09066695539187841, 0.08211665192399364, 0.07492547745567424, 0.08211832123086693, 0.08556287296868781, 0.09104831411175074]}, "mutation_prompt": null}
{"id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(50, budget // 10)\n        self.memory = np.zeros((7, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 7:\n            recent_success = np.mean(self.success_rate_history[-7:])\n            base_factor = 0.5 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.2 * np.random.randn(), 0.3, 1.2)\n            self.crossover_prob = np.clip(0.75 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.6 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Parameter Control and Memory-based Intensification for Superior Global Optimization.", "configspace": "", "generation": 48, "fitness": 0.43439130206134663, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "86e0ef8c-87f8-4097-bb77-8e2edd2b149d", "metadata": {"aucs": [0.8860829715069716, 0.8817076066965187, 0.9034159004003353, 0.8841699368549102, 0.8907911166123358, 0.8863235332840991, 0.8887515788100409, 0.8871388273951019, 0.8875665892835529, 0.8097318560494295, 0.7931497995098262, 0.8145113097318569, 0.8009047679320211, 0.7982848039760451, 0.8062402080430868, 0.7996137697213805, 0.8189277921841603, 0.8099584404088742, 0.16968771221687962, 0.45626913206431063, 0.17127238783163778, 0.5806552305731022, 0.6118276959596834, 0.17634674989071286, 0.6237429223795994, 0.6401673436162745, 0.6692190488830515, 0.5355608084716531, 0.1607016489520975, 0.17892634774693394, 0.40993827135593797, 0.14875840419876263, 0.5691355057750078, 0.5311485312531362, 0.17600170916146995, 0.14796658569829202, 0.9584049380571832, 0.9685228504787224, 0.9796870653894081, 0.9617598217984363, 0.9509344091857269, 0.9350255420721421, 0.9684052831625909, 0.9553894214164202, 0.9445930668798361, 0.6427853842378951, 0.6790690226362796, 0.6902974261713246, 0.6947719221471165, 0.6658077080994589, 0.7292163849699465, 0.658871724817, 0.6646771316530373, 0.7047949937952835, 0.8477708826966429, 0.8184474458985065, 0.8413401409420806, 0.8488981310388497, 0.8615480373516471, 0.8884588735561793, 0.24161413957282973, 0.8522242879408604, 0.8429952265059978, 0.19194520772561408, 0.6079772659953457, 0.21118428376741782, 0.20867628538041016, 0.6928513748108465, 0.18823028769941663, 0.20455709926681942, 0.18429540624496799, 0.17575675633346566, 0.44706816053466936, 0.1794464237599439, 0.19137683147131912, 0.20858357327133115, 0.2101973221738268, 0.15702051342761647, 0.19346297325592055, 0.2538122387962408, 0.20706115367175482, 0.13030696965495114, 0.10469157141943519, 0.1497450894422111, 0.15933299948100832, 0.05391616336283356, 0.25788441103884074, 0.3582685992307787, 0.1729067398988995, 0.05125371364143705, 0.210104033788865, 0.2793100893731254, 0.27536068368232947, 0.0958138720381525, 0.3671020651231486, 0.315262791832432, 0.5888534927899205, 0.5135598458658046, 0.17863952016102613, 0.16650866224256755, 0.12720108319043988, 0.2661608887549246, 0.19437467778356787, 0.1884786793181248, 0.11583466680165255, 0.24130393802533634, 0.14593371703638935, 0.19440338470347762, 0.31590565307254515, 0.32857792268907493, 0.3516213755416788, 0.413003462969063, 0.38437381304458673, 0.43517482309319266, 0.3550161962418472, 0.31011802252118137, 0.2567956637754444, 0.7534542482827287, 0.7866519977220476, 0.712606011285464, 0.7563487530516566, 0.6876914261609655, 0.7269870345400424, 0.6682122570254893, 0.6677018768262187, 0.5409221784717151, 0.14617302951549793, 0.14904680296622064, 0.13733624820789314, 0.1293057973270857, 0.12304209568841185, 0.11406313531141166, 0.14721822142913643, 0.12423405268283061, 0.15003025373979295, 0.16727177827530615, 0.15782650203539084, 0.20573523223788037, 0.18241483195769093, 0.18038728502303947, 0.17773584445918655, 0.19908206460722244, 0.1975480694032492, 0.2313872160782795, 0.5398940887963831, 0.5230527814974779, 0.5938887337260481, 0.6007506114761149, 0.5600188291353275, 0.6161492540106346, 0.671087852973238, 0.7102278015832988, 0.509390060364781, 0.24289611206822947, 0.46914148735396144, 0.44958063391026515, 0.358965732647466, 0.39809877785356107, 0.45378807284340505, 0.4481047385355096, 0.5511956449241603, 0.4739675005797801, 0.20020052094578378, 0.24321048011013668, 0.19964820830050523, 0.20245782181682448, 0.19354923781900335, 0.25158483066443027, 0.19143090029384924, 0.23083706628052802, 0.20936823128161075, 0.6969825238266121, 0.7030878605632722, 0.2341174444415346, 0.6231324747426241, 0.632383262244628, 0.2389137905901645, 0.7081884625352797, 0.22942879936691474, 0.6058948126190795, 0.1638441967859564, 0.1697979053905334, 0.8200102865106242, 0.17700063378951159, 0.849947929305687, 0.18560840943193435, 0.8332441617445332, 0.8021489057829505, 0.8557987333730874, 0.8816573959846228, 0.38537189745446754, 0.8546823487867596, 0.1664726761636508, 0.16713710762262013, 0.20418371913654165, 0.21096578488037276, 0.12685824296052484, 0.6280665448703764, 0.2062392740058886, 0.1886172184243562, 0.200102263021818, 0.18675965729800303, 0.19364689692425907, 0.19251263611558955, 0.1936789314748325, 0.18581888255732126, 0.20077456342389632, 0.09255412363043924, 0.09478897886011894, 0.09357071267175232, 0.09316923710459246, 0.09491255269556698, 0.0886168323916039, 0.09976404426624763, 0.09114770304334985, 0.09650962321449208]}, "mutation_prompt": null}
{"id": "ff82593d-880b-4739-8d64-833c8055d6d4", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.memory = np.zeros((5, 2))  # Memory to store recent parameters\n        self.phase_switch_interval = max(75, budget // 15)\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            base_factor = 0.5 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.3 * np.random.randn(), 0.4, 1.0)\n            self.crossover_prob = np.clip(0.8 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.5, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual, phase):\n        step_size = (0.01 + 0.03 * np.random.randn()) * (1 if phase == 1 else -1)\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def variable_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 30:\n            self.population_size = max(30, int(0.5 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.variable_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                phase = generation // self.phase_switch_interval % 2\n                intense_candidate = self.intensification(population[best_idx], phase)\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic DE with Multi-Phase Intensification and Variable Population Control for Enhanced Global Optimization Efficiency.", "configspace": "", "generation": 49, "fitness": 0.40761943757153174, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.8301055273213638, 0.8321471984737174, 0.8316986246940211, 0.8416929548263472, 0.8304490137103266, 0.8324782602307483, 0.8199726701141954, 0.8290123141498571, 0.8188539792880131, 0.7053078723188635, 0.6754648150443612, 0.7179451004724613, 0.7006466829517137, 0.7225741549521671, 0.6923914224934145, 0.7004371222988321, 0.6911752801470092, 0.7292998150596104, 0.3035905991118809, 0.29140470858094303, 0.35412967721722954, 0.28798361490717916, 0.15899201101736193, 0.15182788223310617, 0.20063297901942478, 0.3020525403882023, 0.15200607160699842, 0.13795169344103364, 0.18370160801562463, 0.1578715135917511, 0.28741948037717846, 0.12911007446541878, 0.2206697293686406, 0.24699729349550292, 0.19804013544979449, 0.23621005252947402, 0.91465793628266, 0.9592255384817141, 0.937208200942717, 0.9127284963221897, 0.960380391452941, 0.9309460026446665, 0.925686526167367, 0.9770223742907699, 0.9406306272595722, 0.5787686135853733, 0.35287178420089393, 0.5545647205780089, 0.6093288157913292, 0.5782297360475357, 0.5327171325473772, 0.5480958391071601, 0.5351027785670673, 0.5182749984560927, 0.7718180897675856, 0.7557594935033045, 0.7896175559669935, 0.8131850943998448, 0.7700553601965323, 0.846791360044725, 0.7714069757806943, 0.7925251021787308, 0.8033701549515531, 0.5911807719300068, 0.23971942001968305, 0.35985620158519027, 0.3225783668693225, 0.29758010384836586, 0.24816922161301158, 0.2575103643724631, 0.2644387742985028, 0.2720631355499721, 0.4540943683632993, 0.14121637436146361, 0.5150951006405426, 0.28992848269224847, 0.3580863080332565, 0.24071704813946737, 0.2485689456310337, 0.2609386177313022, 0.26276912164321253, 0.3772921588440067, 0.39239737806309594, 0.33830275965258805, 0.45848844909843856, 0.38612917246815737, 0.3474022686491747, 0.4058484557993465, 0.33168690302747017, 0.39544006797792364, 0.5113324316090629, 0.4873343088779104, 0.47410515002505027, 0.5698469384274916, 0.4929004277257818, 0.4063384177183834, 0.5880396934714993, 0.560580999983034, 0.5297830771471066, 0.159522066528484, 0.13224199613887244, 0.08903743859253721, 0.2085208936300572, 0.2983705017781364, 0.2543672129490062, 0.16766802237253575, 0.1731086248642023, 0.17241467471983773, 0.3374236880859208, 0.32300075038054366, 0.30551937004870866, 0.3279999454390057, 0.3481343194831452, 0.31891869414317575, 0.35158052493435876, 0.32750319182749876, 0.32125584884501457, 0.6937515062732758, 0.7252055397817389, 0.7441942942204951, 0.6700912895595414, 0.7142907367501508, 0.7038349448759145, 0.7523083823914485, 0.7029089650979308, 0.7313717181606879, 0.12038253708092161, 0.12857298547824525, 0.10792319373211012, 0.11440078408255339, 0.11686217050473513, 0.15910176766092887, 0.12025053469724956, 0.1019771769639537, 0.11424757614007996, 0.5634991250046913, 0.1984653948065327, 0.2248974320697098, 0.27035560946530623, 0.2833244471481793, 0.1499760980224073, 0.16242140825785367, 0.16818746474409618, 0.20221925847252586, 0.41948385040771596, 0.45770897370801955, 0.45600782409288143, 0.4555880930903097, 0.48144064750287463, 0.46492267226499606, 0.49761893034564564, 0.48914740770599285, 0.5038188478966836, 0.4041776468021726, 0.3505745194197638, 0.3419259566905244, 0.36547758609166037, 0.2897226806044215, 0.3506499699559128, 0.3682162288639239, 0.3610614802024008, 0.39278524222477995, 0.18533182517194113, 0.23001631965987712, 0.1884457646422072, 0.20296889568934595, 0.19943470550723175, 0.20173959564655486, 0.2093578830947016, 0.19674321698206054, 0.2063810448466894, 0.4879315848633855, 0.21633996024837798, 0.19535501018887802, 0.22637356996297198, 0.3804796092794456, 0.22850214122635804, 0.26619751141749426, 0.5220372521231792, 0.3726762384368607, 0.1694207901890068, 0.8039921114706229, 0.1949349779442877, 0.1748877520348857, 0.19722690916585672, 0.1956238168072748, 0.6607018011977039, 0.6745843064515706, 0.7301982516650274, 0.6897269167052663, 0.16882961884399061, 0.7329224241484738, 0.20407980442747198, 0.20727480776375407, 0.1970307007901646, 0.7514117394918386, 0.15219884998687916, 0.20926286821068796, 0.1846895188544584, 0.1869386083510508, 0.18315151439118393, 0.19027520031342515, 0.20620698940218207, 0.19523821593440915, 0.20663057589555578, 0.18067185636675043, 0.20659179015852458, 0.08524218878883927, 0.09453682741544944, 0.08539563131889283, 0.11260583945322633, 0.09829018826480629, 0.08563940319644048, 0.08067138582415823, 0.08048241054363248, 0.079007171853536]}, "mutation_prompt": null}
{"id": "de0133e5-5a4e-4d6c-9cac-5d15815b4492", "solution": "import numpy as np\n\nclass OptimizedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.rescale_interval = max(40, budget // 10)\n        self.memory = np.zeros((10, 2))  # Enhanced memory to store past success rates and parameters\n        self.exploration_probability = 0.5\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 10:\n            recent_success = np.mean(self.success_rate_history[-10:])\n            base_factor = 0.6 + 0.2 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.0)\n            self.crossover_prob = np.clip(0.8 + 0.05 * recent_success + 0.05 * np.random.randn(), 0.5, 0.9)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 15 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < self.exploration_probability:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "OptimizedAdaptiveDE", "description": "Adaptive DE with Optimized Memory and Exploration-Exploitation Balance for Enhanced Black Box Optimization.", "configspace": "", "generation": 50, "fitness": 0.41832922165332426, "feedback": "The algorithm OptimizedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.8375434650711648, 0.8250548805267213, 0.847780038273075, 0.8313956441020469, 0.8255446322512405, 0.8410630300560797, 0.8353229112505622, 0.8389541753030776, 0.8248437027070699, 0.7245736800664369, 0.7293727091634498, 0.732332695844572, 0.7389289021480406, 0.7144793524924757, 0.7279928303634404, 0.7388706741334224, 0.7244904548599849, 0.7440723102044342, 0.5751126762636514, 0.2634212290842821, 0.18686432852505652, 0.3402360416544138, 0.3354138851980609, 0.17061835872204134, 0.2404065286923388, 0.22968975525562474, 0.4014596478911393, 0.15803111484621546, 0.15255685677869446, 0.2721354099957938, 0.14709565511832767, 0.1513123166052266, 0.1442712038494559, 0.27542989169845156, 0.15113500490689713, 0.14054912728772473, 0.9351830414734413, 0.9376677322842415, 0.9359474324574064, 0.9617131980327508, 0.9716620161022945, 0.9524085524767762, 0.9340453239433052, 0.9684194841755401, 0.9555167263127594, 0.5900798832942824, 0.5701736093024008, 0.638564836684681, 0.5929920591443837, 0.6155195332067278, 0.5657438215170395, 0.5820157978541689, 0.5864796828311225, 0.5633972519017737, 0.7586591024370195, 0.7603527254987595, 0.7493373817774562, 0.7916653435395757, 0.7936474676179441, 0.7812645114799281, 0.7868085525024018, 0.7969487974698843, 0.7462203475993674, 0.28567352768358256, 0.4585696474025033, 0.3250935317235776, 0.23133865567974032, 0.35052402639207325, 0.3542828093674143, 0.292136306218881, 0.40233671156173867, 0.3291604810211619, 0.28241160148436195, 0.2311466482860084, 0.235361227974747, 0.3644822833506566, 0.3480948910047982, 0.2829423978762924, 0.32571807388378193, 0.28819074663419975, 0.2612326147494648, 0.23150604448869994, 0.3588964606157682, 0.33612229718922493, 0.36055322986333227, 0.3611226130685432, 0.3248325128375703, 0.32615490452899354, 0.34268693331809363, 0.3374118401563364, 0.507700615190497, 0.4787416860401711, 0.44891797563616676, 0.5139543425246985, 0.39520020597177075, 0.4683655762167819, 0.5973829408435337, 0.5137623859656031, 0.5806904535061506, 0.2068126182939396, 0.17909247057196265, 0.22052385564395593, 0.21234643059343716, 0.17067190205595129, 0.1334722782354425, 0.26187949323605886, 0.14386825392107072, 0.17990545805413571, 0.33604895096812315, 0.30243700789302763, 0.3185002504021982, 0.3689490221902756, 0.3399313545773055, 0.3535034739180022, 0.3597743535981889, 0.30207296680022233, 0.28435833224751084, 0.7075490114786549, 0.7310416233898416, 0.7291631327840965, 0.6595554287530547, 0.6930653698959978, 0.702928015113016, 0.7369354409118185, 0.7409987982112054, 0.675894082035352, 0.10207897401689858, 0.15474860847634442, 0.12288110645504735, 0.11340163470159936, 0.13221440861161515, 0.11034101482641767, 0.15798173069389887, 0.14191249011442653, 0.12715881136099816, 0.1623400850714194, 0.22211214161448334, 0.15051468263243006, 0.1680025508136127, 0.169549136958847, 0.20229473855431657, 0.2830966127423349, 0.1973264745927693, 0.36577682675714684, 0.4791682860168487, 0.39191606128676215, 0.46555513680509386, 0.465755082623004, 0.4537016406096612, 0.4614436704773609, 0.4861768357013253, 0.5286296212696899, 0.4948387689009668, 0.322766497343849, 0.31158858437879045, 0.290695336677562, 0.3363210561012715, 0.31283280358934085, 0.3102023864846989, 0.34881237549028077, 0.36849894054307997, 0.35591131339298676, 0.221791449816221, 0.2121533281240532, 0.1951707495658065, 0.19812566302325718, 0.18310240534694056, 0.2458703214229495, 0.2136396755586354, 0.1877266922764096, 0.2144097360241447, 0.44145712479086685, 0.48359346072018394, 0.5110753673541415, 0.4560572144352565, 0.2804985718961769, 0.23216588928112947, 0.3601128632303514, 0.22832394705896808, 0.2880970029453438, 0.1691820890060568, 0.7237548893705434, 0.16053618920708412, 0.7601681442216079, 0.1928495711551358, 0.7445141187325719, 0.20119384824163045, 0.18442503919381414, 0.8024928510652753, 0.7143022850475488, 0.1663787849209044, 0.16652524384408574, 0.7073799396247494, 0.7372286381315205, 0.2000319863225749, 0.7455228334275132, 0.7527604872046182, 0.73579170767079, 0.18511710436418904, 0.19191341091467518, 0.19666761790893184, 0.20339162168361413, 0.2011598765375474, 0.23489084452702647, 0.1966558827896, 0.2087895809276521, 0.2213182321383549, 0.08588991733573237, 0.0818372426241174, 0.09504034815838136, 0.08945604403382745, 0.0930960979751102, 0.08098465077432626, 0.09334217761885832, 0.0982781473087303, 0.08955863341242698]}, "mutation_prompt": null}
{"id": "54de6412-b4de-4e1f-aa1d-3604124f8430", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(50, budget // 10)\n        self.memory = np.zeros((7, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 7:\n            recent_success = np.mean(self.success_rate_history[-7:])\n            base_factor = 0.5 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.2 * np.random.randn(), 0.3, 1.2)\n            self.crossover_prob = np.clip(0.75 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 10 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.6 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Parameter Control and Memory-based Intensification for Superior Global Optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.8860829715069716, 0.8817076066965187, 0.9034159004003353, 0.8841699368549102, 0.8907911166123358, 0.8863235332840991, 0.8887515788100409, 0.8871388273951019, 0.8875665892835529, 0.8097318560494295, 0.7931497995098262, 0.8145113097318569, 0.8009047679320211, 0.7982848039760451, 0.8062402080430868, 0.7996137697213805, 0.8189277921841603, 0.8099584404088742, 0.16968771221687962, 0.45626913206431063, 0.17127238783163778, 0.5806552305731022, 0.6118276959596834, 0.17634674989071286, 0.6237429223795994, 0.6401673436162745, 0.6692190488830515, 0.5355608084716531, 0.1607016489520975, 0.17892634774693394, 0.40993827135593797, 0.14875840419876263, 0.5691355057750078, 0.5311485312531362, 0.17600170916146995, 0.14796658569829202, 0.9584049380571832, 0.9685228504787224, 0.9796870653894081, 0.9617598217984363, 0.9509344091857269, 0.9350255420721421, 0.9684052831625909, 0.9553894214164202, 0.9445930668798361, 0.6427853842378951, 0.6790690226362796, 0.6902974261713246, 0.6947719221471165, 0.6658077080994589, 0.7292163849699465, 0.658871724817, 0.6646771316530373, 0.7047949937952835, 0.8477708826966429, 0.8184474458985065, 0.8413401409420806, 0.8488981310388497, 0.8615480373516471, 0.8884588735561793, 0.24161413957282973, 0.8522242879408604, 0.8429952265059978, 0.19194520772561408, 0.6079772659953457, 0.21118428376741782, 0.20867628538041016, 0.6928513748108465, 0.18823028769941663, 0.20455709926681942, 0.18429540624496799, 0.17575675633346566, 0.44706816053466936, 0.1794464237599439, 0.19137683147131912, 0.20858357327133115, 0.2101973221738268, 0.15702051342761647, 0.19346297325592055, 0.2538122387962408, 0.20706115367175482, 0.13030696965495114, 0.10469157141943519, 0.1497450894422111, 0.15933299948100832, 0.05391616336283356, 0.25788441103884074, 0.3582685992307787, 0.1729067398988995, 0.05125371364143705, 0.210104033788865, 0.2793100893731254, 0.27536068368232947, 0.0958138720381525, 0.3671020651231486, 0.315262791832432, 0.5888534927899205, 0.5135598458658046, 0.17863952016102613, 0.16650866224256755, 0.12720108319043988, 0.2661608887549246, 0.19437467778356787, 0.1884786793181248, 0.11583466680165255, 0.24130393802533634, 0.14593371703638935, 0.19440338470347762, 0.31590565307254515, 0.32857792268907493, 0.3516213755416788, 0.413003462969063, 0.38437381304458673, 0.43517482309319266, 0.3550161962418472, 0.31011802252118137, 0.2567956637754444, 0.7534542482827287, 0.7866519977220476, 0.712606011285464, 0.7563487530516566, 0.6876914261609655, 0.7269870345400424, 0.6682122570254893, 0.6677018768262187, 0.5409221784717151, 0.14617302951549793, 0.14904680296622064, 0.13733624820789314, 0.1293057973270857, 0.12304209568841185, 0.11406313531141166, 0.14721822142913643, 0.12423405268283061, 0.15003025373979295, 0.16727177827530615, 0.15782650203539084, 0.20573523223788037, 0.18241483195769093, 0.18038728502303947, 0.17773584445918655, 0.19908206460722244, 0.1975480694032492, 0.2313872160782795, 0.5398940887963831, 0.5230527814974779, 0.5938887337260481, 0.6007506114761149, 0.5600188291353275, 0.6161492540106346, 0.671087852973238, 0.7102278015832988, 0.509390060364781, 0.24289611206822947, 0.46914148735396144, 0.44958063391026515, 0.358965732647466, 0.39809877785356107, 0.45378807284340505, 0.4481047385355096, 0.5511956449241603, 0.4739675005797801, 0.20020052094578378, 0.24321048011013668, 0.19964820830050523, 0.20245782181682448, 0.19354923781900335, 0.25158483066443027, 0.19143090029384924, 0.23083706628052802, 0.20936823128161075, 0.6969825238266121, 0.7030878605632722, 0.2341174444415346, 0.6231324747426241, 0.632383262244628, 0.2389137905901645, 0.7081884625352797, 0.22942879936691474, 0.6058948126190795, 0.1638441967859564, 0.1697979053905334, 0.8200102865106242, 0.17700063378951159, 0.849947929305687, 0.18560840943193435, 0.8332441617445332, 0.8021489057829505, 0.8557987333730874, 0.8816573959846228, 0.38537189745446754, 0.8546823487867596, 0.1664726761636508, 0.16713710762262013, 0.20418371913654165, 0.21096578488037276, 0.12685824296052484, 0.6280665448703764, 0.2062392740058886, 0.1886172184243562, 0.200102263021818, 0.18675965729800303, 0.19364689692425907, 0.19251263611558955, 0.1936789314748325, 0.18581888255732126, 0.20077456342389632, 0.09255412363043924, 0.09478897886011894, 0.09357071267175232, 0.09316923710459246, 0.09491255269556698, 0.0886168323916039, 0.09976404426624763, 0.09114770304334985, 0.09650962321449208]}, "mutation_prompt": null}
{"id": "299bf028-6941-409c-961c-d2a3547cb1af", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Slightly larger initial population\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.rescale_interval = max(50, budget // 8)  # Adjusted interval for adaptation\n        self.memory = np.zeros((7, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 7:\n            recent_success = np.mean(self.success_rate_history[-7:])\n            base_factor = 0.4 + 0.3 * recent_success  # Adjusted base factor calculation\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.3, 1.2)\n            self.crossover_prob = np.clip(0.65 + 0.15 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        perturbation = np.random.uniform(-0.03, 0.03, self.dim)  # Reduced perturbation range\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 7 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.5 * self.population_size))  # More aggressive population reduction\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Self-adaptive Population Size and Memory-based Exploration for Improved Convergence.", "configspace": "", "generation": 52, "fitness": 0.41401663712157133, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.9030426342528949, 0.8975687325733682, 0.8977675411730905, 0.9004368417421416, 0.8912488434423163, 0.9038819334165167, 0.8966032585288888, 0.9020493966470383, 0.8995862223658052, 0.8262951494334282, 0.8234427145958498, 0.8078694014579327, 0.8176696222607494, 0.8336531254269344, 0.8215880171856165, 0.8194380059762655, 0.8134282515043478, 0.8469387844920744, 0.7338904227740297, 0.6938961516448623, 0.178688708974586, 0.6262166470059287, 0.7117857630999289, 0.1777426781801249, 0.5958382903062129, 0.754258600708106, 0.70522894670269, 0.17288788761045448, 0.7326583405246235, 0.607270646334232, 0.17646738823236652, 0.17635148722226945, 0.17684242685968998, 0.1510687545474919, 0.5073479089140442, 0.601776588743214, 0.9578235830333706, 0.9638847626724133, 0.9790221372480981, 0.9145930374214571, 0.9460709128911653, 0.9712977365512567, 0.9817603935163081, 0.9572279361656414, 0.9624603584519141, 0.6624437241822356, 0.4812231262939386, 0.6840585680137408, 0.4417705387639863, 0.5978274343804368, 0.49852710001904077, 0.4742411506404095, 0.3354840380627402, 0.37643405337373725, 0.8465710977475704, 0.8515414616825272, 0.8325595718375487, 0.8692503839079083, 0.8444365224669061, 0.8155070805441142, 0.8326537889803787, 0.22838578779231355, 0.754498433066336, 0.21494776197603116, 0.15920148325756112, 0.16603831955095416, 0.1292177526136975, 0.16766922474272816, 0.16039897509565348, 0.17795503917188238, 0.197096782283824, 0.15543486990330224, 0.15815073383278, 0.1260926804244804, 0.195128422380346, 0.21593281476758897, 0.4457881924877546, 0.3211961992787864, 0.20444651890791865, 0.19122337604257122, 0.24734322274480613, 0.10327651826864725, 0.22430100660646246, 0.21254632010903796, 0.3008653524313619, 0.15359459694103839, 0.008445644939469643, 0.11576778090343143, 0.11356557172531734, 0.1271450367735899, 0.2499733962856039, 0.16392667607603983, 0.3133233766052024, 0.18557638890806316, 0.20473677587572425, 0.19730926607024935, 0.2706271214173177, 0.1919802718859719, 0.11935503180347551, 0.10753208241475254, 0.11904722106335319, 0.19585460653089082, 0.0899978095398083, 0.16273429447929866, 0.0851160914791379, 0.1528575150963799, 0.1990534074004502, 0.20121001619977275, 0.32861581563082287, 0.3285784680794289, 0.3404907459183629, 0.3705442428958874, 0.2791764143225861, 0.3079158362002501, 0.3125007508632841, 0.250547496314686, 0.1723298253312816, 0.7184324696523676, 0.6970525728612134, 0.693191240016238, 0.4743103288440377, 0.7133148714101789, 0.6833954217467877, 0.6608191711186971, 0.6446177568608464, 0.600428230095258, 0.1485801582288121, 0.10146384107162232, 0.14368722540683243, 0.12099641807900696, 0.12230302015257566, 0.15590453875790977, 0.14136590102956648, 0.1679310900364248, 0.16245853341331096, 0.16080416242856843, 0.16382204839418613, 0.20879437804676504, 0.1555262531948205, 0.19118717425701592, 0.28145383266067925, 0.16691075139498113, 0.17354118405740826, 0.15526660521772373, 0.5784703206689537, 0.5951275604269122, 0.5941682272778253, 0.5514178775474602, 0.6424095322691619, 0.6147481933007171, 0.648834105142921, 0.7070257668163692, 0.7032585665801614, 0.25774352224248176, 0.34418198536981837, 0.4236992870696581, 0.3692418119515264, 0.35706459160531645, 0.35187985986668346, 0.276964324769695, 0.45484797421188095, 0.43676204812973696, 0.19898254120906134, 0.24310965747984448, 0.22291049252170236, 0.20105155099412664, 0.20859798654182804, 0.21087999980525363, 0.22169167724470185, 0.214296299446739, 0.22376826063799504, 0.7138917725806959, 0.6237393454115108, 0.6265287850659311, 0.6365110404193173, 0.21898770132122858, 0.22032736428613853, 0.6453053238408228, 0.7042492716672005, 0.2200106049614733, 0.7840795995444403, 0.8021073204086665, 0.8016862579843063, 0.1736445811192059, 0.1847458537101675, 0.8575996495303112, 0.159689741125842, 0.19554755686592196, 0.20762334839422025, 0.16771943860292704, 0.1625395914608031, 0.8240026057855234, 0.7963608539150442, 0.16617259725091704, 0.361722235507299, 0.6521776861841586, 0.21042265912099478, 0.20985049827906155, 0.19739839548885252, 0.18759260124420918, 0.19230381196486557, 0.1792088154435889, 0.1903667363853273, 0.202388983334168, 0.19956400079981218, 0.18401238033125933, 0.1823263303304984, 0.08947291467426088, 0.0780232535938098, 0.07789305917614564, 0.08576357379398392, 0.10371415836618303, 0.08655376078730348, 0.08591052047610392, 0.09057651070026951, 0.08862535004556449]}, "mutation_prompt": null}
{"id": "7ac94cae-3470-4ed7-8ba3-0c40b7a1d1d1", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 7 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.rescale_interval = max(30, budget // 12)\n        self.memory = np.zeros((8, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 8:\n            recent_success = np.mean(self.success_rate_history[-8:])\n            base_factor = 0.4 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.3 * np.random.randn(), 0.2, 1.3)\n            self.crossover_prob = np.clip(0.8 + 0.1 * recent_success + 0.15 * np.random.randn(), 0.3, 1.0)\n            # Store parameters in memory\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.05 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 12 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.55 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "StochasticAdaptiveDE", "description": "Stochastic Adaptive DE with Dynamic Strategy and Memory-based Intensification, enhancing exploration and exploitation for superior optimization.", "configspace": "", "generation": 53, "fitness": 0.40482843879981456, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.879053062555049, 0.8669028435628332, 0.8748632952473296, 0.8689641144616027, 0.8766702671759808, 0.8909595162871805, 0.8800387806371732, 0.8684901830757504, 0.8672587310008373, 0.7886838925221551, 0.7882222263487789, 0.7755906729272679, 0.7647651621089226, 0.7998710855998657, 0.7884831361067841, 0.7801020414912324, 0.7834602582771588, 0.8025878230984039, 0.3514058156963633, 0.6636601791864816, 0.6045460208062093, 0.1698131519848044, 0.543965257444558, 0.522165710149312, 0.49820124432939206, 0.6654449858146001, 0.6000562221228031, 0.14802763456515955, 0.151907982754642, 0.169187203431998, 0.10311801405781895, 0.15345990145224753, 0.17970044639635274, 0.16763607365647293, 0.17033115521867526, 0.5637162582094871, 0.9683861493589707, 0.9140778583982941, 0.9383224081548118, 0.9517750142746477, 0.9393994047923214, 0.969193041006627, 0.9536688908074089, 0.9517618940385949, 0.9694953677717091, 0.4959993082872507, 0.5810028308367474, 0.6261156077320054, 0.6284083700414049, 0.6668192383432535, 0.6914367833409865, 0.45425163190222284, 0.6573784249649444, 0.41609266882463747, 0.846316697594079, 0.8442619967415494, 0.3711756251921027, 0.2747046078419735, 0.8992261853517625, 0.849724537162202, 0.8991380617544403, 0.8709544888138603, 0.8695905257913845, 0.2737989868255294, 0.2110374104399534, 0.18147397317264946, 0.3396340481957565, 0.27274171512947887, 0.2105586547653414, 0.5229271241667026, 0.2611623034873971, 0.1810560210514952, 0.19536388810767658, 0.19834364303838914, 0.14881300547507148, 0.21396793930958025, 0.18336081089056078, 0.1740219243879808, 0.19917013998240019, 0.19191660580366587, 0.2199649229148407, 0.22540917893637236, 0.32566681770366057, 0.10772527625096895, 0.09045289333152273, 0.04259121729902615, 0.02529164596460154, 0.4842445378216871, 0.2460806159012976, 0.2823704739623649, 0.2435925268207203, 0.0939549178914052, 0.2951674826669487, 0.19334011295875642, 0.2901259712695913, 0.11362326713151594, 0.30166961547878257, 0.11205432862938847, 0.2626296946111115, 0.1572049087152675, 0.07486726178393277, 0.09383729564606913, 0.10671251391043712, 0.2616158931583502, 0.19256518170333659, 0.15778357059958725, 0.09143504702827521, 0.1703097088303861, 0.3846007457351711, 0.3556318631187805, 0.34439345908880703, 0.30201826737122783, 0.4246933031333956, 0.31745492887553417, 0.2373676112248373, 0.35048734196091, 0.35371814223220577, 0.7484048002726005, 0.6701865607761479, 0.6820484511187508, 0.7128329006191193, 0.8066664552176557, 0.6415558491180505, 0.6208095431904513, 0.617727056192855, 0.7125796302746987, 0.1433356846787106, 0.16060388360774414, 0.13287298264923886, 0.14147811353290052, 0.16092770904971965, 0.11516170836574269, 0.1399209289235569, 0.1318934067161568, 0.12307427148788741, 0.5379554375113271, 0.3453230480267785, 0.22662595456963408, 0.411172865559119, 0.16194973005591673, 0.24839545105210614, 0.6811852327025216, 0.19566587676666336, 0.49518011281837826, 0.5221339718781562, 0.547696587487736, 0.5633697466214378, 0.6176680561974086, 0.6787816935914031, 0.5097506478787657, 0.6643662950293194, 0.7047806863431768, 0.48460236321522654, 0.21088038219750693, 0.3472811290921938, 0.4450266368369411, 0.4163274637178638, 0.43328069986661, 0.37863362162490755, 0.5605271355001246, 0.5756989380790177, 0.3422620487693332, 0.20877760193593453, 0.21269348825555778, 0.23241602668193784, 0.1980579909777287, 0.19934600510579348, 0.22291107783448405, 0.23125856384287513, 0.2073367518487529, 0.21152490655934408, 0.24824457250445842, 0.6223907140108844, 0.21766899032623555, 0.24408574955256646, 0.23999093352549916, 0.24633867102230256, 0.7329449448686993, 0.20597524949485524, 0.23563826328208348, 0.2076797667212461, 0.19361267204980537, 0.8287904937141608, 0.17744591218809525, 0.19680408520166015, 0.1982811163788044, 0.167480144718546, 0.17504548414850452, 0.8190617243030176, 0.8335279075326898, 0.20994819301100032, 0.15448148331726586, 0.16625795935577625, 0.20564602478714766, 0.20794599473094422, 0.20961579663387742, 0.7413165981326324, 0.209805772063535, 0.1933853976123424, 0.2164819151274051, 0.21074328276786314, 0.19473937408016095, 0.2233924580290142, 0.18222487204557636, 0.2007913955815528, 0.20534683091924089, 0.1976368155822602, 0.10440366868835593, 0.09712096685609972, 0.0945275222063705, 0.08738737914029293, 0.09500462121302222, 0.09089841932065756, 0.11260340171991212, 0.09442211121159583, 0.0908942644853934]}, "mutation_prompt": null}
{"id": "0a0f9921-770c-48d5-9087-a7fb97d4b5a4", "solution": "import numpy as np\n\nclass AdaptiveRankBasedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.8\n        self.success_rate_history = []\n        self.memory = np.zeros((5, 2))  # Memory to store past success rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= 5:\n            recent_success = np.mean(self.success_rate_history[-5:])\n            base_factor = 0.4 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.3, 1.0)\n            self.crossover_prob = np.clip(0.7 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def rank_based_selection(self, fitness):\n        ranks = np.argsort(fitness)\n        rank_prob = np.cumsum(1.0 / (np.arange(len(fitness)) + 1))\n        rank_prob /= np.sum(rank_prob)\n        return ranks[np.argmax(np.random.rand() < rank_prob)]\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = self.rank_based_selection(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.3:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = self.rank_based_selection(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveRankBasedDE", "description": "Adaptive Differential Evolution Algorithm with Stochastic Rank-based Selection and Memory-based Intensification.", "configspace": "", "generation": 54, "fitness": 0.4058432711649062, "feedback": "The algorithm AdaptiveRankBasedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.8580409148016103, 0.8604475415157863, 0.8741205458196568, 0.8624342277618309, 0.8553426866793024, 0.861431551762488, 0.8443364902934216, 0.8783042498195996, 0.8520406357668506, 0.763416209505903, 0.7532602147268803, 0.7494663003651645, 0.7379394933955774, 0.751550874744054, 0.763312525638018, 0.750688053066016, 0.7562443157698274, 0.7340588477376675, 0.5453910082269546, 0.4618158500459383, 0.4650361529439496, 0.4393696042591547, 0.4002141344023977, 0.4049592901043576, 0.5950877484754056, 0.4568267982924148, 0.4563421195563381, 0.4883061493719464, 0.17059188876721132, 0.5029053702292985, 0.16230883521246908, 0.4052732491589699, 0.14586080015255753, 0.15998944465245946, 0.3561091982498349, 0.15629422043172558, 0.9499610170707974, 0.9829751912545525, 0.9458123122925908, 0.9608455481343254, 0.9398786622545552, 0.9642644420149078, 0.9549840851553794, 0.9442995633596466, 0.9405124777172944, 0.6051742771636027, 0.5465178051757013, 0.5913936316185064, 0.544553171663223, 0.6030999607711329, 0.6162980009970254, 0.4154100299511032, 0.5098957256467096, 0.5451688514034886, 0.738113851189043, 0.7548687508107079, 0.8104767650386218, 0.7997024048861774, 0.7223000371683028, 0.7752836758675697, 0.7593320123972581, 0.7789980525783535, 0.8080559249535494, 0.19605579436217768, 0.2439571078557834, 0.1721183492616497, 0.23693634491841942, 0.12980096186485957, 0.22372469226560365, 0.18315331518568967, 0.18635865901912974, 0.3177698924862018, 0.2278771018790715, 0.1677301600536375, 0.20322762455076793, 0.2048322232097909, 0.2373407599586821, 0.4695331192212301, 0.247062015376457, 0.2098662245649935, 0.19525317237444406, 0.11362358878983692, 0.31471165087604835, 0.1098026115270917, 0.24002386347328997, 0.0952569587472839, 0.26190783612032054, 0.2692681959467491, 0.01208657806120339, 0.14816636216935608, 0.44726475847060887, 0.4336241232455199, 0.35264313683697057, 0.3593077540149714, 0.10690784676587195, 0.09246059061437595, 0.17748524836378987, 0.3057995497805752, 0.25759889256358104, 0.13430235872840346, 0.12447052120826296, 0.11501162710707358, 0.14142074413413197, 0.14203488079419857, 0.0793078391171812, 0.07963902517579813, 0.11227127285081773, 0.17458573179632209, 0.16331643621609093, 0.3257380791827087, 0.24522408738405543, 0.2778632821932818, 0.3031078459170964, 0.29464696749004937, 0.25617390797505857, 0.24203306161656746, 0.2488041985339633, 0.655342724793157, 0.6005646478018154, 0.6157528622864286, 0.6771590784197062, 0.6970290106119549, 0.6992138359648823, 0.6157561721207341, 0.6312319507090722, 0.6638593253363043, 0.12209407867269861, 0.12219453488641685, 0.11936924254550318, 0.1280892250015968, 0.1250480677459207, 0.1237633908905642, 0.11014101078257355, 0.15469339813362581, 0.13357969711143447, 0.18673360336743505, 0.14655175542824672, 0.1928386432121365, 0.2024424802306115, 0.24123264735272165, 0.16966274892553224, 0.2602337256897084, 0.14763349016431238, 0.17295529692944656, 0.4749233302677007, 0.46575596001752273, 0.4894243939751949, 0.5579405980598429, 0.5027843071715958, 0.4781906587355951, 0.5507233263228613, 0.5998606698299394, 0.5492653105829912, 0.32470565201906654, 0.2979591257856883, 0.3247401726239676, 0.3510838158287619, 0.3575568719604626, 0.33261893538869747, 0.3859847108857851, 0.3700030812543188, 0.4000392385883913, 0.2299811152806166, 0.20192653885784406, 0.2025342324862629, 0.20956776627238527, 0.226010536636842, 0.22627468141386808, 0.2079522079190943, 0.2105316008136744, 0.22082990770328725, 0.4517103550873889, 0.44989504649886314, 0.6613392802509297, 0.35792180204355795, 0.49591315693323423, 0.38842429330426387, 0.4707914149685597, 0.508574679236087, 0.46527420048195023, 0.6243918078915696, 0.777131685561723, 0.6907056869467084, 0.17170179931671536, 0.18199830597984745, 0.1958863292933961, 0.540273581937301, 0.7929384927334091, 0.8351460629068386, 0.7220467357594893, 0.2046324162022527, 0.6974908113476659, 0.7373163595393393, 0.5054926190304216, 0.3400938298555457, 0.21089227488870543, 0.525946185721961, 0.21123834381867335, 0.19616881627214422, 0.20280714734459993, 0.193297747782754, 0.19161685287537467, 0.18651852323686657, 0.21304228320207763, 0.18984614843065462, 0.19404970481251915, 0.19641271308334085, 0.0835418736422574, 0.11440947513190836, 0.09341401209184319, 0.0886816907245973, 0.08437042976540521, 0.08605510432925856, 0.08934779842358997, 0.08623635519754402, 0.09504424350556218]}, "mutation_prompt": null}
{"id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.4, 1.3)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.1 * np.random.randn(), 0.5, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.05 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:  # More frequent population control\n            self.population_size = max(20, int(0.7 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Dynamic Intensification and Population Control.", "configspace": "", "generation": 55, "fitness": 0.4666353296377316, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.26.", "error": "", "parent_id": "380a51dc-5efb-47db-aed7-df5d7a68f6ed", "metadata": {"aucs": [0.8600580482991288, 0.8566379568448086, 0.8496941298656548, 0.8648547653886303, 0.8627132017100204, 0.8626319606972419, 0.8566251447823101, 0.8539978446481107, 0.8622169598405758, 0.7597740597596421, 0.7664931270088835, 0.7565193667902264, 0.7779004016061496, 0.7486714114568609, 0.7615822791759086, 0.7596783769958653, 0.49799695969090907, 0.7505074047889393, 0.5249729369356335, 0.5199221785308983, 0.3972264044904389, 0.3810296813348485, 0.4912466358448093, 0.5470453178192775, 0.4583237033827222, 0.5202405618713067, 0.16673534681325197, 0.48889145695291425, 0.14218747708471924, 0.15451863564990875, 0.4360019308225499, 0.1397170445124457, 0.15838740793613193, 0.530841015906651, 0.30615020145777294, 0.15169638678312936, 0.9481740236682212, 0.9512989903781389, 0.9548381863006807, 0.9706270448538575, 0.969054577938291, 0.9521567225468748, 0.955574282372695, 0.9705297400757935, 0.961853859553663, 0.6718599130800778, 0.6963889708537752, 0.6596225122780628, 0.659125833920299, 0.6234804624370285, 0.6705099817134814, 0.6791157503288782, 0.6635013029042052, 0.645342244463895, 0.8495834786509057, 0.8320256326139733, 0.8544380475286989, 0.8593212162910555, 0.8497161685990867, 0.8178796111805887, 0.8185552370980234, 0.8403118015875116, 0.8215153395884381, 0.4527366710084757, 0.38649729678840417, 0.43355135587613836, 0.5312660605339385, 0.46027544802820064, 0.5461568743460925, 0.3213154696824385, 0.2990149351135607, 0.4120178404565086, 0.27258153066847735, 0.32875685061516824, 0.3331423296054592, 0.42275325492938853, 0.6089174402367753, 0.32914422873543514, 0.4947747118254371, 0.2778754396241143, 0.5792033995773493, 0.5571801361022266, 0.4077217671312119, 0.6078585853723341, 0.5667546297816783, 0.5316253877206055, 0.5385819759570736, 0.5821573565111171, 0.46882881870115767, 0.5317103831340472, 0.6448387994577619, 0.5195799045348353, 0.6562387891834036, 0.18462394234788704, 0.6447327793509532, 0.6242875863018786, 0.6673294113453885, 0.6579371451107263, 0.6611319817460006, 0.30139023676067067, 0.07208383244061112, 0.20937435221544243, 0.39425239173008475, 0.4419618779396307, 0.2986541841101932, 0.3092896794383465, 0.11155794357861559, 0.1630669215945456, 0.29697340633789027, 0.43038907728722253, 0.45403328595886006, 0.5052395782194057, 0.47660615907753556, 0.44442461392954447, 0.38513173926742916, 0.3709781137497583, 0.47014915232275445, 0.7583579472257237, 0.7843684972954277, 0.7831483129742245, 0.680024069260581, 0.7903284198473964, 0.7578175856658934, 0.8040403429904296, 0.7828228181364272, 0.7683074388787656, 0.1397317831255317, 0.14383384425583645, 0.1128853460035052, 0.13530927414259442, 0.11711407483294445, 0.15821040137000886, 0.12999198996816064, 0.14595670321500842, 0.12069864958334164, 0.19777676702260594, 0.22062586796406936, 0.1920795911184643, 0.1489668794241532, 0.20973074315024265, 0.20654322994962004, 0.22215070101040169, 0.17430239657247892, 0.2016294674605259, 0.49484915677146046, 0.5081594197383501, 0.5708723419077797, 0.5466160669810038, 0.4670333848831987, 0.5325536830951414, 0.5829681256735649, 0.5860734203448494, 0.5486705150251217, 0.41026053122527373, 0.355012322066537, 0.38687219623280533, 0.36423696149455587, 0.41546449215438486, 0.43162384444270796, 0.4260766763424, 0.4194161918270001, 0.4356086074712746, 0.20490488112246308, 0.20434962864363837, 0.1980571695660588, 0.1804025884092303, 0.19060745964491121, 0.2085452397157691, 0.18552954308671243, 0.19619313628818424, 0.216256067128335, 0.5169269551179024, 0.5518540408176803, 0.20988544233658213, 0.6392949218505126, 0.2008466962598745, 0.47969755756568777, 0.5560774645002418, 0.20426571963634899, 0.23597034511026127, 0.8357319370817792, 0.19604584902731303, 0.1998022062800695, 0.810732403694816, 0.1903550432263531, 0.8510796530284033, 0.2053194411123428, 0.7123216485010093, 0.18206177781594435, 0.7813354919816526, 0.8241862934288289, 0.20454635454221137, 0.775572347110532, 0.2067096520628383, 0.20232064449409093, 0.20799719852041365, 0.20792989888562108, 0.20696974828707815, 0.1880087088877208, 0.18263904030267464, 0.20904457601846393, 0.1944095065884428, 0.1959323225582683, 0.20108550526147861, 0.18820725259977367, 0.1883718242726503, 0.18433152606127656, 0.09674107792256237, 0.08821795934786336, 0.13631039977658888, 0.08700960107078148, 0.08771389558867848, 0.09998531617660866, 0.09092953630327794, 0.08342699150662425, 0.09231691581714496]}, "mutation_prompt": null}
{"id": "9bc128a7-df97-42e1-afe6-529048a1eabd", "solution": "import numpy as np\n\nclass EvolutionaryAdaptivePopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted slightly larger population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Higher initial mutation factor\n        self.crossover_prob = 0.85  # Slightly reduced crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size for parameter adaptation\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.2 * np.random.randn(), 0.5, 1.4)  # Expanded mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.1 * np.random.randn(), 0.4, 0.95)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 6 == 0 and self.population_size > 25:  # Adjusted control frequency\n            self.population_size = max(25, int(0.8 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EvolutionaryAdaptivePopulation", "description": "Evolutionary Population Dynamics with Adaptive Intensification and Mutation Control for Efficient Search.", "configspace": "", "generation": 56, "fitness": 0.3922485044976022, "feedback": "The algorithm EvolutionaryAdaptivePopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.7955778177827919, 0.8077520407908355, 0.7971433118678705, 0.815701414343571, 0.8075248373859008, 0.8221635255329939, 0.8015066909163988, 0.8161342053182112, 0.7969531348107913, 0.6857004129221749, 0.7015453981393763, 0.6710105027285034, 0.6852294968478543, 0.6714570229099072, 0.6506231747521184, 0.6816926826300884, 0.6813038390428744, 0.6822103290813559, 0.34258899072588744, 0.408762039060091, 0.3530803263344652, 0.3315090530326392, 0.26396267172881316, 0.25279363627844087, 0.25772918266660927, 0.3957202847160526, 0.37391058608992433, 0.15830435250923802, 0.15337375249118035, 0.23620620849678076, 0.15721705099707783, 0.28017820034959773, 0.15161051030016137, 0.13358621981478158, 0.24020462937730958, 0.14889168497363714, 0.9396756095808994, 0.961813065252808, 0.9358998403671814, 0.9369836351370879, 0.932643120428784, 0.9445608751606649, 0.9615785085648297, 0.9611377004569189, 0.9191942349631861, 0.5311702455540296, 0.5484678983529325, 0.5220929744228986, 0.5433979834804302, 0.541342916120228, 0.4896816182664332, 0.541886343758047, 0.5095808772951997, 0.5210994501912993, 0.7831974378881504, 0.6747154708247225, 0.7597372533442952, 0.8022372290915608, 0.7415504765221161, 0.713454833880234, 0.7333339958000402, 0.7109327057230388, 0.7423485288868781, 0.3893731820733958, 0.3583476282854332, 0.3138694860107606, 0.2910860250106817, 0.34671026994521503, 0.2772894799371196, 0.3933867890683297, 0.22247264185134674, 0.3401197145154833, 0.287168321332541, 0.18950482401382818, 0.3366143534465482, 0.2886798275612321, 0.2588201178961369, 0.386478143246329, 0.27946014613311776, 0.39029618453438797, 0.3894149953344591, 0.28834382900386557, 0.20877485367518533, 0.23057490065299913, 0.2951439905307123, 0.24661054233528157, 0.2394144504811685, 0.25502518922964745, 0.2498446725045721, 0.2592721680740817, 0.37781060141134803, 0.39705381588263877, 0.41710215390034455, 0.3595487961335958, 0.39798109558471095, 0.3478769941236757, 0.40496885130212434, 0.4434954045565318, 0.413203306615223, 0.1036932351168236, 0.13513479958947305, 0.1525029229490299, 0.11764949986225604, 0.14054200316842036, 0.14416748128796575, 0.1603629243952892, 0.1340300380498045, 0.12090274288366232, 0.266801367938421, 0.22494688869661583, 0.2226677620106321, 0.26015812668574734, 0.28971449220476586, 0.2732373700690335, 0.2518037619138719, 0.2560921880559356, 0.28167348071203946, 0.661996563350755, 0.664879135322596, 0.6490523791955563, 0.6550734507167051, 0.6334092446465613, 0.5958672105067595, 0.6556627060626807, 0.6617527771399923, 0.631424248145384, 0.12187134071647543, 0.15247068437877265, 0.10367052039786795, 0.10669679187775183, 0.12011000324407795, 0.11861744382279049, 0.13192633388280106, 0.1207531106684373, 0.09447836917915176, 0.15613968710332415, 0.15394898015529013, 0.2592971617868238, 0.16723845377662705, 0.15324414112382856, 0.19554856856054592, 0.16527839708961456, 0.19279891445954045, 0.22058098089359324, 0.4017744798125733, 0.42042018361880573, 0.41086514120436346, 0.41979600523965077, 0.4298035864676728, 0.4338240963957922, 0.4529234273042686, 0.45436763942571723, 0.4305028709968852, 0.2603274224376171, 0.2613510606161463, 0.3066842585056444, 0.27515762871405536, 0.2890946773904699, 0.28035238911513993, 0.30552172679853784, 0.3327461780333363, 0.3114859851451359, 0.2533318247187544, 0.2230783544403886, 0.21081638490573085, 0.2092157817785143, 0.2386142950263327, 0.19374100278399875, 0.21102511114602673, 0.18795398907220529, 0.1883329121230357, 0.2700996201693646, 0.3090474280736153, 0.19377361295468976, 0.5479992893475731, 0.22118918335785043, 0.4020647602455122, 0.41669223497149144, 0.49030479351999523, 0.37323611704004356, 0.7773241884203571, 0.7024562999619568, 0.18436979888877536, 0.16523000894501894, 0.635176346265728, 0.5649454564856471, 0.6867718886935203, 0.18185089674827337, 0.7160840667682504, 0.6789649280576363, 0.16949769983674434, 0.743168290160525, 0.6840572264634939, 0.16442807452572983, 0.3731970596769749, 0.20159508812735805, 0.6286076326025137, 0.6899988829577673, 0.1820355961540162, 0.18666842056637112, 0.21121070977913592, 0.20639160391613876, 0.20394739455323918, 0.2150581324916534, 0.20482683697665527, 0.19392369536848586, 0.21347316291161256, 0.08129569694794225, 0.08837298460335385, 0.07849201928778415, 0.08063853491161865, 0.09278023690910153, 0.08816847845676135, 0.09454086546674678, 0.07728274543739411, 0.09575009321149752]}, "mutation_prompt": null}
{"id": "0e628ae5-6aaa-4020-84d4-6003054a5952", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 8  # Reduced memory size for faster adaptation\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.0)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 30:  # More frequent population control\n            self.population_size = max(30, int(0.75 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic DE with Optimized Parameter Learning and Exploration-Exploitation Balance.", "configspace": "", "generation": 57, "fitness": 0.3875497361502515, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.7567910065921768, 0.7895488080528792, 0.7827534625472159, 0.7873470574906831, 0.7870242951389593, 0.8064239211536521, 0.7988449746868889, 0.7852759878015945, 0.7847312769475636, 0.6265683289716266, 0.6346249807186031, 0.626582681027632, 0.6140972373839768, 0.6449443493843476, 0.6387448658439778, 0.6406615744693687, 0.6678606221539949, 0.6012991812492177, 0.1567198126982179, 0.14438359252572008, 0.1437290396150378, 0.16464322259762798, 0.13237138478016552, 0.1268247187797621, 0.13196576507284408, 0.1782552595338266, 0.15923945353937563, 0.13010044566164325, 0.14329223125988522, 0.11429587860463486, 0.15421499430315855, 0.1522990866578533, 0.14576473526854916, 0.1489882145434489, 0.13548738630751556, 0.1372677835638082, 0.965307375521672, 0.93561684873777, 0.9405167128257169, 0.9286814989926788, 0.9330561251842858, 0.9456113166309889, 0.9478922841605061, 0.9126045913956947, 0.9608978569511559, 0.49372957873359524, 0.4928409099265576, 0.4688843663876473, 0.485387840617136, 0.524604754615337, 0.5129073893210019, 0.5083822969893006, 0.5424891562036911, 0.5258184388692704, 0.7362189710033697, 0.7499785966417669, 0.7153635018319071, 0.7783171573830241, 0.7973396500386842, 0.7538878558719997, 0.7615041077281784, 0.763917819743889, 0.794743613579888, 0.38396748890566235, 0.3827107801880679, 0.5150914700272439, 0.36843678188444595, 0.44983203776176506, 0.3741428828119616, 0.4209829834036576, 0.3894463607210311, 0.4960655224986046, 0.33648892032855915, 0.2461776596636699, 0.5601416181695, 0.37429305928997225, 0.35625335717980056, 0.3064524919160412, 0.3462286566748176, 0.3833821788023787, 0.3879838535448311, 0.36244888092868, 0.3813388595334769, 0.3674405080163483, 0.37724216932317356, 0.444098565188209, 0.3710498521852158, 0.404971111392996, 0.42621767022247825, 0.3787004536173325, 0.5028841831492967, 0.5315752605589008, 0.5227946794392992, 0.49880142693167107, 0.5308300372955967, 0.5381656449935183, 0.5601021663812011, 0.5390485062609828, 0.5406218390839771, 0.10054271177794838, 0.10506109706025568, 0.14537170633240948, 0.1923804265725133, 0.15975574305088192, 0.2455384157958601, 0.16015388220965143, 0.19248697087789202, 0.18684790097794268, 0.2924496337236361, 0.3105755017088365, 0.28506544996080807, 0.3100332427350764, 0.3303677565905032, 0.3158687200456398, 0.30751688294885726, 0.32541806032421394, 0.31814582871367225, 0.6956435180402774, 0.6786482035761421, 0.7082482119653424, 0.7026527823601392, 0.7063595980574495, 0.6945911824946114, 0.6925360744815282, 0.6913323957867246, 0.6877761144300348, 0.1269502952839543, 0.11003951668942213, 0.12565531437851463, 0.13194770650915633, 0.10270704312320889, 0.11526131153275887, 0.12500219530038625, 0.09790297585361563, 0.09848505213232106, 0.3182638119363159, 0.1553629028949015, 0.20882546149062997, 0.15718839766739023, 0.18186812317116052, 0.18000287939879744, 0.18770827028301296, 0.18533808929115636, 0.3162469838884284, 0.4207990129903785, 0.40570745729126534, 0.41466463716828306, 0.40152990005814915, 0.39466152450117753, 0.400508770690464, 0.4188403532322317, 0.44216691783895434, 0.41665358912302264, 0.31415028312139326, 0.31320536245534636, 0.32777328439427766, 0.2891185406455934, 0.3224630295432387, 0.2701229813613475, 0.3421172949326735, 0.34315527285496605, 0.3162446681693052, 0.18370895814489152, 0.24966165325478007, 0.2076383076580881, 0.23670542138358708, 0.20216038684887394, 0.23630023292843094, 0.1895277624402325, 0.2161702451064922, 0.22451035315171508, 0.3280186317983088, 0.37846451443455664, 0.21770811805146095, 0.35076773888366186, 0.3786773515311552, 0.500640992678047, 0.31181262280324806, 0.3541763629534269, 0.2885921605728462, 0.1517422533033883, 0.17802829675192466, 0.19144951699340407, 0.1836458735614921, 0.19115226900443105, 0.6777354269483287, 0.19515027190072198, 0.7564482012701659, 0.6746368986355871, 0.19810216515028234, 0.2012750029219481, 0.20275019300262997, 0.6134296271275427, 0.1565967959633584, 0.18849451737797396, 0.2100775368589245, 0.20708344046757354, 0.21064459556908277, 0.21289280041865122, 0.18767413865578897, 0.18746532641361136, 0.19766069344657877, 0.20985439054290855, 0.18993864506630576, 0.22915299961054725, 0.1986445910217468, 0.21542095052174326, 0.1116135646580777, 0.08134455303429544, 0.08604028077986237, 0.09908627262657488, 0.0847826998972312, 0.09380766059719103, 0.07949925107094313, 0.08222172682314921, 0.09307239095201025]}, "mutation_prompt": null}
{"id": "c3fdeb82-8b60-4002-a9c8-a51cc125b54e", "solution": "import numpy as np\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Adjusted memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.55 + 0.45 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.08 * np.random.randn(), 0.6, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def entangled_intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn()  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        quantum_shift = np.sin(perturbation) * np.cos(perturbation)\n        candidate = np.clip(best_individual + quantum_shift, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:  # Adjusted frequency and size\n            self.population_size = max(25, int(0.8 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.entangled_intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired Adaptive Memetic Differential Evolution utilizing Entangled Intensification for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 58, "fitness": 0.41206268375384536, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8381258393936709, 0.8205713344705496, 0.8481464985012913, 0.8529405285062522, 0.8269509180006356, 0.8456810631433899, 0.8342044438807066, 0.8396458085174296, 0.8355581708525277, 0.7232977850541931, 0.7140034700292844, 0.7249350795795267, 0.7187696849348968, 0.7057593216960614, 0.7247434904260417, 0.7089995875175517, 0.7107299188048254, 0.7294189274000646, 0.44199907237479197, 0.30886757045569413, 0.4557167519469498, 0.17279108233464735, 0.383000399534156, 0.21051371904386207, 0.34759207978477247, 0.19559331663791002, 0.2971329190011508, 0.14771401129230877, 0.4087780795757311, 0.1537771707307124, 0.15429669462880935, 0.1684560990971844, 0.2633687666373612, 0.38048655635564554, 0.1421253553342502, 0.1626683057101842, 0.9560477394082021, 0.9542273815631578, 0.9323634600099842, 0.9579147062868576, 0.9520449174518706, 0.9575028636870193, 0.9528314793930155, 0.9729078549014488, 0.9325540778710064, 0.612341392303157, 0.548699428787174, 0.5868147473497474, 0.6240922623849229, 0.6147486943277455, 0.5657738364347893, 0.5662487155710669, 0.5883128816385983, 0.5655231161596953, 0.7589729054562335, 0.7680017443082761, 0.7902097797474446, 0.7679025592356115, 0.8333906095552597, 0.763848326249121, 0.8059707050731635, 0.8088974645528784, 0.7882633134379471, 0.31901590973703564, 0.23997060244062773, 0.38799551155230627, 0.22215068439909824, 0.3496640630493707, 0.3993974015628887, 0.3242929080223397, 0.4092387575428076, 0.38164466736723746, 0.25018403409308854, 0.23578131747715447, 0.12343433061615228, 0.3852343754278982, 0.23906097609637433, 0.44682009889732577, 0.40747053610975836, 0.3702353779237484, 0.3088996585644057, 0.353187150442147, 0.26403750981314367, 0.2610818342441926, 0.31118985343084804, 0.2974592005065475, 0.26303728069662835, 0.381503176281491, 0.3132708717721856, 0.3745216519128014, 0.45787539686913314, 0.4358742724998692, 0.4258199912855487, 0.47234391968321143, 0.3376881818501909, 0.4328929941837155, 0.6034285252917562, 0.4762041322406684, 0.5343538109284256, 0.2260866048648421, 0.10868739417177986, 0.10105978073899313, 0.2775951343616043, 0.2632138971335597, 0.1925321168176496, 0.1153776992511164, 0.23467707068345445, 0.1573122088801161, 0.32687078720089635, 0.2492131003050415, 0.29817549293742107, 0.3390202539319441, 0.3029624921580706, 0.32296469830926666, 0.3172453003294702, 0.2917059647253869, 0.3094616276462635, 0.709314246314849, 0.7137933922814378, 0.7088759834070765, 0.7140613598214773, 0.6834028151953027, 0.7240705441722657, 0.7104396521832135, 0.6960310521374666, 0.6819925676076957, 0.1268781548422827, 0.1346740524587423, 0.1304524884178585, 0.10228309076687347, 0.11028785152113052, 0.11094038297329845, 0.12035368133077828, 0.1356981810122312, 0.13004690056690438, 0.15208078021193272, 0.15166321796482485, 0.21586303226844616, 0.19416124800892043, 0.20520732945000442, 0.21093208111105755, 0.4028546312743869, 0.16645259701574577, 0.15956036163079024, 0.4881065706489234, 0.46450551076126145, 0.4792320249228763, 0.44694334591451157, 0.4744875422467645, 0.4680749743495314, 0.5099531670125284, 0.46935847369556016, 0.4951558867539133, 0.3122184530067178, 0.3315561599099375, 0.2717419204501793, 0.2978617454932808, 0.3266377922500675, 0.32666654319509125, 0.3913455893430027, 0.3587546197265796, 0.37620288632938204, 0.2013895382288723, 0.22948959259607882, 0.27199785983537106, 0.23117703157818437, 0.2023891666866965, 0.18797185179888853, 0.19839862817136444, 0.23844230735861416, 0.20603905623155283, 0.4314702317419653, 0.3168261115293759, 0.22651726934971217, 0.5793902074241373, 0.47221513299276463, 0.4980333457178632, 0.23204584128428563, 0.35382604545997687, 0.5477562689152999, 0.18152225160999147, 0.16633893511150677, 0.181812517261015, 0.18528319033678065, 0.18972432200907507, 0.1865885197162067, 0.7968469451974933, 0.6694641715336682, 0.1896197446821537, 0.6987411251675166, 0.16652235680294325, 0.20687073546821888, 0.749262854109539, 0.7324192929760496, 0.6546945179608379, 0.8069982188335146, 0.2074849395278494, 0.21045201494732646, 0.21347898511897367, 0.20064127622177708, 0.21159013282828354, 0.20264959351649636, 0.20851903609268918, 0.2301235267724916, 0.21104826392339393, 0.18770551479172715, 0.18376788697474722, 0.09487941501694108, 0.08694203901222775, 0.08091483037253677, 0.10418870267975233, 0.09219827811402992, 0.09004283037759109, 0.08485482317975235, 0.08083099799516547, 0.0897771621428145]}, "mutation_prompt": null}
{"id": "443a3fd8-db15-4121-9d45-3050a55768a4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Reduced initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Slightly increased mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.4)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.7 + 0.3 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:  # More frequent population control\n            self.population_size = max(25, int(0.6 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Further increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Improved Adaptive Memetic DE with Enhanced Parameter Adaptation and Selective Intensification for Robust Optimization.", "configspace": "", "generation": 59, "fitness": 0.425681542263978, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8516057852511518, 0.8410711543408856, 0.8455597435063694, 0.84143976827209, 0.8561145926910929, 0.8420660794961197, 0.8574350897378703, 0.8508018393519562, 0.8413512881031567, 0.7405114412877226, 0.7494767952600407, 0.7195744826166464, 0.729006354661326, 0.723349666634612, 0.732690581013927, 0.7294906935682364, 0.7286077876781657, 0.7377006614935204, 0.5142556221126053, 0.5626196780218913, 0.4566263866138477, 0.33328728284367426, 0.529419106456991, 0.39479975085371444, 0.3570037006873438, 0.4754258018961054, 0.5047186459715709, 0.38624753010343904, 0.16534677039247458, 0.15991863709192822, 0.5356732305542651, 0.46985765180345596, 0.11618427386544738, 0.17170169221650888, 0.14695846383807643, 0.1568244818826603, 0.9627831097248803, 0.9670147333406484, 0.9744668086264692, 0.93289495355707, 0.9577440185938307, 0.9406276770311426, 0.9497037003814786, 0.9783090712181455, 0.9588756363769688, 0.6285204627068918, 0.580361241822928, 0.5706409913154099, 0.6699391372368799, 0.5884445174423616, 0.6079932696769199, 0.5916479842560629, 0.6153302532056703, 0.6272732801448282, 0.7606149777379635, 0.7837917303257441, 0.756606866219417, 0.7781603154445891, 0.771581781611306, 0.8161926932207821, 0.7822604606259113, 0.814102505195909, 0.7502258128644675, 0.3044646086570504, 0.2633172546759407, 0.43097990681235676, 0.4908788113656454, 0.34651322733672174, 0.25561612639102727, 0.23079899422543237, 0.6034727284740448, 0.2480015442848681, 0.23430583132873528, 0.22530141178687912, 0.24217009070356588, 0.3071534414178465, 0.3400841167779849, 0.22731380861873685, 0.3072240766715105, 0.259417072533074, 0.2489746123229838, 0.25502295208482306, 0.13181040417217482, 0.23836083818210907, 0.24707483782134754, 0.22816628681715012, 0.3310956103705346, 0.27507350632868743, 0.3678098786715628, 0.2651095770716323, 0.3978394440410662, 0.41734190881964606, 0.38415383863531916, 0.35824019992852896, 0.3678127500504954, 0.3686251340023228, 0.4691982494253295, 0.43963386830432716, 0.4902545560228435, 0.11567816028224842, 0.083680418409807, 0.17299104807514065, 0.214518044528756, 0.22158757081790015, 0.14705938189176415, 0.1392512455769842, 0.16341677301622426, 0.22069227762778865, 0.2808175498993948, 0.26155242227181597, 0.2699966524948114, 0.3441028366989959, 0.3202617451492711, 0.3399765876785057, 0.29676128729797824, 0.295108742302698, 0.35082414462240774, 0.7429370357748244, 0.7307301041376841, 0.7250864534341475, 0.7021894698919074, 0.6782281869388294, 0.728967420157139, 0.7321688097456849, 0.6825501589984863, 0.6937037888585696, 0.13222766944206488, 0.2136390758460075, 0.1212409478163945, 0.14961685876996322, 0.12951684955056209, 0.11198637678724643, 0.12358557376408374, 0.12898492088697822, 0.1439605151612483, 0.19379970184951656, 0.15945514244375703, 0.15483485384689322, 0.26682941288690176, 0.31085478324916194, 0.20971736236765215, 0.18749887628771367, 0.16941961376003023, 0.22728085419560062, 0.4937467052278093, 0.46929376713730475, 0.44658619210749795, 0.5043117181385663, 0.46001053285970905, 0.4600434748498825, 0.5664206759092589, 0.572345328885727, 0.5224365964668404, 0.3370886441919613, 0.3006836980300873, 0.32569229844194103, 0.3217020691793817, 0.2900951165543848, 0.31594402044859304, 0.3706976146685663, 0.3705938095770879, 0.3671691155214931, 0.2099922719637397, 0.19172264517187598, 0.18964903542253664, 0.21396823958128242, 0.21258959818986478, 0.24667130866937315, 0.2443795668790918, 0.24564246545791202, 0.20642331586468365, 0.6409164236094154, 0.4266172086753416, 0.3427534927684083, 0.36766227921164996, 0.49421133520210037, 0.27109193837056345, 0.5913383125484024, 0.22749553768029585, 0.5709757931504673, 0.16191165953413966, 0.8084980903928473, 0.18127746837706904, 0.7000213905547006, 0.6786216006686823, 0.73889796663538, 0.18317178051603333, 0.1915233228699973, 0.7989223947989534, 0.20340584581682974, 0.7578137462563898, 0.750751716154012, 0.19774120310975019, 0.6527932882704048, 0.6381446750212321, 0.6257592262691265, 0.20944970382753703, 0.20993855254775862, 0.2174903324709867, 0.20982716624125886, 0.18999716312322157, 0.20827818752599458, 0.20652676308409068, 0.214947504621823, 0.20371381652317033, 0.20942897306230768, 0.2001303209819112, 0.09810941357444913, 0.09608186057410406, 0.09009336757687958, 0.09615120483022688, 0.08276785954878774, 0.09480874424454266, 0.09263121770336313, 0.08830413461251096, 0.11158960778427263]}, "mutation_prompt": null}
{"id": "4d051397-a3ce-4ce1-85bd-d3e6d8d24e83", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted initial population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor for exploration\n        self.crossover_prob = 0.85  # Adjusted crossover probability for stability\n        self.success_rate_history = []\n        self.memory_size = 12  # Increased memory size for better parameter tuning\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor for mutation\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.05 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Modified step size for precision\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 6 == 0 and self.population_size > 15:  # Adjusted frequency of population control\n            self.population_size = max(15, int(0.75 * self.population_size))  # Adjusted population scaling for exploration-exploitation balance\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability for exploitation\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedMemeticDE", "description": "Enhanced Memetic Differential Evolution incorporating Adaptive Mutation and Crossover using Dynamic Population Control.", "configspace": "", "generation": 60, "fitness": 0.40727945009982536, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8989225768125766, 0.8971670457946073, 0.9035374408911105, 0.8938217537530739, 0.895755819465192, 0.8999992235942754, 0.8988591839806295, 0.8886475169520961, 0.9015200993818627, 0.8376660086991431, 0.8294564156182981, 0.8333965681110123, 0.8367554523248792, 0.82652338513313, 0.8215571543753765, 0.8178036448255879, 0.8202925357642465, 0.831129483867504, 0.7230384593098298, 0.7212775257679267, 0.15330599746994633, 0.6545874439120183, 0.7623513100904882, 0.15598222054051225, 0.17231148290500387, 0.18380376419467104, 0.6318571166922665, 0.17148090173559138, 0.16810444802390134, 0.15330028873167179, 0.12080431264119174, 0.1769001779020738, 0.17337513141255334, 0.15045486218795245, 0.13877875151870955, 0.5655486118472088, 0.9524804306734752, 0.9594967368359615, 0.9670113214432222, 0.9390189448942908, 0.9631349013000918, 0.9842018739878972, 0.9528386490713089, 0.9348043672980475, 0.9456567736107626, 0.7024961563371244, 0.7552743799402784, 0.7540429538203643, 0.7217719188453741, 0.703741134891154, 0.7503143942723424, 0.6872592531710262, 0.6614965261073619, 0.7240206442444729, 0.833764361226936, 0.8604667368524984, 0.3781408031442295, 0.8508237433223614, 0.7289807215377784, 0.1899508179706636, 0.7838978733567796, 0.8575475118657889, 0.8732451799329647, 0.1913564722232879, 0.28229079870645024, 0.19556414994596294, 0.17408503804232078, 0.12939787055462182, 0.2042366978710719, 0.21321977470972364, 0.1938597220125272, 0.19286055570065852, 0.2257580975880492, 0.1183850593110588, 0.19870086526000363, 0.19194311632202876, 0.21914701841508455, 0.18217995377690654, 0.22509594197678173, 0.21593395888651812, 0.21240482572530106, 0.08736908975423652, 0.16966448356689967, 0.2753726289874201, 0.00020157053660008195, 0.09141358801158184, 0.21725653771543507, 0.07438045468994392, 0.23937790842539697, 0.03441819823096337, 0.22483501596592836, 0.2947731830842031, 0.16051821912182274, 0.2737021015752006, 0.267365390286729, 0.16893285573030603, 0.35979493240653393, 0.2811793222436215, 0.33993619881009596, 0.0484385669450319, 0.3377955981122752, 0.29987675403012515, 0.2013985347214735, 0.3418478787356968, 0.1137365284191918, 0.2504507423478938, 0.27707619505376535, 0.17488184961439368, 0.21275120234421674, 0.27727811314967243, 0.39318941934807106, 0.5025269971263806, 0.4309924178355464, 0.23826496717109613, 0.2617763092560573, 0.29630437775290097, 0.3519041411738424, 0.6986632495798069, 0.724467878086714, 0.5207964900309903, 0.7610012887685682, 0.6831817249495307, 0.6873936763523241, 0.6034042995769371, 0.7228216458258779, 0.7472325136333189, 0.13994047671933352, 0.11467423223256645, 0.1667171221767596, 0.1317834065707546, 0.13598814506328805, 0.14942718383807663, 0.14469135593449522, 0.14250602403671564, 0.1373480773114485, 0.22708978782049138, 0.19136710588275252, 0.2319977434724999, 0.172055028189798, 0.16292845166211878, 0.26795917572704764, 0.18264837082545848, 0.22227019073424947, 0.18350041403145056, 0.6860301572508392, 0.5805804736926861, 0.669783077098221, 0.5782594052848922, 0.6709769318777781, 0.5708847537136296, 0.7448683117722883, 0.578090827641969, 0.7585175288145709, 0.4172766863178131, 0.3272984406149888, 0.30277934438492116, 0.450657837392722, 0.4726375322177824, 0.48738928897284584, 0.5700828868417906, 0.5413881829114857, 0.26553503248143917, 0.19793878993451874, 0.19346653312369344, 0.26540908742239566, 0.1952394925656138, 0.21094028421007793, 0.19100798876781355, 0.21795640904653557, 0.2125800076528057, 0.22087110045578473, 0.2132384820824158, 0.8075225492863073, 0.200069467940846, 0.2431099045177163, 0.24669914866920295, 0.24225647233734904, 0.2382538544878281, 0.22296493806941808, 0.2166476881265449, 0.8961804254259947, 0.1513512881627086, 0.1979259395820958, 0.9012971576939457, 0.8057904230531474, 0.16486743042171859, 0.19465849444923056, 0.1788995741126317, 0.16873312709808452, 0.5857229580595056, 0.5337073293307155, 0.20796555270358885, 0.2088912875229194, 0.12638261550891816, 0.8295930058872109, 0.15401383214446995, 0.21240754945507812, 0.2098121384122663, 0.1806027959501354, 0.19393433772817714, 0.19455209499300685, 0.19896791396130598, 0.26173969948612563, 0.20077329626975293, 0.19725331348344222, 0.24560117064615716, 0.20398293370684872, 0.08692216728534474, 0.08955722177557546, 0.09643854489407822, 0.08523479229860786, 0.0978889347492381, 0.09584193182418221, 0.09836900915401181, 0.09732054888357611, 0.0927610129439892]}, "mutation_prompt": null}
{"id": "8dfe0b95-8d88-4143-8e80-e16e6fae6830", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjust population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 8  # Adjusted memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.05 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:  # Adjusted frequency and threshold\n            self.population_size = max(25, int(0.8 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Adjusted intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Strategic Parameter Learning and Enhanced Population Control.", "configspace": "", "generation": 61, "fitness": 0.42426499842863447, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8352856267155107, 0.836572373804717, 0.8307781424829157, 0.8198276756314693, 0.8381178219490781, 0.8403596873699464, 0.8515718452359007, 0.8476418872553644, 0.8349739093837595, 0.7237828336023999, 0.7318443964791412, 0.7030595177174404, 0.7374484090453448, 0.7381118557305338, 0.7264076428173033, 0.7117596067660215, 0.739724659174706, 0.7154730218816707, 0.5634975566526408, 0.4479901015790697, 0.4327879451867046, 0.44840243047794115, 0.3833371393966528, 0.42871488531513713, 0.49094566805972495, 0.3854419795377001, 0.35517043126010117, 0.45044536186369755, 0.14956168731549735, 0.1547783855920163, 0.14638326021555625, 0.34416222541013863, 0.15924718883212297, 0.2888182470612304, 0.15880047617137572, 0.40870749564621467, 0.9059522413591855, 0.9508897904088569, 0.9328431609872693, 0.9359386248596345, 0.9432075432307565, 0.9195273575266019, 0.9690591703677902, 0.974444149263794, 0.9215895806229876, 0.561790532427298, 0.5909592047655033, 0.6280663911543588, 0.5302636203030464, 0.561424101558565, 0.6034980525943714, 0.5713593823292238, 0.6254917175469219, 0.5975721559599103, 0.791349220512293, 0.808080552616552, 0.352252322669539, 0.7892576268384477, 0.8013160200891413, 0.8342478057477193, 0.8180099229387325, 0.8056304146021736, 0.7914156285723078, 0.2615802940290296, 0.2508553434066668, 0.5452272757407888, 0.432547836302806, 0.49568458892426137, 0.32003363497345194, 0.340985600822424, 0.23919749732835094, 0.34473672592529825, 0.3159032893591298, 0.2584776210470515, 0.12979586156932932, 0.33972704460243663, 0.24336065416798702, 0.25939472727393664, 0.30292382278989816, 0.35921188528604486, 0.2553871752455743, 0.34018821407120703, 0.3121713162822741, 0.27780086349154753, 0.38819452601025073, 0.2944909147551289, 0.26468034543797136, 0.41292220224596043, 0.40212992698597094, 0.3357643492148481, 0.46421053856560424, 0.47230233915664555, 0.45348840221169806, 0.4698261413149276, 0.4410763473898076, 0.52300324671711, 0.5429994408945242, 0.4813115762287885, 0.5780425145912731, 0.07685391835214617, 0.21070047721605578, 0.10316865169346989, 0.21085799694042417, 0.26535116365755085, 0.20069037912795207, 0.11693025820190361, 0.1614534509610157, 0.15870648702267376, 0.29088521427316194, 0.3161065136533785, 0.29671555040438957, 0.32273881144974226, 0.3706454205669276, 0.35869336374084915, 0.31651036445959657, 0.3248804209576126, 0.3225366391144223, 0.6954232909211144, 0.7139002991074849, 0.7436598196243467, 0.6227368906244539, 0.7016811062585753, 0.6719309898542642, 0.7187738473106421, 0.7339178394175341, 0.7085274991635544, 0.11423127786422194, 0.1301522196758811, 0.11817993662265747, 0.13558083150572386, 0.13039780248749555, 0.13875816429163113, 0.1106785068850843, 0.14670663935596662, 0.14492643656247217, 0.18615207235633902, 0.1854257332454745, 0.2069042278997626, 0.2707975337812494, 0.16510847482905322, 0.237315004233834, 0.14345109223948527, 0.18978374789313424, 0.2789613039506098, 0.43756725011222863, 0.47068949266024873, 0.4677963512425215, 0.5198991038012287, 0.4984322070005065, 0.4859418135878222, 0.5406537838835326, 0.5177623692347568, 0.5052376322210811, 0.31007034250265575, 0.3761663954877007, 0.3176101555501307, 0.33263813879431714, 0.29887949059157004, 0.30633501149536724, 0.38148562073590253, 0.38310012159684426, 0.3853860381906853, 0.21063959352812822, 0.2070212141603669, 0.22753511834590545, 0.19455451073341778, 0.20721791352043828, 0.2171094673993751, 0.1828671564007821, 0.19142892511847265, 0.2230271283867089, 0.3801935482406994, 0.49630704796047664, 0.33347354218516045, 0.5604094391398888, 0.5064487123004364, 0.44212240116010215, 0.20573395380986892, 0.5903068577033507, 0.4641437450208149, 0.17089425911097567, 0.1508997485515189, 0.20619040703161873, 0.16848785094854468, 0.730433570953607, 0.8167813978901993, 0.16712540576889856, 0.5449611112726379, 0.7685017147273028, 0.2044912864918247, 0.6892303381103935, 0.6345990842593554, 0.7452979494296696, 0.5442123487222367, 0.1621345728405077, 0.20364790771533536, 0.20819084305660185, 0.7722571958439004, 0.21346601281904087, 0.19513426523650945, 0.18479486536667578, 0.18272428076788638, 0.2034181589857521, 0.20905438064833282, 0.22007140633060174, 0.21073692149661483, 0.20712159876822067, 0.08659751108835878, 0.1018116730831009, 0.08557810827627943, 0.10836221027944792, 0.09156722238660386, 0.08953876258019866, 0.10397876611685408, 0.09543892242243146, 0.09382458281845862]}, "mutation_prompt": null}
{"id": "3f67d3f2-3c44-4c79-bc09-f502e3ee3fe5", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Slightly smaller initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.05 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:  # More frequent population control\n            self.population_size = max(15, int(0.65 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.55:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Multi-Strategy Adaptive Differential Evolution with Enhanced Memory and Dynamic Selection.", "configspace": "", "generation": 62, "fitness": 0.41809695426859755, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.9121865740990464, 0.9036595508322796, 0.9027554073290756, 0.9013156469217336, 0.91513055255916, 0.914803166074458, 0.9087288046406095, 0.9047626843882751, 0.9054268816712816, 0.8430851321399885, 0.8359144911309739, 0.8231328616525606, 0.8307913905278317, 0.8186443847150483, 0.8446459653089071, 0.8411620959929842, 0.8456864535487536, 0.83267093926557, 0.15630307371084073, 0.15515710953390627, 0.18151910667403426, 0.615759387949451, 0.7424132126473955, 0.7011089457279307, 0.1522558298132204, 0.17758595280818756, 0.17767601000028876, 0.15236182483624783, 0.13595675951586872, 0.17424598685342696, 0.13982808090446341, 0.17019045181460168, 0.17988417927831812, 0.15169054055351516, 0.178237498551297, 0.1162198071295174, 0.9663355879195358, 0.969045438554842, 0.9834407860567868, 0.9648728714560518, 0.969573650018216, 0.9683048562253236, 0.973422324336797, 0.9679440952942615, 0.976911460591669, 0.7502132353460406, 0.5978359869076144, 0.7472118865667365, 0.7693207327961409, 0.7438366763479749, 0.6767937000508311, 0.7439462105260117, 0.7774086486001973, 0.694261985346343, 0.8533836400713846, 0.87367071770835, 0.8600305095515663, 0.9047540394581112, 0.8892920965204192, 0.27684077140489205, 0.9089876104887307, 0.8894531024205652, 0.8502695935094082, 0.20002818810252632, 0.20732107454157922, 0.25866037353637716, 0.17744992977122243, 0.19606799806024033, 0.2553231805931956, 0.22445046293300663, 0.1794469745576791, 0.22260734167374374, 0.3831708149522226, 0.22950726860882198, 0.1185601378995671, 0.22833978355723306, 0.19239211782546028, 0.3975879820788829, 0.5552012003418302, 0.29313484667400647, 0.22435632723997834, 0.14010333350777893, 0.09092900770470191, 0.11689066325175268, 0.036496521419024375, 0.1248379691519409, 0.04732264460579405, 0.08904617580206431, 0.2446287616404197, 0.1876794314158995, 0.31833868011754907, 0.26704053637792624, 0.3934003957538703, 0.15661328406208863, 0.08800718341088265, 0.11689393660584702, 0.14594516934275847, 0.22097870756670301, 0.41588580310028134, 0.2273140793221755, 0.25966783449103026, 0.1841461159859984, 0.4078065738762571, 0.09245139007810088, 0.2570702890569977, 0.1124548531752938, 0.2088689422629646, 0.1248188910924477, 0.3209034295383464, 0.3412024411502038, 0.46846128927555997, 0.43427974138138836, 0.41100618782700227, 0.3203808269993982, 0.32809201132149257, 0.22964767430947197, 0.3589907146198199, 0.7049022258297393, 0.683463922226616, 0.8119227608190371, 0.7348083358218012, 0.8180147816558632, 0.6390269360631411, 0.7798782333154562, 0.6818261719707275, 0.6166870724507145, 0.1754142578184661, 0.14487861331102725, 0.1526500774401477, 0.13455784234707202, 0.1257488000575142, 0.16163207652654488, 0.1469703982245697, 0.12190348495004577, 0.15216161272836548, 0.2276719426281204, 0.228090053823218, 0.25863890055696104, 0.14859846787360242, 0.31760295464663046, 0.17539663762737545, 0.2139656728246223, 0.26409037013722114, 0.3387659342561935, 0.41841400628045267, 0.7067581582559309, 0.6916245164881163, 0.6398518823977133, 0.6988435068409877, 0.7166463410052174, 0.6307642434546348, 0.7368397442375781, 0.7191097973271694, 0.27542683931798495, 0.26882203241741687, 0.528744258597617, 0.3916525713930735, 0.4263343112310365, 0.44095732152145595, 0.43520599716264285, 0.453887897783548, 0.49640518495112684, 0.2157791041828394, 0.21389732520125349, 0.3048354418094583, 0.21670656718345072, 0.24313851911456663, 0.2540405641834018, 0.2220341900319759, 0.22631872388114638, 0.24220727927691033, 0.21700724226126122, 0.22233548348703536, 0.22060645825624592, 0.24940063354319708, 0.8059639393546089, 0.8059181245285977, 0.7239249726764607, 0.23946157983764316, 0.2205486383799169, 0.16719394185527703, 0.1711623691459817, 0.1819532126287262, 0.18747255706104304, 0.8616294029492285, 0.1905787861315108, 0.8679792923228686, 0.19110700923089985, 0.899096798507356, 0.20843349762254593, 0.1684670077339817, 0.7683205228608544, 0.1651325637915626, 0.1673198050370036, 0.8534079072108697, 0.16635788620647507, 0.12749622261553617, 0.20831610522123511, 0.20157182426337372, 0.22588708689889814, 0.18445148727001726, 0.2593636151989551, 0.22306397459365823, 0.2031040500636283, 0.1957374444604587, 0.19894262478514924, 0.19791350145278286, 0.10074766548214897, 0.08293131198757697, 0.09132736068873315, 0.10801675932123911, 0.10164350828058266, 0.08852451306506914, 0.10257812611197115, 0.09274029948496265, 0.09682369596579288]}, "mutation_prompt": null}
{"id": "ee001e09-4f07-4721-beac-046938d10293", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.7 + 0.3 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:  # More frequent population control\n            self.population_size = max(25, int(0.75 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Intensification and Dynamic Memory-Driven Adaptation.", "configspace": "", "generation": 63, "fitness": 0.4220938555955118, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8481484888750865, 0.8446062932794207, 0.8476962775658221, 0.8491301121552841, 0.8440255508648197, 0.8523443409199261, 0.8534805028628047, 0.8625184252231063, 0.8486890539885787, 0.7560258656022921, 0.7532306245804601, 0.7294469025248019, 0.7373325407638696, 0.7434477592555445, 0.7250640937038613, 0.7445107705412528, 0.7573474064963556, 0.7356379173180951, 0.5580551196584673, 0.17210286285388354, 0.17228135843762227, 0.4593411268475196, 0.16880363689671163, 0.3717169575629209, 0.4441637611280119, 0.16346346809328227, 0.4625399353491725, 0.3583127446177624, 0.415434660513159, 0.15946139373356494, 0.4913421112122217, 0.4314071307623303, 0.1608623417132249, 0.3129421688687043, 0.37995530075643225, 0.3074150853099228, 0.923405064805106, 0.9569387208457566, 0.9391510189112637, 0.9466316794992571, 0.9668206236823156, 0.9653489365024741, 0.9568242337288551, 0.9652184688354517, 0.9638458478396194, 0.6516722170528084, 0.578345486769674, 0.6379658356760386, 0.611129251363365, 0.5839035097296362, 0.6027857789467405, 0.5702779591770408, 0.6237365707312785, 0.6107847370802639, 0.7722406176576473, 0.8086526812894981, 0.7802151351232458, 0.8238744258454314, 0.8018739709323597, 0.8084328257897913, 0.7293946964582059, 0.7995994119528452, 0.7685407541764435, 0.4029386496175178, 0.20733380211100405, 0.3259922733394638, 0.19193932424593718, 0.2654386117128963, 0.24636290156315266, 0.29794415332202084, 0.22372801402599507, 0.4266994965193146, 0.32955450656531127, 0.3840330449794027, 0.20041474318620844, 0.2531454907427656, 0.23249112071794142, 0.3183072260054063, 0.2109573261310833, 0.24965902359322967, 0.27151332686796825, 0.17464236034040004, 0.2989625072680987, 0.225143166792791, 0.2895944721477468, 0.3085254064014541, 0.2628305915930881, 0.26667035940407036, 0.2253282982084105, 0.28777059959875984, 0.37921403720726665, 0.4570043954118277, 0.4234222354398214, 0.3583832931260996, 0.3578655470982557, 0.39225650538169776, 0.4357526963638938, 0.47977010506733264, 0.39184289730849065, 0.14132336762316666, 0.05792007970476698, 0.1755967479571826, 0.23981269953237527, 0.14303677480242782, 0.11418884300066057, 0.13309732522313478, 0.13291967418130968, 0.19160897233251606, 0.28683744220483565, 0.29646848409035464, 0.2971790097241437, 0.36793870002422546, 0.322491262139183, 0.3579004934842708, 0.29033926700578416, 0.31310140608083237, 0.29314355910309375, 0.6890527436095064, 0.7306425244109211, 0.6956308282421212, 0.6805920138257375, 0.6856013664395744, 0.6857948263207483, 0.5870171554513954, 0.6975296137842121, 0.7566513863886507, 0.12337962174022321, 0.1476991718431243, 0.14895327636724687, 0.11607608071036335, 0.15471929717686528, 0.16323360571411083, 0.26318973304513027, 0.20567226512004277, 0.14721747717871236, 0.1484733615063376, 0.24840469145937827, 0.18489064774192543, 0.2620913025426139, 0.1922095634888873, 0.1764842630383613, 0.16040048606196378, 0.1641272514813108, 0.31784235139978423, 0.5216475844508438, 0.49140814860813553, 0.487454807499376, 0.45677705200986807, 0.5032318258591463, 0.47457340748225274, 0.5210970490156354, 0.5879024188761531, 0.49904298871702923, 0.3072173579141456, 0.33050512424099665, 0.3253621202735675, 0.333781448878712, 0.34235860702723653, 0.3344328144427523, 0.3873836771042892, 0.3590947730950186, 0.3758973631895205, 0.19147196760373308, 0.19743510008895282, 0.2339900748528294, 0.2021558164528494, 0.24694019944952317, 0.18327366470341944, 0.20009106936887733, 0.21379683532808558, 0.21089086743928476, 0.398787631141444, 0.6488850310434306, 0.2305793020654643, 0.4015522676679797, 0.5535013216698221, 0.5294429900996178, 0.4829401820338144, 0.5061204559272738, 0.41436983848661757, 0.171872891469233, 0.779857403765646, 0.8552731692442186, 0.7895908868928911, 0.19036336831142697, 0.5687165799012905, 0.5860298565187263, 0.6397632946413591, 0.7797479414429616, 0.8157997894675912, 0.6289951887188171, 0.6593406531441688, 0.20666090123548309, 0.19989577585800267, 0.16412515151265394, 0.2039979936876728, 0.20783213943493084, 0.20816963551364398, 0.1867280105096324, 0.20336494484772472, 0.20001680905811536, 0.1921528716237344, 0.18888705180997123, 0.20635738671578596, 0.18470614188498247, 0.20334099321383836, 0.21413101930680223, 0.09106361187154033, 0.09245560934240415, 0.09269292696256759, 0.09441703758883135, 0.08841018588941751, 0.08964401355779195, 0.09273475483553051, 0.10398177983781731, 0.09395377995730192]}, "mutation_prompt": null}
{"id": "d7b8b82a-d277-46ea-860f-17a4fb826a2b", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.6  # Reduced mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.55 + 0.45 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.05 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 20:  # More frequent population control\n            self.population_size = max(20, int(0.65 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic DE with Enhanced Parameter Learning and Intensification Strategy.", "configspace": "", "generation": 64, "fitness": 0.461676017318074, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8783277453506286, 0.8756929759392612, 0.8566120622132732, 0.8744434046560136, 0.8697297797411923, 0.866196100406, 0.86279989071537, 0.8727566318515116, 0.8799045169243702, 0.7763039281137345, 0.7900447446926707, 0.7664090056454989, 0.7669490644260151, 0.7906941161396902, 0.7875417606980035, 0.7696619882164755, 0.7643119205538259, 0.7870031389375235, 0.17680984722642112, 0.5899377518482846, 0.5600699555478142, 0.43414299488658026, 0.5231231965690951, 0.5479687874835847, 0.40786616396488107, 0.5464134182623547, 0.3963103613375709, 0.5064628851433823, 0.4713988888658599, 0.165784988282636, 0.39026101249965317, 0.1669315291381892, 0.16838623310484313, 0.1539972302789009, 0.15830386235221816, 0.1673681343774972, 0.9552502663421178, 0.9659732071433177, 0.9666285175328263, 0.9549034090845966, 0.9470984968597151, 0.948837142529365, 0.9668753438029883, 0.9658279310994501, 0.9778676526255151, 0.6596301964597846, 0.6650380362307122, 0.681581788644289, 0.6580547041597365, 0.6548670432680395, 0.7006364600279451, 0.6820489584932226, 0.6495619459334313, 0.6816136543936022, 0.8056611920820926, 0.8216770758995062, 0.7930716372098935, 0.8267624872017755, 0.7673223888211367, 0.7875918730216989, 0.8528046125692411, 0.8257848882331632, 0.8302347654036224, 0.3142951313963057, 0.32265014237347955, 0.3869835784867123, 0.36776612227421435, 0.48631448151345935, 0.4656161861905831, 0.23287400915318623, 0.27988258680303046, 0.4606448257381702, 0.2515678226261614, 0.2528049685611693, 0.28651159580190777, 0.2680453107817288, 0.2779875353830624, 0.28504583313728715, 0.3580142521170526, 0.25777715323851824, 0.44830046960094916, 0.4206376653913523, 0.39513119906290883, 0.13406466320086152, 0.38847391523261865, 0.4300618328260176, 0.1983948629360095, 0.4209528814410871, 0.39189935332255776, 0.42769723918706304, 0.4535932213583357, 0.44923977950479577, 0.4223597824546008, 0.5393352934830759, 0.45711103329650815, 0.4930302521677723, 0.17883094749292539, 0.6352948882357148, 0.6844420704392244, 0.12397250604862142, 0.19039390355528685, 0.14386319559747807, 0.3311019373001042, 0.2661495721191285, 0.1414783804499522, 0.12241855427659687, 0.3165217950220939, 0.13965885482400486, 0.30899213409748094, 0.34154293533131663, 0.35249308857541306, 0.4312237622314561, 0.44444307580676234, 0.411944630730688, 0.3357346542265244, 0.27186066103191864, 0.343091501444311, 0.7708454966985907, 0.7556307255115167, 0.7732246124843545, 0.7789063712111666, 0.7879635237098603, 0.7636750228831005, 0.7101820950571104, 0.7626280475891664, 0.7670581968760573, 0.11083124545039613, 0.1228262942232532, 0.30491996086007067, 0.12495880700887685, 0.15036847526437414, 0.11682010114731911, 0.10555629193265126, 0.12339663842541904, 0.129587445796148, 0.1613339024169591, 0.15574468138364395, 0.1503900842684387, 0.19561123440774308, 0.19731757158522956, 0.1632555444856123, 0.19798642109115805, 0.29357260109878736, 0.14873742354853803, 0.5111483033026509, 0.6202984685180293, 0.5463019457453171, 0.5378538524970238, 0.46619886785744113, 0.5296456405594147, 0.6201818366734906, 0.5958281019688154, 0.5863502645584564, 0.4070040803437942, 0.4008059371051452, 0.3172726238232474, 0.32948156565969056, 0.3997662205748965, 0.3352548843872296, 0.41010544426374285, 0.47199173700833397, 0.41565848778955516, 0.1970724695398116, 0.19480343334332662, 0.20990072882637656, 0.19662311395400278, 0.2231931730986212, 0.2071157181517589, 0.22656312732136374, 0.23424242725168465, 0.24037479711599752, 0.5802040927413754, 0.65297507169359, 0.6104712272352546, 0.6746828601359206, 0.1997271674901575, 0.6034969152913727, 0.5199104634887524, 0.5630042637658319, 0.49573323054634355, 0.8123995444618681, 0.8193087554421778, 0.8625336242894971, 0.6932364728819973, 0.19525873877801092, 0.8746637647625642, 0.7409817397345491, 0.6842247278991835, 0.8084287394423881, 0.8011509625898614, 0.20701591617717163, 0.7506599214174039, 0.19795159624997782, 0.16585607056321094, 0.20416124071216624, 0.8101536322750402, 0.21152525046030513, 0.21060267242210584, 0.19011945699386046, 0.1931657523488154, 0.1794579255560408, 0.18985920837850934, 0.1876901141250561, 0.2175946597472308, 0.2163630176807777, 0.19329479962887341, 0.20113875686340466, 0.09562942461808166, 0.09259919286241947, 0.09453205365270878, 0.10215986635539243, 0.0915421184597437, 0.10161944231272213, 0.09407926928787269, 0.08903030198623951, 0.08681592890024603]}, "mutation_prompt": null}
{"id": "76ae7f0f-e2e4-49db-bbcd-6956e9167383", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.12 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.7 + 0.3 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.06 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def maintain_diversity(self, population):\n        if len(population) > 0:\n            diversity = np.std(population, axis=0)\n            if np.mean(diversity) < 0.1:\n                perturbation = np.random.uniform(-0.5, 0.5, (len(population), self.dim))\n                population += perturbation\n                population = np.clip(population, self.lower_bound, self.upper_bound)\n            return population\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.75 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n            population = self.maintain_diversity(population)\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Stochastic Perturbation and Adaptive Diversity Maintenance.", "configspace": "", "generation": 65, "fitness": 0.2751308503158398, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.3598816896305801, 0.40273803497182303, 0.41140257886370735, 0.46557820701341757, 0.509253183142325, 0.43207503483834975, 0.42370372762637365, 0.42356743280063835, 0.451224920151043, 0.2375743477303478, 0.19063277481573393, 0.2164295599883781, 0.25032583527929686, 0.24778134236691607, 0.22997718658650723, 0.2623486895289674, 0.3037208173971857, 0.25002802074651675, 0.20488154711550954, 0.19989832797096907, 0.19143167887634316, 0.20308474098044926, 0.21761140440167437, 0.22078200130908088, 0.18355487593958608, 0.16716763564119919, 0.18713415218206098, 0.18486796913165715, 0.18845007545932135, 0.12055495964370244, 0.14375922580817224, 0.18743735756650037, 0.19295775328396658, 0.15930847636939038, 0.15208376586184513, 0.15681745167076389, 0.9555350417118322, 0.9628162891840865, 0.9511975975715699, 0.9526308991346152, 0.9654690620905036, 0.9639150030776525, 0.9688055638200613, 0.9620232027779597, 0.9645283443562764, 0.2637163444413936, 0.24578557211613083, 0.2425714722837945, 0.2943398688236416, 0.2701069376916254, 0.346425888386787, 0.2301067575215544, 0.2541099601509552, 0.2568208678856493, 0.3710371521268243, 0.3443494741219597, 0.33025435769325884, 0.3396881943220168, 0.36343860362247515, 0.7905571604761994, 0.3530593194629629, 0.41015980632957805, 0.8141180005254017, 0.17633167364032798, 0.16243988987574864, 0.15029799942609878, 0.16583665375545298, 0.1388239989092741, 0.15216715531091174, 0.15908327742795536, 0.15567405129664713, 0.16528638344958468, 0.163822387793784, 0.14183984728196575, 0.1606099094303769, 0.13538428211763054, 0.16337863384992812, 0.13815001333697274, 0.1358030092505753, 0.1448401344978978, 0.1616240244116447, 0.11828013829147821, 0.11260619882577816, 0.14448062955356367, 0.15672869121243382, 0.19052922343617418, 0.22061768733941212, 0.19389084885716235, 0.21601623846717366, 0.12534548427779724, 0.20766930781299653, 0.2349255997348162, 0.29002038716994183, 0.2595119729572424, 0.12225882253967324, 0.27681948817508706, 0.318175503777396, 0.2855975128158176, 0.29154249784624453, 0.09268133609584162, 0.14486738658870402, 0.09762383440846611, 0.08437221893517877, 0.141356732421279, 0.13312479849082137, 0.08449135338093894, 0.08707385591707117, 0.08288626200628535, 0.15422570932962354, 0.17098911327439237, 0.19750517497938747, 0.1436805740401924, 0.132893830214304, 0.15171900773162217, 0.16241410788416355, 0.17293376919599013, 0.1918557072862086, 0.3947939200517764, 0.3930254254756822, 0.39953308046365055, 0.40820683295592153, 0.41716045242244215, 0.38168205296362123, 0.3989715684173427, 0.379424742800213, 0.4191302985919241, 0.13193804141983623, 0.11176513095952612, 0.12430133663167531, 0.1358883047362981, 0.1331422965496447, 0.10647782627064883, 0.11878870332175406, 0.11526691605108319, 0.15315293019187248, 0.17872221674012456, 0.17136166883517467, 0.16268644098613827, 0.16556167008268274, 0.19207132442704167, 0.211606601529436, 0.16559974225833807, 0.16260896382053525, 0.16932720067444207, 0.2821113974499029, 0.2911821655715755, 0.30668260797600067, 0.2949265781210596, 0.2720017215272843, 0.280766824381672, 0.2827403784209227, 0.29568440626741765, 0.29500594361537036, 0.2602127263950863, 0.2622134464113992, 0.2630361635318025, 0.251619450701692, 0.24632129003264036, 0.23739773095713312, 0.25423526863442003, 0.2401860865436637, 0.2650796196585391, 0.21748150364944951, 0.17945701073829945, 0.20918893024475194, 0.19764966660836336, 0.1903933615677863, 0.2022051463760578, 0.19422394703284063, 0.21543794159821839, 0.25785652078943766, 0.2886453193406624, 0.25948693986667193, 0.25167952302000274, 0.3087489291570017, 0.28007788810364276, 0.28510296085626485, 0.2681265358747037, 0.2428323931228108, 0.2638086812245338, 0.575061538360119, 0.573633130050953, 0.5573670534865506, 0.18458628066201854, 0.5124195881419913, 0.547308178153304, 0.5125689095957153, 0.532096446892234, 0.563864770292125, 0.46339462514213436, 0.6674203185358074, 0.49207822068799556, 0.1955044731899549, 0.6347338483733477, 0.20391892304498638, 0.20751385292916058, 0.2072553059078226, 0.2059230794409993, 0.17490093848734467, 0.19446905209724408, 0.19394769006374968, 0.21102356077668005, 0.19595948172664335, 0.2327192230002214, 0.21163152520168593, 0.2091266581168939, 0.21045980760833172, 0.08150597673315019, 0.08857638448489091, 0.07904319465129972, 0.09071476574447701, 0.08788208572042244, 0.09130607718702688, 0.09637762033409358, 0.09272042349552301, 0.09255011017608761]}, "mutation_prompt": null}
{"id": "a846f5bd-beb3-458e-ab1e-815933068b6d", "solution": "import numpy as np\n\nclass StochasticAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 8  # Adjust memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.05 * np.random.randn(), 0.4, 0.95)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:  # More frequent population control\n            self.population_size = max(15, int(0.65 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.45:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "StochasticAdaptiveMemeticDE", "description": "Stochastic Adaptive Memetic DE with Probabilistic Intensification and Enhanced Memory Utilization.", "configspace": "", "generation": 66, "fitness": 0.420950231371592, "feedback": "The algorithm StochasticAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.9024843114182854, 0.8929605197058978, 0.9102855556981149, 0.9085185661684502, 0.8970632521156122, 0.9089661848551371, 0.9094848177358426, 0.9015256020063279, 0.9088041573966511, 0.8494377391709165, 0.8363239596624186, 0.836810306652385, 0.8326823033101518, 0.8480225683744291, 0.8415031766908326, 0.023288500339698426, 0.8525152310870224, 0.8487858400503667, 0.16846547456725924, 0.1775424521608704, 0.18476228489637248, 0.17160709218540593, 0.16659497770413323, 0.7523500593387817, 0.7099454397670946, 0.659346328379613, 0.17565678578483224, 0.17793016065333978, 0.17024739006669531, 0.6043238119858337, 0.15241009685296025, 0.12899992836399654, 0.7213019349826939, 0.17462420438082749, 0.15324743522022688, 0.15971936855906266, 0.9532349418454155, 0.9614486821719803, 0.9587481036660133, 0.9560556511913764, 0.9809707129030472, 0.95467763329223, 0.9739031462737923, 0.9835440349824558, 0.9456128972552004, 0.7471865966315094, 0.5592190176969626, 0.728625027815109, 0.6132066269155254, 0.750506557109003, 0.7314428347477415, 0.7758246309574014, 0.7532003018904374, 0.7287878604937179, 0.21449784168657338, 0.22614903436514044, 0.896398281114487, 0.8517869423613976, 0.8881936044727565, 0.874502894910352, 0.8859591957737166, 0.9023349150698613, 0.9133136009114893, 0.702896915024884, 0.19149949011904355, 0.2605122666590556, 0.1821906704927445, 0.21324411695124867, 0.20380901733664636, 0.2867333286894044, 0.2002973091382967, 0.21370885491289215, 0.26569682811002227, 0.17558559294714504, 0.20423628444390884, 0.2912351566138216, 0.261115793746189, 0.3399298218067597, 0.1696324920785941, 0.23034759676598882, 0.22654980595080587, 0.16026261182477697, 0.12536026093344166, 0.2596549795076484, 0.001600145619939597, 0.11453019437110212, 0.03727261138831672, 0.3350976705248021, 0.15924665596435994, 0.29063215245658125, 0.20922040988561585, 0.1283213011962463, 0.30967622662010774, 0.26965985975877804, 0.08821794386962889, 0.1365623886472377, 0.08574127696227174, 0.2946616180380828, 0.31758819876081523, 0.10338505598316294, 0.19874351172911386, 0.06406170657813015, 0.19428348019456643, 0.09984584615508518, 0.07958175289539271, 0.16025433628542873, 0.15322703486303713, 0.18656173831292489, 0.4034099941425038, 0.34987810082076043, 0.3920910801396651, 0.4149904649130368, 0.280194656477058, 0.3785095315367627, 0.4404011588014429, 0.2422001152929395, 0.33852463635328744, 0.7622080386726149, 0.6219655025503785, 0.7227621712227716, 0.7049172096564595, 0.7066605374656654, 0.6149129609921893, 0.745975490632397, 0.6513726971756115, 0.7029067212777638, 0.13300047220873856, 0.16348028018825933, 0.13333209723610018, 0.13197094193411396, 0.1590977824566735, 0.142300087296236, 0.13959301391969237, 0.15640619092062102, 0.1498080255508023, 0.20562415721542027, 0.1810539129983041, 0.20544828817494076, 0.16863273192909234, 0.21725203071801047, 0.16326982227303288, 0.23102957637617827, 0.20115863237905474, 0.22409972160716274, 0.7019385366152626, 0.6642159416791982, 0.6109601879640074, 0.7038633632069333, 0.6609153129431786, 0.717512236965063, 0.7430817914936937, 0.7705524499920526, 0.7261385282484412, 0.43619005531404587, 0.4510096487150038, 0.527388597022941, 0.45037998930059553, 0.24289960192290105, 0.29264055164112046, 0.5544674887095431, 0.4771478336614049, 0.5668973711947523, 0.21931997663103397, 0.2228241651629741, 0.21425046532355385, 0.22437176367894152, 0.23782890185815553, 0.20690271792811377, 0.22163577839650173, 0.21944022669357377, 0.22340686487482786, 0.7876476384728428, 0.7647693282490275, 0.7040141606583072, 0.24657237257971742, 0.21848978424721777, 0.7106626441907988, 0.24061673856132382, 0.7097676074080359, 0.2211720668131436, 0.8255148462019832, 0.17017156824107083, 0.15186454580519437, 0.18572200799230631, 0.8740899570891743, 0.858270922521575, 0.1698827480623719, 0.18515551845767875, 0.8151214411034702, 0.20413570138316417, 0.2109849896262057, 0.20747957293868913, 0.2067921063914513, 0.806395302954487, 0.7916375210702974, 0.21061590757513682, 0.12726151365555993, 0.21240414743151648, 0.19842431095189839, 0.19567930150110913, 0.20872395630312945, 0.208479408889243, 0.2315432723945462, 0.2143508785266739, 0.225176621599525, 0.2544172390844016, 0.23011157503654334, 0.09664085369366715, 0.09793746432059047, 0.09661384199568779, 0.09445228295263719, 0.09541159767936791, 0.09438039851228675, 0.10333869659195949, 0.08247308807912634, 0.10092164991890118]}, "mutation_prompt": null}
{"id": "458a415a-749a-478d-8a74-cb15bcfe53ee", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.4)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:  # More frequent population control\n            self.population_size = max(15, int(0.75 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with Adaptive Parameters and Dynamic Strategies for Diverse Optimization.", "configspace": "", "generation": 67, "fitness": 0.4217701476524539, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.877598769106336, 0.8751009964781963, 0.8860580208716606, 0.8911958091844261, 0.8826804405914046, 0.8959591701977341, 0.8828156318568222, 0.8757165044198157, 0.8724578788639549, 0.8143636609032361, 0.8174796704768661, 0.8063258698624715, 0.7904254486721278, 0.8119961315070277, 0.8289604543655958, 0.8176877639293623, 0.8290358561529361, 0.8165838873700375, 0.14925409785446242, 0.5661649731496359, 0.1507143239212213, 0.1500812917285197, 0.7161484120761434, 0.6303282032234199, 0.15147654885172745, 0.13754088932789654, 0.7739011313034716, 0.1297019419858323, 0.6114872433402976, 0.15122870364370156, 0.16811300118849304, 0.15253558593743233, 0.6192219532660385, 0.15018924082381968, 0.16542598478504278, 0.1526296648791322, 0.9276942498140217, 0.9477040454807001, 0.9001413906547665, 0.9363855681179978, 0.9597570366562225, 0.9323090402171713, 0.9448927163402543, 0.9505298033040049, 0.9621127149346793, 0.7418436034047148, 0.4293520760786764, 0.6033606513834222, 0.712564019480171, 0.7432797754638535, 0.4914248988284201, 0.558994180573992, 0.5854425990897599, 0.5054317152581589, 0.37896488181165044, 0.8805924195757484, 0.8387433287007394, 0.8775987434391038, 0.8815963074448774, 0.2090971379016665, 0.8665493828616649, 0.8809546017724876, 0.8759921295907498, 0.1289503468168285, 0.20663511990628247, 0.23170715248258422, 0.2602479977159956, 0.19247307800253277, 0.2232591768132337, 0.27416052104931166, 0.2073086503824314, 0.24230634746889446, 0.11517965659031637, 0.12120751205816505, 0.12460686660793818, 0.20725250533019712, 0.29325945936441566, 0.21253504246803445, 0.2616573528471171, 0.2334868397696489, 0.2232117327050941, 0.18234931548544453, 0.2959278891974837, 0.7052157294753396, 0.514135045796234, 0.11449011175167201, 0.3611364133884235, 0.5524669752370991, 0.004021391713071365, 0.6460840373216996, 0.2639042428449494, 0.3274898643240326, 0.25793646627144784, 0.47814273873768554, 0.42947766321998704, 0.2755181903304419, 0.1872908182077423, 0.2598868099293997, 0.4269903682887358, 0.23233424831006055, 0.4900939549631327, 0.19125794574655008, 0.2564175098552449, 0.5373003486085199, 0.07861833033561039, 0.2206964207399842, 0.12216463050181559, 0.15170071827587905, 0.055260148150911514, 0.3624676490755212, 0.3960320716535737, 0.34028871312412856, 0.3598748032704161, 0.29216053979676404, 0.1988649168254386, 0.2940964318438446, 0.41712154330037843, 0.8394134934309375, 0.6139839859757554, 0.5429078125705412, 0.6593943406477839, 0.6588752757712437, 0.6207608429533502, 0.7055172705160533, 0.8597533034312073, 0.6608116029622932, 0.13643769869652622, 0.13470309370099443, 0.12975393292910253, 0.17321772265861723, 0.12606749956876773, 0.14204309565096718, 0.1484297645790833, 0.17352425209610756, 0.11850252204467304, 0.4914716687103253, 0.3723267993880496, 0.20306905950739218, 0.158650377557216, 0.25040857812440775, 0.18524732376465802, 0.14954912025322264, 0.19382971032043117, 0.19481642404506128, 0.6991270251488262, 0.6802672160716947, 0.5837273776336461, 0.43107652336084246, 0.38147416057089145, 0.3573382298280894, 0.7074701122286797, 0.7356083038854974, 0.5273583291982309, 0.24687909122505114, 0.5155251449093639, 0.4927779342041222, 0.46575098341921684, 0.349489974316754, 0.6339788322382229, 0.41136035284938655, 0.5416896706050104, 0.5251085868736873, 0.235225761644545, 0.25330744637853897, 0.20580314623185603, 0.2484069108674275, 0.2168661805470451, 0.2022300915138322, 0.21095270532597143, 0.24261620654415772, 0.2053603010296674, 0.7289857899228698, 0.1997268458545619, 0.21683291500781543, 0.8159830003965602, 0.7517130665298113, 0.7120372854865997, 0.24209775703256153, 0.22255360741993768, 0.2195530413966036, 0.1520178493779667, 0.20970473195578765, 0.15171667582730042, 0.8839790237765001, 0.17779468011502464, 0.17935527584931565, 0.9165475254278119, 0.8103114407417983, 0.16842472881338322, 0.882230633230296, 0.1668333777652934, 0.20889670563953955, 0.16380547797558465, 0.8319768838991222, 0.20476781495266771, 0.20645136058623437, 0.20901919292191118, 0.21111218083369543, 0.20118390593390323, 0.20981590109460146, 0.20385288430954218, 0.22615239128300235, 0.19345343486991073, 0.2307306862911236, 0.19720810162755564, 0.2229621149527674, 0.22864692664020658, 0.08696402272593873, 0.10597095464283302, 0.09439272755845174, 0.08879895502719226, 0.10216325230095624, 0.08572447514755, 0.0847605701506432, 0.09027142689779188, 0.09407259368083432]}, "mutation_prompt": null}
{"id": "19d4a6d4-838d-457e-818d-9452aa0b115b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.15 * recent_success + 0.1 * np.random.randn(), 0.4, 0.95)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 25:  # More frequent population control\n            self.population_size = max(25, int(0.65 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.4:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Multi-scale Dynamic Intensification and Stochastic Population Control.", "configspace": "", "generation": 68, "fitness": 0.426855352050523, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8711378148480831, 0.8459572008962218, 0.8398737642459918, 0.8519380362863547, 0.8575443275909899, 0.8643941688151464, 0.858930666856015, 0.8473892762967221, 0.8428640676468109, 0.7265153168600142, 0.7419194972484218, 0.748585861981077, 0.7247208053108121, 0.7292468784837822, 0.7428941295121614, 0.7429116731631432, 0.7234772882064212, 0.7461703771255264, 0.4004080940169895, 0.273759092513295, 0.5580062323295494, 0.4075370893248067, 0.4588172697072619, 0.41385239832584886, 0.5505801993480817, 0.5086334273135101, 0.4602945363516727, 0.1635876158010947, 0.1539202340872775, 0.14682191973460035, 0.42824620241966715, 0.15135473152946832, 0.15005274509443878, 0.15978093738579224, 0.1634571209765705, 0.14672850497153156, 0.9587515720147148, 0.9328692884004498, 0.9643244446158251, 0.9798278929778911, 0.9245541022547441, 0.9720966635908878, 0.9653037013533721, 0.9664428049168905, 0.9653909314671727, 0.5951322229997059, 0.6000842627685452, 0.6129475206577254, 0.6735206184946203, 0.6183506609505158, 0.6467824754364977, 0.5592038905230611, 0.6237062414724037, 0.6178328123302697, 0.7440427879385301, 0.8023648263252994, 0.8042383517365463, 0.828836892109998, 0.7840607272657566, 0.7872582831961394, 0.8049048420546959, 0.8027917848139663, 0.8290353072606772, 0.26351767200983833, 0.41570030277316306, 0.42754621742496024, 0.3671009733247501, 0.22651545414703622, 0.28554286986477373, 0.3840234018843013, 0.25559808853149846, 0.20757177665531867, 0.197000360022891, 0.20996435666065927, 0.14130924477187257, 0.4229770620958214, 0.25764654333886305, 0.2618480076392028, 0.21806104162818563, 0.34764004795653747, 0.2805223193004931, 0.35219456001042804, 0.42015158793619134, 0.4361318311884854, 0.3519865174983555, 0.4253240657428884, 0.2844954534047742, 0.3299401762506111, 0.37171378412470923, 0.20862995645789584, 0.533517597207205, 0.40035788572643627, 0.518949486035482, 0.49258484851274786, 0.5555336728084646, 0.49094854869832893, 0.563837233484198, 0.548301810575031, 0.5625281028600777, 0.15982527677939162, 0.07355726605432578, 0.09579222250211727, 0.09987049498165723, 0.30227642731285476, 0.15243160194122352, 0.1812933620989371, 0.12549676016947164, 0.17243688967606063, 0.34738153620950196, 0.308487463229033, 0.3052751077302802, 0.33928825877259505, 0.3735702779774035, 0.35860941627059995, 0.3026042277405767, 0.34586351161398987, 0.3546955247805781, 0.6625535919610004, 0.7562088911929499, 0.7417946266126961, 0.7322782838360518, 0.7546773462789724, 0.7450710552616211, 0.7067449196219848, 0.7591690740340747, 0.7095558838586112, 0.13029280322543968, 0.13649701302334472, 0.13456195753566202, 0.13418739651643752, 0.12454082864012794, 0.12740074066660423, 0.13980219409827077, 0.12395561035190317, 0.13340731207269452, 0.20360651171906707, 0.19343864190426552, 0.16702568493129988, 0.20859883233704313, 0.2104972784364969, 0.18528853378600052, 0.16694204157753467, 0.1889891146645749, 0.1909896379524827, 0.45319674475810157, 0.4962907074278927, 0.4753286914740136, 0.5317716150258538, 0.49618832202276797, 0.4824887030657934, 0.5437045788660758, 0.5180334968977092, 0.5665914927871192, 0.3491839503370252, 0.3661735831852234, 0.32759140701692846, 0.39293121577554124, 0.3897051511094133, 0.3287402132089804, 0.35030370305538716, 0.4406286978461066, 0.3730633689153747, 0.19494850033564248, 0.20014611172717522, 0.19329085921247002, 0.2127162881634912, 0.2062332243851941, 0.22702753736912795, 0.21151391290763333, 0.2268310906978923, 0.22160277885970814, 0.5181613034133451, 0.27026154511562006, 0.36205395669528184, 0.4829125183467662, 0.48129338127365595, 0.21941329640882545, 0.4314247846150917, 0.3350681548879636, 0.42042352266275174, 0.18184474874343126, 0.19152251732102976, 0.19310634457804043, 0.7155737146390653, 0.19727631657561595, 0.7143225677002378, 0.7392805408991402, 0.6734339306545483, 0.7829439717553399, 0.7750906696841636, 0.16824993514253261, 0.6470447163399282, 0.19803725006374018, 0.2018445192236783, 0.20127467166679958, 0.20322476197891537, 0.784719265288835, 0.4831666479823017, 0.18377552007792464, 0.1985851924699249, 0.1947460407056848, 0.1776249439317047, 0.2216302457481366, 0.22443221355120113, 0.21791126092540403, 0.1953030618660322, 0.18311060602278872, 0.08808656975001672, 0.08848147383519323, 0.08449293763432231, 0.09319835340402438, 0.0874241985183013, 0.09560933990711151, 0.08547625156693561, 0.08739027074463634, 0.09327235914099297]}, "mutation_prompt": null}
{"id": "13461c47-1b88-4a02-8a04-6afe86faa850", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.75 + 0.25 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.04 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:  # More frequent population control\n            self.population_size = max(25, int(0.6 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.55:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Parameter Adaptation and Memory Usage.", "configspace": "", "generation": 69, "fitness": 0.4304057769667932, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8466980456871638, 0.8426731722128481, 0.8547019214725169, 0.8546500490705736, 0.8682963308413594, 0.8543658756097274, 0.8556726986371859, 0.8549099888199202, 0.8384075378391055, 0.7350474614565957, 0.7509700079841513, 0.7447347476564237, 0.7424870724273588, 0.7407532394266225, 0.7377787523264157, 0.7450316980741947, 0.7267180930472643, 0.7511533652229267, 0.5450496706395287, 0.5413915897640966, 0.44784441810238207, 0.31119936039464824, 0.39457182664477997, 0.4093856871675874, 0.3969866935757669, 0.38357889076331453, 0.4073367453553708, 0.37028758591262123, 0.17249492436954494, 0.1447616581731358, 0.13708306535011328, 0.16485186642142602, 0.3775230729882565, 0.14701186672443378, 0.158800143264074, 0.24944820463088224, 0.9328774265159161, 0.9421370359583431, 0.9703444470632411, 0.9718541577532938, 0.934596798444706, 0.9366150869528854, 0.9549795141215178, 0.9670740952823005, 0.9771289756082795, 0.5421613064140038, 0.6158483053760596, 0.6109306232486604, 0.6293109706514, 0.5964270547865513, 0.6540437574684697, 0.5996902454758051, 0.608108486305512, 0.6052139535681027, 0.7965828566047395, 0.8135839118810646, 0.786312023351992, 0.7994277998535451, 0.8053235885335639, 0.845347309711, 0.8228502978337952, 0.8096954698962402, 0.8217585101312865, 0.3083837053478903, 0.1908439103311822, 0.2761838449804037, 0.23795957002404178, 0.23024216638396922, 0.2933116056978624, 0.4120610819903483, 0.33396212806215675, 0.2828382943892095, 0.27596409033341196, 0.3574171290930136, 0.5158377930456808, 0.3032711765000682, 0.33779296433232797, 0.43541569303680683, 0.24241748102311544, 0.26015375820709996, 0.26737882003482205, 0.42976267610149943, 0.33856756175380587, 0.4320679170702457, 0.07876018711670352, 0.38004762867686737, 0.41933549616399257, 0.37261258369345873, 0.4085783168712571, 0.41202495898986113, 0.5156136308447095, 0.5120221571959769, 0.48655228693706454, 0.5117463092078012, 0.4714407373311654, 0.49840564722147307, 0.5463137596709365, 0.45818631246291164, 0.44327439355518883, 0.11329229625684312, 0.08321342615485006, 0.10047151064440019, 0.21070071825162595, 0.201855280585848, 0.21494927721533563, 0.1508201539960342, 0.13072651188136464, 0.16213136708354892, 0.3057615503424438, 0.2895746845561862, 0.32233274598377215, 0.38206647287637574, 0.3805801195100358, 0.4100190516810672, 0.3364229239306201, 0.34506167134792554, 0.3215213922745792, 0.7399609042873523, 0.7411485784438077, 0.743528304838813, 0.6811187282064921, 0.7473239833862881, 0.718699163424749, 0.7744877380125936, 0.7361804904441652, 0.7547341880053, 0.11450147863919957, 0.13291399178966434, 0.15625521623294703, 0.12144047760209031, 0.11268949164109632, 0.10462899809603643, 0.12279219932983709, 0.1336349986378118, 0.1346684331885445, 0.22472445776448746, 0.16228212491670801, 0.1853467572838019, 0.1666797710429586, 0.18600679162671996, 0.20142474921304343, 0.19372310115143387, 0.16042175240117662, 0.18160937699622803, 0.48298487727998385, 0.5064707598615287, 0.4421161371826211, 0.4809133820575897, 0.4428678648747878, 0.4940168295068452, 0.5747590280499311, 0.5350758802373595, 0.4946358246151942, 0.34500898879215003, 0.32971788105391986, 0.365372163769619, 0.3300998127212571, 0.3098064056300529, 0.3575539987752878, 0.3661832161221168, 0.39163175201547507, 0.3780275596136733, 0.20843245255784137, 0.19050626752598965, 0.18863560124796763, 0.2659476695555629, 0.21450772745429136, 0.2214537273489453, 0.2100562975244622, 0.23042922533332288, 0.2162075353649816, 0.3926995983327337, 0.44027845131856946, 0.33141675870703324, 0.4280945161522355, 0.5104275881849565, 0.4302558663909315, 0.20414054012668092, 0.5224673037495412, 0.4413054275337347, 0.19152094531046548, 0.16394905144961736, 0.7641397905135656, 0.8120394822890563, 0.7403939985948258, 0.8957526589542264, 0.18826986490197972, 0.670633223595869, 0.18394531617942522, 0.6934259423483189, 0.6844911942354824, 0.7081610654085482, 0.2023498339476667, 0.7120616638185902, 0.1966591326046041, 0.21145631544379562, 0.21114708424319684, 0.21079673004356525, 0.24494706050568105, 0.18675512978412745, 0.20945823923170492, 0.19477369718348014, 0.20734908181392875, 0.2043171733279744, 0.1905912597914352, 0.19079776172980334, 0.19334346365832522, 0.08370455836257606, 0.09114173199747488, 0.08943258629897866, 0.10549406304905606, 0.09115399908032196, 0.07964502140279184, 0.09153208427830628, 0.09517014512859678, 0.07628604604967604]}, "mutation_prompt": null}
{"id": "91da8801-c38b-4006-8f6c-70234d7c6091", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Modified mutation factor\n        self.crossover_prob = 0.85  # Modified crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.1 * np.random.randn(), 0.6, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 10:  # More frequent population control\n            self.population_size = max(10, int(0.8 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic DE with Dynamic Intensification and Multi-Strategy Population Control.", "configspace": "", "generation": 70, "fitness": 0.379279362234254, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8978885149877626, 0.9001480709083325, 0.8968856187078033, 0.8877885312548935, 0.8874465108892889, 0.8967451863505169, 0.903103661181274, 0.8851313986372381, 0.8952695567834684, 0.6397156576860009, 0.8427431435970092, 0.8357359402063835, 0.8282556770455027, 0.5610237031398788, 0.6183533531341643, 0.8250274005687375, 0.8252140889152629, 0.8224047962702483, 0.09740825925083463, 0.7266267399986202, 0.12069961768062332, 0.7569589559193742, 0.14870275369281083, 0.6892443242466173, 0.1760618057443567, 0.13759470373463478, 0.1534272226234592, 0.14577976126330416, 0.5600295077139095, 0.13671763170496265, 0.7190996466686779, 0.17274584853525643, 0.1528727240087544, 0.13839019335114322, 0.1339316504654735, 0.14704469175036905, 0.9371533540160142, 0.9606474961121433, 0.9726296001946121, 0.9556181577464462, 0.9524645845537599, 0.9644122633074502, 0.9780614385511036, 0.9499508365252296, 0.952374409076504, 0.6605067796091915, 0.7767462469413887, 0.8010082990801702, 0.7541760982975547, 0.748349056213254, 0.7553961151381862, 0.7560547868877927, 0.722327511279103, 0.7623389551188767, 0.8819406934360389, 0.8738838016801781, 0.3308089093268727, 0.33319720743749226, 0.8850367885564814, 0.27425891911648137, 0.1765284475369192, 0.8952611720551255, 0.3609143452210307, 0.2298978081930343, 0.2530117015113189, 0.25545860321209, 0.281511749541563, 0.27703813932421584, 0.22178532158082442, 0.31771486080333067, 0.24692129856451206, 0.2642602402957208, 0.22959458996453208, 0.23550088339307895, 0.127741374529607, 0.24018035845021346, 0.23258229328458369, 0.24700882534596036, 0.265447834620838, 0.20976105534170475, 0.26644354048191476, 0.12536506501233324, 0.3482350214458335, 0.058230868477116005, 0.10360344084183815, 0.10467870584275607, 0.1889424897737354, 0.1703453663849388, 0.07235928727507035, 0.20147300913897515, 0.19061898572536085, 0.23294632257608372, 0.15742393894573892, 0.10835843445796856, 0.03800728891921212, 0.22175178167588516, 0.29449380052432805, 0.3942067205743961, 0.35560201266715696, 0.0751564663652704, 0.2148319555871584, 0.17050817219404601, 0.09212332344678165, 0.1679818421734537, 0.21230149045169966, 0.1100394597797969, 0.10771958224229461, 0.253945879064981, 0.3289677964233947, 0.34367046021372627, 0.28980770005260614, 0.3725654399674738, 0.39712334379486236, 0.2073028003969729, 0.15614398487349368, 0.3529197380228831, 0.5184069110520599, 0.8077188286296102, 0.6863932598860337, 0.7702106858361063, 0.6420695765853968, 0.8438155901382867, 0.7686130091385439, 0.5897384751723804, 0.7322468538933686, 0.6672665357612279, 0.11203208326106684, 0.14773751937328905, 0.13924118660876517, 0.14033788043556905, 0.1513417817735222, 0.1079054722522178, 0.10727186173746905, 0.11418654042534648, 0.14436738581337738, 0.15385879951192638, 0.1971863811423905, 0.1809297078475227, 0.15285202856998026, 0.14727206055892916, 0.20971028050289253, 0.20920093164935916, 0.16676082187154717, 0.19151824136622198, 0.5075083578442274, 0.5687336314570335, 0.558154991192372, 0.5469530098325953, 0.6077490878280023, 0.41284336253222653, 0.2970115947409432, 0.49413757436572325, 0.498867670419059, 0.4341165928980065, 0.5103164771406141, 0.31613905732615244, 0.25590809288600924, 0.20882018133170088, 0.26885175301935493, 0.3647753537612832, 0.36156598910793636, 0.2944222933113455, 0.1933537270880935, 0.21116186271436632, 0.20803418509125537, 0.23511522789189843, 0.20505694871103342, 0.19931998873374812, 0.20055885368264714, 0.20764173903079308, 0.20955609413772025, 0.2377474280074049, 0.21717337511546797, 0.21639961454092072, 0.24214457744348128, 0.7909873325249126, 0.19246303970241574, 0.23555237579793142, 0.2159578893857068, 0.20969218794009048, 0.16961367738001498, 0.16499167752735444, 0.1621540649562968, 0.172138336541523, 0.19550624619009094, 0.18013183992266935, 0.8728463324500773, 0.19405212423496565, 0.8313856397255783, 0.2047072398149925, 0.16698600585163692, 0.16488691401946542, 0.16375279743629856, 0.12519958664082764, 0.7766670837312104, 0.20853739953197903, 0.20838478391149906, 0.20727572704743424, 0.2300381599270538, 0.21880679917329504, 0.20552294887455647, 0.21596347158319062, 0.2061721266154637, 0.2365695277580696, 0.20656437043271203, 0.20575571488883393, 0.25956906177179695, 0.08716631964857025, 0.09957779476383943, 0.08231424578812752, 0.10088382477871216, 0.1055655369652111, 0.10871357337059584, 0.10484921639120226, 0.09419162769960254, 0.09604266054422783]}, "mutation_prompt": null}
{"id": "ca3a441e-effa-485e-8a45-5a6fe182d891", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))  # Memory for past rates and parameters\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.4, 1.3)  # Adjusted mutation range\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.1 * np.random.randn(), 0.5, 1.0)  # Adjusted crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.05 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:  # More frequent population control\n            self.population_size = max(20, int(0.7 * self.population_size))  # Adjusted population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Dynamic Intensification and Population Control.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8600580482991288, 0.8566379568448086, 0.8496941298656548, 0.8648547653886303, 0.8627132017100204, 0.8626319606972419, 0.8566251447823101, 0.8539978446481107, 0.8622169598405758, 0.7597740597596421, 0.7664931270088835, 0.7565193667902264, 0.7779004016061496, 0.7486714114568609, 0.7615822791759086, 0.7596783769958653, 0.49799695969090907, 0.7505074047889393, 0.5249729369356335, 0.5199221785308983, 0.3972264044904389, 0.3810296813348485, 0.4912466358448093, 0.5470453178192775, 0.4583237033827222, 0.5202405618713067, 0.16673534681325197, 0.48889145695291425, 0.14218747708471924, 0.15451863564990875, 0.4360019308225499, 0.1397170445124457, 0.15838740793613193, 0.530841015906651, 0.30615020145777294, 0.15169638678312936, 0.9481740236682212, 0.9512989903781389, 0.9548381863006807, 0.9706270448538575, 0.969054577938291, 0.9521567225468748, 0.955574282372695, 0.9705297400757935, 0.961853859553663, 0.6718599130800778, 0.6963889708537752, 0.6596225122780628, 0.659125833920299, 0.6234804624370285, 0.6705099817134814, 0.6791157503288782, 0.6635013029042052, 0.645342244463895, 0.8495834786509057, 0.8320256326139733, 0.8544380475286989, 0.8593212162910555, 0.8497161685990867, 0.8178796111805887, 0.8185552370980234, 0.8403118015875116, 0.8215153395884381, 0.4527366710084757, 0.38649729678840417, 0.43355135587613836, 0.5312660605339385, 0.46027544802820064, 0.5461568743460925, 0.3213154696824385, 0.2990149351135607, 0.4120178404565086, 0.27258153066847735, 0.32875685061516824, 0.3331423296054592, 0.42275325492938853, 0.6089174402367753, 0.32914422873543514, 0.4947747118254371, 0.2778754396241143, 0.5792033995773493, 0.5571801361022266, 0.4077217671312119, 0.6078585853723341, 0.5667546297816783, 0.5316253877206055, 0.5385819759570736, 0.5821573565111171, 0.46882881870115767, 0.5317103831340472, 0.6448387994577619, 0.5195799045348353, 0.6562387891834036, 0.18462394234788704, 0.6447327793509532, 0.6242875863018786, 0.6673294113453885, 0.6579371451107263, 0.6611319817460006, 0.30139023676067067, 0.07208383244061112, 0.20937435221544243, 0.39425239173008475, 0.4419618779396307, 0.2986541841101932, 0.3092896794383465, 0.11155794357861559, 0.1630669215945456, 0.29697340633789027, 0.43038907728722253, 0.45403328595886006, 0.5052395782194057, 0.47660615907753556, 0.44442461392954447, 0.38513173926742916, 0.3709781137497583, 0.47014915232275445, 0.7583579472257237, 0.7843684972954277, 0.7831483129742245, 0.680024069260581, 0.7903284198473964, 0.7578175856658934, 0.8040403429904296, 0.7828228181364272, 0.7683074388787656, 0.1397317831255317, 0.14383384425583645, 0.1128853460035052, 0.13530927414259442, 0.11711407483294445, 0.15821040137000886, 0.12999198996816064, 0.14595670321500842, 0.12069864958334164, 0.19777676702260594, 0.22062586796406936, 0.1920795911184643, 0.1489668794241532, 0.20973074315024265, 0.20654322994962004, 0.22215070101040169, 0.17430239657247892, 0.2016294674605259, 0.49484915677146046, 0.5081594197383501, 0.5708723419077797, 0.5466160669810038, 0.4670333848831987, 0.5325536830951414, 0.5829681256735649, 0.5860734203448494, 0.5486705150251217, 0.41026053122527373, 0.355012322066537, 0.38687219623280533, 0.36423696149455587, 0.41546449215438486, 0.43162384444270796, 0.4260766763424, 0.4194161918270001, 0.4356086074712746, 0.20490488112246308, 0.20434962864363837, 0.1980571695660588, 0.1804025884092303, 0.19060745964491121, 0.2085452397157691, 0.18552954308671243, 0.19619313628818424, 0.216256067128335, 0.5169269551179024, 0.5518540408176803, 0.20988544233658213, 0.6392949218505126, 0.2008466962598745, 0.47969755756568777, 0.5560774645002418, 0.20426571963634899, 0.23597034511026127, 0.8357319370817792, 0.19604584902731303, 0.1998022062800695, 0.810732403694816, 0.1903550432263531, 0.8510796530284033, 0.2053194411123428, 0.7123216485010093, 0.18206177781594435, 0.7813354919816526, 0.8241862934288289, 0.20454635454221137, 0.775572347110532, 0.2067096520628383, 0.20232064449409093, 0.20799719852041365, 0.20792989888562108, 0.20696974828707815, 0.1880087088877208, 0.18263904030267464, 0.20904457601846393, 0.1944095065884428, 0.1959323225582683, 0.20108550526147861, 0.18820725259977367, 0.1883718242726503, 0.18433152606127656, 0.09674107792256237, 0.08821795934786336, 0.13631039977658888, 0.08700960107078148, 0.08771389558867848, 0.09998531617660866, 0.09092953630327794, 0.08342699150662425, 0.09231691581714496]}, "mutation_prompt": null}
{"id": "7f8cb4cf-de76-413e-a9cc-57ee3f92e3c4", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Changed initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Changed mutation factor\n        self.crossover_prob = 0.85  # Changed crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Changed memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success  # Changed base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)  # Changed mutation range\n            self.crossover_prob = np.clip(0.75 + 0.2 * recent_success + 0.1 * np.random.randn(), 0.4, 1.0)  # Changed crossover range\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Changed step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:  # Changed population control frequency\n            self.population_size = max(15, int(0.65 * self.population_size))  # Changed population scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Changed intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Adaptability and Strategic Intensification.", "configspace": "", "generation": 72, "fitness": 0.4631803674809658, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8873461455911236, 0.8880119857660669, 0.8880515873032422, 0.8899108434964655, 0.8784116182881543, 0.8968530693734542, 0.8957403720063719, 0.8841921661290213, 0.8810010009083301, 0.8327957742335278, 0.8150402297345002, 0.8181814809046459, 0.8056592867375726, 0.8125540350419411, 0.8100980457518256, 0.8090432879170762, 0.823409816915288, 0.8282613336171221, 0.6268394785174328, 0.5663063019775576, 0.6009886289693106, 0.17907481779655188, 0.6600952249627761, 0.17257052320611, 0.5879004871784581, 0.7464914671130285, 0.6322816600422858, 0.16455778416963063, 0.6646965021563532, 0.5589736392111173, 0.4283997846413218, 0.15146183810247948, 0.5648931489359807, 0.1635556770726342, 0.16397087747996097, 0.15103455614978645, 0.9686814572946231, 0.9507122863082147, 0.9736795470351838, 0.9612554860546664, 0.9506594759777178, 0.9568830711765667, 0.9667111310685411, 0.9694780633437337, 0.9773388407128542, 0.7149961217626316, 0.7190689677696815, 0.7188302841988767, 0.7133697260574943, 0.6873088406794887, 0.714034179954286, 0.7213490380864884, 0.6925738346404225, 0.7236572247391021, 0.7890718711896846, 0.8457524113067478, 0.8549078865288864, 0.8247029279102811, 0.8419894501772374, 0.8570058164795213, 0.751702709679393, 0.8183020097805784, 0.8288129688234042, 0.6737941576796806, 0.511070935306214, 0.27310281863572805, 0.4440626827536429, 0.4797416120850455, 0.5329512779846148, 0.23664901628127832, 0.53036759753497, 0.5461198982245148, 0.3173132744566376, 0.5448610894164445, 0.11708237347774486, 0.547612907940381, 0.43041761101003473, 0.5235652345885176, 0.308614242778277, 0.5304299181601086, 0.3833232716598075, 0.22892445253961735, 0.6000418577213863, 0.2688965284328667, 0.2455436112621956, 0.5834472147993496, 0.06970069735858464, 0.2252908963369885, 0.549358943435464, 0.3851282967980634, 0.5638032196236996, 0.1365595907904228, 0.49755890324394636, 0.537350146750299, 0.3724390695557136, 0.1881283063593704, 0.6502551193708163, 0.6872199748678012, 0.5493710675183483, 0.14098169719459197, 0.19206732316355324, 0.06600515014488151, 0.21498208328859103, 0.25607132268545174, 0.17287984191253403, 0.21252677410377274, 0.16934445912952323, 0.2885199720671894, 0.36761214984461354, 0.3503017200020212, 0.3325226678668115, 0.41616894814904903, 0.45655501889373507, 0.39214982244742214, 0.4251520789000698, 0.40014137323348964, 0.40015052002803164, 0.8079126304863162, 0.6985957785689481, 0.8070544435267246, 0.7194664783129847, 0.7106474094931123, 0.7941015760993648, 0.79346536829182, 0.6467200189298656, 0.8166723847350709, 0.15346619730771704, 0.1295990941390388, 0.11153257050186549, 0.11804843089940698, 0.10820089683280598, 0.11710740231196126, 0.11447401843747451, 0.11214709516972032, 0.13079428547132266, 0.18379476474591594, 0.16245788342433554, 0.15222998211711636, 0.19075306637607436, 0.16905169171975098, 0.33951299436379545, 0.256191473366154, 0.17698877624736908, 0.19240258907035934, 0.54241959510995, 0.586499021969392, 0.5777863818640582, 0.5012425267539962, 0.5604599160204375, 0.5989512611189827, 0.6014040617617181, 0.6506609895809758, 0.6380504578106254, 0.3748734523747622, 0.3963686337511124, 0.33364900155313404, 0.4409093180966991, 0.39268904924181625, 0.3068566646905404, 0.47961369271142584, 0.3052840065455442, 0.443425388728524, 0.23233083028693535, 0.21269733940442204, 0.18622327047511267, 0.18432173575510646, 0.20600877572254417, 0.18989066561823242, 0.22408489955019328, 0.20701096395263008, 0.21504889654914272, 0.6680397964096298, 0.2169000903231194, 0.6792444381468417, 0.24172243015694805, 0.6570018302332583, 0.2198870302310698, 0.7089399897977707, 0.2345282423373073, 0.23485911022103279, 0.1915478206964366, 0.7831645615310101, 0.7745694350978399, 0.18460070129343775, 0.19835919850309458, 0.16648649213726308, 0.7248569993669045, 0.874451188274822, 0.7060230710219667, 0.16794496203651166, 0.16654855097212384, 0.20393896451164506, 0.638788430070986, 0.1653696067303081, 0.21078520672476941, 0.12506586331000924, 0.12727763670696401, 0.21038356146164128, 0.19271918784661501, 0.225646479345061, 0.19838848681732624, 0.2161122336543927, 0.5837296720758275, 0.20152086944107672, 0.20775054169050933, 0.2037204968052574, 0.20940761226260207, 0.10550784885825837, 0.09979104989544707, 0.09448748965913834, 0.09952824193658671, 0.09579266084684657, 0.09870869859924802, 0.09927925340009536, 0.09526379364437032, 0.09044860693211698]}, "mutation_prompt": null}
{"id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:  # More frequent population control\n            self.population_size = max(15, int(0.65 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.55:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic DE with Probabilistic Enhancements and Strategic Redundancy Reduction.", "configspace": "", "generation": 73, "fitness": 0.4849856168910749, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "f108822a-2397-4021-b6ee-f9ef5a0115ec", "metadata": {"aucs": [0.8764576771062145, 0.8788405533328811, 0.8934371200361828, 0.8825368238614877, 0.8991107444117239, 0.8995491252202857, 0.8927277084161738, 0.8824768898130568, 0.8831662829242363, 0.8327957767667631, 0.7078684891213234, 0.7957946419925214, 0.8112772879138395, 0.7953817576120061, 0.7949693837194597, 0.8051272702507339, 0.8099452469546982, 0.7978447203721246, 0.17352891847713603, 0.14081375467453894, 0.14618537893941974, 0.15193404506665031, 0.17631249265460014, 0.6066505692402012, 0.6497022311012014, 0.6201595024437454, 0.17254412721345636, 0.16856194910683442, 0.16924775555144622, 0.5822388201878907, 0.14411519775323156, 0.14582731057428222, 0.4742914734093583, 0.17305415924900303, 0.17045714822680602, 0.14939340443993188, 0.9340887749191638, 0.9633790152146765, 0.9330166200970551, 0.9464722619268182, 0.9549689255955801, 0.9525459276058755, 0.9576445526061662, 0.9409579911080831, 0.95373684415982, 0.7300884103741836, 0.7552085032782688, 0.7510234228004375, 0.7723377043151362, 0.7311341056551484, 0.7346276803531073, 0.767201144487513, 0.7297274473519542, 0.733434094563091, 0.8411971396943638, 0.8871219907255867, 0.823211160208054, 0.8579924966134809, 0.8645285075239656, 0.8409890996220256, 0.8660585484960793, 0.8667617371387963, 0.8930445177347027, 0.5273300104106958, 0.6341079150876536, 0.6207036397077557, 0.5282214299339147, 0.7710590667637561, 0.3852641513962327, 0.418118015878299, 0.6423047706989978, 0.6704104003834676, 0.2467323953020224, 0.47714912177176505, 0.43784219939503133, 0.4946722925168787, 0.5506266577747372, 0.48626800020729366, 0.701766891376933, 0.7363622223811813, 0.5445276589726009, 0.6846924895593136, 0.3447431843782922, 0.4989665054508198, 0.21624376830027925, 0.5823672576335814, 0.5622483867076464, 0.6927150895915692, 0.6668706490063815, 0.2896411020182248, 0.7337860068272881, 0.23111062738476107, 0.3578650532738705, 0.7385084620715587, 0.6746312597648625, 0.20260305458675743, 0.7560852879430751, 0.6648339792390952, 0.7587247837710787, 0.11245265246023806, 0.42893627582589866, 0.05251213723827719, 0.41005461865719195, 0.25643990992242105, 0.30177056804821356, 0.2205509088014832, 0.2175686475544809, 0.11532187606156019, 0.4645432010960524, 0.5899878521276756, 0.43888298616995214, 0.6021836304630508, 0.5891663223334432, 0.44786011109446056, 0.5463939259993338, 0.4012414341266757, 0.5470394515264083, 0.8370469561045553, 0.8211353414295142, 0.8399439297065345, 0.5929036043188931, 0.8278125002141249, 0.8190586060379205, 0.8275290216242153, 0.8471686973273168, 0.733721882064496, 0.09991077380469304, 0.14315014923787184, 0.12937533592915684, 0.13791241537836485, 0.1535403243011071, 0.151736802664033, 0.13540657192469585, 0.13116622091030206, 0.13937530690454392, 0.21391526966481733, 0.166604849980458, 0.7316113496154911, 0.17858817278403383, 0.16249444272689784, 0.20937964824105004, 0.2073584580714467, 0.16558768299867077, 0.16276980329272595, 0.6728903435095781, 0.5815232078928015, 0.5427043015625124, 0.5662351025985524, 0.5356476759230291, 0.5837987950084735, 0.6472663921749524, 0.5457509043608055, 0.604233198591936, 0.5171169171873189, 0.4302773949977683, 0.45405605759202083, 0.5423270669303601, 0.3891926155340075, 0.4459963767897519, 0.4173726707824199, 0.5019323556613743, 0.5906628978853294, 0.22988793427378174, 0.19927096975462122, 0.21483900237207698, 0.2185322916759369, 0.18276324250431786, 0.21259143570851025, 0.22063678769684247, 0.21936975107999424, 0.23294104601226506, 0.21204599959201276, 0.2193350423922028, 0.2379762136911019, 0.6185392380832142, 0.688274383152087, 0.7286638305857293, 0.7928794136094544, 0.23303803701056536, 0.21608081674401625, 0.20517578753736954, 0.19482001981024022, 0.15104844349503, 0.17493495761150846, 0.17766882114664984, 0.8875492331089175, 0.19621277240217128, 0.18593975729550616, 0.8124295816668702, 0.8765250948434298, 0.16740987110516692, 0.8493414858528607, 0.2063060657630439, 0.7572631605300012, 0.20774051721418507, 0.20604853107885857, 0.2055129924364122, 0.2108696341655354, 0.20898185282831072, 0.20217491226628082, 0.21551920403762537, 0.22731153340446664, 0.22435068277369352, 0.17799363622467967, 0.19842433382602298, 0.1907175324356405, 0.19414325966396428, 0.09037800969616783, 0.08864611020158897, 0.08946990579220804, 0.09258040839650017, 0.09376832759893439, 0.09657366842479365, 0.08621354843532536, 0.09427173136665079, 0.0898893765768537]}, "mutation_prompt": null}
{"id": "e7f6b74b-3c28-47ff-a1a8-18af4f25c894", "solution": "import numpy as np\n\nclass DynamicSelfAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.05 + 0.02 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DynamicSelfAdaptiveMemeticDE", "description": "Dynamic Self-Adaptive Memetic DE with Multi-Vector Crossover and Intensification Enhancements.", "configspace": "", "generation": 74, "fitness": 0.4770781569460611, "feedback": "The algorithm DynamicSelfAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8559190282203545, 0.8432005253569496, 0.8550946626583282, 0.8424609449044319, 0.8588880010366275, 0.8432512426130356, 0.861547815208044, 0.8628558652673903, 0.8612463099367251, 0.7425763139992199, 0.7742039989690973, 0.7474051185933515, 0.7663051448763097, 0.7555949332487855, 0.7756953194764349, 0.7567673991152898, 0.7586993867354319, 0.7645778286558458, 0.16205908803156377, 0.31720071418514173, 0.12427610002787182, 0.41511617582655336, 0.19978262519916135, 0.42358203243828507, 0.14559203232134243, 0.23466337128356995, 0.1599900488677678, 0.14374489953558545, 0.15037160910488434, 0.13819000963077765, 0.13183082175172456, 0.13649191975212727, 0.13044512841944145, 0.12693406460508483, 0.1452762872141682, 0.16446208544156748, 0.9213367656416925, 0.9639964846409952, 0.9306644786795076, 0.9664275857646769, 0.9408175597509331, 0.9509107468814109, 0.9610151807280217, 0.94790099936352, 0.9757768708406808, 0.6804936907969619, 0.7090218974829146, 0.7064285944330577, 0.6715843874009271, 0.6736733122025669, 0.7012634014065118, 0.6752069877723331, 0.7040038264479624, 0.6849520753439894, 0.850796499651612, 0.8261666946428987, 0.8543623163119356, 0.8388235428813217, 0.8706619477599409, 0.3664812836528746, 0.8790092145143698, 0.8264927872778853, 0.8760628087836723, 0.3373699259347258, 0.2917855327310155, 0.5742327907785697, 0.5690102726050896, 0.6705889461543312, 0.6631376764883463, 0.5032727949792413, 0.6652529543671439, 0.5314606936888352, 0.6843702158563558, 0.4565594665784861, 0.40516058628473295, 0.2704244694718856, 0.6439822776842112, 0.4748870347969478, 0.5528877727829613, 0.6900476086472155, 0.29184938440719965, 0.680380140911292, 0.4811018657649062, 0.6639585805765899, 0.6614093130680838, 0.6696529958106169, 0.6614139173546496, 0.6968848882693011, 0.6463977813827184, 0.6933588682009699, 0.7429774810211961, 0.719033068440998, 0.5890217817173456, 0.7643186937164277, 0.6916856518692893, 0.7179151929190608, 0.674230588697449, 0.6702411256362677, 0.7281052918746955, 0.4056602481920679, 0.37335984381067966, 0.3148793867300326, 0.2042064397466482, 0.1856254915153065, 0.21610155620219673, 0.15967270733559358, 0.11284186459884371, 0.21300862325183734, 0.5094304109234752, 0.5799990884343154, 0.5429393728637089, 0.5304569594589923, 0.5705324309838535, 0.5945933423039156, 0.5623234867809307, 0.5757420807994569, 0.4486392410370116, 0.8269945694834633, 0.830028497989247, 0.8199481484930591, 0.8204514576819136, 0.8043399216653744, 0.8226776015707209, 0.8244479418473523, 0.8110081921000201, 0.8333964329347255, 0.16207535577808663, 0.11415566813888378, 0.12634728804852458, 0.12322602139522931, 0.12748841508327513, 0.1736480177476466, 0.16647628797841973, 0.11424042054409933, 0.1410548699959543, 0.23119567680331554, 0.34614190134287404, 0.14716385281989208, 0.2215658705407667, 0.20486693240437093, 0.17441454010800195, 0.24238336580235742, 0.17592260348809485, 0.18715878928682483, 0.5597378964559295, 0.5624268924046336, 0.5850642231086356, 0.5345751599199947, 0.518838792960203, 0.5508315622579691, 0.6314506112560541, 0.6119038267185835, 0.6089279086387774, 0.44124700697092856, 0.5143373923694433, 0.4703766984888669, 0.439094594125216, 0.4000942166741567, 0.44207801530366975, 0.45625208312965493, 0.508797645138181, 0.481863357390958, 0.2140071136294106, 0.218317542793402, 0.19797532386760486, 0.2079009526664164, 0.20782522440843154, 0.2042210933187215, 0.2095816793297054, 0.22966175065099725, 0.1989130690449038, 0.6006054044187957, 0.5685617676557091, 0.201885271841032, 0.23004967749134841, 0.2274877392525978, 0.3756227870096023, 0.22804218761123185, 0.19375996834946507, 0.5819203477793751, 0.17125000076184937, 0.8163338447014714, 0.14940111542236756, 0.7698885122619703, 0.19547176457865223, 0.16238627703653563, 0.7830090823620202, 0.18378315178251337, 0.8428364379171631, 0.16564874232307614, 0.20653938611754907, 0.20457306053747848, 0.7781764273622189, 0.2072001459073084, 0.8911590007707839, 0.16533882399969058, 0.20939105824904736, 0.12673710665163485, 0.19420334650423687, 0.19015190931913772, 0.19141080829258506, 0.17958082437686462, 0.22500583647563266, 0.19062716719136685, 0.1955727707723538, 0.17696032970450726, 0.19578901564241025, 0.08625061073231066, 0.09675745917236145, 0.08068744080110424, 0.0955295893900453, 0.09145889540281082, 0.09620840376711126, 0.10177716622656374, 0.09641998742592972, 0.08929997490397668]}, "mutation_prompt": null}
{"id": "79d05fa8-30d6-4e31-9941-425e59e7ad01", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Slightly reduced initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Slightly increased crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Adjusted memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.05 * np.random.randn(), 0.4, 1.1)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.04 * np.random.randn(), 0.65, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.025 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 12:  # Adjusted frequency and minimum size\n            self.population_size = max(12, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Adjusted intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticAdaptiveMemeticDE", "description": "Probabilistic Adaptive Memetic DE with Dynamic Strategy Adaptation and Intensified Local Search.", "configspace": "", "generation": 75, "fitness": 0.4231797415780039, "feedback": "The algorithm ProbabilisticAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.9027910932540385, 0.9065962631541371, 0.8981581761940104, 0.9068943794594229, 0.8890727020684206, 0.9041070549748779, 0.9063178328913147, 0.9146107117123827, 0.8976401645024766, 0.5360074169317128, 0.8353803673985817, 0.8247931839995533, 0.8200961643014442, 0.8406754140554057, 0.8371013134442151, 0.8421747964655424, 0.8415701392424442, 0.8404104430864994, 0.18655977303472393, 0.15218109981217165, 0.15670710313919411, 0.18257048153460076, 0.1670028613845005, 0.13652865286197957, 0.12142146767429607, 0.1580925085525332, 0.1377857365637576, 0.14120920511980017, 0.11364025314847659, 0.126305756653045, 0.14059694765257102, 0.1278577231149014, 0.178142130469075, 0.15262293603194155, 0.16870563664444582, 0.6091648791156709, 0.9785769694526752, 0.9627891669390449, 0.9548286677742794, 0.9670656175317754, 0.9835736873780895, 0.9586973313146436, 0.9755999827651616, 0.9259443982000017, 0.9655273396889867, 0.7825898589771145, 0.7644041947122847, 0.6959075471501319, 0.6858175220954156, 0.7841354843970038, 0.8117751339819494, 0.7345992383307822, 0.8019327828019335, 0.7082623929544085, 0.8921319628729798, 0.8951446991584397, 0.22666609852758624, 0.9115521128211413, 0.8960716801687099, 0.8659625685108552, 0.8911456626053433, 0.9034004145586089, 0.8868210053999283, 0.6222168649355071, 0.2628889498445234, 0.7450983072246934, 0.350143661261349, 0.6119431993561739, 0.6276476559023715, 0.3935470071241395, 0.3333069418232558, 0.2367639757940383, 0.1715549273055087, 0.12260045808403197, 0.20203625145879212, 0.6406235809512668, 0.1327892239890578, 0.3623135054862281, 0.2905213999148887, 0.695818133149334, 0.7033714249924221, 0.44180093384601526, 0.07956051738631975, 0.07714721562810478, 0.2230375720381912, 0.12594547632729713, 0.33197670201470897, 0.24348809717149655, 0.1213376382903103, 0.2983791544914184, 0.34795790740822086, 0.1935732733578731, 0.1791798784492803, 0.18996535178503504, 0.3697596042136416, 0.25648769148061523, 0.32464823996026104, 0.12749552036596357, 0.657780612117856, 0.10003853105573235, 0.16672747144575695, 0.05911365884279074, 0.19941453256809616, 0.1622138924423825, 0.22696250090889203, 0.17542184785704706, 0.2620448120490432, 0.16976877760184683, 0.41488626050284927, 0.2772598101263255, 0.2873079266674836, 0.46954221989582257, 0.3375266818756474, 0.4451992582857499, 0.36311704064975137, 0.3676744288750655, 0.4447096824196972, 0.5874627113141963, 0.6546289994366903, 0.7470109810124168, 0.7269627281857454, 0.5854949827188278, 0.5844756075648581, 0.6569138988299414, 0.6058871059066204, 0.7246341015480708, 0.07926345628049236, 0.15512303403047878, 0.7342738276959617, 0.14633585438186714, 0.15095890279523716, 0.10970647626718133, 0.16122807636840064, 0.17516860720817207, 0.12524574318997073, 0.7174322173210442, 0.22925387449221102, 0.17968123585699214, 0.30757252936083357, 0.16396701335605235, 0.2717362089974016, 0.1657760250302539, 0.18692223570324829, 0.15705868152011448, 0.5397684486659242, 0.6374130665417339, 0.5749060337572889, 0.4656064452954153, 0.7059842830093588, 0.5546411811229772, 0.4811615331618486, 0.5867079230494865, 0.5251370633660619, 0.2626384320002857, 0.26821642988790284, 0.4131268761313813, 0.24369913637370932, 0.4862587516728729, 0.214816581447964, 0.34932024026307684, 0.40495402340887154, 0.5251606875489149, 0.2090652174068982, 0.26723408013465055, 0.2611892590703021, 0.2218120502456924, 0.2670563898374878, 0.23659645402218843, 0.21954331845995523, 0.21841586103932176, 0.210115845895799, 0.21965373387723275, 0.2452167781405774, 0.20639645831546827, 0.20277098702671725, 0.22223772061696667, 0.22457160900874762, 0.2455728182575051, 0.20252371588686013, 0.2229007639826024, 0.18461872748458086, 0.19818507677878283, 0.8558914910689905, 0.9072897940504725, 0.19897294500708562, 0.8565335384629976, 0.14682205088365952, 0.20713929980712087, 0.16224015756601584, 0.15495063417042398, 0.168119852814271, 0.8859585360198929, 0.9204259818103845, 0.7887352084205628, 0.20844695284279924, 0.21169149062966008, 0.2110226712393266, 0.12708028500364854, 0.5195964466791076, 0.2254688441961018, 0.2957289983400203, 0.20241606168953574, 0.24323013655408032, 0.2055850447428762, 0.20406235740365697, 0.25498769884397066, 0.20521055047945191, 0.09047760683948713, 0.0944778970390373, 0.09444929680999159, 0.10248094224619397, 0.09665372251419035, 0.11064064612425994, 0.10741450426498356, 0.10164655493516761, 0.08955438306910601]}, "mutation_prompt": null}
{"id": "b1f0c2c9-9b2a-4ec2-9c11-32fb81780139", "solution": "import numpy as np\n\nclass DualModeMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Enhanced mutation factor\n        self.crossover_prob = 0.9  # Enhanced crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n        self.hyper_heuristic_toggle = True  # New hyper-heuristic toggle\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.4, 1.3)\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.07 * np.random.randn(), 0.5, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 20:  # More frequent population control with environmental feedback\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.65:  # Increased intensification probability with dual-mode\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DualModeMemeticDE", "description": "Dual-Mode Memetic DE with Adaptive Hyper-Heuristic and Environmental Feedback for Dynamic Parameter Control.", "configspace": "", "generation": 76, "fitness": 0.43885736639703543, "feedback": "The algorithm DualModeMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8350166014102569, 0.8576287918762027, 0.8492417440673334, 0.8654080415327658, 0.8375916302638889, 0.8600674297903272, 0.8322974798934992, 0.8531129563409878, 0.8387474879452256, 0.7375904321337817, 0.7349178845359423, 0.7547204055920751, 0.7158318662506873, 0.7565055215659087, 0.7336154509548044, 0.7508062495480899, 0.7360162300813615, 0.7179269867377067, 0.36178580478563316, 0.441700221843917, 0.4477856253468716, 0.32337266989801494, 0.43163322929180536, 0.48168026597317726, 0.5482892672569561, 0.45528899726876704, 0.3817135290856659, 0.1392271232251071, 0.35843112263770416, 0.48596300760514444, 0.1434113022940814, 0.1524377340423615, 0.397005516687125, 0.1642437681881349, 0.2029239647763008, 0.35827618389899685, 0.953162520379016, 0.9677173071990108, 0.9337856587815173, 0.9575498814215301, 0.93377163896957, 0.957113900105228, 0.9400348590465135, 0.9315718026417541, 0.9597410575231426, 0.6120223778451124, 0.6253387748349841, 0.636645608732344, 0.6470535918234446, 0.6151687780432383, 0.6012452417233396, 0.5949720371714169, 0.5990680730315929, 0.5955141054603871, 0.781930599539427, 0.7921010761194885, 0.8102685117912909, 0.8341055764933271, 0.8279464142805616, 0.8398850761328078, 0.7915158176328797, 0.7948845545321361, 0.8167707038626647, 0.4330984756652083, 0.41014753880719246, 0.47249597063696624, 0.36909657710300514, 0.42046153677469034, 0.49220625713339794, 0.42341670647140317, 0.5008063811752201, 0.43582941304451206, 0.608549745132412, 0.1473428756056352, 0.32221271079758707, 0.34216353825446877, 0.4375030238579549, 0.5366804313910515, 0.5615668109405608, 0.4323591287949595, 0.39186042050108916, 0.4411913091504326, 0.47731006233599316, 0.46289347150395144, 0.43020253085819216, 0.42242274974362004, 0.4248537872329836, 0.4654961545122175, 0.4236294978192051, 0.41608420967885695, 0.4929440355094318, 0.4914030908022856, 0.5629622059642541, 0.5216548839887127, 0.551062389335438, 0.551755885270703, 0.5928419942165273, 0.5941400177146097, 0.6095049842497346, 0.1948154505882156, 0.12463415995910132, 0.125401220280429, 0.14280334195322852, 0.1490410820414958, 0.3562827859068133, 0.2049311880530461, 0.1525428949152955, 0.1761475376580418, 0.3743388642504941, 0.3717505287413885, 0.3528569513519234, 0.38772330966921986, 0.3525836056923054, 0.4200017186493137, 0.35803943317109654, 0.34076183405084026, 0.360337063580365, 0.7353665681003811, 0.7333566905701041, 0.7534321473192425, 0.7369910263905286, 0.7432026314419702, 0.7357075162298479, 0.7455464250531951, 0.6081418797058813, 0.7531892880766435, 0.12114776935919724, 0.10136658766357665, 0.11291436227618346, 0.11113359028733594, 0.12356846497311913, 0.11375414807919937, 0.15345956375727543, 0.12492311406963941, 0.1009513003756034, 0.1734165768492163, 0.25631796782399774, 0.18968767185050328, 0.19529493953271626, 0.18341022101092452, 0.2178854774785005, 0.22046327795111542, 0.44110238026518667, 0.17199913576342785, 0.4387750404156976, 0.5250441290308898, 0.4926759396599524, 0.472302001699481, 0.42447539678188384, 0.47405000390919527, 0.48383239802897693, 0.484782096315979, 0.5281061339822385, 0.3276873832210575, 0.3324292461970042, 0.3846320226014823, 0.32895948056373836, 0.30677697842930307, 0.3722332428670636, 0.35151645484709615, 0.36873387500554466, 0.35262720694753225, 0.22076424620341406, 0.2265261894634687, 0.1993126476231557, 0.18439067546400745, 0.18488997600145407, 0.2074840733384501, 0.20890659998294403, 0.2172354331305819, 0.21511210495489663, 0.49051576488461535, 0.4046112234171857, 0.23942892942736815, 0.4780029371560518, 0.287194032601535, 0.4914496442866554, 0.22538662930976738, 0.37082170136543247, 0.2291064778300751, 0.7879886903367294, 0.19642729243984813, 0.15002243845930718, 0.17389627195546598, 0.762393113306892, 0.834063363719741, 0.19994192065712113, 0.17793044544094228, 0.19538348223359814, 0.16550863404761762, 0.6965744281996812, 0.16636832478573538, 0.19864191576764811, 0.721010362995517, 0.20131980454306564, 0.2061827755163721, 0.12461991246245852, 0.20934953251992816, 0.19427349237589087, 0.26207368090513705, 0.35000261249526743, 0.22581494124060053, 0.22069839562196836, 0.20336562647732903, 0.21119552800817942, 0.2008450958359842, 0.2334452636647425, 0.08948376322905638, 0.07430692986457421, 0.08963926576927184, 0.08953582241668323, 0.08422940839639415, 0.10527526208730431, 0.09874369771410152, 0.1065693765404514, 0.0893193882979465]}, "mutation_prompt": null}
{"id": "8461bdad-bda1-46dc-b399-e2839b4b426f", "solution": "import numpy as np\n\nclass ProbabilisticStochasticMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Slightly reduced initial population size for efficiency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Fine-tuned mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Slightly reduced memory size\n        self.memory = np.zeros((self.memory_size, 2))\n        self.intensification_prob = 0.65  # Increased intensification probability\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            self.mutation_factor = np.clip(0.6 + 0.4 * recent_success + 0.05 * np.random.randn(), 0.5, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.02 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 10:  # More frequent population control\n            self.population_size = max(10, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < self.intensification_prob:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticStochasticMemeticDE", "description": "Probabilistic Stochastic Memetic DE with Dynamic Intensification and Population Adaptation.", "configspace": "", "generation": 77, "fitness": 0.34734361063107105, "feedback": "The algorithm ProbabilisticStochasticMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.9181299822274308, 0.9136553656237748, 0.9227541714368923, 0.9207834741262904, 0.8606351813367111, 0.9282385722830679, 0.9233296120736372, 0.9268653514992766, 0.9139805088412203, 0.8622103135918762, 0.877113349789546, 0.8598500291794988, 0.8893426104428739, 0.7937165774715528, 0.886640330519562, 0.7508242650344784, 0.780989945386569, 0.17629954519931812, 0.11999630180327547, 0.14476121433020395, 0.14563415835052762, 0.18081825836388243, 0.11835851588958557, 0.14159434633501622, 0.16933116268499615, 0.15635958493590407, 0.1608160604538964, 0.13208920471542973, 0.11386934278163297, 0.13970355530808498, 0.11497756730336206, 0.17415272367705947, 0.15553268131361087, 0.12206077102602719, 0.13981939818763733, 0.10958977422787952, 0.9623156701231876, 0.9670106687332557, 0.9316212606768147, 0.9539660918754678, 0.9838574752172424, 0.9535627713507775, 0.957819779858919, 0.9502460691459398, 0.9289213804156471, 0.7309880016383714, 0.6101373579636941, 0.6147257657480081, 0.662639891201426, 0.7374722029924126, 0.713408105887539, 0.7468720383360872, 0.6580871631614646, 0.5610108016802162, 0.2912425797733532, 0.9165446396943853, 0.9225543338004338, 0.27867043374198575, 0.9273695988206669, 0.11252641752154069, 0.16645168405825972, 0.23584698478851118, 0.938685622353978, 0.13229132082381512, 0.17588795678761293, 0.266612349191386, 0.24047647342712275, 0.19253163641093318, 0.296717299458776, 0.23145666124066833, 0.3065178700793505, 0.365734157535648, 0.13264865152918937, 0.12157302037878415, 0.6222521942026371, 0.24855631431709335, 0.22900512169284193, 0.24016262786287512, 0.2094219778907611, 0.20744534758184474, 0.22634586860634354, 0.007498368146607426, 0.1540161931848939, 0.007445453986791084, 0.027011720425686336, 0.10065192318333227, 9.999999999998899e-05, 0.14917616467782369, 0.11008571946817969, 0.13584846914962823, 0.20571591771262565, 0.11628606858748369, 0.09969326938967993, 0.11246772475600797, 0.1083648556704424, 0.13009068985423233, 0.24844006175499211, 0.08620154839801653, 0.19676701046691625, 0.16215090617260264, 0.10150073587667574, 0.06528758023260905, 0.15786141175728297, 0.12408288029996106, 0.2797069828078992, 0.12449306152062312, 0.11386398507263307, 0.11280113367553568, 0.21059556237462418, 0.31009082817894873, 0.38241780295473116, 0.015650892525347126, 0.23165897131701318, 0.2003886657079057, 0.37232083915282943, 0.3810758766967718, 0.15038383133938382, 0.5826915972063178, 0.5686268894425629, 0.6034492979621182, 0.599865749989489, 0.5703216302113796, 0.6189191505715359, 0.5467905730763194, 0.563622949695227, 0.6249692687156736, 0.1426488907643224, 0.18124827290330592, 0.12265881903765563, 0.12365422712540108, 0.134587210051617, 0.12049814207191412, 0.14154979097282883, 0.10753886619720032, 0.13022102610163078, 0.21405562469203232, 0.2689899641843544, 0.15581729610071893, 0.18421016964533776, 0.2777388756531244, 0.20642196313087902, 0.17887144594738258, 0.10787416979490005, 0.15591569413901074, 0.2536822572419538, 0.6149791506676707, 0.551370566206584, 0.5288152962449126, 0.5070799590430464, 0.4197616977384061, 0.5992812419272259, 0.516733874726229, 0.5093094871628105, 0.3605005793602818, 0.20594967553789512, 0.31081731620632524, 0.32336262007022587, 0.2739952911792045, 0.24507685173215743, 0.2651199499833843, 0.3256076425935239, 0.26680863240731, 0.23544152708767274, 0.24446214765315177, 0.24129817404456277, 0.23855547459995574, 0.23591380372000326, 0.22634560300675455, 0.22039776056380178, 0.21726162293188211, 0.22465902896454226, 0.1880860671884973, 0.8246008878431331, 0.17306729634483364, 0.2437885191138367, 0.20751861721266007, 0.24669589223060207, 0.22372185909432174, 0.2204179686844242, 0.24629894922690954, 0.8913064780222052, 0.18634081635615307, 0.18725057274685075, 0.1686501766138061, 0.1994579219512932, 0.19879980129490937, 0.17524833597507072, 0.21062738642559187, 0.1649304354673462, 0.7682918218281054, 0.16867686961528738, 0.7231573155128492, 0.1678134810735673, 0.16458207675321412, 0.2079891838690493, 0.21203038367506322, 0.21167688727079037, 0.21096666914364026, 0.21877628149976025, 0.1978567297987034, 0.21608738883074308, 0.23470449780047975, 0.23255041441710866, 0.20345546365163392, 0.21318804404115244, 0.23835015363169165, 0.1840018095053474, 0.09825496046829052, 0.08938442162470306, 0.10210882821053635, 0.10864904519967511, 0.09301511827431352, 0.09754731601707478, 0.10032007813141897, 0.10288721438677761, 0.10953611849662725]}, "mutation_prompt": null}
{"id": "0dd8e2be-9e35-4cb6-8d4b-560ca29f4964", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Base mutation factor\n        self.crossover_prob = 0.85  # Base crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12\n        self.memory = np.zeros((self.memory_size, 2))\n        self.learning_rate = 0.1  # New adaptive learning rate for mutation factor\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success\n            self.mutation_factor = np.clip(base_factor + self.learning_rate * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.65 * self.population_size))\n\n    def preserve_diversity(self, population):\n        diversity_threshold = 0.1\n        if np.std(population) < diversity_threshold:\n            # Increase diversity by adding noise to some individuals\n            noise = np.random.uniform(-0.1, 0.1, population.shape)\n            population += noise\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n            self.preserve_diversity(population)\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.55:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticAdaptiveMemeticDE", "description": "Probabilistic Adaptive Memetic DE with Dynamic Learning Rate and Diversity Preservation for Enhanced Convergence.", "configspace": "", "generation": 78, "fitness": 0.4849856168910749, "feedback": "The algorithm ProbabilisticAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8764576771062145, 0.8788405533328811, 0.8934371200361828, 0.8825368238614877, 0.8991107444117239, 0.8995491252202857, 0.8927277084161738, 0.8824768898130568, 0.8831662829242363, 0.8327957767667631, 0.7078684891213234, 0.7957946419925214, 0.8112772879138395, 0.7953817576120061, 0.7949693837194597, 0.8051272702507339, 0.8099452469546982, 0.7978447203721246, 0.17352891847713603, 0.14081375467453894, 0.14618537893941974, 0.15193404506665031, 0.17631249265460014, 0.6066505692402012, 0.6497022311012014, 0.6201595024437454, 0.17254412721345636, 0.16856194910683442, 0.16924775555144622, 0.5822388201878907, 0.14411519775323156, 0.14582731057428222, 0.4742914734093583, 0.17305415924900303, 0.17045714822680602, 0.14939340443993188, 0.9340887749191638, 0.9633790152146765, 0.9330166200970551, 0.9464722619268182, 0.9549689255955801, 0.9525459276058755, 0.9576445526061662, 0.9409579911080831, 0.95373684415982, 0.7300884103741836, 0.7552085032782688, 0.7510234228004375, 0.7723377043151362, 0.7311341056551484, 0.7346276803531073, 0.767201144487513, 0.7297274473519542, 0.733434094563091, 0.8411971396943638, 0.8871219907255867, 0.823211160208054, 0.8579924966134809, 0.8645285075239656, 0.8409890996220256, 0.8660585484960793, 0.8667617371387963, 0.8930445177347027, 0.5273300104106958, 0.6341079150876536, 0.6207036397077557, 0.5282214299339147, 0.7710590667637561, 0.3852641513962327, 0.418118015878299, 0.6423047706989978, 0.6704104003834676, 0.2467323953020224, 0.47714912177176505, 0.43784219939503133, 0.4946722925168787, 0.5506266577747372, 0.48626800020729366, 0.701766891376933, 0.7363622223811813, 0.5445276589726009, 0.6846924895593136, 0.3447431843782922, 0.4989665054508198, 0.21624376830027925, 0.5823672576335814, 0.5622483867076464, 0.6927150895915692, 0.6668706490063815, 0.2896411020182248, 0.7337860068272881, 0.23111062738476107, 0.3578650532738705, 0.7385084620715587, 0.6746312597648625, 0.20260305458675743, 0.7560852879430751, 0.6648339792390952, 0.7587247837710787, 0.11245265246023806, 0.42893627582589866, 0.05251213723827719, 0.41005461865719195, 0.25643990992242105, 0.30177056804821356, 0.2205509088014832, 0.2175686475544809, 0.11532187606156019, 0.4645432010960524, 0.5899878521276756, 0.43888298616995214, 0.6021836304630508, 0.5891663223334432, 0.44786011109446056, 0.5463939259993338, 0.4012414341266757, 0.5470394515264083, 0.8370469561045553, 0.8211353414295142, 0.8399439297065345, 0.5929036043188931, 0.8278125002141249, 0.8190586060379205, 0.8275290216242153, 0.8471686973273168, 0.733721882064496, 0.09991077380469304, 0.14315014923787184, 0.12937533592915684, 0.13791241537836485, 0.1535403243011071, 0.151736802664033, 0.13540657192469585, 0.13116622091030206, 0.13937530690454392, 0.21391526966481733, 0.166604849980458, 0.7316113496154911, 0.17858817278403383, 0.16249444272689784, 0.20937964824105004, 0.2073584580714467, 0.16558768299867077, 0.16276980329272595, 0.6728903435095781, 0.5815232078928015, 0.5427043015625124, 0.5662351025985524, 0.5356476759230291, 0.5837987950084735, 0.6472663921749524, 0.5457509043608055, 0.604233198591936, 0.5171169171873189, 0.4302773949977683, 0.45405605759202083, 0.5423270669303601, 0.3891926155340075, 0.4459963767897519, 0.4173726707824199, 0.5019323556613743, 0.5906628978853294, 0.22988793427378174, 0.19927096975462122, 0.21483900237207698, 0.2185322916759369, 0.18276324250431786, 0.21259143570851025, 0.22063678769684247, 0.21936975107999424, 0.23294104601226506, 0.21204599959201276, 0.2193350423922028, 0.2379762136911019, 0.6185392380832142, 0.688274383152087, 0.7286638305857293, 0.7928794136094544, 0.23303803701056536, 0.21608081674401625, 0.20517578753736954, 0.19482001981024022, 0.15104844349503, 0.17493495761150846, 0.17766882114664984, 0.8875492331089175, 0.19621277240217128, 0.18593975729550616, 0.8124295816668702, 0.8765250948434298, 0.16740987110516692, 0.8493414858528607, 0.2063060657630439, 0.7572631605300012, 0.20774051721418507, 0.20604853107885857, 0.2055129924364122, 0.2108696341655354, 0.20898185282831072, 0.20217491226628082, 0.21551920403762537, 0.22731153340446664, 0.22435068277369352, 0.17799363622467967, 0.19842433382602298, 0.1907175324356405, 0.19414325966396428, 0.09037800969616783, 0.08864611020158897, 0.08946990579220804, 0.09258040839650017, 0.09376832759893439, 0.09657366842479365, 0.08621354843532536, 0.09427173136665079, 0.0898893765768537]}, "mutation_prompt": null}
{"id": "555e530b-50a3-49a4-9eef-5a2ce63fa047", "solution": "import numpy as np\n\nclass StochasticMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:  # More frequent population control\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "StochasticMemeticDifferentialEvolution", "description": "Stochastic Memetic Differential Evolution with Adaptive Perturbation and Diversity-Driven Intensification.", "configspace": "", "generation": 79, "fitness": 0.4688014376743351, "feedback": "The algorithm StochasticMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8381114967188208, 0.8319622073845357, 0.842540919906848, 0.8552348426952283, 0.8449765284090891, 0.8549548844391065, 0.8475376970596821, 0.8453366542990693, 0.8573845602884727, 0.7241488318412248, 0.7491555372084575, 0.7326823213749631, 0.753453447016096, 0.7433452809120635, 0.7523019090556302, 0.7388250364297919, 0.7404540038783353, 0.7480498708102272, 0.37405930457609315, 0.16409048256116499, 0.16866091137460115, 0.4837783320546569, 0.3959380917159241, 0.43285607858166186, 0.11454042131601616, 0.4127332165877362, 0.40616340225808256, 0.1343907028717669, 0.1152886074361037, 0.14297043529530207, 0.12950911495985107, 0.1437833895332986, 0.15436874625016228, 0.2922137081031294, 0.13993641166769888, 0.13974010946435866, 0.9579849066581209, 0.9376471922910998, 0.973812438915105, 0.9679158952594084, 0.9199467841349745, 0.9493792636010917, 0.9754947270551256, 0.9425339939232468, 0.9516475958465656, 0.6193744806430351, 0.6391668746893473, 0.6586405739263778, 0.6675938521342658, 0.6609145446671086, 0.6449324011271385, 0.589237893612381, 0.646053166294851, 0.6797877027112584, 0.8513852102601052, 0.8168031253268931, 0.7896189805088467, 0.8346327780214139, 0.8187921648202292, 0.8306071293327322, 0.8371203690892757, 0.8923074745554419, 0.7820169040164267, 0.4590469387381011, 0.5077666422963263, 0.526371738173134, 0.48932833570528045, 0.6091492656955011, 0.33079848236565146, 0.5505678017655895, 0.5208666701686449, 0.6633198663431346, 0.3074906084517234, 0.4349349014943298, 0.2880793278821214, 0.43701789159421156, 0.5058552090894739, 0.468140390261493, 0.45141078118140265, 0.5461792472629983, 0.6625316473617098, 0.5955134155453639, 0.5077554997776983, 0.4651866631545457, 0.5880775614253624, 0.6250482148200529, 0.5041153176453708, 0.539738531368483, 0.5469481084809769, 0.589146540369728, 0.6191414716959596, 0.668282327276692, 0.6772249787490061, 0.5999835916900671, 0.6782999531932747, 0.6161199211314095, 0.6613720145103175, 0.7151850559811357, 0.6782634165148604, 0.1322808648527436, 0.12753254324084706, 0.2623373865709495, 0.30344115012149087, 0.24817362869592718, 0.3702967609164677, 0.12225268799200861, 0.13279297120918576, 0.24827994730073233, 0.47213137369578473, 0.43096671723836744, 0.4325112370655615, 0.4885471712466727, 0.49014484823730387, 0.47020859404857485, 0.43172216598958313, 0.47288304897329436, 0.4378335083885798, 0.7471342276351125, 0.7979469242042244, 0.7776977277560411, 0.7770472363655426, 0.7733178828494816, 0.7969451950475727, 0.7880511713671874, 0.757507100779171, 0.7858997120301364, 0.12218559249215921, 0.1295418671937708, 0.1341657616029126, 0.13243540378282992, 0.15748741987635073, 0.14536289424279236, 0.13180862767350376, 0.13597091839387265, 0.13764902499239273, 0.21918167199283112, 0.18509722235687653, 0.17433213375974355, 0.18254222472354087, 0.20343084736622008, 0.2212519009812699, 0.2837033251555421, 0.16982930736083812, 0.17653632465057945, 0.4836550858170052, 0.4996342616511211, 0.5120896094128939, 0.5002251210535267, 0.47676937212588355, 0.5156227074017052, 0.5099415492389564, 0.6087895954462951, 0.4987173813925243, 0.3919061744430782, 0.3780169511150163, 0.34369782586623754, 0.38908521113222294, 0.38425852045376574, 0.3776717110630421, 0.4544148127555029, 0.4252267504513191, 0.4802833778971205, 0.2265373937887164, 0.19477952719309122, 0.1858782906714247, 0.18702837049181864, 0.19321242057916754, 0.22527837252005, 0.2227745879714994, 0.20567958797145003, 0.2048115917808323, 0.20624261525857268, 0.21791597747408564, 0.2066909358615766, 0.2295290418462328, 0.452236572245436, 0.3739944647119713, 0.5782667591147157, 0.23029317098137714, 0.22372325358820067, 0.8252078408277982, 0.184711955830396, 0.8658514447586827, 0.8070896024814707, 0.20397235223933052, 0.8519742309947683, 0.765402716381488, 0.17919885170460514, 0.18401217878440368, 0.1667915857807024, 0.7839461149067899, 0.8060853798150054, 0.1995521034438671, 0.7737104172179159, 0.6883383285194091, 0.20995750510897138, 0.8550662186625314, 0.1260204764960814, 0.21359391916888493, 0.26783245335126726, 0.1996430304383473, 0.2084395100145484, 0.20844560919674837, 0.1858794363789772, 0.2144133980370665, 0.26258040237706726, 0.19155148908586228, 0.08795125536364334, 0.09185677125625169, 0.08834527555783622, 0.08431343549906523, 0.07782757295355147, 0.11478413024503276, 0.0823749889844001, 0.07855426632055607, 0.09747483537080603]}, "mutation_prompt": null}
{"id": "afe14f7a-0b3c-47a3-b346-287f88f5aed2", "solution": "import numpy as np\n\nclass ProbabilisticallyEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Slightly reduced mutation factor for exploration\n        self.crossover_prob = 0.8  # Reduced crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Reduced memory size for parameter adaptation\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.5, 1.0)\n            self.crossover_prob = np.clip(0.8 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.5, 0.9)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.02 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 18:\n            self.population_size = max(18, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticallyEnhancedAdaptiveDE", "description": "Probabilistically Enhanced Adaptive DE with Memory-Based Mutation and Intensification.", "configspace": "", "generation": 80, "fitness": 0.44879176984312846, "feedback": "The algorithm ProbabilisticallyEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8590659704786998, 0.8633534597450562, 0.8760717872579009, 0.863262553563603, 0.864973451386416, 0.8611727666101385, 0.8623986846165859, 0.8657353369042439, 0.8795064096895042, 0.7677517905477603, 0.7803856978313536, 0.7741587287605083, 0.774058256380398, 0.7847553048229677, 0.7749908943807584, 0.7690371179740706, 0.7684138340451783, 0.7838921483114281, 0.14491863528255455, 0.1604855166875464, 0.4399582626297488, 0.40483256892229513, 0.43419938954644377, 0.5173230695240163, 0.5064743525385584, 0.16893191152962828, 0.4051106861586158, 0.16379908867255522, 0.17367724199546575, 0.16795378087217872, 0.12061371992082537, 0.14764592658070286, 0.14345210135122377, 0.38390873878952236, 0.4332655037402846, 0.29092304739545594, 0.9388726395713491, 0.9817959373068552, 0.9766326346767148, 0.947199054049044, 0.922331382401949, 0.9442685503781487, 0.9613374137961668, 0.9308483874015584, 0.9412079733641757, 0.6507804909880377, 0.6764566964459258, 0.6845773049240145, 0.7070801861051985, 0.667213311570735, 0.6993407048797997, 0.6851702474295427, 0.7054743769295948, 0.6550677627184612, 0.8066753591203895, 0.7992320418177009, 0.8225263200900983, 0.8284665148490831, 0.8064781695157892, 0.8301196795130908, 0.8367298986099556, 0.857451114303889, 0.8381642610006326, 0.37694375595448604, 0.6049447097716696, 0.4699922252788782, 0.6441866671424774, 0.35339012929495717, 0.25400008568668386, 0.38755873644911065, 0.42943302763473856, 0.288400763580725, 0.5409157380141322, 0.289233210748262, 0.3255947728114099, 0.2218749035934937, 0.4810618335221266, 0.554849249024501, 0.5655367235322473, 0.1251906749562942, 0.4529964645383321, 0.5204315732444029, 0.44319759555190563, 0.5361421935339143, 0.48434977734478624, 0.3605119282268763, 0.16744430180491576, 0.4760826335764029, 0.4743208447924715, 0.3840740846670646, 0.5913820349003049, 0.6038959305020977, 0.5272468897843006, 0.5633138675764697, 0.1473757432025028, 0.4465154565179801, 0.666707463553825, 0.6261853029442407, 0.6264956330425, 0.16425905183415856, 0.1346602848440709, 0.0820505505569823, 0.31235040614847176, 0.12742721734481477, 0.41977670923896326, 0.2687108277292398, 0.15296285163976386, 0.23811820041048537, 0.39763914041134485, 0.3861871147719591, 0.423434454294363, 0.43169070256446196, 0.4784134925199254, 0.4936278657827682, 0.39703222661658377, 0.3330590855058768, 0.3768567415848929, 0.7621965895853721, 0.7977062545516642, 0.7775843891917332, 0.789536324931326, 0.6809248414841795, 0.8055803975211018, 0.7446120391372892, 0.7900017616480445, 0.7951582109574022, 0.09364807204483971, 0.14400721998922295, 0.1958666973614258, 0.12544883934110307, 0.11432720509301109, 0.11819830649834462, 0.12263356616406584, 0.1593637224101223, 0.13618632435596467, 0.2539332744209263, 0.19418920409590412, 0.18931716711740498, 0.18053566287256728, 0.20813259053258615, 0.18599253805232752, 0.14575458374181394, 0.14973010807440446, 0.1508109322893212, 0.4678461945232405, 0.5498252500008121, 0.5632392430159463, 0.5764526660819733, 0.5479827709303805, 0.5188314099493319, 0.5788175890917964, 0.5435198476663867, 0.6148591659068128, 0.3728339665807078, 0.3592122099140702, 0.374182872387249, 0.3602711014341161, 0.36452057560323714, 0.3655975438412128, 0.3834996845165646, 0.4077985539591066, 0.4846656950276017, 0.1923847037869818, 0.19481574227394505, 0.19279871685182493, 0.2340031858804522, 0.18218875064475393, 0.19364932951234692, 0.21980990481460005, 0.20680460389811106, 0.20510716055789435, 0.24119514526042984, 0.23725307779683869, 0.6391321248197778, 0.3754199910123591, 0.22982952087409125, 0.39090074504579275, 0.626361958407198, 0.6619475186734155, 0.6408086027387482, 0.16033643496249006, 0.16075382331880195, 0.844542262193777, 0.8062548858621565, 0.1886974457004852, 0.19606412952727992, 0.18357495410121005, 0.816373476091967, 0.8074995424652925, 0.7720067545122149, 0.20566729913544424, 0.20251295259433866, 0.2042936287663345, 0.1626073330584521, 0.2048850905505989, 0.20703750889968253, 0.20717000104382455, 0.15392311122779634, 0.2050356143069918, 0.17013458109650914, 0.2067097955002093, 0.20079724370297647, 0.20535051135676774, 0.21002043414297633, 0.1854436488068385, 0.21590061714473952, 0.20822217428802625, 0.08922538820485715, 0.093856138550102, 0.09138395809314948, 0.08047385234208593, 0.09071927432022242, 0.09878169482629184, 0.09252953801082497, 0.08980436457429875, 0.09869887678944655]}, "mutation_prompt": null}
{"id": "b3340a0d-e9f4-4bf6-b2d4-6dd760020223", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_prob = 0.9  # Slightly increased crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n        self.intensification_prob = 0.65  # Increased intensification probability\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.12 * np.random.randn(), 0.6, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.04 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 20:  # Further increased frequency of population control\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < self.intensification_prob:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticAdaptiveMemeticDE", "description": "Probabilistic Adaptive Memetic DE with Dynamic Intensification and Enhanced Memory for Improved Search Efficiency.", "configspace": "", "generation": 81, "fitness": 0.4625308900071347, "feedback": "The algorithm ProbabilisticAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.26.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8257402074623328, 0.8063874851304813, 0.8388176834707051, 0.8278975710145171, 0.851896717031453, 0.827901236424414, 0.836281132364793, 0.8115423481204695, 0.839367102371209, 0.7150186778775761, 0.7187540493596962, 0.7082167173536567, 0.7329179077097812, 0.7272442330560632, 0.7420276278613389, 0.7366673217688646, 0.705589474163627, 0.7008822309717921, 0.3021393356632954, 0.15233492038619245, 0.2925809607352414, 0.1569865060321507, 0.16837911748879053, 0.1707660888321878, 0.2792941898404583, 0.3919211327551675, 0.10867257193026403, 0.1482192053771283, 0.12761553757356525, 0.12698873666871446, 0.32423758040286255, 0.12710518279864058, 0.12292543255827426, 0.15051730233530014, 0.12728547138678403, 0.1240266396763503, 0.9431429385341706, 0.9729373632871656, 0.9282965736607529, 0.9077482006097014, 0.9103286143234879, 0.9514607594199537, 0.9093361951204058, 0.9460013893530731, 0.9672810902061866, 0.5990407086246738, 0.6367795803601835, 0.6115922378436195, 0.6574131335828008, 0.6054041077637655, 0.6384394223292894, 0.6409922630617404, 0.6185082479676717, 0.6037944771474413, 0.8093891658476262, 0.804755498340038, 0.7955566153503564, 0.8485692255812154, 0.8330553288760653, 0.8174215955970956, 0.8359623063899366, 0.8281433825486452, 0.8140170802020528, 0.5219399784174172, 0.5865714243217591, 0.5323801224943738, 0.6091277300877351, 0.6303621188014906, 0.584279800386542, 0.5736875118125186, 0.48906384645010625, 0.6880219319879886, 0.20242915535202133, 0.3671338918382575, 0.6685491007609188, 0.4078235364074638, 0.5153090622380438, 0.47351115389724896, 0.485923510758531, 0.6113592811219326, 0.5496179071322296, 0.651494776468377, 0.5856173781688776, 0.5906583392468379, 0.604363443890749, 0.5823276568448859, 0.6055258321415468, 0.566143707419628, 0.573971054405328, 0.6186909304474477, 0.6901147264826799, 0.6864775059855756, 0.6997876627733151, 0.703022095305071, 0.6502669853513732, 0.5890996039252637, 0.6732494849020279, 0.6779019003461948, 0.6617114166866772, 0.28803359616559654, 0.25410878197171305, 0.1300968424972072, 0.46143813786282073, 0.47921125658869157, 0.2809659452547497, 0.26133507592989236, 0.25684444105948223, 0.22452401492997265, 0.5117358984255216, 0.4734696922108601, 0.4913889394520432, 0.47416675915141326, 0.49435663770924, 0.5106296699332777, 0.4392628656592932, 0.4524818913096642, 0.4693562672100806, 0.7833675433646645, 0.808739120161764, 0.7660574304938204, 0.7746535676899112, 0.787489560498411, 0.7933264460999213, 0.798021773587606, 0.7857526030244188, 0.7749451501144125, 0.0972063214800446, 0.12639438282427107, 0.1556800497656442, 0.13033386330366026, 0.13209009024602292, 0.13646367285013672, 0.17818817733101044, 0.10964049511644247, 0.3200176176945818, 0.2680858682356685, 0.16836735170806238, 0.16568593816110966, 0.2101061481035551, 0.5259409744486468, 0.270415851031541, 0.2340116723247252, 0.18674637101097846, 0.14287420558084574, 0.5032492585609887, 0.5046506838699161, 0.44536700481181857, 0.4757603357699266, 0.4783444606922612, 0.4988795073657245, 0.5204243390745205, 0.5416838127504844, 0.49658864223664634, 0.3704676551424826, 0.37132675341491916, 0.44707143111258774, 0.3612653598992349, 0.37478990001860635, 0.38852046977391774, 0.41221287429082554, 0.4027413828859824, 0.4316706334752941, 0.1979349187698699, 0.1940166792005209, 0.19560648955697912, 0.2125250728575635, 0.18654221228218537, 0.1997753103834986, 0.1969386701127278, 0.210589018879887, 0.20893710517205288, 0.17652901325892578, 0.2121446233314468, 0.5581642206303591, 0.2148956105059594, 0.23675336729110397, 0.5640543259760751, 0.2102548299637751, 0.6131918402430518, 0.22626229566066436, 0.1699663157497967, 0.852903278741648, 0.16376653164155663, 0.7686484681510685, 0.18903684733676984, 0.16871507739562697, 0.15923565780947024, 0.7925703388181173, 0.7618871756676715, 0.7759038700067296, 0.2073822922120223, 0.16694100482232788, 0.2035302226054181, 0.7505700634298702, 0.2023029898208638, 0.20645274129318447, 0.1261334516466739, 0.2098216202958223, 0.18859934559862024, 0.23488819733900945, 0.22899704744921834, 0.24568375917803376, 0.21683089904224673, 0.22211870650625165, 0.19415599293487973, 0.248231412996457, 0.23121155358145784, 0.10064960717796145, 0.08854139962917196, 0.09691472609311791, 0.08936231342353806, 0.10027953424422176, 0.1082442515072426, 0.13993673126232076, 0.089641837201057, 0.08444920719378735]}, "mutation_prompt": null}
{"id": "b12ab7d0-d756-4ca7-8456-7d4fa2847930", "solution": "import numpy as np\n\nclass ProbabilisticSelfAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Self-adaptive mutation factor\n        self.crossover_prob = 0.9  # Self-adaptive crossover probability\n        self.success_rate_history = []\n        self.memory_size = 10  # Adjusted memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.4, 1.3)\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.07 * np.random.randn(), 0.5, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.035 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 14:  # Dynamic population control\n            self.population_size = max(14, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                if np.random.rand() < 0.35:  # Probabilistic mutation\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    d = population[np.random.choice(idxs, 1, replace=False)][0]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c + d), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Targeted intensification\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticSelfAdaptiveMemeticDE", "description": "Probabilistic Self-Adaptive Memetic DE with Dynamic Diversity Control and Targeted Intensification.", "configspace": "", "generation": 82, "fitness": 0.2985027396459997, "feedback": "The algorithm ProbabilisticSelfAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.7810388690334682, 0.7930278027222888, 0.7991556693514126, 0.7672821721159699, 0.7988905125645653, 0.7981099873948658, 0.7561636159758836, 0.7378128539130364, 0.7949460104680736, 0.6531739004904714, 0.6443890025642516, 0.5692717484960759, 0.6148276717589486, 0.6166934913080915, 0.6197819296114262, 0.6109445709565284, 0.6383062430551731, 0.6345223765937329, 0.22608914191759888, 0.18575852986280528, 0.07433510664658916, 0.2402766041304023, 0.1997402256537758, 0.20992493003128798, 0.19865454129722615, 0.04917848628247956, 0.05703687633356569, 0.1514895489445247, 0.12439133037066841, 0.11879717379753418, 0.13135370975939498, 0.10437005925683152, 0.048366367391718956, 0.14691525581799547, 0.16136012493137664, 0.13903719535688275, 0.9733668885985376, 0.9794215108685435, 0.9751872879679563, 0.9745040808956311, 0.974039002185518, 0.9851508724987097, 0.9818738966572124, 0.9702027031608814, 0.9852287119850871, 0.48362156075466234, 0.48629228041208383, 0.30711997485315656, 0.48262173429911903, 0.45242836395755326, 0.40432852159477484, 0.3217790298457881, 0.44639897236378157, 0.4465737201628386, 0.2026485967843492, 0.768338201486396, 0.3464441242652033, 0.2528513071086784, 0.20692920397389003, 0.18521368276817585, 0.5424091146631413, 0.13732905256030148, 0.6853134348433905, 0.21708216828482363, 0.1903262461734212, 0.20136531074788366, 0.12565140052139356, 0.12184056831467172, 0.1892122742677137, 0.14669614759736538, 0.1774715182036083, 0.11865655253385443, 0.1127884196125738, 0.11124006968351552, 0.12385092054161106, 0.20519741694431437, 0.21030540867258118, 0.18281585287171875, 0.10407016282845694, 0.2074182449542331, 0.09723058515173166, 0.08403312290832532, 0.23251068629104643, 0.0647160324498014, 0.01315398381945887, 0.0433274026440289, 0.035037392402711864, 0.16860673879571464, 0.1537083180562102, 0.04651055316560704, 0.14584107901027255, 0.11768687794147703, 0.13543623862031673, 0.26281901138761576, 0.09811100354486169, 0.15653899771258506, 0.1580540217524966, 0.0667718194736946, 0.19136181228359694, 0.054770526870035474, 0.14780507831928857, 0.15721272085189464, 0.08837222961955793, 0.07552707042017215, 0.07180360360907945, 0.09051216451221666, 0.08986320611353726, 0.08971342943269411, 0.06842831568175733, 0.2251548130640867, 0.25471802934590915, 0.24896569810272706, 0.22187161692874902, 0.1763546525091455, 0.20875610775760223, 0.24327277571182948, 0.12202521157055657, 0.5735031848802801, 0.5384700886500863, 0.5700529518420904, 0.5155162402053939, 0.578918028000707, 0.4791951207729225, 0.5692074812462276, 0.6339729947247874, 0.6243526814014491, 0.06652831287456862, 0.05895464519473148, 0.10686504745634662, 0.11842992350001824, 0.10486844934270212, 0.13236649560983804, 0.12059219969989066, 0.1311219437601956, 0.12010687729663438, 0.36140237354315474, 0.16763984969372536, 0.1501179433909856, 0.40992022036979503, 0.23369217416377297, 0.193194067867426, 0.16205032012683518, 0.2293899888657902, 0.18176548470690423, 0.36329614038464464, 0.2398980117796955, 0.2409021350262045, 0.21525574356036736, 0.2778358846359723, 0.36201846582830366, 0.3746113066673834, 0.44441155475599625, 0.39497505747240846, 0.2224464705480944, 0.2012162482321841, 0.20818173359941605, 0.19714525937716088, 0.27811818934713983, 0.26050459933362136, 0.20917550996397338, 0.2940975550991578, 0.16238791897714278, 0.20006032594885514, 0.22143061992478108, 0.2087830883869578, 0.2245381543730517, 0.196583467115505, 0.20492152186580181, 0.2282505845324042, 0.18302277381558107, 0.19911907624452552, 0.2662835069318972, 0.3890314551694134, 0.2229275243826213, 0.38389553051126646, 0.22555063518476504, 0.27324982896457894, 0.484061348072948, 0.215188587569484, 0.22754264098954058, 0.2023072578338886, 0.18320989688408362, 0.19322702391814905, 0.1710033359412848, 0.19194694677864965, 0.17484156754776903, 0.17049641639680635, 0.7528012668355504, 0.16470734333372217, 0.3822149994902271, 0.16935488216904304, 0.1521821848121686, 0.4713785293102154, 0.682164656751113, 0.6966774061731452, 0.20844209493156818, 0.12354923408040397, 0.21007119951132758, 0.22961161903822935, 0.19588911900819972, 0.19131339458874141, 0.2160619974662612, 0.21026286940108507, 0.20156010751179088, 0.21328516150173404, 0.24205967867484346, 0.22149426265932326, 0.10544786432021669, 0.07973947403862636, 0.10035729330199461, 0.07866087502917618, 0.0970448565821489, 0.08310035126574422, 0.0937149149891513, 0.08508244790198083, 0.09261461153906114]}, "mutation_prompt": null}
{"id": "96230890-4d6c-461d-b747-e6cb08a5c366", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_prob = 0.8   # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n        self.adapt_frequency = 3  # Frequent parameter adaptation\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.025 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:  # Adjusted population control\n            self.population_size = max(20, int(0.6 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            if generation % self.adapt_frequency == 0:\n                self.adapt_parameters()\n\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Stochastic Memory-Enhanced Adaptive DE with Dynamic Intensification and Population Control.", "configspace": "", "generation": 83, "fitness": 0.4411790666524466, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8466938214462761, 0.8488222503023908, 0.8688699434005132, 0.8595845203411635, 0.8470252982771187, 0.860019281847461, 0.8399825631859954, 0.8520425284419395, 0.849992429258921, 0.7444146396648057, 0.7565027298013105, 0.7473693449239469, 0.7168600535828491, 0.7336065115013501, 0.7419275218284522, 0.7294670482327953, 0.7402924298089383, 0.7542283231023397, 0.43420898975852296, 0.5557046149374183, 0.5777742344550535, 0.25554683435060355, 0.41473832997801596, 0.4972237945033112, 0.40205853203391473, 0.48818906128771433, 0.349118031046584, 0.1452134898330012, 0.35614738477636754, 0.1639791969061818, 0.15511411868519664, 0.4924344212379108, 0.15989291534506533, 0.15293046341186567, 0.15932797564642964, 0.1343608569144098, 0.9582271385881599, 0.9786658518958766, 0.9631199022901988, 0.9639121412305465, 0.9574522990779376, 0.949998028429002, 0.9792065950202472, 0.978725981594986, 0.9280322202277151, 0.6368495016152635, 0.6069592045364417, 0.6405617496510683, 0.6253243607571908, 0.5952695022715007, 0.6591395721129278, 0.6264404513304487, 0.6173867195197197, 0.6398696045046781, 0.8009439650870475, 0.8003466585282595, 0.8023686010924392, 0.7900882010585979, 0.7835235231410934, 0.8282934927284824, 0.7583395460616954, 0.8419188450045711, 0.7794426601999789, 0.5139979103766134, 0.37965636203687636, 0.5148221542827038, 0.5066059580665854, 0.49706495588211974, 0.5249613309277127, 0.49622754406416647, 0.42304603107398486, 0.5370820926435047, 0.2938020468840301, 0.34852578851883287, 0.47658992066461414, 0.5107400078375608, 0.3843566786894417, 0.13172010630317998, 0.45229792187568396, 0.43839890331660836, 0.4923557484490325, 0.30997586713494807, 0.4347216957447244, 0.36957164907509654, 0.4189879065954799, 0.2677727394564773, 0.43294407265876966, 0.49590114027044496, 0.3784347375006649, 0.4815631987916801, 0.5699489772436039, 0.521270976212056, 0.5535948654936953, 0.5224476722287096, 0.5271985196075359, 0.5485059180545124, 0.5834990707553345, 0.6057710888518475, 0.5637478678781088, 0.11929210818961378, 0.1179648386604959, 0.23135869572703682, 0.33319079299125176, 0.320761786988093, 0.31425273053981284, 0.17993372347150338, 0.1737435741966581, 0.24790989173647826, 0.31813768073009396, 0.34936918379519377, 0.3262022583856029, 0.4252264845452284, 0.3547727716643392, 0.4103762827703695, 0.3563892004975949, 0.32500604344007566, 0.36825848075836365, 0.7739967589609953, 0.7493339235731912, 0.7684868848298475, 0.7390591918346384, 0.7397278700675782, 0.7393397668604724, 0.7190629733890823, 0.7366223526485396, 0.7507136321066672, 0.12482163328587281, 0.1163408139680463, 0.13108815424313724, 0.11947141034368325, 0.11611300297875782, 0.11206787874890345, 0.1155030589640661, 0.11152294096978566, 0.12799167503579578, 0.19004681626735243, 0.18160119078188264, 0.37078997815432, 0.4324378039239761, 0.1965033922809062, 0.3088098548016779, 0.21272620809231735, 0.1940035342177262, 0.2738831967006795, 0.5075291471729331, 0.5024601801962489, 0.48257206237320827, 0.46608518781444586, 0.43615283351532885, 0.5135747767671396, 0.5110903127100761, 0.49388389954113265, 0.4963764661021204, 0.3129136182391853, 0.3099816329380174, 0.3528772041890208, 0.29679491559389937, 0.3203506115053718, 0.3194937986591502, 0.34734697008029647, 0.39347508495548333, 0.38732624404618254, 0.19817899638285008, 0.19438254244574904, 0.2516763859539701, 0.1937803989094623, 0.1944588915849882, 0.2238696014656485, 0.20936573281631288, 0.2731744158724938, 0.21559022863468424, 0.36116435826295235, 0.40723117722269997, 0.21705725673198262, 0.3799930892492164, 0.5037615461339064, 0.23128479395873358, 0.4592476175994763, 0.4321129701005101, 0.5223757090823224, 0.6463844283008023, 0.1937959478906065, 0.7489971482292814, 0.19896200934278685, 0.18672800212762242, 0.1820910989135186, 0.164696296757339, 0.18123619887703324, 0.20550720572669612, 0.7633165364131094, 0.16858031494645398, 0.16852486097306718, 0.20747023524293728, 0.6840435748942704, 0.7182155524220938, 0.12536250581418795, 0.20887578712046384, 0.2108049417795398, 0.21744461748096577, 0.21591799309994353, 0.19927749750403645, 0.22848263995811302, 0.2065714083496467, 0.19893150059023335, 0.20926493951318936, 0.2283200749685681, 0.2300824917670108, 0.08954145229320698, 0.08894106133078372, 0.0867491438007808, 0.09440570200150722, 0.0958521425471821, 0.09647403851028669, 0.08982094600652524, 0.08170696643700615, 0.0999178220136091]}, "mutation_prompt": null}
{"id": "405906b9-cd06-4b92-8814-7727c4f0d086", "solution": "import numpy as np\n\nclass EnhancedStrategicAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Adjusted based on stochastic control\n        self.crossover_prob = 0.9  # Enhanced crossover probability\n        self.success_rate_history = []\n        self.memory_size = 12\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            self.mutation_factor = np.clip(0.7 + 0.3 * recent_success + 0.1 * np.random.randn(), 0.5, 1.3)\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.02 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.70 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedStrategicAdaptiveMemeticDE", "description": "Enhanced Strategic Adaptive Memetic DE with Stochastic Control and Dynamic Intensification for Improved Convergence.", "configspace": "", "generation": 84, "fitness": 0.43112036473476667, "feedback": "The algorithm EnhancedStrategicAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8106376179682939, 0.8286095479240162, 0.8389778676410397, 0.8490940854239928, 0.8532066351875306, 0.8393195509632015, 0.8362464746152027, 0.8490956767845473, 0.8500587847712424, 0.7010557661022305, 0.7252063399200603, 0.722380846376265, 0.7424125997334658, 0.724918113839007, 0.7241924291101016, 0.7220334155109058, 0.7491696608101558, 0.7326418855656325, 0.38140338869295387, 0.3509202893644484, 0.5612862697743901, 0.41943009226943095, 0.39943119001947835, 0.5097812262443862, 0.3495095609008091, 0.16370551901001817, 0.21364900691188038, 0.13561427712422702, 0.15964352420788053, 0.30519463247044587, 0.15623316660411024, 0.2328203284905198, 0.16064861994272073, 0.15402359604122373, 0.15324636915003742, 0.29070669051992726, 0.9675066086988359, 0.9638081340043598, 0.9773445057847857, 0.9477962842442516, 0.9321447517230105, 0.9531460306269707, 0.9761501101860017, 0.9753582668062624, 0.9796093836418578, 0.610501820678106, 0.6361204572334211, 0.5897567481985437, 0.6127174399941342, 0.6451577717261285, 0.5965878698050753, 0.6713952528347151, 0.6128629654534072, 0.6342681774993898, 0.7548523786130112, 0.7864220464344094, 0.7660561779958115, 0.872194661246243, 0.8261463292544744, 0.8050977456015398, 0.8264710469824672, 0.8219220250482746, 0.7704659496737618, 0.4182651515951723, 0.38660804820640615, 0.4847631133594087, 0.5277945115737211, 0.47003635403136323, 0.45089595368104096, 0.41404000644361494, 0.41213104336006035, 0.4411982231024125, 0.5677801737541056, 0.5425460886552237, 0.344243490158198, 0.5974668908880578, 0.5378188001155958, 0.3570093500306465, 0.3372503063538481, 0.45155560363687863, 0.36037348668064617, 0.4241863299565679, 0.3024710119127558, 0.462035815186689, 0.3742498845109927, 0.3754917226487722, 0.3301249825870337, 0.38676957875430706, 0.4997078530175527, 0.3881281125399966, 0.4973905406114635, 0.53177890005533, 0.46012749949783427, 0.5186191161563904, 0.5152155674524685, 0.49785826095202124, 0.5436158867316829, 0.5655765580078866, 0.5739002268911306, 0.21420052962624425, 0.16803625186393734, 0.08804361519416493, 0.26416414016599066, 0.21583348324498253, 0.2615390984511409, 0.11575766549543309, 0.24189232088044077, 0.14972472446807095, 0.3050376869945898, 0.3297325478442288, 0.3149668703070594, 0.32873480461573057, 0.3813878954057047, 0.3699773533623355, 0.3440506169037224, 0.3827959936740032, 0.3060404286894727, 0.7132212816649499, 0.7197832370469435, 0.727001388901477, 0.7179233429348812, 0.7039157184896738, 0.7306848989338391, 0.7391673116342181, 0.754381832703416, 0.725132808404672, 0.13545865258738055, 0.12072467768460504, 0.1092382731653786, 0.13887491700282606, 0.12871622734223287, 0.11730744926522274, 0.13033040858926814, 0.11974988524310315, 0.12789506350668067, 0.18998410686109346, 0.15818801515477132, 0.18735185613541594, 0.13452080300257052, 0.15214820683001762, 0.18895403622224927, 0.17157499624235184, 0.1896438798895026, 0.22891456074141336, 0.3998289877090512, 0.44113257257161576, 0.448073810240997, 0.47370545435220124, 0.48277133120263216, 0.4421161778651046, 0.5014614119790561, 0.48796528751878365, 0.465622433289802, 0.2902322362817463, 0.32497341079726616, 0.2793241519034334, 0.32621974888410155, 0.320360053050069, 0.2923547965085126, 0.3707064840575647, 0.3866199620064794, 0.3384963766811875, 0.23985699260365323, 0.17112959248475001, 0.24850276379493375, 0.2434105576106731, 0.20724895477403327, 0.20619336578468872, 0.1834820811542709, 0.20897211839294016, 0.18149671895370767, 0.2120100904023875, 0.4498996121674098, 0.3015806417322676, 0.2302787136955875, 0.5697885850641772, 0.5720028132726283, 0.5025129559395902, 0.5823922323035047, 0.23131397428048794, 0.19420436404303631, 0.7956153221164731, 0.16432471611393973, 0.804248135698624, 0.18823238351571847, 0.717211962977204, 0.736178453283187, 0.1824824583040211, 0.18306343162008376, 0.16488187205961624, 0.8005580874512553, 0.20556361677507973, 0.744208212148125, 0.12543257353858184, 0.20400518749469987, 0.21060380853600302, 0.2106471703372188, 0.20961257611882134, 0.1905602940747395, 0.2004321474756502, 0.18861334935631746, 0.21146909436700823, 0.2108451048230089, 0.1847038742315048, 0.20340170763858834, 0.2079924865119609, 0.19862861996627812, 0.07698500615054604, 0.0854749329818455, 0.07836469190881157, 0.09044480425075885, 0.09332202978428195, 0.08218105095115247, 0.08863099961980114, 0.08369010233151242, 0.09105241040313972]}, "mutation_prompt": null}
{"id": "de7dcab2-2824-4db4-bcaa-68974d487dc5", "solution": "import numpy as np\n\nclass ProbabilisticDynamicMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.7 + 0.3 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.6, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n                \n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Further increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ProbabilisticDynamicMemeticDE", "description": "Probabilistic Dynamic Memetic DE with Enhanced Memory and Redundancy Control for Adaptive Optimization.", "configspace": "", "generation": 85, "fitness": 0.464894537462637, "feedback": "The algorithm ProbabilisticDynamicMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.842353162961093, 0.8357854146017705, 0.8419596565381015, 0.8421180874589155, 0.8556038057176278, 0.8326664220533835, 0.8460271307374572, 0.8430298323941074, 0.8286151113115576, 0.7169078868796712, 0.727518770771969, 0.7355388880584186, 0.7019956491645845, 0.7346973495578332, 0.7181535000693113, 0.754630639913858, 0.720993001275829, 0.7231330664833495, 0.15026911233971618, 0.16984799857825728, 0.1413172626187006, 0.16481571495031588, 0.1899117088162623, 0.5398406194918923, 0.136898902043726, 0.18491021866955948, 0.5927459223999965, 0.1310876658638881, 0.15409011202078404, 0.36006939414318473, 0.25967962208732465, 0.13540288572950454, 0.1482090576469216, 0.15369465394792337, 0.38447425654556255, 0.23558820910257305, 0.9516876740828544, 0.9321985681990569, 0.9321006252538636, 0.9474738677166836, 0.9473667226950347, 0.9621536134970852, 0.9523259584931055, 0.9112479197646827, 0.9642081782250224, 0.6312386260633136, 0.6439516764545423, 0.5689890311324137, 0.6499408408879327, 0.6459740583956919, 0.6324609050511787, 0.6156954279452502, 0.6401689969011297, 0.63487564638321, 0.8474831999066146, 0.8276875787256934, 0.8079180555964529, 0.8271711565205664, 0.8695329403149226, 0.8301031709779001, 0.820983816404496, 0.8457098382629977, 0.8231979269808622, 0.6040677894810309, 0.5936541402754807, 0.5640432202933785, 0.5400621912326558, 0.5616094249205192, 0.1291739429027874, 0.5406571601163117, 0.5564683272677109, 0.6191188844747013, 0.6879138367181619, 0.7150362411093588, 0.5400521312857511, 0.6415223636788676, 0.5247700188448441, 0.6196573475900493, 0.5060936453105913, 0.5407821684122395, 0.6139382417400618, 0.6407476414843389, 0.600038102942716, 0.6589744118358372, 0.5997479184814716, 0.5923621319318999, 0.5825505742622944, 0.6038097708507324, 0.6057568822912585, 0.6030487192206587, 0.7406478742907519, 0.6843916276752486, 0.6701909229253836, 0.6924845385312024, 0.6997644343843983, 0.7076322503862544, 0.7409487763678726, 0.6878842914650908, 0.7182632280325538, 0.13305443478971424, 0.342363094282898, 0.1681165088310037, 0.24337356248628772, 0.19020256444359218, 0.18048091450631654, 0.2895035830816026, 0.22652248225126004, 0.17985440599235825, 0.457919704963358, 0.47637659152467293, 0.4778907089356067, 0.5039991478221815, 0.4902200488082291, 0.49408561239469306, 0.44537953433904653, 0.44123881196251025, 0.46651562921199363, 0.8025395605847006, 0.7681078577067485, 0.817088928547647, 0.7866013708239019, 0.7799060234631476, 0.799117296936688, 0.7670812967478611, 0.7896398161384122, 0.8054717471304899, 0.10657745609002611, 0.13640827108874742, 0.15905077708906357, 0.17302900999020254, 0.15216268534478428, 0.13154437357151383, 0.13799105225629904, 0.12894533498533378, 0.1065265281472495, 0.20084957734814568, 0.14927001342099533, 0.19499989671813323, 0.1813402659650254, 0.23638246385207262, 0.19867096999009481, 0.1416836303670128, 0.14984179695766575, 0.18342475612949982, 0.487281266946885, 0.47027550242515803, 0.5138166589191386, 0.4718343549295678, 0.4534449637997292, 0.5057559841012169, 0.5569430498945229, 0.5351864917900029, 0.5348682934277831, 0.43091248164087514, 0.4177457437014712, 0.36710949865388387, 0.37283836155363925, 0.40888407454233977, 0.3245996367407612, 0.4220540759184682, 0.4217110929817922, 0.43960125066247224, 0.23790855735073524, 0.19271436994579993, 0.19710592889530598, 0.19991821431513013, 0.18179563975340263, 0.2001153631324043, 0.21261637519803767, 0.19764822461973064, 0.24889739145227963, 0.6252032330715607, 0.22469735140760727, 0.5072978939079145, 0.49005318117419516, 0.4801711047893009, 0.19034035043596442, 0.5376926422682449, 0.2324902533188984, 0.4742592135506475, 0.16948373434713015, 0.8423918734569311, 0.16482199140690046, 0.18184058602306263, 0.19498540433267342, 0.797874221658395, 0.1681983975078074, 0.15907017425040415, 0.15816557064582593, 0.16651600580610282, 0.2054296584089027, 0.16626246680903767, 0.1987726214736314, 0.817747175785468, 0.2049551017729908, 0.20877688642995895, 0.8287565970510922, 0.20492989910765735, 0.19262495966737092, 0.20759525227683018, 0.2026135614057767, 0.1925278554771932, 0.18715216314156302, 0.229653468842699, 0.26413180252788004, 0.1641008298788562, 0.21837498647241493, 0.09153965854909074, 0.08949350162161396, 0.0981923966232614, 0.08873653759610056, 0.09807594857726576, 0.10527530937697538, 0.08716219995594654, 0.07955706612267055, 0.09800417151450658]}, "mutation_prompt": null}
{"id": "92313212-79be-4a78-91cd-108e51104e81", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_prob = 0.9   # Slightly increased crossover probability\n        self.success_rate_history = []\n        self.memory_size = 14  # Further increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.6, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:  # Adjusted intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic DE with Progressive Vector Adjustments and Stochastic Enhancements.", "configspace": "", "generation": 86, "fitness": 0.47397095507448345, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8692954009028606, 0.8469639446646, 0.8434812495010362, 0.8628973503291844, 0.8440859397628768, 0.8574494049755319, 0.86304424494756, 0.857688840055313, 0.858915793743903, 0.7423939142623871, 0.7492228562074246, 0.7736705309720676, 0.7670118316892716, 0.7520534906927882, 0.7488264169088991, 0.7828937431332564, 0.7491274865713873, 0.7818074863032786, 0.17928544037132765, 0.43565404597762614, 0.12658988062649745, 0.16278114308314673, 0.155331775973665, 0.21280006286980357, 0.12191343861372084, 0.1477114448802629, 0.13911219714616108, 0.15190110693170988, 0.13256567927684193, 0.12802604152861097, 0.2311937887264771, 0.1520023727746853, 0.14545538822509319, 0.1472239377751361, 0.12475826119230282, 0.132220131954492, 0.9245749081740109, 0.9522816807254387, 0.9494646199747978, 0.9274057229518896, 0.9651993936480443, 0.9140111430927907, 0.9441397212336804, 0.9555109586007413, 0.9838584336346079, 0.6925635406519538, 0.6709959327919348, 0.6528549584959366, 0.6766969780141243, 0.6957388684503865, 0.6816530015995914, 0.6951227647435445, 0.6789817327985193, 0.6449018052563047, 0.869740189817255, 0.8481703524839519, 0.8268234667604443, 0.8450361774374127, 0.8471146217432862, 0.8560805277186462, 0.8561769267194548, 0.8582146643076758, 0.8494357916972621, 0.5103937010009514, 0.5950687800486272, 0.5473920371341761, 0.5130574214290031, 0.5156112486442368, 0.6575959226184229, 0.5647596806651562, 0.2864983525704692, 0.6827305290110488, 0.24966845796994142, 0.11831557143606408, 0.4325219611573079, 0.6331032969830113, 0.3578058461082998, 0.37564734896388985, 0.6766323666213419, 0.4963479557131717, 0.5535837810623556, 0.650274746546925, 0.6217370667505588, 0.6395316209182283, 0.6519595338674512, 0.6886315196030587, 0.63091044062899, 0.6712965601471046, 0.6530225671095893, 0.6831598572953889, 0.7384001381040102, 0.7256639297353988, 0.7264141990833142, 0.6852429639804622, 0.7009526958801543, 0.3966059739631217, 0.7527653597872809, 0.7536080434116263, 0.7616038116794663, 0.24128036653706386, 0.108872766605427, 0.13938054151815504, 0.4687012183100251, 0.5703712515780773, 0.5542599723059978, 0.3319331223303281, 0.38299340546670124, 0.2333868713670666, 0.5178571800880065, 0.5603466120203769, 0.5737953554366158, 0.5927727987249273, 0.5563765267737377, 0.5364167437870466, 0.597043150117627, 0.5528163629547023, 0.52475603269653, 0.8317905461872369, 0.8182320013773048, 0.8074712789314289, 0.8170349947007944, 0.8101408004000407, 0.7819352834990937, 0.8267030722546413, 0.7984155719693568, 0.8018177465144183, 0.11898727463762937, 0.12524267111895748, 0.14290683473864974, 0.10478209063198662, 0.11993147047349995, 0.14748838655878604, 0.13068108119142907, 0.09973586944976032, 0.14352498516892942, 0.1618183161575123, 0.21692734023082616, 0.15453389365341286, 0.18185022210348312, 0.14171140736176435, 0.17459363817193463, 0.184414431561033, 0.22637983145036877, 0.16088670298100005, 0.5649685741776044, 0.5642851296350814, 0.5169202890371445, 0.5951941438297577, 0.4972255220046311, 0.5506332189380037, 0.5993165986451319, 0.6040076790268183, 0.5614097235519802, 0.4410231456052782, 0.4627896236775132, 0.3545087023668413, 0.4515081380951437, 0.4073863761686767, 0.4486544003865077, 0.46048011132632605, 0.4813504747250137, 0.5204071929997682, 0.24220663437015444, 0.22777563121058486, 0.20237532707478678, 0.1817016006738139, 0.18283374759104432, 0.20066539215419998, 0.20266254226083202, 0.19316457283023736, 0.1987484704227871, 0.5194470255376851, 0.5378302105192233, 0.5575690279512289, 0.20629011372740869, 0.5713375574014162, 0.21006047004941852, 0.21310861573113238, 0.2188509667609012, 0.5348681663825028, 0.19794995782251357, 0.16885964106131868, 0.8709896356638536, 0.1971268354389737, 0.7836565927728201, 0.16630254794496702, 0.8230297264159268, 0.18283242072103467, 0.18245954498942252, 0.20326552192675618, 0.8172357181443357, 0.16696344705641764, 0.7255243752426459, 0.20226683083500152, 0.20480185261157557, 0.20811399572209843, 0.2104776708607764, 0.1264273004224673, 0.189705390924653, 0.1699620550518568, 0.2014079222558629, 0.18974289202824624, 0.2043464694759125, 0.20991225536924618, 0.20989023428905362, 0.2107553695724479, 0.20400635700780567, 0.10787375881304506, 0.0914849010860258, 0.09330553054574575, 0.08822331850050091, 0.10052385503383099, 0.08875994774796103, 0.09904328405474994, 0.09890165856706468, 0.08611410646675088]}, "mutation_prompt": null}
{"id": "0379c8b9-6c88-44f7-9c3e-5c1f4079412d", "solution": "import numpy as np\n\nclass RefinedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Adjusted mutation factor\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 15  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success  # Adjusted base factor\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.3)\n            self.crossover_prob = np.clip(0.8 + 0.2 * recent_success + 0.05 * np.random.randn(), 0.5, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def diversity_enhancement(self, individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n\n    def intensification(self, best_individual):\n        step_size = 0.03 + 0.02 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 20:  # Frequent population control\n            self.population_size = max(20, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(self.diversity_enhancement(population[i]))\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:  # Increased intensification probability\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "RefinedAdaptiveMemeticDE", "description": "Probabilistically Refined Adaptive Memetic DE with Enhanced Diversity and Strategic Intensification", "configspace": "", "generation": 87, "fitness": 0.18957769056934712, "feedback": "The algorithm RefinedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.3868710987666416, 0.3544686180741278, 0.36186284268621804, 0.39204848812748216, 0.4247163970965613, 0.3837151088992937, 0.36465952905908383, 0.4286829740742406, 0.38418056190991834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016137241565561955, 0.02873481230395669, 0.017987759083285315, 0.0985267186911295, 0.10588530479754188, 0.09124429038325321, 0.09449648928953225, 0.09678514846602881, 0.09086131246346307, 0.11587286290783028, 0.11156702047077871, 0.1031947634697652, 0.09352191382985364, 0.08532610637692484, 0.10450514784849496, 0.0829300416957427, 0.09228041135470699, 0.09676821745153685, 0.08663272884498019, 0.08324219679905787, 0.10547139489991697, 0.9421911556414448, 0.908596160649507, 0.9218375204541754, 0.9383711965042326, 0.3075335644063153, 0.38477211478982454, 0.9362066318364638, 0.9177383004945096, 0.9083916166989978, 0.2402229185792245, 0.2544009833910267, 0.2540066486738679, 0.23572766647615873, 0.2134308313209725, 0.2386311488495606, 0.22224989064617862, 0.21780407366018117, 0.2067248189405393, 0.2392972997497671, 0.23358178693568743, 0.24515891848827764, 0.29958500414674016, 0.2502366810947788, 0.2795441963415284, 0.2442039179639831, 0.29023784445167033, 0.27599203463270805, 0.1301247548789175, 0.12376468202557722, 0.12615258624241865, 0.11710169640849821, 0.1234520236533404, 0.1292991329109533, 0.1339238820210532, 0.14794029825385901, 0.1217510158616848, 0.12293783965296734, 0.13345647191589982, 0.0782602678758354, 0.13826773226126843, 0.12632546780406206, 0.12307064188045147, 0.13388949857724763, 0.13481858563498916, 0.12722195888360477, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007229015133990435, 0.01753588050154431, 9.999999999998899e-05, 9.999999999998899e-05, 0.10231049666942871, 0.08575241860427085, 0.10405098538455182, 0.06986518657724505, 0.07776659688889265, 0.061911309480274235, 0.11061706010774142, 0.07689441494570359, 0.07694690259889125, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061380021913950644, 0.06171003729789104, 0.05767625155965761, 0.08343927019354269, 0.07503470345891528, 0.08307930786213802, 0.07443591709731767, 0.07997356907905817, 0.07342895505001235, 0.3711001300876102, 0.38252444578279143, 0.3371486114731084, 0.37651594783080145, 0.3697456576039737, 0.3504194821297688, 0.3427053939955206, 0.3455192141573894, 0.3817584772817306, 0.10082532305893477, 0.11521759945921806, 0.10794356536061112, 0.0936226555156009, 0.11783070331798629, 0.075992805552623, 0.09738669645716003, 0.08516471866979225, 0.10781119279980944, 0.13465096873685156, 0.1864577624220639, 0.15043706230848142, 0.15140066694624532, 0.1402472361833461, 0.14658460290267106, 0.17704856094244592, 0.13655385490176375, 0.147987884135794, 0.241344941263401, 0.254588623125666, 0.23995386450149347, 0.27389725056300285, 0.2518836018362993, 0.23953947706149525, 0.24393506815719934, 0.2532548601148523, 0.25727601522579957, 0.19909635960775574, 0.1846420745657299, 0.1902242515515703, 0.16246821748507623, 0.18151273394686263, 0.18520282683102118, 0.20448917586080673, 0.1985809979271118, 0.19379767231565648, 0.18500265167983843, 0.19030930997863327, 0.1873450918653604, 0.18232503861940164, 0.19939240510262712, 0.20132631750354812, 0.2052365500940012, 0.19964587564461944, 0.19601248735276544, 0.17588030845200942, 0.1779211336887443, 0.18259882172501363, 0.1745412511528528, 0.18238313189005861, 0.17758962801994183, 0.1834509853969719, 0.19198147155012835, 0.18582458740330254, 0.1648540938230728, 0.1955133145047283, 0.15916576336509314, 0.45768143150053364, 0.44373860557990685, 0.501886689568263, 0.20313446499017174, 0.4952458086705237, 0.5154883991001691, 0.16706418178476157, 0.20655931287607132, 0.20226379589018284, 0.19757653234308914, 0.19849240209308205, 0.27510331974659297, 0.20336567287672747, 0.31003679084716074, 0.20988971006568535, 0.1860362921106662, 0.16720663268997582, 0.19390955592735593, 0.18041622796661927, 0.18086015870415872, 0.1902245114282315, 0.1817404211702538, 0.1884757316876846, 0.19284427391520254, 0.06571394072500603, 0.07244655226839003, 0.09315246993941129, 0.07836744830284481, 0.08310902495936368, 0.07376990454149268, 0.07550174534679732, 0.08330500285035991, 0.08473543509175452]}, "mutation_prompt": null}
{"id": "57ea620d-be0f-4af9-865c-5310462f21f9", "solution": "import numpy as np\n\nclass DynamicAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.memory_size = 15\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.6 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DynamicAdaptiveMemeticDE", "description": "Dynamic Adaptive Memetic DE with Enhanced Population Control and Strategic Parameter Tuning.", "configspace": "", "generation": 88, "fitness": 0.4950617238870704, "feedback": "The algorithm DynamicAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.28.", "error": "", "parent_id": "2bcf8cc7-1d89-47a2-80e1-0d7629ef45bc", "metadata": {"aucs": [0.8400419310819978, 0.8622148694824587, 0.8665345905271379, 0.8605326727476512, 0.8628686966554087, 0.8671331472410799, 0.8794779451174015, 0.8475919869183289, 0.8568729851055112, 0.7646273583224092, 0.7717124016558135, 0.7393157449134298, 0.7515855166292191, 0.7511319857762175, 0.7542679026848609, 0.763854456883615, 0.780292997322696, 0.7518711016749067, 0.39934445499112114, 0.16381882814988025, 0.3628130877172615, 0.45112181953548125, 0.6271723458292601, 0.47496356206833845, 0.3040531010384693, 0.24113244128783773, 0.17682218509195813, 0.15700427047185717, 0.1303054308551962, 0.4066547698418308, 0.4355864514620583, 0.13268073417699178, 0.15153871222292215, 0.11289788939746581, 0.13355169689383617, 0.14293792746599177, 0.9175967378643913, 0.9508026293163881, 0.9561706768264809, 0.9634953585882639, 0.972868463261297, 0.9598072528345014, 0.9703703517436122, 0.9470446907428778, 0.9621016343399702, 0.7095066946212996, 0.618814730739961, 0.6640755119278189, 0.7116708170175821, 0.6541263444560292, 0.6613127575054621, 0.6590106866867241, 0.68958811704254, 0.6350573572267657, 0.8818279954368924, 0.8482236363395728, 0.8676564803160536, 0.865925209571975, 0.8648507048601901, 0.8510600551734522, 0.864194537552438, 0.88916036899631, 0.8800335030664512, 0.5414861735959899, 0.6503920056206085, 0.6391264362110367, 0.44376402962832373, 0.6654833899618897, 0.6374774524252727, 0.6083784568088346, 0.632911310261504, 0.4224948336088291, 0.12823486000849205, 0.4052753259910016, 0.6341623326171069, 0.47344094322252406, 0.47984321901850924, 0.5008377703824883, 0.3182714107264386, 0.5668880083329556, 0.4912145857088426, 0.68682429587488, 0.6705423313767105, 0.4176608229478608, 0.7134712581983863, 0.6690273238200144, 0.6266623272033561, 0.5131546166554044, 0.6781243638892082, 0.6614324311071864, 0.7494342549448998, 0.6965671172606476, 0.7436877749368395, 0.7521868364346919, 0.6884127445152668, 0.7406580811760255, 0.776932120297895, 0.7228922689791704, 0.7833752404130474, 0.08707639034702319, 0.14554729636421726, 0.29660126399758, 0.27012996897196984, 0.6022946416505296, 0.5579024165881505, 0.4217139133514355, 0.15760314458510782, 0.3237819435637579, 0.5549693663109561, 0.5118216790543431, 0.5765248844601847, 0.5854770778755503, 0.5412443721612, 0.5765393319706567, 0.5644732391793801, 0.5333882546443713, 0.5783270734712616, 0.8100298765845372, 0.8368725494626562, 0.8171182012046648, 0.8239517071398329, 0.8194621736092147, 0.807611286903834, 0.8270758301396903, 0.8094467034072624, 0.8185343034869368, 0.15124930324491692, 0.11427898696397276, 0.12132794241672396, 0.11190089006916826, 0.15513345239204335, 0.13486518462960995, 0.1287509711952347, 0.17119834056867367, 0.1277601572323832, 0.30506114609811885, 0.3192179946797339, 0.4282074745949588, 0.23149546457122838, 0.14431665865357768, 0.2263030170732605, 0.30704795061348933, 0.6005695889287898, 0.16717928526472137, 0.5549023133838646, 0.5758631187582006, 0.6119402532929638, 0.6251089038308826, 0.5652418651040734, 0.5556914329920755, 0.5825895297804924, 0.6139746798010117, 0.6173198280510552, 0.4042535378984534, 0.47723845419973665, 0.4342925252698496, 0.23011974032846083, 0.42077396472049666, 0.44119095235070327, 0.5072457183375665, 0.43881681024388086, 0.495114972690063, 0.2067959957574943, 0.19908571595500502, 0.20504852742787494, 0.20610035999070142, 0.24831677051613998, 0.20613186293886554, 0.21228686052311652, 0.23504708322378365, 0.23286968896952331, 0.2299060094699652, 0.6945846368284537, 0.22155705776198642, 0.23630777889896826, 0.23533558234636986, 0.23873966513299394, 0.2059575310907652, 0.20676050862501416, 0.22806273683465206, 0.18433734733501483, 0.8533146756755743, 0.14078462683919135, 0.8769199494773339, 0.8749432009506495, 0.1842564842750004, 0.16073109823298815, 0.19412829612204374, 0.16142122905946776, 0.635923306303026, 0.16828513776732146, 0.8697550856255027, 0.20652963859068574, 0.20483099733674248, 0.8015365733766433, 0.15120117991565507, 0.8400570963168736, 0.21035542110315975, 0.2136513197337273, 0.23137908663228157, 0.18899321396077473, 0.2238742178032258, 0.2911797035145438, 0.24296211362599252, 0.20063193999586515, 0.19687501240528127, 0.25092842701503526, 0.09460384165887825, 0.09003109959981848, 0.07517764587765596, 0.09600347735522319, 0.08437506526224481, 0.10474316874949896, 0.09212340717652368, 0.11894619472170909, 0.09217634975829914]}, "mutation_prompt": null}
{"id": "58fa584d-6116-4a84-92c3-47311d64454f", "solution": "import numpy as np\n\nclass DynamicAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.7\n        self.crossover_prob = 0.9\n        self.success_rate_history = []\n        self.memory_size = 15\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.6 + 0.4 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.3)\n            self.crossover_prob = np.clip(0.9 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.01 + 0.04 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 5 == 0 and self.population_size > 20:\n            self.population_size = max(20, int(0.6 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.6:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DynamicAdaptiveMemeticDE", "description": "Dynamic Adaptive Memetic DE with Enhanced Population Control and Strategic Parameter Tuning.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8400419310819978, 0.8622148694824587, 0.8665345905271379, 0.8605326727476512, 0.8628686966554087, 0.8671331472410799, 0.8794779451174015, 0.8475919869183289, 0.8568729851055112, 0.7646273583224092, 0.7717124016558135, 0.7393157449134298, 0.7515855166292191, 0.7511319857762175, 0.7542679026848609, 0.763854456883615, 0.780292997322696, 0.7518711016749067, 0.39934445499112114, 0.16381882814988025, 0.3628130877172615, 0.45112181953548125, 0.6271723458292601, 0.47496356206833845, 0.3040531010384693, 0.24113244128783773, 0.17682218509195813, 0.15700427047185717, 0.1303054308551962, 0.4066547698418308, 0.4355864514620583, 0.13268073417699178, 0.15153871222292215, 0.11289788939746581, 0.13355169689383617, 0.14293792746599177, 0.9175967378643913, 0.9508026293163881, 0.9561706768264809, 0.9634953585882639, 0.972868463261297, 0.9598072528345014, 0.9703703517436122, 0.9470446907428778, 0.9621016343399702, 0.7095066946212996, 0.618814730739961, 0.6640755119278189, 0.7116708170175821, 0.6541263444560292, 0.6613127575054621, 0.6590106866867241, 0.68958811704254, 0.6350573572267657, 0.8818279954368924, 0.8482236363395728, 0.8676564803160536, 0.865925209571975, 0.8648507048601901, 0.8510600551734522, 0.864194537552438, 0.88916036899631, 0.8800335030664512, 0.5414861735959899, 0.6503920056206085, 0.6391264362110367, 0.44376402962832373, 0.6654833899618897, 0.6374774524252727, 0.6083784568088346, 0.632911310261504, 0.4224948336088291, 0.12823486000849205, 0.4052753259910016, 0.6341623326171069, 0.47344094322252406, 0.47984321901850924, 0.5008377703824883, 0.3182714107264386, 0.5668880083329556, 0.4912145857088426, 0.68682429587488, 0.6705423313767105, 0.4176608229478608, 0.7134712581983863, 0.6690273238200144, 0.6266623272033561, 0.5131546166554044, 0.6781243638892082, 0.6614324311071864, 0.7494342549448998, 0.6965671172606476, 0.7436877749368395, 0.7521868364346919, 0.6884127445152668, 0.7406580811760255, 0.776932120297895, 0.7228922689791704, 0.7833752404130474, 0.08707639034702319, 0.14554729636421726, 0.29660126399758, 0.27012996897196984, 0.6022946416505296, 0.5579024165881505, 0.4217139133514355, 0.15760314458510782, 0.3237819435637579, 0.5549693663109561, 0.5118216790543431, 0.5765248844601847, 0.5854770778755503, 0.5412443721612, 0.5765393319706567, 0.5644732391793801, 0.5333882546443713, 0.5783270734712616, 0.8100298765845372, 0.8368725494626562, 0.8171182012046648, 0.8239517071398329, 0.8194621736092147, 0.807611286903834, 0.8270758301396903, 0.8094467034072624, 0.8185343034869368, 0.15124930324491692, 0.11427898696397276, 0.12132794241672396, 0.11190089006916826, 0.15513345239204335, 0.13486518462960995, 0.1287509711952347, 0.17119834056867367, 0.1277601572323832, 0.30506114609811885, 0.3192179946797339, 0.4282074745949588, 0.23149546457122838, 0.14431665865357768, 0.2263030170732605, 0.30704795061348933, 0.6005695889287898, 0.16717928526472137, 0.5549023133838646, 0.5758631187582006, 0.6119402532929638, 0.6251089038308826, 0.5652418651040734, 0.5556914329920755, 0.5825895297804924, 0.6139746798010117, 0.6173198280510552, 0.4042535378984534, 0.47723845419973665, 0.4342925252698496, 0.23011974032846083, 0.42077396472049666, 0.44119095235070327, 0.5072457183375665, 0.43881681024388086, 0.495114972690063, 0.2067959957574943, 0.19908571595500502, 0.20504852742787494, 0.20610035999070142, 0.24831677051613998, 0.20613186293886554, 0.21228686052311652, 0.23504708322378365, 0.23286968896952331, 0.2299060094699652, 0.6945846368284537, 0.22155705776198642, 0.23630777889896826, 0.23533558234636986, 0.23873966513299394, 0.2059575310907652, 0.20676050862501416, 0.22806273683465206, 0.18433734733501483, 0.8533146756755743, 0.14078462683919135, 0.8769199494773339, 0.8749432009506495, 0.1842564842750004, 0.16073109823298815, 0.19412829612204374, 0.16142122905946776, 0.635923306303026, 0.16828513776732146, 0.8697550856255027, 0.20652963859068574, 0.20483099733674248, 0.8015365733766433, 0.15120117991565507, 0.8400570963168736, 0.21035542110315975, 0.2136513197337273, 0.23137908663228157, 0.18899321396077473, 0.2238742178032258, 0.2911797035145438, 0.24296211362599252, 0.20063193999586515, 0.19687501240528127, 0.25092842701503526, 0.09460384165887825, 0.09003109959981848, 0.07517764587765596, 0.09600347735522319, 0.08437506526224481, 0.10474316874949896, 0.09212340717652368, 0.11894619472170909, 0.09217634975829914]}, "mutation_prompt": null}
{"id": "26a2f655-1c6b-458f-bd48-93c796f7dcfa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased initial population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Slightly higher initial mutation factor\n        self.crossover_prob = 0.85  # Slightly adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 20  # Increased memory size\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success  # Adjusted base factor calculation\n            self.mutation_factor = np.clip(base_factor + 0.2 * np.random.randn(), 0.4, 1.5)  # Extended range for mutation factor\n            self.crossover_prob = np.clip(0.85 + 0.15 * recent_success + 0.06 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.03 * np.random.randn() * np.random.choice([1, -1])  # Adjusted step size\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 6 == 0 and self.population_size > 15:  # Adjusted condition and size\n            self.population_size = max(15, int(0.7 * self.population_size))  # Adjusted reduction factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.65:  # Adjusted probability for intensification\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic DE with Improved Self-Adaptive Mechanism and Memory Utilization for Better Convergence.", "configspace": "", "generation": 90, "fitness": 0.41006915610600814, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8826605773465848, 0.8728084551176819, 0.8900501424389058, 0.8934259393562026, 0.8876819974534778, 0.8838760589145039, 0.879610075406648, 0.8842234223614783, 0.8792564227680606, 0.8096363217458135, 0.8091932180727697, 0.7285089716255262, 0.8095188252995769, 0.8118053077523413, 0.7954024534212232, 0.8265280782889415, 0.8245590301244371, 0.818108272903261, 0.17092550413244445, 0.17191907311875587, 0.41959427946079353, 0.17276662034656565, 0.6797846516855572, 0.6004681459711148, 0.1492743260945918, 0.15133252625741644, 0.17788184071120416, 0.14056363531877358, 0.17439251290214908, 0.14905759875507096, 0.13588115294845338, 0.1490554867456918, 0.16895127774559227, 0.1733416344697749, 0.16645283429663282, 0.17610982832206756, 0.9697491554974055, 0.933117745429756, 0.9335525406461984, 0.9284122770755835, 0.9350651162726898, 0.9158046951792652, 0.9475809572917652, 0.9614722064320036, 0.9559418092372232, 0.7357212524769389, 0.7507357951972914, 0.6559858923560349, 0.7013513765472672, 0.7223186985022427, 0.7207976483911691, 0.7092349146200929, 0.6812719570694992, 0.6162720350901209, 0.3827598664415973, 0.35569293065105645, 0.8733703134903463, 0.27301087133274526, 0.8780879212812038, 0.8710647986347445, 0.8715014386220903, 0.8772720765801707, 0.8642573782158793, 0.1289657994414205, 0.2523525903770608, 0.4862546004725391, 0.22138535630128253, 0.3549539763052907, 0.2568334507690946, 0.34859130380387127, 0.37331222793077656, 0.2960543069673225, 0.11341835106051223, 0.23226706260405616, 0.21022434354131814, 0.48732214749898284, 0.20110692360993698, 0.1868189178415588, 0.21995733031855258, 0.20498116545720613, 0.27304444698379626, 0.12117246048158703, 0.26138584186466474, 0.14363659721991628, 0.1208087067275927, 0.08766263480856851, 0.2774238173389765, 0.24755872858918349, 0.5513494836614476, 0.19997579436456026, 0.22969890454453723, 0.3893875494525125, 0.41931742858508225, 0.3417410983761975, 0.06485612660726015, 0.3736456698565279, 0.3975445333390275, 0.07675883950393347, 0.5516549237407253, 0.1329622781385671, 0.1494187420361892, 0.21614727713256565, 0.25112307416228563, 0.1865501568554888, 0.22152806252491752, 0.18067996336331416, 0.1006979231682722, 0.17778448243426082, 0.39196689603022195, 0.34358147665697003, 0.3194753556545905, 0.5189172294481859, 0.40370150384703074, 0.33871382342539513, 0.4402889022602581, 0.22877113546588812, 0.3621589182625693, 0.7746519946103783, 0.8442984908714698, 0.6238522370383124, 0.6035228741141868, 0.5928389258416165, 0.5523506595694041, 0.5754549094913275, 0.7329339905750346, 0.65083674966502, 0.15053285223739998, 0.13934382370828058, 0.26371317003322337, 0.11256715342636037, 0.1376908131496628, 0.1410429940778456, 0.10031863731616997, 0.1214669209528354, 0.12928123700332295, 0.15373858465239532, 0.17838130871276447, 0.37116601587165443, 0.18217785859561642, 0.20946170223503713, 0.20210918992814253, 0.19475864003110543, 0.2539358187493793, 0.30581788436788615, 0.6426830038383051, 0.4556048762446798, 0.4180841114073883, 0.6867321719628515, 0.4173819093331712, 0.6778238787485615, 0.7256200791802327, 0.7268221904431365, 0.6942928778456549, 0.45455427298512663, 0.48819925592771585, 0.571332114212636, 0.3050042523435117, 0.4216463135807349, 0.4748562079583022, 0.35594166952661377, 0.301295419441273, 0.4732909679417785, 0.22806597001510132, 0.20795188142744891, 0.23711555295826747, 0.2385303057214383, 0.23845802717657505, 0.20055620481481917, 0.19942870126557255, 0.2241950130371292, 0.2147044153175537, 0.6910563668972778, 0.22492435957545198, 0.758465236260312, 0.21097661093999953, 0.2477637746759247, 0.24128529680487865, 0.7601448071968676, 0.22083515502846196, 0.24091009000061214, 0.8592338307137958, 0.19642255634514827, 0.15078771516661704, 0.8469528407961857, 0.195283299799917, 0.1825990387370119, 0.20164366607456263, 0.1982587779285223, 0.8820137575554314, 0.20830968826157747, 0.20698773770444567, 0.7638856903632605, 0.7613647035791099, 0.19761017982144347, 0.16418971421381334, 0.20826412543927553, 0.20908408777844456, 0.20965112416116927, 0.1936642012828793, 0.24839787060722007, 0.2148384032256404, 0.20708970667125381, 0.1959287390659029, 0.20623417412689804, 0.22908606990385683, 0.18757416337284372, 0.2017046673531685, 0.09070904568544325, 0.09917997299641024, 0.10162666037449786, 0.10140435123553104, 0.09213151165536582, 0.10271373330716393, 0.09354183224364465, 0.09342350590931159, 0.09446698712347446]}, "mutation_prompt": null}
{"id": "fc826577-cede-4f1a-ab20-7a8fe180b3fd", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(40, 8 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 20\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.3, 1.5)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.05 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 30:\n            self.population_size = max(30, int(0.7 * self.population_size))\n\n    def multi_intensity_search(self, best_individual):\n        perturbations = [self.intensification(best_individual) for _ in range(3)]\n        return perturbations\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                for intense_candidate in self.multi_intensity_search(population[best_idx]):\n                    intense_fitness = func(intense_candidate)\n                    budget_used += 1\n\n                    if intense_fitness < fitness[best_idx]:\n                        population[best_idx] = intense_candidate\n                        fitness[best_idx] = intense_fitness\n                        break\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedMemeticDE", "description": "Enhanced Memetic Differential Evolution with Adaptive Strategy and Dynamic Multi-Intensity Search.", "configspace": "", "generation": 91, "fitness": 0.43769640395739046, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8151194414452712, 0.8102078732194252, 0.8168570295395657, 0.8114106200132394, 0.8234440239718146, 0.8300213199028991, 0.847428754114012, 0.8382562530463679, 0.8293436066731183, 0.6784514036420322, 0.6898835310029781, 0.6751692351285005, 0.6638166132154075, 0.6926734068228328, 0.6881626626771014, 0.692874830029675, 0.6765358284781142, 0.6845957635152888, 0.1593572551879895, 0.21940217154627606, 0.3601925083504297, 0.43297531220803553, 0.21526307463934813, 0.3409006708619121, 0.42308111662134307, 0.4212115808176007, 0.14406652320464686, 0.15326228119975094, 0.1326394205486615, 0.14072845092773478, 0.1470092623379312, 0.13249582261084125, 0.30679546824412607, 0.13896198092116452, 0.23818577570670907, 0.18689500889264044, 0.9566787954960962, 0.9666640270987248, 0.9283277116443025, 0.9643835745734555, 0.9543309130742362, 0.9831369504132598, 0.9351309065276102, 0.9545354566056151, 0.9800013785924887, 0.6071966928280925, 0.5764784395966186, 0.579517708733269, 0.5960843274589318, 0.6017388884423682, 0.555969152889892, 0.5933474632550885, 0.572679582319314, 0.565662516419214, 0.7835097918606065, 0.7482776843537279, 0.22077773079482343, 0.8375328111439251, 0.8344210564395198, 0.8030482624927334, 0.8010943751306824, 0.8206942448513802, 0.7621518086346944, 0.39971423577689646, 0.2654120692293179, 0.4395968677372424, 0.38212231478178205, 0.35583148835336054, 0.33736048127188334, 0.4649557470120709, 0.3702021827599964, 0.47849646110028377, 0.6474786804075652, 0.4382052251485379, 0.3374408170485844, 0.5269127478076329, 0.33628331319865834, 0.45702945578222975, 0.6002478113245213, 0.42636376057057646, 0.3035111674493133, 0.4113031477659852, 0.400371940112066, 0.4139697186021306, 0.4907771130216846, 0.5020901801618137, 0.479616141754584, 0.48153893682537086, 0.5051477855453614, 0.47836563471714133, 0.5959314042665649, 0.5658164093158897, 0.5588293198620192, 0.6298677694301791, 0.6018563848485647, 0.5506206610377433, 0.6217451793728926, 0.6348807482894454, 0.6251721346794934, 0.24606656220846623, 0.095960318809861, 0.12165617493980385, 0.22424986780904, 0.42800000636879576, 0.17934648239749784, 0.26872157674517383, 0.21989778073989952, 0.22871759121297208, 0.36100237410003744, 0.37560577275140594, 0.3530282672487839, 0.37882823693082923, 0.39173900276009055, 0.4055043042154608, 0.3518657873392974, 0.37039859816480625, 0.3499556690184601, 0.7371423416345025, 0.7433454797528078, 0.7482917710594205, 0.7125880749989061, 0.7656953532479203, 0.7492871760465584, 0.7255151580901178, 0.7366642415473401, 0.7339387473648733, 0.12777929017060397, 0.12876045430138816, 0.1578914589658882, 0.13196161829502817, 0.15087962104745856, 0.11483994797395336, 0.1179347086221958, 0.12300717027040808, 0.13259316931020892, 0.20578446683634188, 0.16961003316489154, 0.14640914779292125, 0.23313367819207653, 0.2307227131047257, 0.16482276091937076, 0.23213995965136414, 0.17045731045040957, 0.17586786689652667, 0.44767731735472127, 0.4027661464622794, 0.4658824190129077, 0.4771508864647158, 0.48113146244862404, 0.48214188542614633, 0.47975342974834967, 0.49165193770114934, 0.48684923012505155, 0.34710016450767056, 0.35840369393482807, 0.377245958378312, 0.3479248316816359, 0.3354172960981946, 0.375436087288992, 0.40673380760098676, 0.4296961059308366, 0.3859467481658616, 0.21386299066204362, 0.2201965511167896, 0.19521636513224416, 0.18793248825885067, 0.2052952155545058, 0.18458827928144794, 0.20496956459249505, 0.23766057950785158, 0.19361834680340717, 0.34389524445484076, 0.3689612278314123, 0.2217259897658167, 0.5038533734142215, 0.21938670635492297, 0.21230069251471761, 0.2605241495529226, 0.5327486297392727, 0.43969650265232596, 0.7860310268366892, 0.8276558291121312, 0.19386188824252826, 0.16896189241645265, 0.7594705031326789, 0.16333871763428665, 0.6202199313098558, 0.17880145211812648, 0.7448225096559482, 0.8339377408870068, 0.7116686714037795, 0.7095782096232575, 0.20532677140220035, 0.20131631165488106, 0.8424527584787084, 0.5890579536585904, 0.21007845962602456, 0.20989156829717692, 0.20488115305749222, 0.19578188051634537, 0.2180612868491033, 0.20383324442080908, 0.20066459317719199, 0.19593801768042363, 0.20569050836697422, 0.2133282852546764, 0.1923390867091731, 0.08846895362651308, 0.09746264255882997, 0.08747927808629263, 0.09837685355214654, 0.09739747203505411, 0.08612608829442525, 0.08931836104909785, 0.10034362649744888, 0.11139575927893386]}, "mutation_prompt": null}
{"id": "55d0d2aa-f1ba-4a7b-89d1-be75435c47bd", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.75  # Slightly increased mutation factor\n        self.crossover_prob = 0.85  # Adjusted crossover probability\n        self.success_rate_history = []\n        self.memory_size = 20  # Increased memory size for better adaptation\n        self.memory = np.zeros((self.memory_size, 2))\n        self.phase_change_interval = 10  # Introduced phase change interval\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.12 * np.random.randn(), 0.5, 1.3)\n            self.crossover_prob = np.clip(0.85 + 0.12 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn()\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def diversification(self, population):\n        diversification_rate = 0.1  # Added diversification phase\n        diversified_population = population + diversification_rate * np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        return np.clip(diversified_population, self.lower_bound, self.upper_bound)\n\n    def dynamic_population_control(self, generation):\n        if generation % self.phase_change_interval == 0:\n            self.population_size = max(20, int(0.65 * self.population_size))  # Altered reduction rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            if generation % self.phase_change_interval == 0:\n                population = self.diversification(population)\n\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:  # Adjusted probability for intensification\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDynamicAdaptiveMemeticDE", "description": "Enhanced Dynamic Adaptive Memetic DE with Multi-phase Adaptation and Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 92, "fitness": 0.18036975360640306, "feedback": "The algorithm EnhancedDynamicAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.34065819046618695, 0.28619202222353735, 0.32849332738071113, 0.3104167554534546, 0.3164814543835299, 0.3314516627015547, 0.30754084331098497, 0.35230749414076434, 0.3627260348334457, 9.999999999998899e-05, 9.999999999998899e-05, 0.019834399054664886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09079365087395508, 0.08347708028169598, 0.08117002836729081, 0.0896693780720379, 0.09034939955545274, 0.08807837024876042, 0.07916400353490627, 0.100899404848934, 0.07520044797765857, 0.07111720484475681, 0.07450094568992027, 0.09172386972586133, 0.059594947837829704, 0.07262743554098783, 0.07030730815287511, 0.08295117873436753, 0.0700587626761986, 0.06507712858406667, 0.9405918970765732, 0.9292966992376297, 0.9243324072072785, 0.9380251228123578, 0.9391652650862921, 0.9621621753850907, 0.9613602616207619, 0.9598064546139389, 0.9444985239468715, 0.195474648816663, 0.17530138495755176, 0.17867743715297946, 0.21043571955346674, 0.18574154549772037, 0.1742783019074905, 0.19814011952645405, 0.18452380720788464, 0.15858821216935426, 0.2057495246697454, 0.2171228684155908, 0.20069761309610323, 0.24466713893253722, 0.2386520891236419, 0.2234208030819126, 0.29078326698541324, 0.21745430787276576, 0.3094542012498104, 0.13243416812859177, 0.10101450407689339, 0.10645325091764557, 0.09707061251945093, 0.09241214520905983, 0.15877601575339872, 0.10387876151769082, 0.12437982391488511, 0.11928782152347372, 0.08312227340541578, 0.08712773539967134, 0.05709451911943764, 0.12321520638403871, 0.10095486404517506, 0.11952361237410347, 0.12160835881540111, 0.10383838909015486, 0.10539464207719595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06587370297395867, 0.1029226018702809, 0.057185970355733806, 0.07166604334045334, 0.08372096726886136, 0.0865324749618176, 0.06344429919472527, 0.046076953130048004, 0.07015175142835228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03885473990347599, 0.037374500673242994, 0.05678311856702989, 0.05828607960728771, 0.056557882162979856, 0.037524850897510675, 0.06763012824373726, 0.05078170155012052, 0.05060659264815781, 0.32214064291019195, 0.34350259361282565, 0.32431965347581226, 0.35706258718374906, 0.34420404697622686, 0.32712845664073, 0.2992590438335707, 0.32121489912111945, 0.35530806972047557, 0.11780994845791559, 0.08343900570091844, 0.07873732139162404, 0.09507607571888288, 0.0742748787704468, 0.10977487158396126, 0.08447248412737685, 0.0791654455077212, 0.09428684873366544, 0.12405154047010125, 0.1636733211912833, 0.15800561806756763, 0.1784191900754457, 0.17186226768541968, 0.1721849022363391, 0.1751930428796037, 0.15452240869442724, 0.14394702087131395, 0.24547252604281633, 0.22931050894579774, 0.21795656615205938, 0.23869365291092204, 0.21491089470913272, 0.22934754756170517, 0.24911073586961419, 0.23821882938035532, 0.2479806280764446, 0.1974299202245995, 0.1879195166617229, 0.18928539037971992, 0.15789603126376028, 0.1645816912885566, 0.1699854727464737, 0.15641883883764962, 0.16164828006949805, 0.16231324231169586, 0.18170646022790538, 0.18490875906623327, 0.18697477539148977, 0.21981866997127286, 0.18563337928510815, 0.17857513056331953, 0.19103183474762675, 0.2036797501727451, 0.19530493380717384, 0.17227281550988482, 0.18178677601751536, 0.1739313568291314, 0.17908167623960913, 0.17127764749153995, 0.1639807386876586, 0.17146986587161261, 0.17500274584774633, 0.17144923602093964, 0.3846181928762168, 0.3737782324816018, 0.20244474378879596, 0.173640737925002, 0.16771862412818028, 0.3797748007803954, 0.3013083694622325, 0.3497693647387059, 0.4298562828740873, 0.14966789238601452, 0.1937192649653321, 0.19151225567109142, 0.1982908018084849, 0.19108804749984087, 0.14468518212466586, 0.31395370853381055, 0.2768763727708443, 0.20246718758268678, 0.19523456205179113, 0.18540987017600896, 0.20612718833826338, 0.20049602664835375, 0.18676096561170885, 0.20238335666490004, 0.18929529894916353, 0.18511375081804693, 0.20980418332771544, 0.08222836849825821, 0.06529255244062171, 0.0674784305284909, 0.0629483774650369, 0.06572831764331388, 0.06805538731506677, 0.06941718894911864, 0.07833391744956497, 0.07176037314017081]}, "mutation_prompt": null}
{"id": "ed40348e-6db9-4cb8-b707-c36bef428b43", "solution": "import numpy as np\n\nclass EnhancedDynamicMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 25:\n            self.population_size = max(25, int(0.65 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedDynamicMemeticDE", "description": "Enhanced Dynamic Memetic DE with Local Search Refinement and Adaptive Mutation-Crossover Balance.", "configspace": "", "generation": 93, "fitness": 0.4508843448366914, "feedback": "The algorithm EnhancedDynamicMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8578244535098842, 0.8504810240438828, 0.8464376743701365, 0.8515465262186402, 0.8620136776324383, 0.8498538725871569, 0.8295486980402589, 0.8491332443986515, 0.8431737413079011, 0.7137435859846211, 0.7391799099411116, 0.724164170045942, 0.7304984725636222, 0.7392179618146444, 0.7328342445398857, 0.738368992548653, 0.7431038474787578, 0.7381341962552224, 0.1783983709989463, 0.26938482159821264, 0.3086672741315438, 0.16464599016155157, 0.37597656460965523, 0.31859183224071674, 0.16274766615138303, 0.4083069989352077, 0.42554489689477104, 0.25915020796102695, 0.14427202403616224, 0.1566753525456468, 0.13774375602037403, 0.13553854465543314, 0.1423140865640371, 0.15194056608314022, 0.1731278899193458, 0.24507925769169936, 0.9748035582233542, 0.9562534263085348, 0.9213970019685335, 0.9783040647733916, 0.9287884115140725, 0.8950357649847112, 0.9302136989281824, 0.9715255746930294, 0.9500995123159963, 0.6415137586422395, 0.6703581386179556, 0.5802612323363321, 0.6186206929324481, 0.6229512082709641, 0.6223232086747577, 0.6237545006091504, 0.6133277387053808, 0.6118764290232541, 0.8060997154212171, 0.8404503641352411, 0.8298472017386711, 0.8300972011249945, 0.27089351691660524, 0.8104451910735248, 0.8196204867634104, 0.8298344578438165, 0.7925912250215539, 0.3708028376181467, 0.28631773832669405, 0.30964925638150975, 0.12767079570625794, 0.5936192008942245, 0.4878552592480454, 0.5265362866716938, 0.3836697203534557, 0.22381043622756502, 0.20770473186840155, 0.2700323653052493, 0.6330906151072321, 0.6448354919142132, 0.4973011054721126, 0.28813235457597663, 0.5372058722481214, 0.23906883815784696, 0.20546910336595814, 0.5645790604836232, 0.5234484413479539, 0.49928101787650125, 0.5396435563353155, 0.5737028635435921, 0.4962804355140049, 0.6037568280487724, 0.5667397567880599, 0.48972258848864936, 0.6131473373318646, 0.6039344486346384, 0.6297002200522892, 0.6312063563234762, 0.6667802311515612, 0.3891788216513634, 0.702935961834295, 0.6614445536816131, 0.6509301549154847, 0.28931869369892305, 0.31466475185590903, 0.10403850432658801, 0.4622991557118551, 0.43153463839363093, 0.3623434075597315, 0.09682057203228811, 0.3084714283393809, 0.1351543744072593, 0.4558368817763063, 0.4349462939372478, 0.41050920148632697, 0.5017734647333496, 0.43351420392357964, 0.42796243141604284, 0.45538136928619743, 0.44178585474541254, 0.39463987110739385, 0.7699868900022603, 0.7665918181455993, 0.7712891537018575, 0.7905030909061784, 0.7555698354111057, 0.7526118784164523, 0.7789111341811497, 0.746638573875528, 0.7458060731875713, 0.43101077621744366, 0.1416020660350631, 0.127517018930409, 0.1329343114225361, 0.12491467921845156, 0.10570167321034862, 0.1437775018630908, 0.15665132820146588, 0.13398640764120906, 0.16011838445075643, 0.3405187350272538, 0.1902763742724991, 0.19332310881956338, 0.21510667669622063, 0.19795107033251258, 0.21233759757359383, 0.1841067762923423, 0.16439846081730924, 0.5092458542484841, 0.5239583853263574, 0.4824020562534025, 0.5268947017041805, 0.5069482457926606, 0.4946300011475787, 0.5699526017015928, 0.5541521136254595, 0.5533013960180951, 0.3865241903799702, 0.3738062984683893, 0.38469416374681575, 0.3699027721273994, 0.34700457150042807, 0.39926135300478927, 0.4087975497710292, 0.4513854682240662, 0.397151513108403, 0.2065151646937856, 0.19772485970684595, 0.21096305196757348, 0.21388427784226527, 0.20049767461569945, 0.196184895620657, 0.20065567307547982, 0.20224721424327752, 0.2505187580363957, 0.3532882047893201, 0.6264955701682497, 0.36344253347085864, 0.18555088812039955, 0.5720332922550471, 0.45771063109946464, 0.32407726618353594, 0.511894497972774, 0.2620081597883964, 0.15196894107486714, 0.8353466232314136, 0.18580302603198462, 0.17171328136636843, 0.7874043065524603, 0.18828275729307986, 0.8156839705428552, 0.16483110568657777, 0.8601188823164152, 0.1964197491899341, 0.20154017848104566, 0.6802047267324627, 0.7710343034852578, 0.8077275990807896, 0.19773098100143627, 0.20578147374523947, 0.20313730042276135, 0.2071262401835906, 0.20458180305412654, 0.1912717910943179, 0.20108364256893463, 0.19479616036573766, 0.18995434685238832, 0.19336281349793294, 0.21166417358206102, 0.2647422205810378, 0.2164401267007353, 0.10462205733856156, 0.09057495724444564, 0.0850069476511287, 0.09406514968317514, 0.0801522881697816, 0.09791282054991712, 0.09973546330509331, 0.09236197008601843, 0.09815564310773572]}, "mutation_prompt": null}
{"id": "434bb9aa-66a1-4ee6-8b63-761d1c4bda35", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 20\n        self.memory = np.zeros((self.memory_size, 2))\n        \n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n            \n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridMemeticDE", "description": "Hybridized Memetic DE with Dynamic Strategy Adaptation and Enhanced Local Search for Improved Convergence.", "configspace": "", "generation": 94, "fitness": 0.44266845766439616, "feedback": "The algorithm HybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8672410850401467, 0.878103310228419, 0.8804078599271057, 0.8831715605836417, 0.8744084961319152, 0.8901574736937911, 0.8853684184932823, 0.8714095002414242, 0.8596933271529322, 0.7890332809095767, 0.8107953822410461, 0.7957894729449124, 0.781133601124485, 0.7884048213922252, 0.7949413021847651, 0.7993089193118577, 0.7911607700996529, 0.7961158069389229, 0.14989891250600773, 0.5435997041245813, 0.34976565376858826, 0.15016114021866123, 0.17226912208343814, 0.6186469185240394, 0.16863294640316873, 0.385526046161231, 0.1561936113556609, 0.554776064165718, 0.15453742686712413, 0.5287401630794158, 0.1369727965260099, 0.14241958278461642, 0.11558821811071596, 0.1327640651800801, 0.13082000451482234, 0.16559175863145303, 0.9480172378115834, 0.9673827306822034, 0.9440981400198194, 0.9506211633140862, 0.9404913830411235, 0.9418840502742376, 0.976840972182336, 0.9620445605377248, 0.9476270722450204, 0.7440596771100834, 0.6727951815718871, 0.7047329041089598, 0.7001322856033984, 0.743492023909115, 0.7168616591461574, 0.717794423126742, 0.6803143159694576, 0.7307423801357922, 0.8604634315313165, 0.8623972259541024, 0.8774365887262879, 0.8757379136327125, 0.8782744676342155, 0.8828844806508845, 0.869171068975251, 0.8455245904924902, 0.8769527061170044, 0.5096049942528305, 0.5646407938196154, 0.6759824859255568, 0.5901060292981016, 0.44885232235289707, 0.6296262129203103, 0.6765594712608117, 0.6256279994036331, 0.12969867281454295, 0.2859062130402663, 0.12513662178269858, 0.318759436929533, 0.662508952911403, 0.6549182712343651, 0.5340456731274038, 0.4597992000028098, 0.6323576580843946, 0.12752564245861653, 0.2979406752003181, 0.6460715484062092, 0.32510264056978533, 0.3713105811395656, 0.5858206951596333, 0.061047277879287654, 0.1259277208100893, 0.3425918373090735, 0.1716917362102155, 0.4819177332521204, 0.20344021695573733, 0.4227627702877981, 0.3110087020755976, 0.14674659094452214, 0.379833750873779, 0.48882330764957704, 0.5828282681568152, 0.28405777549389033, 0.10734576483740044, 0.14395891297384733, 0.29498567558765953, 0.2365952586631742, 0.20699322993972746, 0.28319822118432125, 0.17354124645225344, 0.17980224386409627, 0.22900392957980176, 0.38150329792533233, 0.5176894532757784, 0.4329495045020285, 0.4721187460335674, 0.4654541389250637, 0.5947163236155208, 0.5015062291596799, 0.3410838996290314, 0.36315956846015884, 0.8435683117862007, 0.715012121964737, 0.8058553166102413, 0.6806615967996004, 0.7660764668482773, 0.7946642078370708, 0.7934274902480201, 0.6686909081357086, 0.8090846476145104, 0.15498580807517792, 0.12921761307466928, 0.13110078321331653, 0.12493066711684642, 0.11552345502084027, 0.17764990696233962, 0.12691987741354038, 0.11163930204077865, 0.1416241060418355, 0.16012858509196248, 0.1784554240749323, 0.3585513617190068, 0.18211504006088586, 0.3374222540002595, 0.2067878453306885, 0.16842190730917628, 0.28146047417414455, 0.15360647980306297, 0.6253300789927168, 0.5469476335249734, 0.6579348735617307, 0.5860663889500307, 0.5882597950421921, 0.5506809961804247, 0.6093022076225525, 0.6512919135311133, 0.6714370810753123, 0.3292157589366349, 0.43754540739188263, 0.4655176804451526, 0.3935469499204346, 0.5276981273650155, 0.47393684038050865, 0.5532976921532475, 0.5040048997080114, 0.5203276003104927, 0.2021957452728398, 0.19174220261825703, 0.22734049223029196, 0.22087691934330456, 0.19987637029641925, 0.22901190304543362, 0.2122508248392413, 0.21382587616750293, 0.19563610494610018, 0.20870972053704928, 0.6202026736874615, 0.22189401957880917, 0.19942280257183054, 0.2431540825641465, 0.6616639569160055, 0.21226839678937282, 0.7317516285850685, 0.21710644077158459, 0.16905975723019306, 0.20588730461156568, 0.1519522148915552, 0.19450667902967722, 0.1857187429315793, 0.163934838267208, 0.18408325605456688, 0.163717272942129, 0.20686626367389815, 0.8702594439133537, 0.16667582195528063, 0.2033963592416047, 0.20661591420243786, 0.20482240688734388, 0.20227901354052824, 0.7318063168759545, 0.12619146083107857, 0.20902064080917704, 0.19559715383941667, 0.1934268795339763, 0.19354177281104978, 0.20603052665095667, 0.22069000522889382, 0.19068948285350185, 0.1944720177977841, 0.20668927084054378, 0.20921624206790146, 0.10033313433609692, 0.0923754149872259, 0.09081321613648774, 0.08462869260526751, 0.08927328266239043, 0.0857273446381922, 0.08925889170306434, 0.08860424578087023, 0.10086224617418449]}, "mutation_prompt": null}
{"id": "1ef6695e-31f8-4087-8715-9b17f2ceee93", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 20\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.65 + 0.35 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.88 + 0.12 * recent_success + 0.04 * np.random.randn(), 0.6, 0.95)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 30:\n            self.population_size = max(30, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.7:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution with Strategic Intensification and Adaptive Memory.", "configspace": "", "generation": 95, "fitness": 0.40695798878311856, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.24.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.7950715631723093, 0.7719379880620862, 0.784289084463473, 0.7768202662005897, 0.7899725551149674, 0.8022999966794222, 0.783830398143355, 0.7818558008429473, 0.7930451975698645, 0.5914770015809968, 0.6222135691030304, 0.631979828749227, 0.6246848627005299, 0.6402638283156985, 0.6426247549215075, 0.6528387918393083, 0.6328760277785789, 0.644742759777172, 0.14555928888861414, 0.12120042815926968, 0.15703153382674118, 0.11459041017940275, 0.12945550218976043, 0.20457218435522095, 0.12497418403406846, 0.16780245788881343, 0.12612080231405143, 0.13707111646567116, 0.13674110753309288, 0.13278060347891352, 0.13637524716442806, 0.12714152574856685, 0.11929212663997968, 0.13216406452700646, 0.14288901940171383, 0.12381903534866179, 0.9296003747370993, 0.9557177697333499, 0.9188388869901571, 0.9217147892655831, 0.9598862267487099, 0.9526954847972444, 0.9484470700405909, 0.9243431449161948, 0.9716226627689984, 0.514780348419444, 0.5119482009441979, 0.5273579443633101, 0.46513150034794604, 0.5130068132000892, 0.493082748151461, 0.5116547671437689, 0.5269709971443808, 0.503997428069002, 0.7430342639213539, 0.7744966399103599, 0.7626819642887227, 0.7303218379252949, 0.7931686373091619, 0.7840582296633156, 0.7672404673486795, 0.7604437031994635, 0.7438675846743675, 0.4214539670108829, 0.33352786579808336, 0.449305059012981, 0.4626855261319025, 0.2927066894113213, 0.5041353064120482, 0.4300022683919482, 0.35599333700077307, 0.4771534659842991, 0.494621071362926, 0.35293085728660756, 0.12075829727771925, 0.4063103562207372, 0.439930603446957, 0.4487781161231954, 0.3605047754045181, 0.39360879079384536, 0.46838121604117255, 0.43280063915577216, 0.3991147200464097, 0.42334910048536134, 0.43711362104486884, 0.44447933999930767, 0.4219044102212417, 0.44214486522400265, 0.3259727728274654, 0.3395444768713004, 0.5074496386002885, 0.547946240157917, 0.5629548617381677, 0.504692979158871, 0.5569356334027786, 0.5542596243582827, 0.5502584194588929, 0.5604030766792172, 0.568465684255365, 0.164384975912226, 0.17836252931025998, 0.15193377272027353, 0.27684211039992046, 0.1706792199897882, 0.2771015526218735, 0.15826125091161214, 0.21520455486740564, 0.10556680393621987, 0.2993552264989261, 0.3246413805783215, 0.31713180743850444, 0.35777554359396524, 0.31980517532155084, 0.3244528650457015, 0.3172570279343244, 0.28786046939451404, 0.30374053814149793, 0.7062431591938236, 0.6878368079656505, 0.6805600797640645, 0.6897549583839107, 0.6897076243588156, 0.7079442198001359, 0.6724675992638831, 0.6958780151830619, 0.6706524461554584, 0.1233814912574891, 0.13084393342674716, 0.1378488581905114, 0.10511840640440984, 0.1097988224351073, 0.13388793012453115, 0.09519525191713929, 0.11767038508480587, 0.1252078284508923, 0.2301352161990302, 0.16228647109306382, 0.1982083327414801, 0.3549015493952504, 0.2566621776228247, 0.23892001941378893, 0.1634032357949332, 0.21097363354744314, 0.20234318205160606, 0.406757940471251, 0.372105189274088, 0.39384774720921556, 0.3895939284473171, 0.4131611064865083, 0.37663420623186084, 0.4189981925431129, 0.43939469414689925, 0.46500378985206103, 0.2995083120078984, 0.29739295531181664, 0.3141760267975009, 0.2766999251511204, 0.31981079725901274, 0.28704606573105684, 0.3291498571057605, 0.309684104285763, 0.34696978695073444, 0.1945130760393331, 0.20277771898981878, 0.21693974704977181, 0.19594230137692537, 0.20473063882869347, 0.22737108787926752, 0.18548972928011798, 0.19061684320518912, 0.1999600149462074, 0.23865850956134294, 0.30346329846417497, 0.3346602277514248, 0.19546017598654886, 0.35811431742096445, 0.24379594120031312, 0.21207596578582855, 0.19738232812710543, 0.4083767233394485, 0.7383785502404911, 0.7534897709833241, 0.7536539061502237, 0.17976746140164157, 0.8025562864958892, 0.7000428805158709, 0.7016308350354643, 0.17774679621643863, 0.6771043444557369, 0.6770119886887185, 0.20069533861799804, 0.6899825075901169, 0.5448089868528946, 0.6809410545481267, 0.15779613510616686, 0.20398311655049672, 0.780121191038306, 0.20979340331117624, 0.24060690330116652, 0.20167418835394124, 0.18500141023304206, 0.24323243866815292, 0.1854286968487724, 0.20056295297363214, 0.20715979173435406, 0.20499605963524525, 0.26582631697327186, 0.08312973145234792, 0.08421803088906454, 0.09112077759164272, 0.08475682520348815, 0.0822841975505324, 0.08008520814810294, 0.09290515248864872, 0.09692984065087562, 0.08395771834733345]}, "mutation_prompt": null}
{"id": "5f6e767b-463c-4698-b378-f736ff6fb5aa", "solution": "import numpy as np\n\nclass AdaptivelyBalancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.4, 1.5)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.6, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 4 == 0 and self.population_size > 18:\n            self.population_size = max(18, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.55:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptivelyBalancedMemeticDE", "description": "Adaptively Balanced Memetic DE with Interactive Population Dynamics and Fine-Tuned Parameter Control.", "configspace": "", "generation": 96, "fitness": 0.4509995694098671, "feedback": "The algorithm AdaptivelyBalancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8731854848838625, 0.8753730848622797, 0.8734445238349283, 0.8775463409286391, 0.8829848262313744, 0.8823791951082987, 0.8748206074749297, 0.8697276756272907, 0.884672278870314, 0.7971765189129341, 0.7928931254629659, 0.7786484329552346, 0.8042595102036885, 0.804178647770615, 0.7998286785639176, 0.7859180914881208, 0.803004340354748, 0.7851324834435066, 0.6057343915368846, 0.5494880948668306, 0.17167910368197914, 0.3886444085388364, 0.17061107452754098, 0.651339531971667, 0.16696956084313186, 0.4341831190414297, 0.17303565808616928, 0.14777225254907667, 0.11617123931256479, 0.1265562347021918, 0.16383954630467035, 0.55038199630451, 0.15151019566047308, 0.15154561626584384, 0.10900798577291826, 0.16362533466123386, 0.952026132583613, 0.9639422972863805, 0.9215477772287366, 0.9320835878502656, 0.9651316776287334, 0.9400625789461582, 0.9574840041374914, 0.9406551677009564, 0.9496371654554756, 0.7013863340728962, 0.7299574722244625, 0.6893769844963675, 0.7048063161617453, 0.7170057935974041, 0.7113646624555245, 0.7240875166927885, 0.7485853537653067, 0.6917256907402803, 0.8482900555786536, 0.8660674355568657, 0.8576631196626254, 0.8595545409532731, 0.8338679728463078, 0.8602335942967028, 0.8616561217914949, 0.3903382136488044, 0.8716965090286328, 0.2510569707872339, 0.1279389677437186, 0.28086251084831637, 0.6624688174206679, 0.24481999896233142, 0.2929403600338163, 0.21517615473336504, 0.20476010086495633, 0.20615290052195356, 0.27129971177829015, 0.11587649210917839, 0.23387626783972715, 0.4588864730299824, 0.6584029617464482, 0.22337178097159271, 0.26843242690823155, 0.5346349974853022, 0.18432187050698068, 0.5686407775297573, 0.11594542486342907, 0.19261889566325885, 0.1706896261621298, 0.6869200573102519, 0.5084618754148751, 0.536503979385405, 0.39550525832845274, 0.2752982075892303, 0.6282708984863963, 0.4931315226956121, 0.7165506421087411, 0.4347716091260112, 0.7411536707620416, 0.12264604312717764, 0.3771495880570226, 0.7576528132452636, 0.3211477581237786, 0.1975804155198264, 0.3572195893003397, 0.10378798274985312, 0.3590616563817739, 0.48004251326759917, 0.22212040589551707, 0.1677035433363746, 0.1712897943757118, 0.25321678609459086, 0.44665313964598585, 0.36883653135558425, 0.35969049581919676, 0.4441698857823959, 0.5227941375464571, 0.48751203104914176, 0.4512218285339521, 0.380962787522405, 0.5134935900660292, 0.7755932461840861, 0.8259784982300377, 0.6391155593500704, 0.6689033888441408, 0.8314824759337596, 0.6796296717800459, 0.6473367141757385, 0.8261735326184021, 0.8308023425407027, 0.14866687961699376, 0.12076404708050814, 0.14301997008423628, 0.14932333874241233, 0.1407264639021103, 0.1567304826673135, 0.13628650172484613, 0.16843711661015026, 0.15070368162622094, 0.27063856162755184, 0.19797774221677966, 0.1521916948513934, 0.25681858751365116, 0.18551314791257534, 0.2256434204067157, 0.22422847937031498, 0.30240885467675027, 0.42403761350932623, 0.4570171456020109, 0.6407866358814198, 0.6691726794231316, 0.6766198414355643, 0.5318291121173189, 0.6082522513642519, 0.6679795801144206, 0.693087914437013, 0.6855783531525295, 0.30420068655012267, 0.33261371378507, 0.5389401885968921, 0.45664202213663574, 0.5011481522805303, 0.5470692105118147, 0.36927665746585925, 0.5987657909945152, 0.233022836253043, 0.24175830755772965, 0.2031080810314514, 0.22435260949801228, 0.197906289094829, 0.21555144372215895, 0.19449119317350072, 0.20938074465174428, 0.2328262376093675, 0.2143318507041695, 0.23751746095666926, 0.7552868829561654, 0.5940437905991882, 0.2054043594545817, 0.687291032852352, 0.23743411260461955, 0.20689378227106425, 0.23725785293291302, 0.6983485542285611, 0.20530197324473654, 0.8797552630301356, 0.8720499814898376, 0.16014907717009597, 0.1945615950121503, 0.19381515677927585, 0.1846898647587203, 0.17211123959248487, 0.8635920858580068, 0.16711787776422626, 0.2107524630415536, 0.821632781166881, 0.20929040030272106, 0.16124864095565716, 0.6771590074426297, 0.8233980809174246, 0.165558592917042, 0.20505665366990877, 0.19655004862819192, 0.2206631791442244, 0.20171694265019324, 0.19272941713060365, 0.2078468018981352, 0.19119137496009575, 0.19699741483781597, 0.21804260899136096, 0.20901566178492614, 0.09949950433291066, 0.08759941575698849, 0.09497509710741503, 0.09145361728818624, 0.08950382916361266, 0.08306550309611316, 0.08624275777146218, 0.10282140822318997, 0.10123350834711964]}, "mutation_prompt": null}
{"id": "2ee7c663-e2c0-4ae8-a2a4-defa20b7244a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 20\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.15 * np.random.randn(), 0.4, 1.2)\n            self.crossover_prob = np.clip(0.8 + 0.1 * recent_success + 0.1 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.5 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.65:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic DE with Stochastic Time-Varying Strategies and Improved Intensification.", "configspace": "", "generation": 97, "fitness": 0.41469789111293903, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.9025450911001026, 0.9072615872982429, 0.9192364016350859, 0.9094255723146372, 0.9007247425093625, 0.9117201051114094, 0.9134490094758088, 0.8959433521822289, 0.9046312483031179, 0.855899581786594, 0.8365068822284342, 0.8526867490862982, 0.8312478050102221, 0.43819245743684254, 0.781935838975474, 0.8321500075791868, 0.8380707497606587, 0.834119231572218, 0.7084950592000163, 0.18827575385811157, 0.14230057566435084, 0.17826736494390794, 0.7166855907138928, 0.5881232428179399, 0.1706131018300704, 0.6853916773092172, 0.529890507227929, 0.15224780431490303, 0.5106852561850644, 0.12075076805671903, 0.18103550565064552, 0.16173400295683915, 0.1279220521249541, 0.6518568805184786, 0.1633066814406866, 0.13826873236095527, 0.9622164524036781, 0.9722144531192649, 0.9781185598928026, 0.9839540175163772, 0.9433578994032052, 0.962688232158512, 0.9731909741127884, 0.9811468536393307, 0.9786084386463805, 0.7297888343733966, 0.7525287243311566, 0.7365962642348225, 0.7957908651544532, 0.5400055245564424, 0.7323056296793139, 0.7489311705172383, 0.7093562670029084, 0.6964235511407069, 0.8281683687939241, 0.8919760383725831, 0.9187671162596376, 0.2757659795965862, 0.8457315763277753, 0.3778763542495348, 0.8842030163442361, 0.8651696473575987, 0.9105451683789563, 0.22738854883629556, 0.21998465515232457, 0.7205937062229864, 0.2571327202031306, 0.22877293800004195, 0.21457096988201685, 0.21027151528056198, 0.20911741325093236, 0.1845694682798944, 0.21281629370326172, 0.25178586195786934, 0.22509120180266118, 0.20355116213494462, 0.23412074165773988, 0.2311675621094451, 0.2213369651083431, 0.24673790634168702, 0.18664393382526456, 9.999999999998899e-05, 0.29288229991208814, 0.12041605832762892, 0.17020116506769267, 0.2234181112620397, 0.2730751149558538, 0.03912656182270713, 0.07149146998418254, 0.08241936130593985, 0.2814567599769039, 0.21706370478959924, 0.2197849683160512, 0.12164969931283665, 0.22404359479052893, 0.2554895328864686, 0.30887832355640976, 0.286216638319597, 0.35623553219571535, 0.1262249107180189, 0.0715868065015084, 0.1603315633130794, 0.19339281114890028, 0.11909697970491884, 0.1837356515343136, 0.12373244910540016, 0.3488714080419347, 0.14744109848772313, 0.4014555530650613, 0.3381712336307774, 0.16325085747991452, 0.36809762670670365, 0.38115519362999606, 0.3568133544131039, 0.3110218827185939, 0.28478364133762346, 0.21425587793083123, 0.7501725097105655, 0.8037703016565908, 0.8273123638163643, 0.6786438477850072, 0.6855044049422832, 0.5951870057188388, 0.6376144014427347, 0.6453693075222215, 0.7325070967685858, 0.14969397383629857, 0.13904634104255797, 0.14271867079950296, 0.15476460876397236, 0.4530407340859772, 0.15785229690186642, 0.13269899778290872, 0.13710058722607443, 0.133429569979169, 0.2346173602013819, 0.20998560698748703, 0.235130444599989, 0.18584443692189268, 0.22343156474439363, 0.18826883143370343, 0.25285155122939373, 0.30973797315240914, 0.19224560191322404, 0.5608664968468303, 0.597226950758708, 0.7050214520818725, 0.6928913202670499, 0.6780952492819527, 0.688672262290376, 0.7200131630800848, 0.6088240266927518, 0.6301885893731023, 0.4151839085616441, 0.4424134526817205, 0.22970155655274083, 0.5517691992473255, 0.4751125547048205, 0.4576472482821562, 0.5573916576982452, 0.46442420223597314, 0.2550876519081424, 0.21673057834443332, 0.19895173923486786, 0.22595886101400053, 0.22423149820620147, 0.2207916853662124, 0.22783742730892564, 0.2181584304875952, 0.21249684227319732, 0.258076052043524, 0.8026236119132625, 0.20697399994827825, 0.21245041889355898, 0.7733031585730847, 0.24181963188513045, 0.24266995379696865, 0.7124628058977427, 0.7101779054275595, 0.6789346652606858, 0.1696549938620444, 0.16477318085664716, 0.17021313289523132, 0.18669078564327246, 0.19887384826481225, 0.1985960030365055, 0.15640297674752257, 0.16041770855454685, 0.17032681169645003, 0.6052466679140847, 0.1667706992879141, 0.8664275847160127, 0.2081113335867132, 0.16574999873752017, 0.16641622486828833, 0.15464319230329016, 0.7454473976606422, 0.211205441585662, 0.1906987298300069, 0.2326110863637183, 0.19890554886303913, 0.19371703844509514, 0.2237340975836497, 0.1984993793422284, 0.17803410097956962, 0.2022849125303583, 0.20587162953570504, 0.09655263858897811, 0.10718028089985476, 0.09180200322689014, 0.10113562348928629, 0.09922074868229924, 0.1072529401302692, 0.09700120149356772, 0.10856944629585219, 0.09194018440689966]}, "mutation_prompt": null}
{"id": "4e153e0a-df5e-4e38-b0dc-2d3251675ae0", "solution": "import numpy as np\n\nclass DynamicAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 10\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.3 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.1 * np.random.randn(), 0.3, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.05 * np.random.randn(), 0.6, 0.95)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.02 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 3 == 0 and self.population_size > 15:\n            self.population_size = max(15, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.5:\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DynamicAdaptiveMemeticDE", "description": "Dynamic Population and Intensification with Adaptive Parameter Control in Memetic Differential Evolution.", "configspace": "", "generation": 98, "fitness": 0.42365258783255827, "feedback": "The algorithm DynamicAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.919443422680454, 0.9040370528406895, 0.9183857288691367, 0.9196979069376743, 0.9154530341896765, 0.9156984610697523, 0.911451787535314, 0.9231202885849208, 0.909519943655366, 0.8468384183517403, 0.8269098634618216, 0.835901126645717, 0.848422220722119, 0.8548237736220745, 0.8456070063882274, 0.8460090582017774, 0.8366045649669355, 0.84315061911385, 0.7732443810313937, 0.15319479717839912, 0.7367630107766356, 0.7236280834868909, 0.15299805885488726, 0.17661898732617642, 0.701363864224014, 0.5772624554851431, 0.7014677411091528, 0.08264088366775135, 0.12162122232725503, 0.14957270771492237, 0.15667635511887124, 0.1488201268334084, 0.1097097706465342, 0.1579912143719594, 0.15231163952840654, 0.18073623988260878, 0.973162767609583, 0.9625621694152849, 0.9674427806140194, 0.9680140038104426, 0.9536132325244663, 0.947827731875482, 0.9352803749406366, 0.9703632586563058, 0.9208490953534747, 0.5943195089576132, 0.37963306540630914, 0.6834071612412381, 0.73380755699559, 0.6695864876755795, 0.7583002093585447, 0.5344350298910805, 0.7630788204060518, 0.8022002822625289, 0.37414897775901945, 0.898067762773452, 0.8911606027987644, 0.852877106718166, 0.9128013041022918, 0.9089691829986176, 0.8824298095754912, 0.9233808026770187, 0.48282907862214386, 0.41779505550963514, 0.1857046921455816, 0.23610249532794958, 0.18905376851487454, 0.3122813652561788, 0.2205936830169739, 0.18979641437429173, 0.20539180395427414, 0.20135270272316086, 0.32281467232317795, 0.11472945006619761, 0.23197271109351636, 0.19165939039926627, 0.3157209131877242, 0.20123659270898275, 0.2629175290725839, 0.19557651449730917, 0.18301523444263024, 0.08169006299769577, 0.15736034348978045, 0.20931117139602073, 0.07224954243751558, 0.15306305367495587, 0.03960807705909153, 0.18498499887809905, 0.19266996298931705, 0.1735401708326061, 0.221151196404208, 0.3660277478565993, 0.31066695486830587, 0.24083750761471268, 0.1366047482958549, 0.07925264768670548, 0.6809833679702345, 0.30298408101165464, 0.46320425142907573, 0.16586505325902923, 0.20134002464965184, 0.19576865112429276, 0.3158282004549282, 0.22474619803309093, 0.21933166621559352, 0.16739879467643282, 0.14485707879700727, 0.12134089572553608, 0.3945145938676232, 0.21334784671638984, 0.2649079564222153, 0.30871681177260024, 0.4614873879214487, 0.31967162765378465, 0.2127748994772376, 0.3316258540051126, 0.48736933593475107, 0.6638492463485206, 0.7108992101150972, 0.7838447883615461, 0.6174664361646047, 0.5705997422164801, 0.6223930036145007, 0.5352134995201023, 0.6836818639485918, 0.6307195290874397, 0.15870361949081324, 0.6458551494050976, 0.6208787752642511, 0.10714937805855296, 0.1808379933459231, 0.10467944318189115, 0.1278664058321377, 0.14404427154768729, 0.12909943102323274, 0.1426834674422105, 0.6445218768195544, 0.24734320251480113, 0.1337807887410587, 0.4586018245151706, 0.18048717348949828, 0.22019786527537066, 0.22642750949769785, 0.21819659793470425, 0.5764373198361656, 0.6444495652356534, 0.726150899302517, 0.7373631403506313, 0.7317737532121115, 0.7184248433634568, 0.7144411184442923, 0.547441791626855, 0.7820779849607924, 0.3108429859823013, 0.47597658687616395, 0.3936289902608009, 0.5262304223130667, 0.24826241532873006, 0.6187615979877732, 0.380806814680099, 0.45167700801502453, 0.5119279079442166, 0.23826461392273857, 0.24037632188875757, 0.21212192314173473, 0.24892497038631212, 0.24024466309949666, 0.22342318589060428, 0.2712875695516077, 0.24292570127365654, 0.24759747420590683, 0.24718375149425997, 0.20484532627520569, 0.7846948472868438, 0.2486402103868729, 0.8092164698087054, 0.24727295911895963, 0.20673008786859148, 0.22232328819957015, 0.20719168278116273, 0.1835015648243662, 0.7102838144418455, 0.9004766636782945, 0.19878407955991106, 0.19948996848058465, 0.8951792682016698, 0.1641619838483117, 0.1678564728063251, 0.17231885723042673, 0.11349406843602805, 0.21039366766490508, 0.16712005681939013, 0.7377736291424477, 0.2092936463461026, 0.206262226554643, 0.21116611137956975, 0.2099267041016557, 0.6086909741939686, 0.19307341447970794, 0.2105123015839485, 0.19450463270624208, 0.2158515907962717, 0.2209722396315036, 0.22513154560157167, 0.27292047039991674, 0.20415900530039877, 0.2190193989217527, 0.09331008746629887, 0.10971583224689108, 0.09894947721366021, 0.11762319901726692, 0.09148319537826177, 0.10135878139717647, 0.10823874715754955, 0.1012761549805371, 0.09768112015067631]}, "mutation_prompt": null}
{"id": "35769e40-462a-4428-b04a-e9fb22ccdf53", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Adjusted for more aggressive mutation\n        self.crossover_prob = 0.85\n        self.success_rate_history = []\n        self.memory_size = 20  # Increased memory for better adaptation\n        self.memory = np.zeros((self.memory_size, 2))\n\n    def adapt_parameters(self):\n        if len(self.success_rate_history) >= self.memory_size:\n            recent_success = np.mean(self.success_rate_history[-self.memory_size:])\n            base_factor = 0.5 + 0.5 * recent_success\n            self.mutation_factor = np.clip(base_factor + 0.05 * np.random.randn(), 0.5, 1.2)\n            self.crossover_prob = np.clip(0.85 + 0.1 * recent_success + 0.03 * np.random.randn(), 0.7, 1.0)\n            self.memory = np.roll(self.memory, -1, axis=0)\n            self.memory[-1] = [self.mutation_factor, self.crossover_prob]\n\n    def intensification(self, best_individual):\n        step_size = 0.015 + 0.03 * np.random.randn() * np.random.choice([1, -1])\n        perturbation = np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def dynamic_population_control(self, generation):\n        if generation % 8 == 0 and self.population_size > 25:  # Adjusted for more stability\n            self.population_size = max(25, int(0.7 * self.population_size))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used = self.population_size\n        generation = 0\n\n        while budget_used < self.budget:\n            new_population = []\n            new_fitness = []\n            self.dynamic_population_control(generation)\n\n            for i in range(self.population_size):\n                idxs = np.delete(np.arange(self.population_size), i)\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                    self.success_rate_history.append(1)\n                else:\n                    new_population.append(population[i])\n                    new_fitness.append(fitness[i])\n                    self.success_rate_history.append(0)\n\n                if budget_used >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.adapt_parameters()\n\n            best_idx = np.argmin(fitness)\n            if budget_used < self.budget and np.random.rand() < 0.65:  # Slightly increased chance of intensification\n                intense_candidate = self.intensification(population[best_idx])\n                intense_fitness = func(intense_candidate)\n                budget_used += 1\n\n                if intense_fitness < fitness[best_idx]:\n                    population[best_idx] = intense_candidate\n                    fitness[best_idx] = intense_fitness\n\n            generation += 1\n\n            if budget_used >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QuantumInspiredAdaptiveMemeticDE", "description": "Quantum-Inspired Adaptive Memetic DE with Enhanced Population and Mutation Strategy Tuning", "configspace": "", "generation": 99, "fitness": 0.44432048564859417, "feedback": "The algorithm QuantumInspiredAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "57ea620d-be0f-4af9-865c-5310462f21f9", "metadata": {"aucs": [0.8339110995112785, 0.8224931764866013, 0.8241130774147388, 0.8298872591022008, 0.835655403943437, 0.8303226766586199, 0.8250172677997871, 0.8316781569474384, 0.8334892244992156, 0.7050768754499442, 0.7364476718599318, 0.7152481141288876, 0.7196838593249604, 0.716368820031823, 0.7443320108511398, 0.697702427139842, 0.720613979688635, 0.7176368398080879, 0.23309610738015807, 0.22818210078798862, 0.1744050432674743, 0.15396042757714146, 0.30174422910809273, 0.38311983939973493, 0.19567186823995963, 0.22578508028603173, 0.3713221540647662, 0.13371480818973447, 0.2779922392402361, 0.29373581724375186, 0.16467367375541597, 0.15819676065541133, 0.1463132013667109, 0.1437261666178139, 0.14749552124591903, 0.15792183149398642, 0.9380306554922326, 0.9627881966133764, 0.9278720162389601, 0.929588242032042, 0.9286527483455674, 0.9437881529861774, 0.9470152290190367, 0.9402160293013324, 0.9140860571248463, 0.636830399314247, 0.612980600505377, 0.5722371457702984, 0.6341724797520172, 0.5427693734075615, 0.6487144280828365, 0.6267944787740115, 0.6214057534524661, 0.47517846667090025, 0.7887366967024119, 0.8000956573878872, 0.7820504681801149, 0.8292183928127457, 0.8432862612293445, 0.7962304736089943, 0.8055030963538369, 0.8017600603279975, 0.8110411585181883, 0.6117690397268571, 0.5100433822621016, 0.6020790443896213, 0.6008784498199442, 0.24976067204186903, 0.12757892990579145, 0.35978833071482363, 0.39556755148131173, 0.2372652402903449, 0.1291727629257119, 0.1161305575975683, 0.27851003763314597, 0.31756075412250817, 0.3069031902168544, 0.3204688274399782, 0.2743207447776784, 0.3861199697777068, 0.4107293082056239, 0.5529911359594089, 0.40755161665642436, 0.5071557207028914, 0.5971960323156167, 0.5249354593025544, 0.3653085882006416, 0.5237513528187923, 0.5433085661233057, 0.5552224501382088, 0.6562481099015114, 0.594534232414131, 0.6398261887049952, 0.6130843191640241, 0.6281370418444621, 0.612319525711895, 0.6169848663001227, 0.6291427813930227, 0.5907101171243907, 0.16321655271309665, 0.11189402783388469, 0.048256266799349246, 0.1596549510653813, 0.14961570793463796, 0.3270389580978733, 0.26106932035006336, 0.17858722158541673, 0.15766158882917802, 0.44072144425506576, 0.3771102891684178, 0.40311872027857176, 0.4456687363049837, 0.4479097217533914, 0.4588864714564933, 0.45219593188047225, 0.41959053536034474, 0.4097065933060261, 0.7760685109830303, 0.7483124732197194, 0.7773478127174409, 0.7652082157217608, 0.7747001618161661, 0.7699160712222873, 0.6003328021454306, 0.7671397359427915, 0.7755258223333918, 0.14511640882943244, 0.15460418232063622, 0.11419298249882615, 0.1344609038425738, 0.1279529798740312, 0.11539702533764917, 0.13797966091096192, 0.1251831146422301, 0.14446570154877225, 0.17385146667532936, 0.14314236702634098, 0.2169603859568362, 0.16708803822418483, 0.15615607840406187, 0.1765981769943552, 0.16909198549684734, 0.1640401188647953, 0.20923834125504304, 0.5141989074024275, 0.5016702026664948, 0.5188325706064082, 0.532750410918618, 0.5034900754180502, 0.5157622621196054, 0.5264664879992809, 0.577625037710442, 0.5113587628610761, 0.4254643271469599, 0.40090991812759347, 0.36934060104368804, 0.3719831736529454, 0.36832826521724826, 0.4037953629997981, 0.4370837074588576, 0.4434898538448663, 0.41062025438986316, 0.25709347165456065, 0.21275516789870152, 0.2034412986600208, 0.18940289735869253, 0.23746712838353523, 0.24420220283915006, 0.21355750311390886, 0.21271416235335494, 0.2045828558412529, 0.23422275982662366, 0.30276263827476635, 0.5428126536857669, 0.5370257015456069, 0.44427111031997646, 0.601388646382493, 0.34728239089351765, 0.4721442335932381, 0.225091154234505, 0.1676665822470239, 0.16464517800533252, 0.18177450129292838, 0.752853592904017, 0.7996374908725858, 0.8392606170485741, 0.1825287912611362, 0.6914182419528997, 0.7941731095895379, 0.6640617933702556, 0.20495301632562535, 0.7201072006881798, 0.6763882577908864, 0.620883347979245, 0.20619495561661882, 0.20971974314438657, 0.8600168984002206, 0.2087475933847398, 0.22815333894370726, 0.21281643763327973, 0.23538667638151967, 0.2500783808287589, 0.19105862713432287, 0.19569532563093872, 0.1971333155927164, 0.24400772033166185, 0.19420275611433202, 0.09533842978871598, 0.08451100425935199, 0.09017373775039783, 0.09183849533110766, 0.09914026713109847, 0.08886512230374377, 0.10257279828988553, 0.08351616285201291, 0.10151024302558287]}, "mutation_prompt": null}
