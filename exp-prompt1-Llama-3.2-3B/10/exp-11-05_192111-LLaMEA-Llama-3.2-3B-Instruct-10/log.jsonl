{"id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 24, in __call__\n  File \"/opt/conda/lib/python3.11/random.py\", line 456, in sample\n    raise ValueError(\"Sample larger than population or is negative\")\nValueError: Sample larger than population or is negative\n.", "error": "ValueError('Sample larger than population or is negative')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 24, in __call__\n  File \"/opt/conda/lib/python3.11/random.py\", line 456, in sample\n    raise ValueError(\"Sample larger than population or is negative\")\nValueError: Sample larger than population or is negative\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "f851407b-a6e3-4e3a-b015-6074363cb2e3", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def adaptive_crossover(self, parent1, parent2):\n        if random.random() < self.wavelength:\n            child = (parent1 + parent2) / 2\n        else:\n            child = parent1\n        return child\n\n    def adaptive_mutation(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            if random.random() < 0.5:\n                solution[index] += np.random.uniform(-1.0, 1.0)\n            else:\n                solution[index] -= np.random.uniform(-1.0, 1.0)\n        return solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "ecfbe610-ec6b-4ec7-9a12-d41ba8dea6b2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            if random.random() < self.mutation_rate:\n                solution[index] += np.random.uniform(-1.0, 1.0)\n            return solution\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Hybrid Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "fdf47793-65aa-4d3b-a4a8-04f9f4298b25", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-0.5, 0.5)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "be0df11b-a7f1-49ac-8ea4-131f2be46be7", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = self.population[0]\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for i in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.population, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(self.population[i]))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.array(solutions)\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population management.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "13929ea0-5a1e-40ec-b539-c469200e7e93", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = np.linspace(0.5, 0.9, 5)  # Adaptive wavelength\n        self.crossover_probability = np.linspace(0.9, 0.95, 5)  # Adaptive crossover probability\n        self.mutation_probability = np.linspace(0.1, 0.15, 5)  # Adaptive mutation probability\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability[_ % len(self.crossover_probability)]:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength[_ % len(self.wavelength)]:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability[_ % len(self.mutation_probability)]:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "39e6e65e-a63c-4e36-8763-84a6e0e813e8", "solution": "import numpy as np\nimport random\nfrom scipy import optimize\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.differential_evolution_params = {'popsize': 50,'maxiter': 100, 'x0': None}\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n            # Apply differential evolution\n            for _ in range(self.population_size):\n                if self.differential_evolution_params['x0'] is None:\n                    self.differential_evolution_params['x0'] = solutions.copy()\n                def f(x):\n                    return func(x)\n                res = optimize.differential_evolution(f, [(-5.0, 5.0)] * self.dim, x0=self.differential_evolution_params['x0'])\n                self.differential_evolution_params['x0'] = res.x\n                solutions = np.array([res.x, solutions])\n                solutions = np.unique(solutions, axis=0)\n                solutions = solutions.copy()\n                solutions = self.filter_solutions(solutions, func)\n                self.harmony_memory.append(solutions.copy())\n                self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Differential Evolution\" algorithm for black box optimization.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "7809bee6-ffd7-430a-875b-6d17c9057405", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.harmony_memory = self.harmony_memory[-100:]  # Truncate harmony memory\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Harmony Memory Truncation\"", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "1b48dfec-1b37-48e3-9638-a665bbc638e6", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2, self.dim)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim), self.dim))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2, dim):\n        child = parent1.copy()\n        for i in range(dim):\n            if random.random() < self.wavelength:\n                if random.random() < 0.5:\n                    child[i] = (parent1[i] + parent2[i]) / 2\n                else:\n                    child[i] = (parent1[i] + parent2[i]) / 3\n        return child\n\n    def mutate(self, solution, dim):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, dim - 1)\n            mutation_range = np.random.uniform(-1.0, 1.0)\n            solution[index] += mutation_range\n            if solution[index] < -5.0:\n                solution[index] = -5.0\n            elif solution[index] > 5.0:\n                solution[index] = 5.0\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved crossover and mutation strategies.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "84dc41af-6302-4b64-97f9-32925d12fcd4", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            # Ensure the solution is within the bounds\n            solution = np.clip(solution, -5.0, 5.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "db5febee-a6fa-4ac5-b3dd-fea942b19f53", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solutions = []\n        self.population_fitness = []\n        self.fitness_history = []\n\n    def __call__(self, func):\n        if not self.best_solutions:\n            self.best_solutions = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solutions.copy())\n            self.fitness_history.append(func(self.best_solutions))\n            self.population_fitness.append(func(self.best_solutions))\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.fitness_history.append(func(solutions))\n            self.population_fitness.append(func(solutions))\n            self.update_best_solutions(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solutions(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < np.min(self.population_fitness)):\n            self.best_solutions = solutions[best_idx]\n            self.population_fitness = np.append(self.population_fitness, fitness[best_idx])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Multi-Objective Optimization\"", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "9d612149-3d85-431a-bfdd-16bc7293b2aa", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_size = 10\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def update_memory(self):\n        if len(self.harmony_memory) > self.memory_size:\n            self.harmony_memory.pop(0)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e27c3d58-793e-495a-aee2-97491b75b037", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_size = 5\n        self.memory = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def update_memory(self, solutions):\n        self.memory.append(solutions)\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)\n\n    def get_best_solution_from_memory(self):\n        if self.memory:\n            best_solution = np.min(self.memory, axis=0)\n            return best_solution\n        return self.best_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Memory\" algorithm for black box optimization.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "c9660d6b-1d12-4859-ae9f-3edb57545cc5", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.adaptive_wavelength = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def update_adaptive_wavelength(self):\n        best_fitness = np.min([func(solution) for solution in self.harmony_memory])\n        self.adaptive_wavelength = min(self.adaptive_wavelength + 0.1, 1.0)\n        for solution in self.harmony_memory:\n            for i in range(self.dim):\n                if random.random() < self.adaptive_wavelength:\n                    solution[i] = (solution[i] + np.random.uniform(-1.0, 1.0))\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Adaptive Wavelength\" algorithm for black box optimization.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "769aca7d-a0c5-40c9-82cd-4c30740ef7ce", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.init_population(func)\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def init_population(self, func):\n        self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n        for _ in range(self.population_size):\n            self.harmony_memory.append(self.best_solution.copy())\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Better Initialization", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (50,) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (50,) + inhomogeneous part.')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "b213fa55-7a55-4ff7-af11-f12d86886296", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5  # New: diversity maintenance\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        \n        # New: maintain diversity\n        diversity = np.linalg.norm(solutions - self.best_solution, axis=1)\n        if np.mean(diversity) < self.diversity_threshold:\n            # Introduce new solutions to maintain diversity\n            new_solutions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n            new_solutions = self.filter_solutions(new_solutions, func)\n            self.harmony_memory.append(new_solutions.copy())\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Maintenance\"", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "ab35a4ce-3600-489e-841b-a6c9c9ec8c5f", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.8  # New parameter to maintain diversity\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n            # Maintain diversity by replacing worst solutions\n            worst_solutions = solutions[np.argsort(np.mean(solutions, axis=0))[:int(self.population_size * (1 - self.diversity_threshold))]]\n            self.harmony_memory[-int(self.population_size * (1 - self.diversity_threshold)):] = worst_solutions\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Diversity Maintenance", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "c4ea875e-29b9-44c8-b1cf-dda2c5c760eb", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            if solution[index] < -5.0:\n                solution[index] = -5.0\n            elif solution[index] > 5.0:\n                solution[index] = 5.0\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n", "name": "SwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "ae773efe-0803-4554-9796-bdfe05df2ccf", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.adaptive_wavelength = 0.7\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength + self.adaptive_wavelength * random.random():\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "3a86d38e-86bc-4a6b-ae3b-c4ca41112b82", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = self.population[0]\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            new_population = self.population.copy()\n            for i in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    new_population[i] = child\n                else:\n                    new_population[i] = self.mutate(self.population[i])\n            \n            new_population = self.filter_solutions(new_population, func)\n            self.harmony_memory.append(new_population.copy())\n            self.population = new_population\n            self.update_best_solution(func, new_population)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, func, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "4217c809-d884-41f6-97ea-2537528a8b4d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        if self.population is None:\n            self.population = [self.best_solution.copy()]\n        \n        for _ in range(self.budget):\n            solutions = []\n            for individual in self.population:\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(individual))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n            self.population = solutions.copy()\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Population Reinitialization\"", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "fcd7e42a-0740-4c39-b28b-e53726b6b118", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.filter_threshold = 0.1\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        # Use a filter threshold to filter out weak solutions\n        filtered_fitness = fitness[(fitness - np.min(fitness)) / (np.max(fitness) - np.min(fitness)) > self.filter_threshold]\n        best_idx = np.argmin(filtered_fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Enhanced Filtering", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "8c0144cb-925c-49cf-a266-f61394560b76", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population_history = []\n        \n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population_history.append(solutions.copy())\n            self.update_best_solution(solutions)\n            \n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            \n    def plot_population_history(self):\n        import matplotlib.pyplot as plt\n        for i in range(len(self.population_history)):\n            plt.plot(self.population_history[i], label=f'Iteration {i}')\n        plt.legend()\n        plt.show()\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n\n# Refine the strategy by adding a plot of the population history\n# ```python\nswarm.plot_population_history()", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "7527a188-0148-4753-a5d3-2d0db2b4a432", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        else:\n            self.update_diversity(self.best_solution, solutions)\n\n    def update_diversity(self, best_solution, solutions):\n        diversity = np.linalg.norm(solutions - best_solution, axis=1)\n        if np.min(diversity) < self.diversity_threshold:\n            # Preserve diversity by replacing the best solution with a new one\n            new_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            while np.any(np.abs(new_solution - best_solution) < 0.1):\n                new_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.best_solution = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Preservation\" algorithm for black box optimization.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "173f40ab-b089-4a37-91b1-bc4da0a69d3d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.mutation_rate = 0.1  # Adaptive mutation rate\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    # Adaptive mutation rate based on the number of evaluations\n                    if len(self.harmony_memory) < 10:\n                        self.mutation_rate = 0.1\n                    elif len(self.harmony_memory) < 50:\n                        self.mutation_rate = 0.05\n                    else:\n                        self.mutation_rate = 0.01\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_rate:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "bb35c197-463a-4fdf-9405-f79bde2b323d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.ceil(self.budget * 0.5))\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Dynamic Population Size\" algorithm for black box optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "f15e297d-e9ca-4d6b-8f24-6d1cc9e0a249", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population_adaptation = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n            # Adapt population size based on convergence\n            if len(self.harmony_memory) > 10:\n                if np.all(self.harmony_memory[-10:] == self.harmony_memory[-1]):\n                    self.population_size *= self.population_adaptation\n                else:\n                    self.population_size *= (1 - self.population_adaptation)\n        \n        # Update best solution\n        fitness = func(self.harmony_memory[-1])\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = self.harmony_memory[-1]\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Population Size Adaptation\" algorithm for black box optimization", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "be7ad410-d78f-4980-b36d-669ea3801b3c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population handling.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "a3e0c003-3464-4334-a143-0b9830c66399", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = np.random.uniform(0.4, 0.6)  # Adaptive wavelength\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "f85d9361-58b2-464e-b8f6-3f8bfbb08a67", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            mutation_factor = np.random.uniform(0.0, 1.0)\n            solution[index] = solution[index] + mutation_factor * np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Probabilistic Mutation\"", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "6d970f77-c686-476a-81bf-c30de324d1c6", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_rate:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def adjust_mutation_rate(self):\n        if np.sum(func(self.harmony_memory)) < np.sum(func(self.best_solution)):\n            self.mutation_rate += 0.01\n        else:\n            self.mutation_rate -= 0.01\n        self.mutation_rate = max(0.05, min(self.mutation_rate, 0.3))\n\n    def adjust_crossover_rate(self):\n        if np.sum(func(self.harmony_memory)) < np.sum(func(self.best_solution)):\n            self.crossover_rate += 0.01\n        else:\n            self.crossover_rate -= 0.01\n        self.crossover_rate = max(0.5, min(self.crossover_rate, 0.95))\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nfor _ in range(10):\n    swarm.adjust_mutation_rate()\n    swarm.adjust_crossover_rate()\n    swarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Mutation Rate Adjustment\"", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'list' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'list' and 'int'\")", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e335e97d-cc64-4176-88ed-0d91075dadd8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "b98dec94-274c-4fd6-832b-ff4577ab24d0", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.search_space = (-5.0, 5.0)\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(self.search_space[0], self.search_space[1], self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(self.search_space[0], self.search_space[1], self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-self.search_space[1] + 1, self.search_space[1] - 1)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "35e35138-a20c-4a63-aa4c-5096259cc039", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        elif np.any(np.abs(solution) > 5.0):\n            index = np.random.choice(self.dim, 1, replace=False)[0]\n            solution[index] = np.clip(solution[index], -5.0, 5.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "fa3dd922-6aa4-434e-8b95-1caa29708d32", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "88c81a31-db25-4e47-a7df-51a88a6de748", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.initialization_strategy = \"random\"\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            if self.initialization_strategy == \"random\":\n                self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n                self.harmony_memory.append(self.best_solution.copy())\n            elif self.initialization_strategy == \"harmony_memory\":\n                if len(self.harmony_memory) < self.population_size:\n                    self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(len(self.harmony_memory))])\n                else:\n                    self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n                self.harmony_memory.append(self.best_solution.copy())\n\n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm.initialization_strategy = \"harmony_memory\"\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population initialization and crossover strategy.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "c9fee92c-4c2f-4dad-9cb9-48393f2fdea6", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n            self.population = self.best_solution.copy()\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.concatenate((self.population, solutions))\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved handling of population size.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "aafb9819-8305-407a-9650-0c526fb055f1", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        \n        # Preserve diversity\n        diversity = np.mean(np.linalg.norm(solutions - self.best_solution, axis=1))\n        if diversity < self.diversity_threshold:\n            # Introduce new solutions to preserve diversity\n            new_solutions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n            new_solutions = self.filter_solutions(new_solutions, func)\n            self.harmony_memory.append(new_solutions.copy())\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Preservation\" algorithm for black box optimization.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "9750724e-b91c-4110-a1ed-d79fe398f49b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n\n# Refine the strategy\nclass RefinedSwarmHarmonySearch(SwarmHarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.local_search_probability = 0.2\n        self.local_search_radius = 1.0\n\n    def __call__(self, func):\n        super().__call__(func)\n        for _ in range(int(self.budget * self.local_search_probability)):\n            best_solution = self.harmony_memory[np.argmin([func(solution) for solution in self.harmony_memory])]\n            new_solution = best_solution + np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n            if func(new_solution) < func(best_solution):\n                self.harmony_memory[np.argmin([func(solution) for solution in self.harmony_memory])] = new_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = RefinedSwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "fc326d74-c466-48ba-9577-02c4ec45ccaa", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self HybridSelectionThreshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if fitness[best_idx] < self HybridSelectionThreshold * np.min(fitness):\n            return solutions[best_idx]\n        else:\n            return solutions[np.argmin(fitness)]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Hybrid Selection\" algorithm for black box optimization", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 14, 14, '        self HybridSelectionThreshold = 0.5\\n', 14, 38)).", "error": "SyntaxError('invalid syntax', ('<string>', 14, 14, '        self HybridSelectionThreshold = 0.5\\n', 14, 38))", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "099871ef-19ec-47c0-9c3e-bdbd793a7934", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n            self.population_history.append(self.best_solution)\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population_history.append(solutions)\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            if solution[index] < -5.0:\n                solution[index] = -5.0\n            elif solution[index] > 5.0:\n                solution[index] = 5.0\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        if len(self.population_history) > 10:\n            self.population_history.pop(0)\n        self.population_history.append(solutions)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "0ad6438e-0258-413e-b73e-3b0737a4817f", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        # Add adaptive crossover\n        if random.random() < 0.1:\n            index1, index2 = random.sample(range(self.dim), 2)\n            child[index1] = parent2[index1]\n            child[index2] = parent2[index2]\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            # Add mutation probability adjustment\n            if random.random() < 0.05:\n                solution = self.mutate(solution)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "f39c2930-1aa1-4a24-a934-d66b05414cba", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.fitness_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        # Use the 5% best solutions to update the harmony memory\n        best_idx = np.argsort(fitness)[:int(0.05 * self.population_size)]\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.fitness_history.append(fitness[best_idx])\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Improved Filtering\"", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "5871381a-c902-4524-84c7-b77c5a731d38", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.harmony_dimensions = [np.random.uniform(self.dim, 2*self.dim) for _ in range(self.population_size)]\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization using a population of harmonies with different dimensions.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e9a8c55f-342a-4978-a469-cca75a759ac7", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = np.random.uniform(0.2, 0.8)\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0) * np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "4e575bc4-9da1-4a79-906c-aa0f91a14da9", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = np.random.uniform(0.1, 0.9)  # adaptive wavelength\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = solutions  # update population\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "5cad8e48-5d29-4643-8bd1-1ab257ee7644", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population initialization.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "d7c11b7f-3a47-4e82-b357-a381f43c160d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n            self.population = self.filter_solutions(self.population, func)\n            self.harmony_memory.append(self.population.copy())\n            self.update_best_solution(self.population)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population management.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "92da2524-93ed-41a5-b474-6df843e6d1fb", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population_history.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.population_history = solutions.copy()\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "adedf880-0794-4e10-89d2-3ebffec8ce1d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n        self.diversity_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n            self.update_diversity(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def update_diversity(self, solutions):\n        diversity = np.mean([np.linalg.norm(solution - self.best_solution) for solution in solutions])\n        self.diversity_history.append(diversity)\n        if len(self.diversity_history) > 10:\n            self.diversity_history.pop(0)\n        if diversity > self.diversity_threshold:\n            self.harmony_memory = [self.harmony_memory[-1]]\n            for _ in range(len(solutions)):\n                self.harmony_memory.append(np.random.uniform(-5.0, 5.0, self.dim))\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Maintenance\" algorithm for black box optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "7672a582-9916-4088-abeb-ace33ae94f67", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Refine the strategy\nclass SwarmHarmonySearchRefined(SwarmHarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.adaptive_crossover_probability = 0.8\n        self.adaptive_mutation_probability = 0.2\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.adaptive_crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearchRefined(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "170b8e51-f07e-4bfb-94b5-1ffb7452b276", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = solutions\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "a9c19775-e70a-4af5-98c4-04010fddaa20", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-0.5, 0.5)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "78262af0-574c-4992-a35d-dbdf70fa7f24", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.harmony_memory = self.harmony_memory[-100:]  # Truncate harmony memory\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Harmony Memory Truncation\" algorithm for black box optimization", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "191acae8-753e-47b7-85a1-69c2b8a05c6c", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.hybridization_rate = 0.1  # New parameter to control hybridization\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n            # Hybridization: 10% of the time, select a random solution from the harmony memory\n            if random.random() < self.hybridization_rate:\n                index = random.randint(0, self.population_size - 1)\n                solutions[index] = self.harmony_memory[index].copy()\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Hybridization\" algorithm for black box optimization.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "5c3e1601-f794-455b-9b2f-5c401eda952d", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        if random.random() < 0.05: # 5% chance of applying a more aggressive mutation\n            solution[index] += np.random.uniform(-2.0, 2.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Enhanced Mutation", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "0a08e853-982a-4fe1-a050-1167b6e51bad", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.gaussian_std_dev = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    # Use Gaussian mutation to introduce more randomness\n                    solution = self.mutate(np.random.uniform(-5.0, 5.0, self.dim))\n                    solutions.append(solution)\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.normal(0, self.gaussian_std_dev)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Gaussian Mutation\" algorithm for black box optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "54cdf896-b9ce-4273-a5fa-e1ed8b03f095", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0) * 0.5\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "63d60f3c-afea-45d3-a2d1-b45c1ea68974", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n            self.update_diversity(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def update_diversity(self, solutions):\n        diversity = np.mean([np.sum(solutions!= solutions[best_idx]) for best_idx in range(solutions.shape[0])])\n        if diversity < self.diversity_threshold:\n            self.harmony_memory.pop(0)\n            self.harmony_memory.append(solutions.copy())\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Control\"", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "ce33f06c-8f34-4158-9a4e-655cb7b156ba", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def maintain_diversity(self):\n        if len(self.harmony_memory) > 10:\n            average_solution = np.mean(self.harmony_memory, axis=0)\n            self.harmony_memory = [solution for solution in self.harmony_memory if np.linalg.norm(solution - average_solution) > self.diversity_threshold]\n            self.harmony_memory.append(average_solution)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Enhancement\"", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "2f3c89d7-e38e-4cea-8812-9f41c184e59b", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.concatenate((self.population, solutions), axis=0)\n            self.population = self.population[:self.population_size]\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Better Handling of Population Sampling", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "f69bb4e1-138d-4c19-a5f3-5af1cf9b3bb8", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def adaptive_crossover(self, parent1, parent2):\n        if random.random() < 0.5:\n            return self.crossover(parent1, parent2)\n        else:\n            child = parent1.copy()\n            for i in range(self.dim):\n                if random.random() < 0.5:\n                    child[i] = parent2[i]\n            return child\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "517588dc-2f93-4120-af0b-a1420ec869a2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.mutation_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            mutation = np.random.uniform(-1.0, 1.0)\n            if mutation < 0:\n                mutation = abs(mutation)\n            solution[index] += mutation\n            self.mutation_history.append((index, mutation))\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def evaluate_mutation(self):\n        if len(self.mutation_history) > 10:\n            self.mutation_probability = np.mean([x[1] for x in self.mutation_history])\n            self.mutation_history = []\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e9cd6945-7f4a-4ed6-a5a4-fdc1e7a68272", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_size = int(self.population_size * 0.2)\n        self.memory = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        self.memory.append((self.best_solution, fitness[best_idx]))\n        if len(self.memory) > self.memory_size:\n            self.memory.pop(0)\n        self.update_best_from_memory()\n\n    def update_best_from_memory(self):\n        best_from_memory = min(self.memory, key=lambda x: x[1])\n        if best_from_memory[1] < func(self.best_solution):\n            self.best_solution = best_from_memory[0]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "1d970d74-e7ad-43bc-b66c-75d23a360649", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.adaptive_crossover_rate = 0.8  # New adaptive crossover rate\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2, self.adaptive_crossover_rate)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2, adaptive_crossover_rate):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        if random.random() < adaptive_crossover_rate:\n            child = self.mutate(child)\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "849b94d6-6844-4411-a67f-1f304be0a4f8", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "fe0a2e01-f7e6-4b22-bd48-5adbe05abfc3", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.population = [np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)]\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = solutions\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "0adf4030-9a44-4cae-8ea3-5681bb23a008", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "1722cbc6-a76b-4841-b550-6b5f81aa7999", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9 + 0.1 * np.random.uniform(0, 1, size=self.population_size)  # Adaptive crossover probability\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive crossover probability", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "22b47660-84d9-428c-81cc-f7461223f82b", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_weight = 0.2\n        self.memory_decay_rate = 0.9\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n        else:\n            self.harmony_memory[-1] = self.memory_decay_rate * self.harmony_memory[-1] + (1 - self.memory_decay_rate) * self.best_solution\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization using a novel adaptive harmony memory update strategy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "23ca8d55-9a40-4854-8bfe-a31328599ac7", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.population, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.vstack((self.population, solutions))\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population handling.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "107021a5-23a5-471d-a44f-44ae7318bd1c", "solution": "import numpy as np\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.num_threads = 4  # parallel processing\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        with ThreadPoolExecutor(max_workers=self.num_threads) as executor:\n            futures = []\n            for _ in range(self.budget):\n                solutions = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(self.harmony_memory, 2)\n                        child = self.crossover(parent1, parent2)\n                        solutions.append(child)\n                    else:\n                        solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n                \n                futures.append(executor.submit(self.filter_solutions, solutions, func))\n                self.harmony_memory.append(solutions.copy())\n            \n            for future in futures:\n                solutions = future.result()\n                self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Parallel Processing\" algorithm for black box optimization.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "85ecff33-3cef-41fe-b653-86e61382b8c1", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.population = solutions.copy()\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "068429fe-6ce9-4824-8043-e703618a74fe", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            # Apply a more aggressive mutation to increase diversity\n            if random.random() < 0.2:\n                solution[index] += np.random.uniform(-2.0, 2.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "50d0f575-91f3-46c5-8fa1-60f2071875eb", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population_history = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n            self.population_history.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population_history.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.population_history.append(self.best_solution.copy())\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "0559faa8-c5e9-4a5f-a411-406cc90fd73f", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            # Add a check to ensure the mutated value is within the bounds\n            solution[index] = max(-5.0, min(solution[index], 5.0))\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "a1c8f349-765d-4217-b64a-1f6e2a416e40", "solution": "import numpy as np\nfrom multiprocessing import Pool\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.processes = []\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        with Pool(processes=self.population_size) as pool:\n            for _ in range(self.budget):\n                solutions = []\n                for _ in range(self.population_size):\n                    if random.random() < self.crossover_probability:\n                        parent1, parent2 = random.sample(self.harmony_memory, 2)\n                        child = self.crossover(parent1, parent2)\n                        solutions.append(child)\n                    else:\n                        solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n                \n                solutions = np.array(solutions)\n                solutions = self.filter_solutions(solutions, func)\n                self.harmony_memory.append(solutions.copy())\n                self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Parallel Processing\" algorithm for black box optimization", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "5eac08e8-936a-41b7-8423-84288bf131fd", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.random_neighborhood = 0.2\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim), self.random_neighborhood))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution, random_neighborhood):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0 + random_neighborhood, 1.0 - random_neighborhood)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Randomized Neighborhood\" algorithm for black box optimization", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "2f705dfa-2c4a-447c-a3d3-3784ba7831ac", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9 + 0.1 * np.random.uniform(0, 1, self.population_size) # Adaptive crossover probability\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization using adaptive crossover probability.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "da50a7f4-0125-4b7e-ba1b-26fa70269ad2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        if random.random() < 0.2:  # 20% hybridization\n            child = (child + self.harmony_memory[np.random.randint(0, len(self.harmony_memory))]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Hybridization\" algorithm for black box optimization", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "f2250e99-1b82-45fa-8665-c3aa7e26e34a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = np.linspace(0.1, 0.9, self.population_size)\n        self.crossover_probability = np.linspace(0.8, 0.99, self.population_size)\n        self.mutation_probability = np.linspace(0.05, 0.15, self.population_size)\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for i in range(self.budget):\n            solutions = []\n            for j in range(self.population_size):\n                if random.random() < self.crossover_probability[j]:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength[i]:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "17447d4d-d05e-4913-8984-5faa773e1798", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "73795c1b-fd9e-46df-844e-14a0ea7a76bd", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n\n# Refine the strategy by adding a population size adjustment mechanism.\nclass SwarmHarmonySearchRefined(SwarmHarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.population_size_adjustment = 0.1\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n            \n            # Adjust population size based on convergence\n            if self.budget / self.population_size < self.population_size_adjustment:\n                self.population_size = int(self.population_size * (1 + self.population_size_adjustment))\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm_refined = SwarmHarmonySearchRefined(budget=100, dim=10)\nswarm_refined('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved handling of population size.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "d06f2e4e-a2a8-42f6-8246-f5c75a37c8bc", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_size = 10  # added memory_size attribute\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.harmony_memory = self.harmony_memory[-self.memory_size:]  # remove oldest solutions\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "75ff4a18-8787-40e5-b5a7-c651566adceb", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solutions = []\n        self.fitness_values = []\n        self.best_solution_index = 0\n\n    def __call__(self, func):\n        if self.best_solution_index == 0:\n            self.best_solutions = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.fitness_values = [func(solution) for solution in self.best_solutions]\n            self.harmony_memory.append(self.best_solutions.copy())\n            self.best_solution_index += 1\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.fitness_values.append([func(solution) for solution in solutions])\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = [func(solution) for solution in solutions]\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = [func(solution) for solution in solutions]\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < np.min(self.fitness_values[self.best_solution_index - 1])):\n            self.best_solutions[self.best_solution_index - 1] = solutions[best_idx]\n            self.fitness_values[self.best_solution_index - 1] = fitness\n            self.best_solution_index += 1\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Multi-Objective Optimization\"", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'str' object is not callable\").", "error": "TypeError(\"'str' object is not callable\")", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e8dd0cf5-4874-4e50-b09f-37e76b36a198", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.adaptive_wavelength = 0.7\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength + self.adaptive_wavelength * random.random():\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Enhanced Mutation.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "ef54359d-d963-4b91-ab21-b1b42c7e6e80", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n        self.diversity_count = 0\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n            self.enhance_diversity(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def enhance_diversity(self, solutions):\n        if self.diversity_count > 0 and self.diversity_threshold < np.mean(np.linalg.norm(solutions - self.harmony_memory, axis=1)):\n            self.harmony_memory = solutions\n            self.diversity_count = 0\n        else:\n            self.diversity_count += 1\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Enhancement\" algorithm for black box optimization.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e89f8158-0b48-4c11-bd94-78eb0ceaf1dc", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.diversity_threshold = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n            # Preserve diversity\n            if len(self.harmony_memory) > 100:\n                self.harmony_memory.pop(0)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Diversity Preservation\" algorithm for black box optimization.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "05d40953-23ab-4ab4-ac72-30b3d7c228fb", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0) * (2 * np.random.uniform(0, 1) - 1)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "b0d6fb64-7a2b-4849-885d-c2509cbb4e5c", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength * (self.crossover_probability + random.random()):\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def adaptive_mutation(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def adaptive_filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def adaptive_update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover for BBOB optimization", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "0884c19c-ff04-4c84-bd2a-31042801cb09", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "e05c8a00-978b-46e3-a70b-93088a432e9a", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = self.population[0]\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(self.population[_]))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.array(solutions)\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nimproved_swarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nimproved_swarm('func')", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "9a25b173-49e5-4da2-89f4-8f760764a57a", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n            # Ensure solution is within bounds\n            solution = np.clip(solution, -5.0, 5.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "2b09da84-46f6-4241-98fe-148643df690f", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.memory_threshold = 10\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if len(self.harmony_memory) > self.memory_threshold:\n            self.harmony_memory = self.harmony_memory[-self.memory_threshold:]\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover and Memory-Based Selection\"", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "4b4955ac-0979-478e-abba-aad738fdc312", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.array(solutions)\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "6752a9f4-f092-40c0-82a7-3d52e7a6ba5a", "solution": "import numpy as np\nimport random\n\nclass ImprovedSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.dynamic_population_size = self.population_size\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.dynamic_population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = ImprovedSwarmHarmonySearch(budget=100, dim=10)\nswarm('func')\n", "name": "ImprovedSwarmHarmonySearch", "description": "Improved Swarm Harmony Search with Adaptive Crossover and Dynamic Population Size", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "14325e01-5c5e-4f72-b3d2-a2655db7b095", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.population = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = self.population[0]\n            self.harmony_memory.append(self.population.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.population, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.population = np.vstack((self.population, solutions))\n            self.population = self.population[:self.population_size]\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with improved population handling", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "9dac3166-47f0-47b1-8ec3-1412d4247d07", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.mutation_range = 0.5\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            mutation = np.random.uniform(-self.mutation_range, self.mutation_range)\n            solution[index] += mutation\n            solution[index] = max(-5.0, min(5.0, solution[index]))\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "8bd8e358-9843-47f2-8d09-5367bfb0df92", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-0.5, 0.5)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
{"id": "8eab6693-b361-45a6-9efe-5f1c41f072d2", "solution": "import numpy as np\nimport random\n\nclass SwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.wavelength = 0.5\n        self.crossover_probability = 0.9\n        self.mutation_probability = 0.1\n        self.harmony_memory = []\n        self.best_solution = None\n        self.crossover_probability_decay = 0.01\n\n    def __call__(self, func):\n        if self.best_solution is None:\n            self.best_solution = np.array([np.random.uniform(-5.0, 5.0, self.dim) for _ in range(self.population_size)])\n            self.harmony_memory.append(self.best_solution.copy())\n        \n        for _ in range(self.budget):\n            solutions = []\n            for _ in range(self.population_size):\n                if random.random() < self.crossover_probability:\n                    parent1, parent2 = random.sample(self.harmony_memory, 2)\n                    child = self.crossover(parent1, parent2)\n                    solutions.append(child)\n                else:\n                    solutions.append(self.mutate(np.random.uniform(-5.0, 5.0, self.dim)))\n            \n            solutions = np.array(solutions)\n            solutions = self.filter_solutions(solutions, func)\n            self.harmony_memory.append(solutions.copy())\n            self.update_best_solution(solutions)\n\n    def crossover(self, parent1, parent2):\n        child = parent1.copy()\n        for i in range(self.dim):\n            if random.random() < self.wavelength:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutate(self, solution):\n        if random.random() < self.mutation_probability:\n            index = random.randint(0, self.dim - 1)\n            solution[index] += np.random.uniform(-1.0, 1.0)\n        return solution\n\n    def filter_solutions(self, solutions, func):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        return solutions[best_idx]\n\n    def update_best_solution(self, solutions):\n        fitness = func(solutions)\n        best_idx = np.argmin(fitness)\n        if np.all(fitness[best_idx] < func(self.best_solution)):\n            self.best_solution = solutions[best_idx]\n            self.crossover_probability *= (1 - self.crossover_probability_decay)\n\n# Example usage\ndef func(x):\n    return np.sum(x**2)\n\nswarm = SwarmHarmonySearch(budget=100, dim=10)\nswarm('func')", "name": "SwarmHarmonySearch", "description": "Novel \"Swarm Harmony Search with Adaptive Crossover\" algorithm for black box optimization", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Sample larger than population or is negative').", "error": "ValueError('Sample larger than population or is negative')", "parent_id": "e167e816-62b2-49d6-bb61-e3a00e17e68f", "metadata": {}, "mutation_prompt": null}
