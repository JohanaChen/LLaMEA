{"id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        \n    def mutate(self, idx):\n        idxs = [idx]\n        while len(idxs) < 3:\n            idxs.extend(list(np.random.choice(np.delete(np.arange(self.pop_size), idxs), 3 - len(idxs), replace=False)))\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Adaptive parameter adjustment\n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution algorithm that dynamically adjusts parameters for exploration and exploitation within a defined budget.", "configspace": "", "generation": 0, "fitness": 0.1759731863317295, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3867332500635432, 0.37059919742809966, 0.3857821092909711, 0.3866830490491032, 0.37040117929791816, 0.39156024904179665, 0.3716625722962663, 0.37844883533966744, 0.3629685125775506, 0.09381457459166964, 0.09436427633643307, 0.11568937921577593, 0.1036261674299741, 0.10223238449634542, 0.10398897968707532, 0.10077124379040192, 0.09799371433623949, 0.10225220223318321, 0.08095113007513832, 0.0895464563524605, 0.0756984445995087, 0.08016122330626185, 0.08104942400488868, 0.09675150083834483, 0.08730467966524524, 0.07762696113521617, 0.07843541587470604, 0.06973069189403691, 0.08587824244364439, 0.06803119378239719, 0.06592560948093362, 0.06527627845954287, 0.06819439299957053, 0.06745069940950943, 0.06897734043376091, 0.07224058054518867, 0.9268707033789667, 0.9249373075795037, 0.8911018544230854, 0.9160971487348002, 0.9171748457543794, 0.8481090289221689, 0.9278217459544568, 0.9158162458452603, 0.9451465110077405, 0.16111025214129482, 0.16211149752961285, 0.16048589937924285, 0.16733132590055788, 0.18241695916739653, 0.15735290261893276, 0.15983158501726646, 0.1552821994752165, 0.15171835899496056, 0.23094744143051915, 0.2185011629855329, 0.24004644998849745, 0.23419751779106224, 0.23793077297656595, 0.2312246854051394, 0.22616382645837463, 0.22753173118271774, 0.24053942814364881, 0.08861525198473952, 0.07880512015285968, 0.10356084186559333, 0.08996646119505514, 0.1041720791311469, 0.10080523466390134, 0.09167587495839413, 0.09005394483161067, 0.0894411739695532, 0.10437129790916277, 0.08931139762187867, 0.08268829394526234, 0.08428429337596066, 0.09704901803848676, 0.10174201389889403, 0.09798344282148042, 0.0800957999595272, 0.08927963629535662, 0.023766544575238413, 0.028781252071631958, 0.022052083133062617, 0.014207711132343093, 0.014223060610804139, 0.01523284941554115, 0.02411274719235368, 0.010195688190945629, 0.020300510710096198, 0.13528122694094813, 0.12384083286071867, 0.1467622283119977, 0.14883328845185384, 0.11807607567180767, 0.12037874032724671, 0.15201750671783232, 0.15246519964290361, 0.15449998840298462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013416188466275347, 0.08421909240042247, 0.06213187935797271, 0.06200421102863496, 0.0543925942660779, 0.07225295864187242, 0.08122183559188312, 0.07577669161242628, 0.06603507966832423, 0.06966237786968466, 0.3311901498009895, 0.32680103963908436, 0.3211767116640435, 0.3697250346805647, 0.328905451356841, 0.3312876050145407, 0.3367049534450648, 0.3399081960554974, 0.3409115918190644, 0.0689448679013307, 0.07965501362462113, 0.06603526956039207, 0.07342176092244568, 0.06906497953148993, 0.07752415405768953, 0.06854779994619842, 0.0662315178881181, 0.07468328792307644, 0.13667140017213986, 0.1459200062260777, 0.13909787935148565, 0.1372726725940121, 0.17468106405507366, 0.1396518620132583, 0.1379779544298685, 0.1289256853336994, 0.1385971196098117, 0.19261543986545626, 0.18925315878914684, 0.19522563432285933, 0.19614013522278373, 0.18720329103608957, 0.1961026683563245, 0.19555427720114538, 0.19790441843908957, 0.1873435590476873, 0.132136549474833, 0.1400059779060837, 0.13001871227609152, 0.14203175650066968, 0.13916559042073662, 0.13332654956430456, 0.15378609841291613, 0.14625584527195623, 0.1552424810048535, 0.20751186678947975, 0.17704181254097562, 0.15825727125693412, 0.17179104945862855, 0.16763312752298576, 0.1588574861262969, 0.18808911401563666, 0.17832032818116694, 0.18104223158217558, 0.1714701774648294, 0.1794415002440728, 0.18009864035482737, 0.16809174284672623, 0.1775551473228304, 0.16787554379606695, 0.17166690504170035, 0.1683078239422755, 0.16881372197600342, 0.2569048329063749, 0.19756644586929095, 0.22106558645369456, 0.16795705000689487, 0.21499538720018274, 0.2099326859386279, 0.16899965998391986, 0.15157405459718465, 0.15434293099929364, 0.2132052539249082, 0.17964040794921987, 0.20658320980329203, 0.15932889959171392, 0.13990109814510399, 0.2400601909800153, 0.1908042099389643, 0.21692313397984264, 0.19439524717866175, 0.18848310510584332, 0.17929140265418386, 0.17314992036205934, 0.17681545752511652, 0.19521687029237567, 0.17937696167976536, 0.19705171244298847, 0.1870038840132453, 0.2049532331408609, 0.0634145915730443, 0.06063634586442601, 0.07606148344833275, 0.05523356385282063, 0.05833065614761779, 0.06717097803597283, 0.05879797511212359, 0.06875226241479881, 0.06143377305728459]}, "mutation_prompt": null}
{"id": "4570a89d-6c1b-4bdc-aae0-b541b542125a", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        \n    def mutate(self, idx):\n        idxs = [idx]\n        while len(idxs) < 3:\n            idxs.extend(list(np.random.choice(np.delete(np.arange(self.pop_size), idxs), 3 - len(idxs), replace=False)))\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Adaptive parameter adjustment\n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution algorithm that dynamically adjusts parameters for exploration and exploitation within a defined budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "metadata": {"aucs": [0.3867332500635432, 0.37059919742809966, 0.3857821092909711, 0.3866830490491032, 0.37040117929791816, 0.39156024904179665, 0.3716625722962663, 0.37844883533966744, 0.3629685125775506, 0.09381457459166964, 0.09436427633643307, 0.11568937921577593, 0.1036261674299741, 0.10223238449634542, 0.10398897968707532, 0.10077124379040192, 0.09799371433623949, 0.10225220223318321, 0.08095113007513832, 0.0895464563524605, 0.0756984445995087, 0.08016122330626185, 0.08104942400488868, 0.09675150083834483, 0.08730467966524524, 0.07762696113521617, 0.07843541587470604, 0.06973069189403691, 0.08587824244364439, 0.06803119378239719, 0.06592560948093362, 0.06527627845954287, 0.06819439299957053, 0.06745069940950943, 0.06897734043376091, 0.07224058054518867, 0.9268707033789667, 0.9249373075795037, 0.8911018544230854, 0.9160971487348002, 0.9171748457543794, 0.8481090289221689, 0.9278217459544568, 0.9158162458452603, 0.9451465110077405, 0.16111025214129482, 0.16211149752961285, 0.16048589937924285, 0.16733132590055788, 0.18241695916739653, 0.15735290261893276, 0.15983158501726646, 0.1552821994752165, 0.15171835899496056, 0.23094744143051915, 0.2185011629855329, 0.24004644998849745, 0.23419751779106224, 0.23793077297656595, 0.2312246854051394, 0.22616382645837463, 0.22753173118271774, 0.24053942814364881, 0.08861525198473952, 0.07880512015285968, 0.10356084186559333, 0.08996646119505514, 0.1041720791311469, 0.10080523466390134, 0.09167587495839413, 0.09005394483161067, 0.0894411739695532, 0.10437129790916277, 0.08931139762187867, 0.08268829394526234, 0.08428429337596066, 0.09704901803848676, 0.10174201389889403, 0.09798344282148042, 0.0800957999595272, 0.08927963629535662, 0.023766544575238413, 0.028781252071631958, 0.022052083133062617, 0.014207711132343093, 0.014223060610804139, 0.01523284941554115, 0.02411274719235368, 0.010195688190945629, 0.020300510710096198, 0.13528122694094813, 0.12384083286071867, 0.1467622283119977, 0.14883328845185384, 0.11807607567180767, 0.12037874032724671, 0.15201750671783232, 0.15246519964290361, 0.15449998840298462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013416188466275347, 0.08421909240042247, 0.06213187935797271, 0.06200421102863496, 0.0543925942660779, 0.07225295864187242, 0.08122183559188312, 0.07577669161242628, 0.06603507966832423, 0.06966237786968466, 0.3311901498009895, 0.32680103963908436, 0.3211767116640435, 0.3697250346805647, 0.328905451356841, 0.3312876050145407, 0.3367049534450648, 0.3399081960554974, 0.3409115918190644, 0.0689448679013307, 0.07965501362462113, 0.06603526956039207, 0.07342176092244568, 0.06906497953148993, 0.07752415405768953, 0.06854779994619842, 0.0662315178881181, 0.07468328792307644, 0.13667140017213986, 0.1459200062260777, 0.13909787935148565, 0.1372726725940121, 0.17468106405507366, 0.1396518620132583, 0.1379779544298685, 0.1289256853336994, 0.1385971196098117, 0.19261543986545626, 0.18925315878914684, 0.19522563432285933, 0.19614013522278373, 0.18720329103608957, 0.1961026683563245, 0.19555427720114538, 0.19790441843908957, 0.1873435590476873, 0.132136549474833, 0.1400059779060837, 0.13001871227609152, 0.14203175650066968, 0.13916559042073662, 0.13332654956430456, 0.15378609841291613, 0.14625584527195623, 0.1552424810048535, 0.20751186678947975, 0.17704181254097562, 0.15825727125693412, 0.17179104945862855, 0.16763312752298576, 0.1588574861262969, 0.18808911401563666, 0.17832032818116694, 0.18104223158217558, 0.1714701774648294, 0.1794415002440728, 0.18009864035482737, 0.16809174284672623, 0.1775551473228304, 0.16787554379606695, 0.17166690504170035, 0.1683078239422755, 0.16881372197600342, 0.2569048329063749, 0.19756644586929095, 0.22106558645369456, 0.16795705000689487, 0.21499538720018274, 0.2099326859386279, 0.16899965998391986, 0.15157405459718465, 0.15434293099929364, 0.2132052539249082, 0.17964040794921987, 0.20658320980329203, 0.15932889959171392, 0.13990109814510399, 0.2400601909800153, 0.1908042099389643, 0.21692313397984264, 0.19439524717866175, 0.18848310510584332, 0.17929140265418386, 0.17314992036205934, 0.17681545752511652, 0.19521687029237567, 0.17937696167976536, 0.19705171244298847, 0.1870038840132453, 0.2049532331408609, 0.0634145915730443, 0.06063634586442601, 0.07606148344833275, 0.05523356385282063, 0.05833065614761779, 0.06717097803597283, 0.05879797511212359, 0.06875226241479881, 0.06143377305728459]}, "mutation_prompt": null}
{"id": "eb95c663-d3a3-49fe-b321-5c7fdf5d9e80", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        \n    def mutate(self, idx):\n        idxs = [idx]\n        while len(idxs) < 3:\n            idxs.extend(list(np.random.choice(np.delete(np.arange(self.pop_size), idxs), 3 - len(idxs), replace=False)))\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Adaptive parameter adjustment\n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution algorithm that dynamically adjusts parameters for exploration and exploitation within a defined budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "metadata": {"aucs": [0.3867332500635432, 0.37059919742809966, 0.3857821092909711, 0.3866830490491032, 0.37040117929791816, 0.39156024904179665, 0.3716625722962663, 0.37844883533966744, 0.3629685125775506, 0.09381457459166964, 0.09436427633643307, 0.11568937921577593, 0.1036261674299741, 0.10223238449634542, 0.10398897968707532, 0.10077124379040192, 0.09799371433623949, 0.10225220223318321, 0.08095113007513832, 0.0895464563524605, 0.0756984445995087, 0.08016122330626185, 0.08104942400488868, 0.09675150083834483, 0.08730467966524524, 0.07762696113521617, 0.07843541587470604, 0.06973069189403691, 0.08587824244364439, 0.06803119378239719, 0.06592560948093362, 0.06527627845954287, 0.06819439299957053, 0.06745069940950943, 0.06897734043376091, 0.07224058054518867, 0.9268707033789667, 0.9249373075795037, 0.8911018544230854, 0.9160971487348002, 0.9171748457543794, 0.8481090289221689, 0.9278217459544568, 0.9158162458452603, 0.9451465110077405, 0.16111025214129482, 0.16211149752961285, 0.16048589937924285, 0.16733132590055788, 0.18241695916739653, 0.15735290261893276, 0.15983158501726646, 0.1552821994752165, 0.15171835899496056, 0.23094744143051915, 0.2185011629855329, 0.24004644998849745, 0.23419751779106224, 0.23793077297656595, 0.2312246854051394, 0.22616382645837463, 0.22753173118271774, 0.24053942814364881, 0.08861525198473952, 0.07880512015285968, 0.10356084186559333, 0.08996646119505514, 0.1041720791311469, 0.10080523466390134, 0.09167587495839413, 0.09005394483161067, 0.0894411739695532, 0.10437129790916277, 0.08931139762187867, 0.08268829394526234, 0.08428429337596066, 0.09704901803848676, 0.10174201389889403, 0.09798344282148042, 0.0800957999595272, 0.08927963629535662, 0.023766544575238413, 0.028781252071631958, 0.022052083133062617, 0.014207711132343093, 0.014223060610804139, 0.01523284941554115, 0.02411274719235368, 0.010195688190945629, 0.020300510710096198, 0.13528122694094813, 0.12384083286071867, 0.1467622283119977, 0.14883328845185384, 0.11807607567180767, 0.12037874032724671, 0.15201750671783232, 0.15246519964290361, 0.15449998840298462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013416188466275347, 0.08421909240042247, 0.06213187935797271, 0.06200421102863496, 0.0543925942660779, 0.07225295864187242, 0.08122183559188312, 0.07577669161242628, 0.06603507966832423, 0.06966237786968466, 0.3311901498009895, 0.32680103963908436, 0.3211767116640435, 0.3697250346805647, 0.328905451356841, 0.3312876050145407, 0.3367049534450648, 0.3399081960554974, 0.3409115918190644, 0.0689448679013307, 0.07965501362462113, 0.06603526956039207, 0.07342176092244568, 0.06906497953148993, 0.07752415405768953, 0.06854779994619842, 0.0662315178881181, 0.07468328792307644, 0.13667140017213986, 0.1459200062260777, 0.13909787935148565, 0.1372726725940121, 0.17468106405507366, 0.1396518620132583, 0.1379779544298685, 0.1289256853336994, 0.1385971196098117, 0.19261543986545626, 0.18925315878914684, 0.19522563432285933, 0.19614013522278373, 0.18720329103608957, 0.1961026683563245, 0.19555427720114538, 0.19790441843908957, 0.1873435590476873, 0.132136549474833, 0.1400059779060837, 0.13001871227609152, 0.14203175650066968, 0.13916559042073662, 0.13332654956430456, 0.15378609841291613, 0.14625584527195623, 0.1552424810048535, 0.20751186678947975, 0.17704181254097562, 0.15825727125693412, 0.17179104945862855, 0.16763312752298576, 0.1588574861262969, 0.18808911401563666, 0.17832032818116694, 0.18104223158217558, 0.1714701774648294, 0.1794415002440728, 0.18009864035482737, 0.16809174284672623, 0.1775551473228304, 0.16787554379606695, 0.17166690504170035, 0.1683078239422755, 0.16881372197600342, 0.2569048329063749, 0.19756644586929095, 0.22106558645369456, 0.16795705000689487, 0.21499538720018274, 0.2099326859386279, 0.16899965998391986, 0.15157405459718465, 0.15434293099929364, 0.2132052539249082, 0.17964040794921987, 0.20658320980329203, 0.15932889959171392, 0.13990109814510399, 0.2400601909800153, 0.1908042099389643, 0.21692313397984264, 0.19439524717866175, 0.18848310510584332, 0.17929140265418386, 0.17314992036205934, 0.17681545752511652, 0.19521687029237567, 0.17937696167976536, 0.19705171244298847, 0.1870038840132453, 0.2049532331408609, 0.0634145915730443, 0.06063634586442601, 0.07606148344833275, 0.05523356385282063, 0.05833065614761779, 0.06717097803597283, 0.05879797511212359, 0.06875226241479881, 0.06143377305728459]}, "mutation_prompt": null}
{"id": "f24d71f7-e2c4-463a-b63e-23b63ea56fbd", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        \n    def mutate(self, idx):\n        idxs = [idx]\n        while len(idxs) < 3:\n            idxs.extend(list(np.random.choice(np.delete(np.arange(self.pop_size), idxs), 3 - len(idxs), replace=False)))\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Adaptive parameter adjustment\n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution algorithm that dynamically adjusts parameters for exploration and exploitation within a defined budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "metadata": {"aucs": [0.3867332500635432, 0.37059919742809966, 0.3857821092909711, 0.3866830490491032, 0.37040117929791816, 0.39156024904179665, 0.3716625722962663, 0.37844883533966744, 0.3629685125775506, 0.09381457459166964, 0.09436427633643307, 0.11568937921577593, 0.1036261674299741, 0.10223238449634542, 0.10398897968707532, 0.10077124379040192, 0.09799371433623949, 0.10225220223318321, 0.08095113007513832, 0.0895464563524605, 0.0756984445995087, 0.08016122330626185, 0.08104942400488868, 0.09675150083834483, 0.08730467966524524, 0.07762696113521617, 0.07843541587470604, 0.06973069189403691, 0.08587824244364439, 0.06803119378239719, 0.06592560948093362, 0.06527627845954287, 0.06819439299957053, 0.06745069940950943, 0.06897734043376091, 0.07224058054518867, 0.9268707033789667, 0.9249373075795037, 0.8911018544230854, 0.9160971487348002, 0.9171748457543794, 0.8481090289221689, 0.9278217459544568, 0.9158162458452603, 0.9451465110077405, 0.16111025214129482, 0.16211149752961285, 0.16048589937924285, 0.16733132590055788, 0.18241695916739653, 0.15735290261893276, 0.15983158501726646, 0.1552821994752165, 0.15171835899496056, 0.23094744143051915, 0.2185011629855329, 0.24004644998849745, 0.23419751779106224, 0.23793077297656595, 0.2312246854051394, 0.22616382645837463, 0.22753173118271774, 0.24053942814364881, 0.08861525198473952, 0.07880512015285968, 0.10356084186559333, 0.08996646119505514, 0.1041720791311469, 0.10080523466390134, 0.09167587495839413, 0.09005394483161067, 0.0894411739695532, 0.10437129790916277, 0.08931139762187867, 0.08268829394526234, 0.08428429337596066, 0.09704901803848676, 0.10174201389889403, 0.09798344282148042, 0.0800957999595272, 0.08927963629535662, 0.023766544575238413, 0.028781252071631958, 0.022052083133062617, 0.014207711132343093, 0.014223060610804139, 0.01523284941554115, 0.02411274719235368, 0.010195688190945629, 0.020300510710096198, 0.13528122694094813, 0.12384083286071867, 0.1467622283119977, 0.14883328845185384, 0.11807607567180767, 0.12037874032724671, 0.15201750671783232, 0.15246519964290361, 0.15449998840298462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013416188466275347, 0.08421909240042247, 0.06213187935797271, 0.06200421102863496, 0.0543925942660779, 0.07225295864187242, 0.08122183559188312, 0.07577669161242628, 0.06603507966832423, 0.06966237786968466, 0.3311901498009895, 0.32680103963908436, 0.3211767116640435, 0.3697250346805647, 0.328905451356841, 0.3312876050145407, 0.3367049534450648, 0.3399081960554974, 0.3409115918190644, 0.0689448679013307, 0.07965501362462113, 0.06603526956039207, 0.07342176092244568, 0.06906497953148993, 0.07752415405768953, 0.06854779994619842, 0.0662315178881181, 0.07468328792307644, 0.13667140017213986, 0.1459200062260777, 0.13909787935148565, 0.1372726725940121, 0.17468106405507366, 0.1396518620132583, 0.1379779544298685, 0.1289256853336994, 0.1385971196098117, 0.19261543986545626, 0.18925315878914684, 0.19522563432285933, 0.19614013522278373, 0.18720329103608957, 0.1961026683563245, 0.19555427720114538, 0.19790441843908957, 0.1873435590476873, 0.132136549474833, 0.1400059779060837, 0.13001871227609152, 0.14203175650066968, 0.13916559042073662, 0.13332654956430456, 0.15378609841291613, 0.14625584527195623, 0.1552424810048535, 0.20751186678947975, 0.17704181254097562, 0.15825727125693412, 0.17179104945862855, 0.16763312752298576, 0.1588574861262969, 0.18808911401563666, 0.17832032818116694, 0.18104223158217558, 0.1714701774648294, 0.1794415002440728, 0.18009864035482737, 0.16809174284672623, 0.1775551473228304, 0.16787554379606695, 0.17166690504170035, 0.1683078239422755, 0.16881372197600342, 0.2569048329063749, 0.19756644586929095, 0.22106558645369456, 0.16795705000689487, 0.21499538720018274, 0.2099326859386279, 0.16899965998391986, 0.15157405459718465, 0.15434293099929364, 0.2132052539249082, 0.17964040794921987, 0.20658320980329203, 0.15932889959171392, 0.13990109814510399, 0.2400601909800153, 0.1908042099389643, 0.21692313397984264, 0.19439524717866175, 0.18848310510584332, 0.17929140265418386, 0.17314992036205934, 0.17681545752511652, 0.19521687029237567, 0.17937696167976536, 0.19705171244298847, 0.1870038840132453, 0.2049532331408609, 0.0634145915730443, 0.06063634586442601, 0.07606148344833275, 0.05523356385282063, 0.05833065614761779, 0.06717097803597283, 0.05879797511212359, 0.06875226241479881, 0.06143377305728459]}, "mutation_prompt": null}
{"id": "3d780007-d161-4b03-a0e1-2439f64fa1d7", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Mutation factor\n        self.CR = 0.9  # Crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        \n    def mutate(self, idx):\n        idxs = [idx]\n        while len(idxs) < 3:\n            idxs.extend(list(np.random.choice(np.delete(np.arange(self.pop_size), idxs), 3 - len(idxs), replace=False)))\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n                \n            # Adaptive parameter adjustment\n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution algorithm that dynamically adjusts parameters for exploration and exploitation within a defined budget.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "metadata": {"aucs": [0.3867332500635432, 0.37059919742809966, 0.3857821092909711, 0.3866830490491032, 0.37040117929791816, 0.39156024904179665, 0.3716625722962663, 0.37844883533966744, 0.3629685125775506, 0.09381457459166964, 0.09436427633643307, 0.11568937921577593, 0.1036261674299741, 0.10223238449634542, 0.10398897968707532, 0.10077124379040192, 0.09799371433623949, 0.10225220223318321, 0.08095113007513832, 0.0895464563524605, 0.0756984445995087, 0.08016122330626185, 0.08104942400488868, 0.09675150083834483, 0.08730467966524524, 0.07762696113521617, 0.07843541587470604, 0.06973069189403691, 0.08587824244364439, 0.06803119378239719, 0.06592560948093362, 0.06527627845954287, 0.06819439299957053, 0.06745069940950943, 0.06897734043376091, 0.07224058054518867, 0.9268707033789667, 0.9249373075795037, 0.8911018544230854, 0.9160971487348002, 0.9171748457543794, 0.8481090289221689, 0.9278217459544568, 0.9158162458452603, 0.9451465110077405, 0.16111025214129482, 0.16211149752961285, 0.16048589937924285, 0.16733132590055788, 0.18241695916739653, 0.15735290261893276, 0.15983158501726646, 0.1552821994752165, 0.15171835899496056, 0.23094744143051915, 0.2185011629855329, 0.24004644998849745, 0.23419751779106224, 0.23793077297656595, 0.2312246854051394, 0.22616382645837463, 0.22753173118271774, 0.24053942814364881, 0.08861525198473952, 0.07880512015285968, 0.10356084186559333, 0.08996646119505514, 0.1041720791311469, 0.10080523466390134, 0.09167587495839413, 0.09005394483161067, 0.0894411739695532, 0.10437129790916277, 0.08931139762187867, 0.08268829394526234, 0.08428429337596066, 0.09704901803848676, 0.10174201389889403, 0.09798344282148042, 0.0800957999595272, 0.08927963629535662, 0.023766544575238413, 0.028781252071631958, 0.022052083133062617, 0.014207711132343093, 0.014223060610804139, 0.01523284941554115, 0.02411274719235368, 0.010195688190945629, 0.020300510710096198, 0.13528122694094813, 0.12384083286071867, 0.1467622283119977, 0.14883328845185384, 0.11807607567180767, 0.12037874032724671, 0.15201750671783232, 0.15246519964290361, 0.15449998840298462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013416188466275347, 0.08421909240042247, 0.06213187935797271, 0.06200421102863496, 0.0543925942660779, 0.07225295864187242, 0.08122183559188312, 0.07577669161242628, 0.06603507966832423, 0.06966237786968466, 0.3311901498009895, 0.32680103963908436, 0.3211767116640435, 0.3697250346805647, 0.328905451356841, 0.3312876050145407, 0.3367049534450648, 0.3399081960554974, 0.3409115918190644, 0.0689448679013307, 0.07965501362462113, 0.06603526956039207, 0.07342176092244568, 0.06906497953148993, 0.07752415405768953, 0.06854779994619842, 0.0662315178881181, 0.07468328792307644, 0.13667140017213986, 0.1459200062260777, 0.13909787935148565, 0.1372726725940121, 0.17468106405507366, 0.1396518620132583, 0.1379779544298685, 0.1289256853336994, 0.1385971196098117, 0.19261543986545626, 0.18925315878914684, 0.19522563432285933, 0.19614013522278373, 0.18720329103608957, 0.1961026683563245, 0.19555427720114538, 0.19790441843908957, 0.1873435590476873, 0.132136549474833, 0.1400059779060837, 0.13001871227609152, 0.14203175650066968, 0.13916559042073662, 0.13332654956430456, 0.15378609841291613, 0.14625584527195623, 0.1552424810048535, 0.20751186678947975, 0.17704181254097562, 0.15825727125693412, 0.17179104945862855, 0.16763312752298576, 0.1588574861262969, 0.18808911401563666, 0.17832032818116694, 0.18104223158217558, 0.1714701774648294, 0.1794415002440728, 0.18009864035482737, 0.16809174284672623, 0.1775551473228304, 0.16787554379606695, 0.17166690504170035, 0.1683078239422755, 0.16881372197600342, 0.2569048329063749, 0.19756644586929095, 0.22106558645369456, 0.16795705000689487, 0.21499538720018274, 0.2099326859386279, 0.16899965998391986, 0.15157405459718465, 0.15434293099929364, 0.2132052539249082, 0.17964040794921987, 0.20658320980329203, 0.15932889959171392, 0.13990109814510399, 0.2400601909800153, 0.1908042099389643, 0.21692313397984264, 0.19439524717866175, 0.18848310510584332, 0.17929140265418386, 0.17314992036205934, 0.17681545752511652, 0.19521687029237567, 0.17937696167976536, 0.19705171244298847, 0.1870038840132453, 0.2049532331408609, 0.0634145915730443, 0.06063634586442601, 0.07606148344833275, 0.05523356385282063, 0.05833065614761779, 0.06717097803597283, 0.05879797511212359, 0.06875226241479881, 0.06143377305728459]}, "mutation_prompt": null}
{"id": "085623bf-ef68-4390-a7af-b0f67edd891f", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.stagnation_counter = 0\n        self.max_stagnation = 50\n        \n    def mutate(self, idx):\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), [idx]), 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def restart_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.array([np.inf] * self.pop_size)\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            improved = False\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                    improved = True\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if improved:\n                self.stagnation_counter = 0\n            else:\n                self.stagnation_counter += 1\n                \n            if self.stagnation_counter >= self.max_stagnation:\n                self.restart_population()\n                self.stagnation_counter = 0\n                self.fitness = np.array([func(ind) for ind in self.population])\n                evaluations += self.pop_size\n            \n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "An enhanced differential evolution algorithm with adaptive mutation and crossover rates, incorporating a restart mechanism to escape local optima.", "configspace": "", "generation": 5, "fitness": 0.2637473443126608, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "d9b48df0-a52d-49b0-b85c-d4b1cbdc1dcd", "metadata": {"aucs": [0.6403347386092207, 0.6253467478251254, 0.6347553183995955, 0.6522349834758849, 0.6883044974983701, 0.6554034956698405, 0.6582817221985722, 0.5986243662362232, 0.6310690624950699, 0.28430224835896467, 0.4004289906074574, 0.3877923352816318, 0.3594920974288254, 0.32024152985909116, 0.3792255718941214, 0.365123359073959, 0.3448555442110479, 0.3911194668737191, 0.113797077970755, 0.10329444622552042, 0.1178161706392451, 0.1119814370632155, 0.10695841442957021, 0.09764221916056193, 0.10813819650615664, 0.11238390469121917, 0.10760434992308188, 0.09789817979363014, 0.09508648592970126, 0.09900072780358316, 0.10177528859304075, 0.10319717872394107, 0.09602171567355855, 0.09731904573552586, 0.09398645669434391, 0.10644763036964267, 0.9188669791209483, 0.920238019214635, 0.9005044518818177, 0.9421915559261953, 0.8914062883769838, 0.9121292075889601, 0.9075768221426022, 0.9087808758174717, 0.9598061880317073, 0.2864486280199937, 0.28543762500544856, 0.25838272176280375, 0.2973624313932516, 0.2772819365448076, 0.2943079032664322, 0.28336034135238775, 0.28532920851788557, 0.30095423203661587, 0.36473402011107137, 0.5557832848189574, 0.5004794328403182, 0.5755822220743267, 0.6028032464568576, 0.6105774108721526, 0.4772478277299468, 0.5427063003878969, 0.5874678894309262, 0.168087925781213, 0.15678104151906047, 0.20033306797985284, 0.20609484562489522, 0.21456271330798637, 0.1939775758252762, 0.22678821876935185, 0.1926474443371603, 0.19493379008706568, 0.18400919407740635, 0.18938789340600415, 0.17639132877343, 0.2220931193700989, 0.1766244796408618, 0.21196453064678267, 0.18588358509930158, 0.19958002988620882, 0.17764569029179544, 0.10636930600747652, 0.11680138927340289, 0.08394969475667835, 0.11786685173893074, 0.10748735175926216, 0.08823678849434269, 0.1070926623532269, 0.11715727467425618, 0.12314259990993759, 0.22682888217457187, 0.26150787591182967, 0.28326613068578477, 0.2622403949199532, 0.2724563497657546, 0.2397506523709405, 0.28197097865494025, 0.3225188196474196, 0.27547627249010975, 0.013749547489172453, 0.01341492586815185, 0.014117260733001569, 0.0385700990871819, 0.01927005828027939, 0.02972404815470997, 0.053066859552168166, 0.02447693618752178, 0.01926958895423081, 0.15556266070479086, 0.1311356898386481, 0.14592448547636105, 0.16023760642149643, 0.16335086771835117, 0.17733529118921598, 0.14910478281840533, 0.1574777916356015, 0.17599417737533807, 0.4826577151228354, 0.48214542207064315, 0.488360960566238, 0.4583853127299372, 0.48023013704081163, 0.4814613285360607, 0.4664369350895341, 0.45871708509211817, 0.5067330721468841, 0.10172126107323021, 0.09998975722400649, 0.08871691656273706, 0.08695034111622224, 0.08108114694610191, 0.10791470314409546, 0.10970150420530267, 0.08615934711592521, 0.09382536721148793, 0.14480637917984418, 0.18533846656317854, 0.14615982428757157, 0.14686743087236775, 0.1360968432324502, 0.14902263830810825, 0.18247670585317433, 0.1543395868664984, 0.12977868853599106, 0.2678509533708825, 0.2750441765478999, 0.2824714196507604, 0.261180077668536, 0.2697028224292669, 0.27400763065800815, 0.282170067225329, 0.2969347261963621, 0.2916037187719057, 0.2016244699040617, 0.21424350977127438, 0.19712733643509228, 0.18603845333437663, 0.1849072923380468, 0.21130610991579146, 0.20505591522819766, 0.2595005588152298, 0.21563750578801077, 0.16595475230925438, 0.18068357755683295, 0.1965947790803526, 0.18843323931016354, 0.1895741129613111, 0.17331843569673677, 0.17345335939034945, 0.17918906944749902, 0.1875543951734755, 0.18619968942702558, 0.17808870897803752, 0.1806440398298258, 0.18658380357501292, 0.17917620489297514, 0.18307779323452045, 0.17813065205167822, 0.17931133915454356, 0.18380500749732032, 0.5298792524997057, 0.1912959922158598, 0.18559193485715952, 0.4817638217772523, 0.37314652175493723, 0.1775116924515805, 0.3124045569130379, 0.30431612416895815, 0.41334958963012214, 0.16018602239608792, 0.1942277007219927, 0.5622914230947818, 0.18874788039415702, 0.199075126911477, 0.1887129423440197, 0.1994584695918129, 0.5276128346925497, 0.21045421652170493, 0.17723331075127446, 0.1945341275752206, 0.1892954588543957, 0.1731607660234047, 0.1896529256423023, 0.1769322515061602, 0.19333053000575495, 0.18755899243436203, 0.18290555506600503, 0.0803510754654142, 0.07338322325706448, 0.07634730536054413, 0.06700214515857228, 0.06865817659562523, 0.07322030473424224, 0.07457009175757301, 0.08187170195760407, 0.07841626599909357]}, "mutation_prompt": null}
{"id": "e10b59ad-37f9-4457-8281-afb7b5e11377", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim\n        self.F = 0.6\n        self.CR = 0.7\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_rate = 0.1\n        self.neighbors = 5\n        self.stagnation_counter = 0\n        self.max_stagnation = 40\n\n    def mutate(self, idx):\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), [idx]), 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def restart_population(self):\n        elite_count = int(self.pop_size * self.elite_rate)\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        elite_population = self.population[elite_indices]\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.population[:elite_count] = elite_population\n        self.fitness = np.array([np.inf] * self.pop_size)\n    \n    def neighborhood_search(self, idx, func):\n        best_fit = self.fitness[idx]\n        best_pos = self.population[idx].copy()\n        for _ in range(self.neighbors):\n            neighbor = best_pos + np.random.normal(0, 0.1, self.dim)\n            neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n            fit = func(neighbor)\n            if fit < best_fit:\n                best_fit = fit\n                best_pos = neighbor\n        return best_fit, best_pos\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            improved = False\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                    improved = True\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n            \n            if improved:\n                self.stagnation_counter = 0\n            else:\n                self.stagnation_counter += 1\n                \n            if self.stagnation_counter >= self.max_stagnation:\n                self.restart_population()\n                self.stagnation_counter = 0\n                self.fitness = np.array([func(ind) for ind in self.population])\n                evaluations += self.pop_size\n            \n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.15 if success_rate > 0.15 else -0.1)), 0.3, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.15 if success_rate > 0.15 else -0.1)), 0.3, 0.9)\n        \n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            new_fit, new_pos = self.neighborhood_search(i, func)\n            if new_fit < self.fitness[i]:\n                self.population[i] = new_pos\n                self.fitness[i] = new_fit\n                evaluations += 1\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdvancedDifferentialEvolution", "description": "An advanced differential evolution with adaptive strategies and neighborhood search, incorporating diversity control and elitism for improved convergence.", "configspace": "", "generation": 6, "fitness": 0.1993828073379475, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "085623bf-ef68-4390-a7af-b0f67edd891f", "metadata": {"aucs": [0.46006993413509134, 0.46096093070736543, 0.4512244666011509, 0.47833878960489096, 0.46795457766184556, 0.4897032326413907, 0.45950090638554764, 0.4518316900154812, 0.45664253952231393, 0.18431665601939762, 0.19763720110387628, 0.20434230714433255, 0.1903880447505646, 0.1754733072631086, 0.20390012830946447, 0.18095914270864288, 0.20183452541344216, 0.18162653055226352, 0.10251006441970845, 0.09242035187090891, 0.09343707993190242, 0.11121350157055565, 0.08692130161664302, 0.08729367304026359, 0.09419753698761923, 0.0907637274088926, 0.10694530810744163, 0.0876147386265067, 0.07571713902855048, 0.08039036669800903, 0.08692589036527132, 0.07642928897641177, 0.07299203930636233, 0.07912184401321498, 0.08545126902208322, 0.08229817715545473, 0.9414656828320466, 0.9284191434224028, 0.9392890503059818, 0.9355646021533218, 0.9268094576405044, 0.9136633610635738, 0.9373206139091106, 0.9244721957103772, 0.918938312520106, 0.17459728794853413, 0.1897944477920882, 0.2055390297896872, 0.19472877849006154, 0.20472847251761783, 0.18587506551147126, 0.19423324802493058, 0.2092500661046579, 0.1959384833440222, 0.2606490748689635, 0.2381612025817298, 0.245990008835688, 0.3057593392348109, 0.2598521995827314, 0.25587833514863856, 0.27655097879501667, 0.2370775235114927, 0.27123632021187705, 0.13542606084650544, 0.12854834814040073, 0.12969011321165436, 0.11957627190433762, 0.12965102266777462, 0.10156433716924407, 0.12991558582828533, 0.1161183154774923, 0.12271144185631988, 0.1472771594064115, 0.11661399999914379, 0.11809374327948896, 0.1488823632521995, 0.13057657905959863, 0.1490295122546933, 0.12653597166869845, 0.11116694820606732, 0.1352810927137631, 0.01865190683923701, 0.03454440183375196, 0.021090487917253986, 0.02907691301113413, 0.03887301547939692, 0.030857532134485388, 0.03242874597402445, 0.025634715097454852, 0.03810272731965614, 0.14098185670022134, 0.15571285287058567, 0.1542625747839853, 0.15638087751599528, 0.12010667677533005, 0.11918926774812977, 0.15062874981603236, 0.16268479024242277, 0.15370867624250473, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011042193076343798, 9.999999999998899e-05, 0.002150545771078538, 9.999999999998899e-05, 0.00044457653008689313, 9.999999999998899e-05, 0.0010697728694841757, 0.07852933691465147, 0.09541112818466047, 0.08770342271222054, 0.08896833660760473, 0.09245286832274213, 0.08309199819062396, 0.09263092467234624, 0.09063559707450619, 0.08758125214512424, 0.3982316601830581, 0.3945623869384397, 0.39635092914812997, 0.40243021862614436, 0.4025273794534352, 0.3906550365044781, 0.384113110888908, 0.38591169431934635, 0.3999876459530738, 0.0822059207461211, 0.08592203506035734, 0.07959982275576372, 0.07922645238572645, 0.08783955667658816, 0.08832225006894023, 0.07392048610524182, 0.08513162627689708, 0.08968562070005004, 0.1590856778717329, 0.1344507775540431, 0.15148649885184184, 0.14998721152381334, 0.15194210651267748, 0.1390662839271104, 0.15047970864150628, 0.13959355647896887, 0.16943708045174333, 0.23124821678306795, 0.24544199300042013, 0.23179888824352757, 0.22979940135732602, 0.21881375813751092, 0.2209752363966333, 0.24085341010168426, 0.24952935840089951, 0.2435490932720661, 0.16806753287073584, 0.16926198064961495, 0.16204882859808856, 0.14656690532212402, 0.178361748203416, 0.15526635528270183, 0.18720271725110793, 0.1961927521510869, 0.176785150924049, 0.1877838652439099, 0.16350056789945833, 0.18340591430668907, 0.18272057044781664, 0.17429251851126826, 0.18581932862439687, 0.18250905414851637, 0.17913036585317244, 0.19822403293476332, 0.1791706347380343, 0.17435011442916581, 0.17524068715087504, 0.17368123323425622, 0.17326006567352248, 0.170103559633332, 0.17461755127411815, 0.17248759266369396, 0.16864912399279675, 0.1996506747962471, 0.16718189099578995, 0.28120396827514826, 0.17309722184927412, 0.19015243272443627, 0.21815742650047598, 0.17098446338752127, 0.1912615834363499, 0.2214416835434435, 0.1861353374421857, 0.29664290073910493, 0.2210340307031794, 0.17274761243794567, 0.18106709760609685, 0.17318654765249064, 0.19991839361245978, 0.20175560403518322, 0.18957507736098356, 0.18725148275452874, 0.18445508753981177, 0.190292334709817, 0.19826268578976647, 0.18300682778147637, 0.17229552080674926, 0.19825783760748827, 0.18338184769192467, 0.19524529468599672, 0.06508646124202477, 0.061136022351637065, 0.0693229622046323, 0.06531692283334867, 0.06652508539707702, 0.06763626221860286, 0.0687366259676403, 0.06417462118042405, 0.06526560774155554]}, "mutation_prompt": null}
{"id": "d1b7e1d8-037b-4156-95ec-00e63847d8dc", "solution": "import numpy as np\n\nclass DynamicHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.adapt_factor = 0.1\n        self.local_search_radius = 0.1\n        \n    def mutate(self, idx):\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), [idx]), 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def adapt_population_size(self):\n        improvement_rate = np.mean(self.fitness < np.median(self.fitness))\n        if improvement_rate < 0.2:\n            self.pop_size = max(int(self.pop_size * (1 - self.adapt_factor)), 4)\n        else:\n            self.pop_size = min(int(self.pop_size * (1 + self.adapt_factor)), self.initial_pop_size)\n        self.population = self.population[:self.pop_size]\n        self.fitness = self.fitness[:self.pop_size]\n    \n    def local_search(self, best_idx, func):\n        best = self.population[best_idx]\n        perturbation = np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n        local_candidate = np.clip(best + perturbation, self.lower_bound, self.upper_bound)\n        candidate_fitness = func(local_candidate)\n        if candidate_fitness < self.fitness[best_idx]:\n            self.population[best_idx] = local_candidate\n            self.fitness[best_idx] = candidate_fitness\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            improved = False\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                    improved = True\n                else:\n                    evaluations += 1\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.adapt_population_size()\n            \n            if improved:\n                best_idx = np.argmin(self.fitness)\n                self.local_search(best_idx, func)\n                evaluations += 1\n            \n            if evaluations % (self.pop_size * 10) == 0:\n                success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n                self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n                self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DynamicHybridDE", "description": "A dynamic differential evolution algorithm with adaptive population size and local search exploitation to enhance convergence and maintain diversity.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 45').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 45')", "parent_id": "085623bf-ef68-4390-a7af-b0f67edd891f", "metadata": {}, "mutation_prompt": null}
{"id": "1031fba7-e013-4ae5-b07d-46c661608594", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 8, "fitness": 0.4546155881972443, "feedback": "The algorithm AdaptiveEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "085623bf-ef68-4390-a7af-b0f67edd891f", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "3d794e0c-6580-4b8f-bbee-4dafa4c79161", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "df24ba9b-8dd4-4ac3-ad2b-a8a03b57f3f5", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "c3693322-4054-4185-a210-ae590e51b324", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "ba488107-0295-4e61-a200-ac1b0ca3fff2", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "26ec13a8-b6aa-4359-82e0-81b6ee2187c1", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "9473b67c-f71c-4cc9-b805-b7f23cdf9c53", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "6647c85f-775f-4833-aa64-57c2c518ccb6", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "f2dd28ea-6238-404c-b652-768d609d211e", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "921e7b6f-68d7-4360-b201-070fc46fec98", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "ecedb414-664e-4f65-9a81-48dcbc7c0cbe", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "26500ac8-7bf1-45dd-b8fa-8765ee4a0586", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "ba57b838-a2b4-4973-9894-a85d86d15baf", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "a2552997-8c7c-4b7e-a12c-5f3808e9bb80", "solution": "import numpy as np\n\nclass ImprovedAdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F_base = 0.6\n        self.CR_base = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx, strategy=\"rand\"):\n        if strategy == \"best\":\n            best_idx = np.argmin(self.fitness)\n            a = self.population[best_idx]\n        else:  # \"rand\"\n            elite_indices = np.argsort(self.fitness)[:self.elite_count]\n            idxs = np.random.choice(elite_indices, 2, replace=False)\n            a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), [idx]))]\n        return a + self.F_base * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR_base\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                strategy = \"best\" if np.random.rand() < 0.5 else \"rand\"\n                mutant_vec = self.mutate(i, strategy)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n\n            elite_improvement = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F_base = np.clip(self.F_base * (1 + (0.3 if elite_improvement > 0.2 else -0.15)), 0.1, 1.0)\n            self.CR_base = np.clip(self.CR_base * (1 + (0.3 if elite_improvement > 0.2 else -0.15)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedAdaptiveEliteDE", "description": "Improved AdaptiveEliteDE using hybrid mutation strategies and adaptive elitism to enhance exploration and exploitation balance.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'b' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'b' referenced before assignment\")", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {}, "mutation_prompt": null}
{"id": "51ddd443-813f-42a0-9251-6b56aa2a9f51", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "d2d000e6-ecdb-4f6f-83cd-4096a2d5e73c", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "270dcb0d-b9e3-4fd8-bd3b-ac125c1537df", "solution": "import numpy as np\n\nclass AdaptiveEliteDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 9 * dim\n        self.F_min = 0.4\n        self.F_max = 0.9\n        self.CR_min = 0.3\n        self.CR_max = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        F = np.random.uniform(self.F_min, self.F_max)\n        return a + F * (b - c)\n    \n    def crossover(self, target, mutant, elite_target):\n        CR = np.random.uniform(self.CR_min, self.CR_max)\n        cross_points = np.random.rand(self.dim) < CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return 0.5 * (trial + elite_target)\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                elite_target = self.population[np.argmin(self.fitness)]\n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec, elite_target)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDEv2", "description": "An improved differential evolution variant integrating adaptive scaling factors and elite-guided crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.2833929725405153, "feedback": "The algorithm AdaptiveEliteDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.9729296239938038, 0.9717381695135354, 0.9728966949248519, 0.9741531838875869, 0.9679034080373764, 0.9734775399989936, 0.9721635882284397, 0.9743414716401131, 0.9741628425574407, 0.7709896162983854, 0.5113360340548212, 0.8092274406549379, 0.33037718593018006, 0.46294662105281936, 0.8269277488473272, 0.44695226949364364, 0.716493895360363, 0.8920332158395634, 0.13759375407076113, 0.12795492770506023, 0.07182572125687148, 0.1372151903376544, 0.08785133236387732, 0.06149550898282019, 0.07419286821940785, 0.12055732499569494, 0.0844963901344874, 0.12027084513971131, 0.09083400285079024, 0.08120194351133925, 0.09876442919170025, 0.04548821559608529, 0.06913075854201145, 0.09070914853838108, 0.09098405738194726, 0.12799547770406916, 0.7907018843515045, 0.7672357886461176, 0.8222032508212389, 0.9580078758737828, 0.9412583213612412, 0.9243858191989908, 0.948292362483503, 0.7240506109923451, 0.9406298263757426, 0.18799246062612607, 0.18657805694360918, 0.35002946626360754, 0.23912991467124034, 0.18164584489168412, 0.4433563551923565, 0.406435290263766, 0.20764491372462157, 0.7187298610842867, 0.22893698444867727, 0.32974446567298665, 0.16359183702842905, 0.21057923484814334, 0.3957915736493094, 0.21599407292081252, 0.18002318391204586, 0.15323665701104217, 0.18854707189962128, 0.22476656218195112, 0.19844641244118844, 0.13036761114530104, 0.15505665038434124, 0.13199458534229214, 0.12618026209466682, 0.13724125670746123, 0.1643538671427619, 0.1689105863367324, 0.15803044590773552, 0.1949285953868266, 0.13247869439115512, 0.1635536138936763, 0.15844698781809097, 0.1322563001514927, 0.20325045424581722, 0.1316886760363939, 0.1319581869509504, 9.999999999998899e-05, 0.14385819131670474, 0.08036422528962284, 0.1099628298003048, 0.3256321335938933, 9.999999999998899e-05, 0.12215477948481801, 9.999999999998899e-05, 9.999999999998899e-05, 0.17043886365088368, 0.30251875341323664, 0.2964799241833327, 0.08769142781606265, 0.04258413794642224, 0.08494309885645579, 0.1769002778681068, 0.17631158673974567, 0.14573360776221156, 0.12334727424797998, 0.12978467959724893, 0.1551615692614745, 0.14242554410919817, 0.18557688664569683, 0.2606405881677334, 0.2992739416299939, 0.1935142219219309, 0.22676860996130976, 0.18054539335708208, 0.14990723603400824, 0.12338512086160058, 0.05791229118003116, 0.07109028531724793, 0.1593243067494614, 0.1549191290298484, 0.17434068595990626, 0.1105006432672111, 0.6552598832639472, 0.5582275107090184, 0.5298943997498137, 0.49456073641550413, 0.6887354580945977, 0.5424409664954261, 0.7507749219315565, 0.6703047740966274, 0.6274712360988295, 0.07152780506275813, 0.09869947696650361, 0.06326473409988043, 0.16508571595348753, 0.08400970350646497, 0.14879776737157113, 0.08164709372391699, 0.09831018577668726, 0.10795397169436782, 0.22117811431987466, 0.3084695226687266, 0.1623041831002049, 0.2726027298385497, 0.21422877226170645, 0.22227281319006864, 0.2904086660336238, 0.13197616776049248, 0.308093871012614, 0.24962613781305398, 0.390239245680721, 0.3079108780378611, 0.21466626065431138, 0.22634803847240903, 0.3576120498346156, 0.23645988720762756, 0.35124582986673525, 0.3538678421165493, 0.11472214025846061, 0.2547092702198124, 0.28216296962226184, 0.28634798837494857, 0.20625762946188875, 0.3359076198802261, 0.11112536473008316, 0.2714068400608354, 0.20263309418819642, 0.24426475096055789, 0.2526446122881687, 0.1877862581425671, 0.18971713616134867, 0.19686927028658763, 0.21786486414883233, 0.22338605583555415, 0.19349711723472474, 0.23526563292269043, 0.16314088486942946, 0.19372041020326247, 0.19054662225025, 0.1727030487396667, 0.1882614994691546, 0.2003692683112942, 0.18940209654974405, 0.1866405123597732, 0.1922808435940062, 0.5657931259520821, 0.1272101818689514, 0.14920433902893748, 0.686860823547918, 0.20228416428359375, 0.20172255729577315, 0.5966944824961773, 0.17013359005351636, 0.1691098433422985, 0.6402985378275262, 0.21437327660995997, 0.07362174275717703, 0.21385405987336215, 0.16982309944372942, 0.1454063509344229, 0.10549224572196059, 0.10529956259903606, 0.10513753905641521, 0.17865847068367968, 0.17978876812309696, 0.17402431191981227, 0.21006185561963153, 0.1828227983891375, 0.2033100820229894, 0.19974312587025356, 0.19362001348080304, 0.21728396582676368, 0.08683244365104725, 0.08964347420746344, 0.10151962139332449, 0.08301912652281207, 0.09502787621644349, 0.09542835248140713, 0.07298001428156364, 0.10581190186809131, 0.1082077659218379]}, "mutation_prompt": null}
{"id": "5b0c1b70-48b8-464e-bbc6-61c2e66b957a", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "8e265732-97c1-4363-8b65-67b346704d9c", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "cbf8a1ca-e1d2-4c38-908f-f6433f946e58", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "034bc34f-ec45-4a65-8f1e-7ff029f562bd", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "5a9dfd74-a2f4-4d88-b884-48a5e7446156", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "b6c511c5-61b3-45eb-a80c-e9340ddc2cd0", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "713916f7-05d6-4a53-8a58-de7823afffce", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.15\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 3, replace=False)\n        a, b, c = self.population[idxs]\n        mutant = a + self.F * (b - c)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    success_count += 1\n                evaluations += 1\n                \n            success_rate = success_count / self.pop_size\n            self.F = np.clip(self.F + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n            self.CR = np.clip(self.CR + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution with elite preservation and self-adaptive mutation and crossover rates for diverse exploration and stable convergence.", "configspace": "", "generation": 31, "fitness": 0.1404383311775076, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.09.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.46198401201510664, 0.22530837444198892, 0.2604097210053292, 0.32966022656473626, 0.20943771200461836, 0.3753533486707398, 0.188038141170481, 0.25931221791120906, 0.24346256281208212, 0.14326491493042337, 9.999999999998899e-05, 0.1448418719893294, 9.999999999998899e-05, 0.0407664165091246, 9.999999999998899e-05, 0.07384699989659715, 9.999999999998899e-05, 0.15151935691602503, 0.13112037069637117, 0.1559326086918934, 0.11272218198192463, 0.16423546716711557, 0.1485804950209384, 0.10744071919558906, 0.14721708590491944, 0.1517672820045709, 0.12306403442401492, 0.05478270754608949, 0.11548777497581142, 0.09894859206028106, 0.09479262649841635, 0.12457446384210069, 0.08049050055524443, 0.14616970187514977, 0.05746365519963004, 0.03764436879692057, 0.28224390127364063, 0.22197266678970495, 0.18283337000206767, 0.11964948413408671, 0.15396406973448407, 0.23765296583246132, 0.0896920735560005, 0.12287641593756504, 0.13526554045028083, 0.10876105858279383, 0.07381465995161673, 0.09428129800634266, 0.015553142288673216, 0.10814132430207557, 0.005219940232277787, 0.15719736952500885, 0.08101778100557622, 0.04167425355921883, 0.22373391766704087, 0.15861963016735936, 0.09592623937376243, 0.28392135865312496, 0.26875475252438397, 0.17430642263634943, 0.1317013119253143, 0.31726497424225597, 0.24830956421371597, 0.19443540437371554, 0.10206762402426617, 9.999999999998899e-05, 9.999999999998899e-05, 0.1417673966738695, 9.999999999998899e-05, 0.13753080239602533, 0.041262059027265985, 0.07244837874094578, 0.11815837233764981, 0.12856452433822418, 0.03177790293580873, 0.14521714352743387, 0.047230242081214624, 0.09088506205693014, 0.10577416047713195, 9.999999999998899e-05, 0.05469977730455444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10941750740844891, 0.03706861622236046, 0.062098008525991455, 0.08359741681736654, 0.03694067943649737, 0.021036917723206927, 0.09660811167307692, 0.0649096316432708, 0.08569870562607806, 0.06074027388879588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08194730884961032, 0.1268919300789827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02293725653669043, 9.999999999998899e-05, 0.04476613785313077, 0.21724888661947106, 9.999999999998899e-05, 0.17201286257279824, 0.016463861556687, 9.999999999998899e-05, 0.06003626254108074, 0.2320086885091207, 0.1775820794405899, 0.21959468576821406, 0.20722288252356358, 0.3072780480024093, 0.33698823805186273, 0.37378355705883337, 0.27889629809307404, 0.2857247298225861, 0.11213364215749932, 0.09747454072306194, 0.10017136680792993, 0.13155784707024254, 0.055485355747598275, 0.1124878235043758, 0.0826793666668807, 0.0862240577959541, 0.12911116260611055, 0.11031001995987988, 0.13624282021047784, 0.12465462637816216, 0.15469920601248288, 0.21043156677486163, 0.16201299917893142, 0.20394348443782084, 0.11161616518709128, 0.24234750003771965, 0.29689148583121383, 0.36334942743787413, 0.18734155344721537, 0.25324823296427246, 0.33580166649011667, 0.2945084833069046, 0.20530113012594942, 0.32691254602713804, 0.31596512302808, 0.3583824479023865, 0.31469429437144936, 0.2631716313697944, 0.19151017260763148, 0.17200078615643744, 0.22045030734829474, 0.2759176323287854, 0.2658122273456571, 0.23478005409253933, 0.19974771792122137, 0.17688816723965484, 0.1894918494341612, 0.1853257027564419, 0.1657577141471036, 0.15549653659790075, 0.18407268752255557, 0.19930645930987678, 0.19904578570278164, 0.17941772100153708, 0.19340534237267204, 0.2704566244513047, 0.2074996829762874, 0.2001573611824361, 0.17823357656448757, 0.17490316772323744, 0.19617054320072813, 0.1878282754521169, 0.2727349178821823, 0.12062176001292135, 0.14410847930415183, 0.29407101726251517, 0.14925131936261882, 0.11691403119805177, 0.15554370023254216, 0.11194213498824535, 0.12150159357254886, 0.3145868835422365, 0.1787207537027562, 0.13322646991892784, 0.15644998552290146, 0.1688353700455344, 0.10908585954605421, 0.0949258464385393, 0.10506534970095838, 0.15358892600409058, 0.17521241595759984, 0.2048531496060918, 0.18586609787770614, 0.1495605030760082, 0.16771624656642614, 0.16113818029745475, 0.17940915991226825, 0.15095538181474644, 0.18484514434847, 0.04368256183623087, 0.06860310221827581, 0.06009102987695791, 0.06075110439161724, 0.08315856768042995, 0.08372080044914743, 0.08537255567438007, 0.07559977445270838, 0.1022332580912354]}, "mutation_prompt": null}
{"id": "547832b9-5f94-4317-aff0-fca02983840b", "solution": "import numpy as np\n\nclass AdaptiveEliteCMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.learning_rate = np.full(self.dim, 0.5)\n        self.cov_matrix = np.eye(self.dim)\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.learning_rate * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            fitness_variance = np.var(self.fitness)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.learning_rate = np.clip(self.learning_rate * (1 + fitness_variance), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteCMADE", "description": "Enhancing AdaptiveEliteDE by incorporating an adaptive learning rate based on fitness variance and elite guidance through covariance matrix adaptation.", "configspace": "", "generation": 32, "fitness": 0.2281096876478815, "feedback": "The algorithm AdaptiveEliteCMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.7628888660849418, 0.5614503925764598, 0.5575396691414068, 0.8177285667095454, 0.1900023674509821, 0.5390346553430578, 0.19403624837305278, 0.5014942767624405, 0.8300040420653692, 9.999999999998899e-05, 0.0768574228570098, 9.999999999998899e-05, 0.06592210685350053, 0.7125592764470188, 0.06757908172448202, 0.059002537960763934, 0.018744103447418614, 0.13547459421450947, 0.2823662028899645, 0.13507668645984627, 0.14846580634725948, 0.1168962299717603, 0.1498663416725181, 0.07608390487381733, 0.15118220355566936, 0.20862872167325297, 0.1704805622686243, 0.16083935321939968, 0.12056265293498525, 0.16876426930891575, 0.23240635036023072, 0.118042887353767, 0.17065881346382195, 0.14669688347294885, 0.11183133033170611, 0.10777270296070152, 0.9902333248362213, 0.9924558602397908, 0.9916098790843847, 0.9917864774611743, 0.9909364650837518, 0.9919065650459798, 0.9917087667068837, 0.9926282984634249, 0.9933767223446707, 0.15661426579007642, 0.20511755730379888, 0.060422377253720905, 0.20664299709093992, 0.22052233581899794, 0.242109523932185, 0.1198381553023179, 0.20110547144068125, 0.08766024561256802, 0.3587633561152559, 0.16973049108669624, 0.22288308210723584, 0.33444720367370906, 0.3715556646021695, 0.2444851125152988, 0.21894581389280643, 0.2319924979547362, 0.3455630284290131, 0.2527657974401565, 0.22283529346412, 0.24478008850579003, 0.2477351620961522, 0.18744420275596463, 0.13484274334498336, 0.2979702262634869, 0.13289579610856672, 0.16222354678396023, 0.3411748161361222, 0.3343692059175494, 0.2948064689752722, 0.19843649466074675, 0.35482336021574323, 0.18493797606127083, 0.2625782724898489, 0.12684066395875504, 0.22832666152723347, 0.007116470541208231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03419558419111368, 0.10141206055600127, 0.08381348991955839, 0.07196110652743304, 0.10949518578834139, 0.06748978131567507, 0.011718536073339614, 0.09165701178322838, 0.1143727504552402, 0.10560387947963934, 9.999999999998899e-05, 9.999999999998899e-05, 0.016576174795469023, 0.06115105525892284, 9.999999999998899e-05, 0.01845887512730149, 0.0477507219890394, 9.999999999998899e-05, 9.999999999998899e-05, 0.011020692475369076, 0.10056495501829954, 0.08741049840906612, 0.03817739696118483, 0.20352503879243478, 0.09869408889484765, 0.049982709464284514, 0.11521386575229886, 0.049363371853726856, 0.3645500539171994, 0.4238594701596544, 0.4624813546372919, 0.46537250430474153, 0.36198598195592435, 0.43768495001195273, 0.5182682587546296, 0.5051453190164925, 0.46896572073038045, 0.05928333823221221, 0.08678712305607172, 0.06063214610532919, 0.08433714700727701, 0.07185106922327755, 0.08619155565811121, 0.07368851633311657, 0.0759976958157258, 0.10613106667902372, 0.17675061628138555, 0.12911415202837329, 0.12545907931716516, 0.14907419240227648, 0.12989458119795805, 0.1629990219475943, 0.12835392458971806, 0.1936721620298717, 0.14289323377423002, 0.2905691134641847, 0.4343206104942964, 0.3344245276635691, 0.21303311121424917, 0.19073533981846746, 0.34354401498426224, 0.39501728385629875, 0.27519235246431795, 0.20563345069907446, 0.18675225749489666, 0.19439967297502425, 0.12743147014253953, 0.15075787132184792, 0.19165966011438573, 0.18372353531851227, 0.14846330882207714, 0.25065629733912387, 0.15808312995674534, 0.19426558485505308, 0.1685066873445349, 0.17767348398055216, 0.18539127243781717, 0.16402973180882874, 0.17812435550759587, 0.16446609665344403, 0.17162950296931867, 0.16227160387247364, 0.21231728708434217, 0.1900090380597268, 0.2103249367823753, 0.2017440528420711, 0.2026468785007035, 0.19789202399376282, 0.19184048349370542, 0.22517532388172978, 0.23294211892525962, 0.18102351508590075, 0.19411673631799942, 0.15317313426010792, 0.4026861397084276, 0.16226686694221137, 0.7733719768574487, 0.18211529540807136, 0.1767427834139027, 0.16551161610393483, 0.5896207473715032, 0.27553202834874935, 0.15363338065613863, 0.7363583171449939, 0.4961647085100752, 0.15999007445450208, 0.1892646147621092, 0.41781571817111374, 0.11309488116620181, 0.19517736566101063, 0.20562224472658208, 0.16778332883979352, 0.17274504153249015, 0.160415673733045, 0.20696235409884634, 0.22848203402428735, 0.19107046607860434, 0.16039454287994703, 0.06420614674924019, 0.05577867587954499, 0.06582304741508449, 0.07082947318882038, 0.07020254708541274, 0.06373999642425676, 0.06213303581066687, 0.07043714947685353, 0.0804414389019974]}, "mutation_prompt": null}
{"id": "9070f174-4ddb-4418-94e0-1cb2b76f4528", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.global_best = None\n        self.global_best_fit = np.inf\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def adaptive_scaling(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        self.F = np.clip(self.F * (1 + (0.5 if diversity < 0.1 else -0.3)), 0.1, 0.9)\n        self.CR = np.clip(self.CR * (1 + (0.5 if diversity < 0.1 else -0.3)), 0.1, 0.9)\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                    if self.fitness[i] < self.global_best_fit:\n                        self.global_best = self.population[i]\n                        self.global_best_fit = self.fitness[i]\n                else:\n                    evaluations += 1\n            \n            self.adaptive_scaling()\n            if evaluations % (self.pop_size // 2) == 0:\n                exploration = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                new_candidate = np.clip(self.global_best + self.F * (exploration - self.global_best), self.lower_bound, self.upper_bound)\n                self.select(new_candidate, np.argmax(self.fitness), func)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution algorithm incorporating adaptive scaling of reproduction parameters and a new exploration-exploitation balance step.", "configspace": "", "generation": 33, "fitness": 0.35333188426560524, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8847305909215691, 0.8935400417345247, 0.9061785187262982, 0.8951894236595666, 0.884513119080283, 0.8855919402764914, 0.8825839687217268, 0.8975100023718039, 0.8981742738066659, 0.7842720926653735, 0.8238436684410506, 0.7514336781759035, 0.8079682095557639, 0.8031314504985139, 0.7160788967228326, 0.791456621446446, 0.8069326470298501, 0.8421817506462284, 0.7836669690860723, 0.16190278593862928, 0.7383177866467535, 0.1871807151206083, 0.7291435321786882, 0.79221971604945, 0.18930033921801892, 0.8040605822726324, 0.8144038690205047, 0.1871216311385383, 0.12274782684647234, 0.16112513297473885, 0.783613569964298, 0.1871131577849442, 0.7285327693307015, 0.7120279168102939, 0.12469562521128497, 0.7740722692195546, 0.9865433894275262, 0.9878044901800258, 0.9809775801624278, 0.9850027497920274, 0.9892786662307909, 0.992913153830542, 0.9899287016201277, 0.9741845890258714, 0.9934715418004282, 0.2989341370650751, 0.26523958204794484, 0.30009358386580487, 0.33838766858265046, 0.3360490573970797, 0.37473529948753026, 0.27388405261525517, 0.22843543439599523, 0.24744965180387213, 0.2987570181962189, 0.21840048847389915, 0.5507315908079733, 0.277865691636512, 0.21956960605617148, 0.22022201062854396, 0.17492140287338265, 0.23388518219278287, 0.8151877960645896, 0.12860364835075944, 0.10809585648463804, 0.5373337919005814, 0.6915179808473008, 0.12408397774331847, 0.2483736202189969, 0.16929391551862538, 0.19997724432313024, 0.17829953338605442, 0.15201611626143985, 0.11477151239152772, 0.5844747794735483, 0.24937197300602387, 0.18961620804939516, 0.17451167594546368, 0.26739917237319766, 0.17338724132731553, 0.21751866540663622, 9.999999999998899e-05, 0.00205853309617543, 9.999999999998899e-05, 0.00027473595001903384, 9.999999999998899e-05, 9.999999999998899e-05, 0.03310907987517897, 9.999999999998899e-05, 9.999999999998899e-05, 0.06842909376188144, 0.06789526896689624, 0.08777423961878028, 0.05974456710888831, 0.02442820617947805, 0.06145600102813509, 0.11453689836529979, 0.06197171996394757, 0.09509640985755452, 0.049708396531068844, 0.14930984843341955, 0.3836418551452483, 0.5446464454278728, 0.0686019136839483, 0.11315002439355337, 0.18744751737829946, 0.0887725256364309, 0.09084457853977934, 0.15300975783579474, 0.15280434759887906, 0.13890295565655975, 0.4413312110661157, 0.18924160009192537, 0.09216215867190836, 0.11366303407907052, 0.1365536607162119, 0.42321493545284494, 0.8046400894992656, 0.7857730754837383, 0.7721908381651033, 0.786818405314966, 0.8089182688150973, 0.7672825786815063, 0.7844307579228225, 0.8147724305983233, 0.7942265630890712, 0.11476048676201789, 0.10887082267882231, 0.10695317802045701, 0.16287384880704958, 0.13461270635302192, 0.13400507048577037, 0.10691745086789628, 0.1522868266264943, 0.13230756432224622, 0.20808760323772946, 0.2277421265391556, 0.2505225297514626, 0.2433514226774265, 0.19355222942443118, 0.1686127002373351, 0.2624658506185862, 0.22917110214464376, 0.18442314158816575, 0.26779880302344583, 0.4375838615691612, 0.31604128242166263, 0.45034613992592887, 0.28319266333047477, 0.47166739202144403, 0.345117701542517, 0.5459994895571079, 0.504160324147948, 0.25582779464750427, 0.2465329463316871, 0.22634215640090483, 0.2394692287781509, 0.359773602851025, 0.2589679803714674, 0.2113086746188667, 0.25166711727986335, 0.34168072222021306, 0.23041475126421962, 0.21191334110935234, 0.1966362476138256, 0.2373945982418758, 0.21164797121520484, 0.22605771989119572, 0.22010835943907736, 0.23786222318583883, 0.21572196650986653, 0.2119051199733547, 0.24983871262934254, 0.20070479007615194, 0.3842355030411647, 0.226961897276449, 0.22317655879634035, 0.19512876546005575, 0.22129268716623118, 0.20944404872043987, 0.16518595703964, 0.18491021406943442, 0.15344686466609492, 0.801239364721103, 0.9120044697635692, 0.867636880546582, 0.38753586990093003, 0.1723211224911021, 0.16766652985061703, 0.15530960074718791, 0.21134325969468826, 0.15310487104490766, 0.2055715502729738, 0.1673359999206312, 0.1545145118425345, 0.21145033905780575, 0.5709324433933147, 0.4299961565456526, 0.19279754981730501, 0.1837443240974337, 0.18637428484890484, 0.18248289166769371, 0.17518023746142808, 0.17846991437981286, 0.18412298803572946, 0.18088942559349175, 0.19424481327301768, 0.0986628041719978, 0.09432462554200627, 0.08862482688831264, 0.09679791695500684, 0.09243585849627778, 0.0803067913004264, 0.0955694399226299, 0.09265289705713908, 0.09356695625813749]}, "mutation_prompt": null}
{"id": "08763c34-2fbd-4b94-96c9-14b283ad291e", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "499ff750-7411-4e69-a548-2e468b702763", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "70204ff8-cb57-4737-a668-777fd492ec84", "solution": "import numpy as np\n\nclass AdaptiveRotationalDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def rotational_mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        d = self.population[np.random.choice(elite_indices)]\n        return a + self.F * (b - c) + 0.5 * (d - a)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.rotational_mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            diversity = np.std(self.fitness)\n            self.F = np.clip(self.F * (1 + (0.3 if diversity > 0.1 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.3 if diversity > 0.1 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveRotationalDE", "description": "An improved adaptive differential evolution algorithm enhancing diversity through rotational mutation and adaptive scaling/crossover strategies.", "configspace": "", "generation": 36, "fitness": 0.40185300706655375, "feedback": "The algorithm AdaptiveRotationalDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.9192677030274313, 0.907832627900019, 0.9203746966775269, 0.9163590125083733, 0.9094367194812514, 0.9154800146730611, 0.9292296710955784, 0.9203562815939996, 0.9191321737388226, 0.8432311976988829, 0.8094888408718697, 0.8169176846241869, 0.8272187590328757, 0.8355396980945455, 0.8309485479215255, 0.8251340698809874, 0.8493914243056947, 0.8206498024986348, 0.2456501963928177, 0.10895544494842746, 0.17278755573514648, 0.13111802091281388, 0.24275857489318875, 0.12344439172118327, 0.10795106078966277, 0.13303947706562957, 0.1248548421451594, 0.10808065664182864, 0.10874942848369884, 0.10786607223048339, 0.13713556738788302, 0.1033971373272492, 0.1455950226505558, 0.11529024250391595, 0.138605203431322, 0.11549975568076465, 0.9909181263211072, 0.9927131222633397, 0.9912745790387714, 0.9944226315294803, 0.9871524077338154, 0.9919458658742379, 0.9913606139647307, 0.988221740434121, 0.9946609066706895, 0.6036829458604329, 0.5325607657635689, 0.4951207052550409, 0.5897583124039997, 0.5052705309990071, 0.5886130955640277, 0.4647024251089752, 0.4757470896424151, 0.5157848487028657, 0.8440011593966136, 0.8852942346323612, 0.9164173900719359, 0.3867520515243419, 0.902781865283966, 0.8847799297116977, 0.893157811128378, 0.8778543149600856, 0.9160142237056319, 0.3057629147798995, 0.4568137561083174, 0.403125866045122, 0.13427672018613213, 0.3300139150223508, 0.4500687389725403, 0.34028372530191686, 0.36254145650655634, 0.35653308541832796, 0.3185817806054553, 0.32890238523027815, 0.374261405548156, 0.4119459350500211, 0.4588166543737612, 0.4252307544124845, 0.4240888833595924, 0.30481976805515354, 0.47367304139342414, 0.38612543672072597, 0.32164645798649494, 0.30388412150500554, 0.32394316300237314, 0.31221476608187326, 0.31301628460142505, 0.3680720583184962, 0.3429845031461687, 0.37583351002619814, 0.3367646206763537, 0.3575597548024223, 0.3890894621136777, 0.33394251686538334, 0.35484684682041934, 0.34065793416246415, 0.15858566618645853, 0.3813590688723162, 0.37868132128040577, 0.17165365060142757, 0.18268868077028821, 0.23440710593156855, 0.32077645074404915, 0.2792311966249911, 0.22760609094042028, 0.22087070397812347, 0.2042492299230757, 0.1962896103688524, 0.3224086586537367, 0.30465648645923105, 0.29603423668688567, 0.3120737610223435, 0.31404833224222506, 0.31412180776670406, 0.29199380438463063, 0.2971934907693049, 0.2812811775030126, 0.5499788316966985, 0.5325821180415569, 0.5201727861521015, 0.5377104688127752, 0.5685392091355777, 0.505151043979353, 0.54505677233413, 0.49018359611442697, 0.5864910531036378, 0.09373090429523667, 0.12147340550836672, 0.11800158796163973, 0.10580956381134221, 0.10885029350524256, 0.09705753798411354, 0.1099437068171274, 0.14462735195064214, 0.12207562903927516, 0.2582606320035793, 0.3196831469755005, 0.24934657371947955, 0.1480767585779562, 0.3774768389333848, 0.16653302369893086, 0.17158781383727584, 0.21991758175669263, 0.20490470456063248, 0.43503174688379154, 0.4057525612791134, 0.4211767330026248, 0.3950266784684471, 0.49099725675508266, 0.3938124320216515, 0.5318561256215963, 0.43713859709692293, 0.5479777616777763, 0.39381510571006806, 0.24858004607288475, 0.3383839684207661, 0.3645354368962318, 0.3355536144299325, 0.33980091908193055, 0.3498681676387023, 0.3694913672754371, 0.3868947790590779, 0.21273517775909045, 0.18636630374460406, 0.21088578839476024, 0.20965323459097662, 0.20868744086115376, 0.19734554835381957, 0.19332319949235388, 0.2146956658982746, 0.21155135959422045, 0.7845296381256733, 0.7870761902970868, 0.21552688223226468, 0.6835185379728643, 0.24629864282149538, 0.6960612889750859, 0.22117168569865098, 0.2301014215399667, 0.6678251281344105, 0.15680161393617564, 0.19583533986284474, 0.15407047440541388, 0.17305658491326592, 0.8783962730603314, 0.19924557276702115, 0.7406774817185066, 0.16600717072496807, 0.15799438790060616, 0.5446652793901671, 0.20896014181103106, 0.16768950804419946, 0.8376154394039319, 0.2119572598373155, 0.2017546443513656, 0.10497877042057302, 0.7292329267988904, 0.1562365474037355, 0.19934757649536572, 0.1939004120481902, 0.19209081461407918, 0.19989287343770468, 0.14975976203255337, 0.17369156303104027, 0.17164451698721517, 0.1912827600509135, 0.19127288490265104, 0.08824950386068309, 0.07379754147118733, 0.06861024768702861, 0.08592296183369563, 0.07643823258713178, 0.08082008106487215, 0.07778762016347285, 0.08148322735129554, 0.08454813879906664]}, "mutation_prompt": null}
{"id": "0aba1e65-fdeb-4283-b110-53ae7385cab2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.feedback_threshold = 0.1\n    \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def update_parameters(self, success_rate):\n        self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.2, 0.9)\n        self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.2, 0.9)\n        if success_rate < self.feedback_threshold:\n            self.pop_size = min(self.pop_size + 1, self.initial_pop_size * 2)\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))\n            self.population = np.vstack([self.population, new_individuals])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            successful_trials = 0\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    successful_trials += 1\n                evaluations += 1\n\n            success_rate = successful_trials / self.pop_size\n            self.update_parameters(success_rate)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveEliteDE", "description": "Enhanced AdaptiveEliteDE with feedback-driven parameter adjustment and adaptive population size for improved convergence and diversity.", "configspace": "", "generation": 37, "fitness": 0.3379291645641729, "feedback": "The algorithm EnhancedAdaptiveEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8763161292412357, 0.8416178065600081, 0.8726399563692947, 0.868963903629187, 0.8830225118497022, 0.8881965234610547, 0.867263373537777, 0.8733080962798045, 0.869841448977053, 0.7514925688328931, 0.7566478746516071, 0.7416127898337233, 0.7681311152717304, 0.7793281206390155, 0.776621769219767, 0.7630838719897989, 0.7885298882704912, 0.7767979238751236, 0.7515963236916101, 0.6979438248785595, 0.7356554064268551, 0.7256278397085589, 0.18245589756173264, 0.7244978935859634, 0.7428604587634429, 0.7307754595420548, 0.17703636371433584, 0.6843631695346392, 0.17843771731777502, 0.6879914352203673, 0.1780621859960846, 0.686183819925555, 0.7167487848129573, 0.26352539372941, 0.728970787039731, 0.18216034421492133, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.2972115618293596, 0.2915351877223217, 0.32214283200647464, 0.3742596929898855, 0.33970561555532874, 0.3891285542286428, 0.3609991259186347, 0.2944271908144094, 0.3648328194994134, 0.22140739419070887, 0.3376890470009952, 0.45665863466560885, 0.5512253387506327, 0.7118210536467349, 0.3645798012903927, 0.24074309322366916, 0.35170676932074596, 0.2733497237873038, 0.15523067374669286, 0.20758599047173443, 0.18222657200075554, 0.20049896757741492, 0.1947418499498378, 0.1028105716702743, 0.21887527840049614, 0.25831138257668673, 0.12936959951604698, 0.2158714584955861, 0.010125445613113682, 0.14714983986705832, 0.19839102344294357, 0.20647264297032852, 0.18689974125715658, 0.14564906504781905, 0.23095003187177876, 0.15473545128535193, 9.999999999998899e-05, 0.02361326194593727, 9.999999999998899e-05, 0.0003372358328953551, 9.999999999998899e-05, 0.060222032444633644, 0.002541694289688534, 0.004248452526149582, 0.03720571612484913, 0.08546051908781849, 0.1287734843799968, 0.1260292847116341, 0.037133380393674975, 0.04808601436639515, 0.031620258136976886, 0.10541398065333163, 0.0516062092928431, 0.05953945627107682, 0.013791995501834187, 0.008725849832889487, 0.04583760170851181, 0.07918832338509896, 0.07545256646912535, 0.005397194677909334, 0.05080345585386736, 0.08502329035033251, 0.10092040950392234, 0.19640103457273472, 0.16693819162333834, 0.13962620825874128, 0.05570690492729591, 0.20476405610190584, 0.1369409199100965, 0.1682505855142188, 0.1416157828613812, 0.1283687489018741, 0.5259451070432528, 0.5680034351183174, 0.5594553052435833, 0.56913911410333, 0.5185926494195072, 0.5504511349507306, 0.5568798487039618, 0.5234514554912076, 0.5473309895501831, 0.10022480163317782, 0.1402556682592886, 0.08770831861973916, 0.13168392018421093, 0.13718596927787108, 0.1266665478971496, 0.13218033043438426, 0.12527985255850438, 0.13276462678546452, 0.14633640945039572, 0.1691279530890979, 0.17332698584060413, 0.15794912807031358, 0.14760452042271155, 0.155250489376766, 0.14436706853156633, 0.15047564068592945, 0.15904440915527462, 0.3828622318744439, 0.22998331446215947, 0.3743483515904018, 0.40354129405939243, 0.36980624580578014, 0.3205208182218112, 0.405947932373377, 0.6220044289354323, 0.5799677108999641, 0.23141438845337325, 0.3007724889882154, 0.22340991174088443, 0.19459242119465248, 0.2008903958368894, 0.24232000513940988, 0.3341680479320285, 0.34400546772850904, 0.35898169635995314, 0.22413312798174756, 0.18540663132357227, 0.20758072030664199, 0.22793249140340288, 0.20925243356187295, 0.2190350194150945, 0.22572350068388147, 0.2202473549097581, 0.19190169915708, 0.5703340785970936, 0.2375552741738376, 0.6312405983682654, 0.7738535959713487, 0.6110831463663615, 0.2220370762541446, 0.5400591352991552, 0.24442860666266386, 0.6245725067641277, 0.21085283443270753, 0.1970382514827439, 0.1543851366492336, 0.8628864271098, 0.640285722783998, 0.17125479534746468, 0.1684434601093635, 0.1698163383142648, 0.1688727245068944, 0.15095978082533568, 0.21049040581932088, 0.28642918721440014, 0.12645654264241712, 0.16771737494629646, 0.19533347131905998, 0.1982885988998596, 0.5893587488502106, 0.15381368402210027, 0.18754686718879976, 0.20168110831995834, 0.17708441385663354, 0.18981061388359544, 0.20431731995727243, 0.17328888485228888, 0.1837759872092002, 0.17529413894288104, 0.20169536016702172, 0.09445451041191022, 0.08940487353939408, 0.10183040800084886, 0.08458495922454023, 0.09204117791653332, 0.08571209930946644, 0.0834992720451595, 0.09308616023265781, 0.08797432275386963]}, "mutation_prompt": null}
{"id": "e7fcf1d0-f489-4e14-8d9c-8ae15be39500", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "671d0900-1596-4376-be71-417ad2cb28af", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "0274c4ac-e02d-45d9-a248-4449803385db", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.5\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def elitist_local_search(self, idx, func):\n        perturb = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(self.population[idx] + perturb, self.lower_bound, self.upper_bound)\n        candidate_fitness = func(candidate)\n        if candidate_fitness < self.fitness[idx]:\n            self.population[idx] = candidate\n            self.fitness[idx] = candidate_fitness\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n                if np.random.rand() < 0.1:\n                    self.elitist_local_search(i, func)\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveEliteDE", "description": "Enhanced AdaptiveEliteDE with adaptive scaling, mutation adaptation, and a novel elitist local search for improved convergence.", "configspace": "", "generation": 40, "fitness": 0.2001717141294726, "feedback": "The algorithm EnhancedAdaptiveEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.5292266315111767, 0.5744612914555111, 0.4946267695495673, 0.53815787264443, 0.5146495155980298, 0.5931662064810412, 0.4665090637770011, 0.4700254589857892, 0.5057342795690251, 9.999999999998899e-05, 0.004674305261936906, 0.01457520048397909, 9.999999999998899e-05, 0.048201261514316696, 9.999999999998899e-05, 9.999999999998899e-05, 0.010706927666790378, 9.999999999998899e-05, 0.1069979013115051, 0.1275235874540751, 0.058086673166774516, 0.062623988404094, 0.09685795587143953, 0.1384799673129139, 0.06748257079952347, 0.07930186699473729, 0.10507044911084795, 0.07984609540387233, 0.05241674761294668, 0.0680156205857314, 0.10202610936781753, 0.0604280974067779, 0.08385745471615669, 0.06566676080521916, 0.05125202372405069, 0.031161540950164435, 0.8472343033508845, 0.9087888456805284, 0.7242264442691007, 0.8968360388135767, 0.812675956425869, 0.9116914770350687, 0.9170733671697064, 0.9255383651483371, 0.9495312901572589, 0.3135206960331508, 0.2325536526497899, 0.25533767149793907, 0.31430134396721754, 0.29142588709262585, 0.319068238461539, 0.32192348950325556, 0.31271666982507074, 0.31729862228098027, 0.24490266420918283, 0.19620177739428113, 0.18416351623923644, 0.20863717311660301, 0.28339305994797725, 0.2822479117987089, 0.08102110593554623, 0.23476354787632192, 0.15356317768948624, 0.1272466473291899, 0.0520730853310204, 0.13823009202308056, 9.999999999998899e-05, 0.20872327344643904, 0.1597224847359544, 0.12980546533517612, 0.1500365240851339, 0.21406844021969296, 0.20161782228663994, 0.11875784633179387, 0.1316535960865518, 0.17175350322908434, 0.13356306540097262, 0.11278403904201373, 0.25887270683381525, 0.1678082582073641, 0.08432734650406215, 9.999999999998899e-05, 0.04206196061581091, 9.999999999998899e-05, 0.00650466695757701, 0.02667816316551963, 0.009331030298909027, 0.06869569956472754, 9.999999999998899e-05, 0.03340365000888035, 0.117901788994759, 0.046500948444040846, 0.11347741439481329, 0.09015771928243799, 0.0578888014722847, 0.022126210897500442, 0.10504138850937272, 0.22283797067552313, 0.12569585767462743, 9.999999999998899e-05, 0.02963183036003958, 0.002389047297943425, 0.02835584385799561, 0.0002878428394100796, 0.014051566408597282, 0.013602910216803488, 9.999999999998899e-05, 0.006060106903991946, 0.18968288127791788, 0.05653914064544985, 0.08847416412584719, 0.06966305490981362, 0.049706717703068115, 0.09823448655251688, 0.05120098069529033, 0.1349802239643635, 0.08182705223099196, 0.4092094872452643, 0.44262489852402365, 0.4242850423362584, 0.42781060442838426, 0.4047942174407263, 0.4347985543370031, 0.4076344118780143, 0.4457690090773765, 0.4346833629265131, 0.0948366479613112, 0.10263994219410233, 0.06664186625526036, 0.0700744556408599, 0.06172068909908812, 0.07508376672848993, 0.0809924580820045, 0.14640992275922038, 0.0937271743627518, 0.1489555911946392, 0.22671742522882665, 0.1471559916966878, 0.21273621673422605, 0.19534028957485094, 0.19351558621397658, 0.2226231895934363, 0.3355401811033786, 0.15908631332105527, 0.18499253891562772, 0.18788871425045683, 0.2953619806338902, 0.2395046715904805, 0.21592909003067595, 0.18020722382628407, 0.23411347397744342, 0.2731949241502424, 0.1997907553826057, 0.20242357486410834, 0.16746864188547717, 0.10587419198955506, 0.2548623005934111, 0.16772014304997662, 0.26139597380460533, 0.17007342916591373, 0.2333410806294871, 0.2055224740879491, 0.21029737285105, 0.13343939513096825, 0.20515552714207907, 0.1691622414837728, 0.1875243308986162, 0.17944276621700628, 0.17908375294162393, 0.15024640232576436, 0.19951812668929247, 0.17032110432937153, 0.1616853382686193, 0.19495814520620824, 0.21123737790223474, 0.19581508584258722, 0.17117239942100038, 0.20997442179697223, 0.1756638230084312, 0.1629113519855233, 0.19809410929467342, 0.20011189184111067, 0.17344304300848257, 0.6834800761991389, 0.18823465550449292, 0.19958887716530282, 0.1428792856545722, 0.16859496305920874, 0.15770767042717093, 0.6165712980825784, 0.21101762244293143, 0.1562295964227275, 0.21061618628837397, 0.1677137554529945, 0.15015061477980673, 0.16940510240403306, 0.10420732895881679, 0.4014859547304398, 0.15840526564901247, 0.17608938299039945, 0.19169100675210893, 0.16812643274964978, 0.23726433432789018, 0.1587312508359473, 0.1659380663482145, 0.1720778840932986, 0.17619091969708356, 0.08851816969630766, 0.05258038395428011, 0.07995266284047176, 0.0637808986119539, 0.08905398469102144, 0.046038943155136125, 0.06675044900727278, 0.08155127816128138, 0.044553658039565014]}, "mutation_prompt": null}
{"id": "b1634328-fe42-4a40-ad68-69377e579164", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.strategy_change_interval = 5\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        strategy_switch = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            if evaluations // self.pop_size > strategy_switch:\n                strategy_switch += 1\n                if strategy_switch % self.strategy_change_interval == 0:\n                    self.CR = np.clip(self.CR * np.random.uniform(0.8, 1.2), 0.1, 0.9)\n            \n            self.F = np.clip(self.F * (1 + 0.2 * np.random.uniform(-1, 1)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveHybridDE", "description": "A hybrid differential evolution with adaptive learning and strategic diversity control to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.1743178385263152, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.14.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.3873981719202999, 0.5060939912817306, 0.3965455973822203, 0.3292753496923999, 0.3524010791139852, 0.2748315674037992, 0.2975739828918863, 0.19610531685637078, 0.20571517132427164, 0.02134430652192476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07374396947763817, 0.09264331201385034, 0.15191570136365973, 9.999999999998899e-05, 9.999999999998899e-05, 0.1335608513853842, 0.16127593460533685, 0.17552384605207094, 0.11342236020465823, 0.1899645331713079, 0.14122754260964487, 0.169316908918955, 0.40723263808842347, 0.16013380058281068, 0.09636974517773456, 0.08624536383017023, 0.1636087916016724, 0.08906359508172967, 0.10162227560422321, 0.11161785239478283, 0.11693307129883779, 0.09378167202722287, 0.11392431631377042, 0.11654983072751002, 0.10499235516110805, 0.1493271829762305, 0.10731598823031163, 0.1073792822079257, 0.9495565256761168, 0.21180721982198658, 0.5197518572979352, 0.1278743414962915, 0.09993008034381723, 0.08301714787001724, 0.13875212212959465, 0.11707841521410634, 0.07818245299878579, 0.10271021021126525, 0.04820891296130103, 0.10355723010373064, 0.23427340936940833, 0.15758143630007837, 0.25227724900905557, 0.2113966707021161, 0.2748796832705356, 0.3705250871833726, 0.12074775222814549, 0.23739448642442518, 0.23561730115172508, 0.22456444847899082, 0.15429398372969394, 0.10800887405451343, 0.14630864869811067, 0.10851641734763795, 0.13055466752960676, 0.17642028275233712, 0.22429524363809805, 0.11676140654745282, 0.16740786490069914, 0.1826406165020107, 0.10500423234054468, 0.04728142239774602, 0.2561604717079219, 0.14738889854138015, 0.13619347488040134, 0.14669534631310366, 0.13519339387135787, 0.14891700359164173, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0509995038293648, 9.999999999998899e-05, 9.999999999998899e-05, 0.05964163511259846, 9.999999999998899e-05, 9.999999999998899e-05, 0.05426628324608396, 0.02220338376159048, 0.10713901519581104, 0.051541411165246465, 9.999999999998899e-05, 0.11253785561928675, 0.08073297377572741, 0.07749078638238682, 0.1002181556160936, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004231649386553182, 0.12768190122110368, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006730558316401236, 0.13816719937255917, 0.09854134349868726, 0.06042985319708727, 0.07517048914654023, 0.12581388864936893, 0.07972607134827414, 0.1800424662966872, 0.08995918920521839, 0.3624494272275306, 0.5441348607075738, 0.39235713759712465, 0.4421852859132267, 0.4082532909857699, 0.5034551248760101, 0.4680410757973036, 0.42082735888586764, 0.3142853292950508, 0.10928849579603994, 0.07407262648494162, 0.07567583013388979, 0.13470140937502617, 0.10346233096991386, 0.08160679607723376, 0.11403739881663899, 0.07979926008956695, 0.14713193525552049, 0.18090351823238293, 0.18128755538168317, 0.174184521902377, 0.2057668634227906, 0.17721758634412876, 0.10798713552628325, 0.15004862322303558, 0.16220620702252397, 0.11970347370513446, 0.3719876126212689, 0.2683831889858874, 0.3134546836740655, 0.35234658567399124, 0.28222310845134135, 0.3463835589679124, 0.3623664106068796, 0.362778419252744, 0.6244116600193983, 0.2439641349115086, 0.3151149678671026, 0.23849621642678753, 0.2770578544461175, 0.26346049462991994, 0.3862211890435867, 0.24564244185699802, 0.2400542653662483, 0.24487686579446, 0.21656069856739324, 0.19378953861478598, 0.18906928838937598, 0.26008392527751434, 0.21121824768265274, 0.19567899505558606, 0.21350723947269457, 0.22348810874762948, 0.1861253596821203, 0.20138165967090405, 0.1888138984706289, 0.8279409991034524, 0.22885885684536855, 0.2236784299062632, 0.24412268524490477, 0.17927896218002426, 0.20535274942220694, 0.19004710914390188, 0.14331341845342227, 0.14669692468071172, 0.23389538733484017, 0.1704887211001227, 0.28322627277115975, 0.1682291999586929, 0.1155885729646865, 0.16857645584202752, 0.16342674822236147, 0.2486344303653868, 0.19151038599396064, 0.1784045836391217, 0.17875573201701334, 0.15385544950485963, 0.16761262392610554, 0.09103233419707302, 0.15438882214518213, 0.19518947835810707, 0.17900099632947009, 0.1926958943691498, 0.1604711306501867, 0.19077518392399184, 0.1646840671336629, 0.1935861297018423, 0.18663128982912536, 0.18551826510577918, 0.16664113462942265, 0.10445521599521179, 0.06901553274681427, 0.09126417130716036, 0.09715084084710301, 0.0840366631957482, 0.10128921704079075, 0.0974749076061906, 0.08420304587378358, 0.06473136886479203]}, "mutation_prompt": null}
{"id": "2157e463-1cc9-4eb8-a62f-63f9d9a36361", "solution": "import numpy as np\n\nclass AdaptiveEliteDEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.success_archive = []\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c) + np.random.normal(0, 0.1, self.dim)  # Added noise for exploration\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            self.success_archive.append((self.F, self.CR))\n            return True\n        return False\n\n    def adapt_parameters(self):\n        if len(self.success_archive) > 10:\n            self.F, self.CR = np.mean(self.success_archive, axis=0)\n            self.success_archive = []\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n\n                self.select(trial_vec, i, func)\n                evaluations += 1\n\n            self.adapt_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDEv2", "description": "Introduce a self-adaptive mutation and crossover mechanism that adjusts based on recent improvements to enhance convergence.", "configspace": "", "generation": 42, "fitness": 0.24358314960891556, "feedback": "The algorithm AdaptiveEliteDEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.4940123412885222, 0.5036703080165678, 0.5060895724370621, 0.5509999357011246, 0.4869160220445867, 0.5069542048529907, 0.5067231763202686, 0.4915721551542298, 0.5279431898691451, 0.15025404109203466, 0.1625323371465256, 0.14852521492669057, 0.1300036902888584, 0.10966686084614119, 0.13086592515772832, 0.12669243668508223, 0.12407163946781607, 0.12978734288484362, 0.13833678815908657, 0.13478907414677233, 0.13598268567510663, 0.13513850013511086, 0.1453807529186696, 0.13406529390795874, 0.1508281635451627, 0.13038734282729403, 0.06974825051378941, 0.13115279928079604, 0.11534161951024635, 0.12153611768265982, 0.1392914097554221, 0.12567858188435588, 0.1349494889301528, 0.1305056302422528, 0.10508868051547837, 0.1283790747573974, 0.9911070124695965, 0.9882776026406968, 0.9933812652111921, 0.9797762320711619, 0.9934570173833644, 0.9910720438365053, 0.9933703166297175, 0.9891154901295997, 0.9877451985203857, 0.3409533140584151, 0.3311489423189845, 0.3176986115812521, 0.33599353764736084, 0.34160857319210314, 0.33200459397877835, 0.3264544915071814, 0.34034706975613016, 0.3494743710162924, 0.17208505350376768, 0.6662740382621222, 0.4499479713416966, 0.36973904762990273, 0.21323979036113738, 0.21250474577203526, 0.5826396715692497, 0.17888488357633892, 0.7235539758686669, 0.21148622484067203, 0.19390903732296716, 0.22450733410405688, 0.12459484731771409, 0.13330335228822876, 0.2030452706095367, 0.19406816568701313, 0.19276428067297724, 0.19387523447391397, 0.20678630659042907, 0.19129270444244617, 0.21883319886248287, 0.20294203891072993, 0.20498399721201677, 0.22080012947811034, 0.21854066242671155, 0.10319714348646791, 0.22014493822815528, 0.04770437757139301, 0.025131350427940236, 0.06180045780475152, 0.06822940391094767, 0.01901562064606588, 0.011464672816363652, 0.011031230309870965, 0.04741756389225571, 0.05364841049381919, 0.11710786476192625, 0.09606750272694187, 0.15569906030650216, 0.09815818092125206, 0.05695632732198119, 0.16432193769733727, 0.13067782851222542, 0.12969897177302625, 0.053677806117255034, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1231720778594999, 0.11228145706082993, 0.12005767661578015, 0.1297504389473999, 0.11672363763631999, 0.12648860782685956, 0.14099392400773192, 0.1147945838849852, 0.10792962092674785, 0.43909619465764205, 0.46900291761285795, 0.46160925646195805, 0.4397955549171618, 0.4751538696463331, 0.4468252468762939, 0.4684488737664926, 0.4530955068465202, 0.48998740443136957, 0.11663845989701971, 0.11858063483728198, 0.12412941345100537, 0.11405459010686969, 0.11391113731707514, 0.10664296240309612, 0.10974551881271255, 0.12151747577179872, 0.10125319965882718, 0.2598261150982457, 0.14195036460530996, 0.2609654954304945, 0.23722512785245364, 0.1963203900704713, 0.23621218897874818, 0.34495988157775925, 0.24502184178735475, 0.2453508522764718, 0.3133094121526496, 0.3209881309898541, 0.31349046903555144, 0.32352306061978775, 0.32274904510835956, 0.3080177174897206, 0.33574956781076215, 0.32260404827057854, 0.319515096812222, 0.24624365046286334, 0.2432496147989739, 0.23527904022980195, 0.2517285111187001, 0.18482861441059795, 0.25378707944098056, 0.2646118594722362, 0.25357182222963326, 0.25880878024227627, 0.2040529200380734, 0.20561019741781805, 0.20164480217266378, 0.1972264204446239, 0.18716323138400048, 0.1933893357573404, 0.20094247635628626, 0.19138902383551992, 0.2437199043905418, 0.2589933071876992, 0.23213537729120848, 0.19870616733233215, 0.24001634538384553, 0.2172992140462019, 0.2691447782971622, 0.21671184169780933, 0.25695870858889835, 0.24408163228800372, 0.16604431862724012, 0.17236698172138876, 0.153641648238531, 0.17745069994176155, 0.19918763431490183, 0.19981759656770426, 0.6890244631548891, 0.20918511010552465, 0.16025096316784293, 0.6604022393031495, 0.2086327787399207, 0.21129363958656056, 0.20978596948000428, 0.16702997091443683, 0.16879472429308828, 0.21355663748077358, 0.15634011889889643, 0.11291530832827756, 0.21580640071767654, 0.1919684744772434, 0.20240050932819809, 0.19392323882331486, 0.18311481934468654, 0.1720139314481477, 0.1935245183606411, 0.17514534689192574, 0.1881081000352901, 0.08590525615633982, 0.0950252265053978, 0.08665898439652542, 0.08256635266619228, 0.08770232333347683, 0.09928378851394049, 0.0954500114918061, 0.0852642299534222, 0.09012535032723012]}, "mutation_prompt": null}
{"id": "a42f5abb-0219-4b4f-8117-6afcc1cfa37c", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "292198f2-32e9-4a61-ba7f-b7701a48343d", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "5b681a21-e725-4682-8c90-b6215bbaeb51", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "e426574d-a2d1-4554-87f7-886dbccdae4f", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        \n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n    \n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    evaluations += 1\n                else:\n                    evaluations += 1\n                \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "A dynamically adaptive differential evolution variant incorporating elite preservation and a modified mutation strategy to enhance convergence while maintaining diversity.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7561984798591523, 0.770517882312169, 0.7734372015935906, 0.7628666662001531, 0.7790365915432849, 0.7646752622824605, 0.5249136230062446, 0.5679740938978212, 0.16688482748258848, 0.5050726934861351, 0.0747223791365157, 0.1412390742260624, 0.15010307146588164, 0.1553944797730048, 0.16621399982257956, 0.166804593556088, 0.13127870037692335, 0.16196286892534284, 0.1406078907874333, 0.1590802501392573, 0.16571589002413234, 0.17400007786459826, 0.49694458110416506, 0.16331348973157112, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.6649683121703752, 0.7056655428550012, 0.5924925658947067, 0.6164502599275801, 0.7399090421181984, 0.6312817827508213, 0.6435563522063793, 0.6821606149069488, 0.6740653059121495, 0.7739176698331203, 0.8580588009038677, 0.8009063276357835, 0.8545011980711691, 0.8837399053481463, 0.8481996268977252, 0.8233268442281018, 0.7938837048752423, 0.8731146479166882, 0.5883931924426005, 0.7064363937505089, 0.7085159695672018, 0.6652127368500931, 0.6606749511396113, 0.1064255229014972, 0.6809655535600412, 0.6936730973660011, 0.667232297338705, 0.6743384892876062, 0.010125445613113682, 0.691069302761207, 0.6599382322938256, 0.6714200997113936, 0.6556752429065209, 0.6845271189910311, 0.689089705805864, 0.6764630924395332, 0.582644988724099, 0.07265181972745427, 0.552860862727106, 9.999999999998899e-05, 9.999999999998899e-05, 0.5856780970153599, 0.6050473956026354, 0.5551803070628887, 0.5758719624350714, 0.670487429880109, 0.440774492884635, 0.6306642265910828, 0.6300400314641201, 0.68748034298362, 0.6945204635651916, 0.7493948444999312, 0.1229800215503205, 0.42918218897517435, 0.25731883617925433, 0.2244497554994035, 0.269816241617987, 0.07772650185101049, 0.49308503300048123, 0.4755101164685762, 0.377438035380802, 0.4082323187022764, 0.1003208768021141, 0.41407815530402337, 0.44976948317177434, 0.43946588157836386, 9.999999999998899e-05, 0.4916007840018578, 0.48078720478666415, 0.3966163551957058, 0.3510405333834826, 0.3905441086131587, 0.7836193085812126, 0.8109844909211732, 0.798454488987455, 0.7776414448536989, 0.8204551308542469, 0.7908069008460799, 0.7952688424951293, 0.709400703993035, 0.7960273867413393, 0.09667821876341154, 0.14201696057824176, 0.08888869848364067, 0.15470767167964172, 0.12014185534896404, 0.10616924214609114, 0.10594177789724057, 0.1316874978699012, 0.10597290123664627, 0.2436300116520984, 0.1912633016189076, 0.15334520180003508, 0.30267130685538757, 0.23456642136199413, 0.14375131804958907, 0.2565672906826849, 0.3070238838493229, 0.17199532566002895, 0.5237453768658886, 0.419896197823738, 0.42154612003073944, 0.5172164432320171, 0.5061810737870445, 0.463987462775602, 0.20614873144656998, 0.6396524451285883, 0.5256150728456996, 0.36923438428875677, 0.4011621756933178, 0.35967115877866795, 0.393820966425361, 0.4726738050440408, 0.3399064380057002, 0.4067200130811568, 0.3615395824639578, 0.4160067610274283, 0.18419792366424315, 0.1809005618666215, 0.17042602088387337, 0.1784700042472125, 0.18947883868748516, 0.20717174260578308, 0.19580684488818445, 0.17966283469481492, 0.2068167808433511, 0.23725532192752607, 0.22587020777180677, 0.6981175748218249, 0.7308615128683511, 0.1993201525664441, 0.6017524491493438, 0.23449874042069419, 0.22030429993949585, 0.1967928588672634, 0.21100704736939857, 0.17024764597647335, 0.15438336413287856, 0.8893662352809039, 0.19957716447203933, 0.17192094240024458, 0.17027688082464065, 0.1684110479278892, 0.915221176479845, 0.8900419942114883, 0.2098142024901758, 0.12580183342969098, 0.20728199153853522, 0.16769396273142467, 0.1539389487437547, 0.18929853904038896, 0.8735800971652562, 0.15383156085674476, 0.17426839570020025, 0.18670471851280268, 0.18266537987745424, 0.18981061388359544, 0.18378011981324682, 0.1776669540563347, 0.19185445587562555, 0.19041288013330315, 0.17182340198568946, 0.07431186046352356, 0.07878814475100315, 0.0735142773583155, 0.08227903055350394, 0.08414182016865202, 0.06643168127813093, 0.07214152633674298, 0.06956599246724215, 0.08205988623011506]}, "mutation_prompt": null}
{"id": "948416f9-a6d7-4cbf-bde6-bc4060318e0b", "solution": "import numpy as np\n\nclass AdaptiveEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.initial_pop_size * self.elite_ratio))\n        self.F = 0.6\n        self.CR = 0.8\n        self.success_threshold = 0.15\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n        \n        while evaluations < self.budget:\n            success_count = 0\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n\n                mutant_vec = self.mutate(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.select(trial_vec, i, func):\n                    success_count += 1\n                evaluations += 1\n\n            success_rate = success_count / len(self.population)\n            self.F = np.clip(self.F * (1.2 if success_rate > self.success_threshold else 0.8), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1.2 if success_rate > self.success_threshold else 0.8), 0.1, 0.9)\n            \n            if evaluations < self.budget and success_rate < self.success_threshold and len(self.population) > 5:\n                self.population = self.population[:int(len(self.population) * 0.9)]\n                self.fitness = self.fitness[:len(self.population)]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteDE", "description": "An enhanced differential evolution algorithm using dynamic population resizing and adaptive parameter control to improve efficiency and convergence speed.", "configspace": "", "generation": 47, "fitness": 0.30440983463200977, "feedback": "The algorithm AdaptiveEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.8511582336442607, 0.8574212083673984, 0.8463325406952279, 0.8832390150551488, 0.8853012627248946, 0.8790125105249789, 0.8630394617002517, 0.871765667939048, 0.8699481505008344, 0.7924530292498881, 0.7747079632859999, 0.766846600821101, 0.7567770401521219, 0.770517882312169, 0.7768883242328481, 0.7628666662001531, 0.7790365915432849, 0.75854477929028, 0.15812635918752516, 0.18334780605970313, 0.18555994489491845, 0.502544179160089, 0.07406820838158001, 0.6141053029828227, 0.15797063807673783, 0.33720203280265326, 0.254769106847903, 0.15671014601920563, 0.14055023628118612, 0.1532255793397117, 0.14212381647915295, 0.15505239202757293, 0.0988382860923892, 0.1152769185555359, 0.15461618823704926, 0.1564740528350268, 0.992181505397336, 0.9924373010851293, 0.9912502056666209, 0.9918586897282468, 0.9894002981839644, 0.992913153830542, 0.9917766982656205, 0.9915364593535629, 0.9934715418004282, 0.26776060291732373, 0.452329187746513, 0.3167635743608779, 0.6618770615727264, 0.5335276276909588, 0.4943932189500799, 0.24612327414876511, 0.4120060045595606, 0.30437447123619765, 0.25187893133179273, 0.23382402088975296, 0.3084038755670715, 0.37027920882837206, 0.2637064031476367, 0.32437419060182715, 0.3081747750138937, 0.345603738139307, 0.3623195301349992, 0.31142442511747603, 0.26294153795591824, 0.25426545388536337, 0.4265266934556661, 0.24891437389038484, 0.1068179420487011, 0.4141997177576875, 0.1944858597331961, 0.48508479917524594, 0.2509601970601568, 0.010125445613113682, 0.1725881204263695, 0.14012997857824117, 0.30082848981103805, 0.2321358663821098, 0.14943289294221263, 0.2791270490831369, 0.22353047512398383, 9.999999999998899e-05, 0.07264233813410226, 0.04227189045404245, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006992679810658098, 0.05503390364005789, 9.999999999998899e-05, 0.0755838177042153, 0.044404819938886564, 0.09783292562495227, 0.05848677026750648, 0.12066788588397126, 0.028740071594590022, 0.21953083133387996, 0.05867225524783881, 0.038066431179185956, 0.13003864900714868, 0.056116681259294254, 0.05821069850674043, 0.07772650185101049, 0.09607077576646716, 0.050140664049643235, 0.13311768478410158, 0.12103014945520318, 0.1003208768021141, 0.1970909450694035, 0.222209635240182, 0.1416353119371503, 9.999999999998899e-05, 0.2380600837538428, 0.2592693819458117, 0.1658987457829495, 0.18356987659489876, 0.19520360643449908, 0.4781892703213487, 0.5718441764745908, 0.5303024654723131, 0.571129450966922, 0.5902416384884209, 0.7143202203438448, 0.5078992318825633, 0.47597307526628696, 0.6022623258079456, 0.10033526437452256, 0.16822039339925665, 0.07279383780119209, 0.13643036128837793, 0.10827622751016386, 0.15029765728342026, 0.10657805921898111, 0.11883587666034456, 0.10508143206948428, 0.17660269884659174, 0.17891687642912424, 0.15334520180003508, 0.17736772677696044, 0.15616570209209113, 0.17244809128195315, 0.16579329970287704, 0.17183607521426547, 0.15437885674455742, 0.32992016969450855, 0.2771669530156696, 0.36386148759478154, 0.32669057312950145, 0.29031860622322625, 0.31084977136014746, 0.19399486468124116, 0.4800389587110757, 0.5190273197207456, 0.22001700601221041, 0.24558551137902607, 0.23902921936982502, 0.23091241715505328, 0.2432999664132165, 0.22031196346799498, 0.2995294075318474, 0.28591471001307134, 0.2975026811363115, 0.18089717757549129, 0.19080142379479148, 0.20717473996962843, 0.20143469686187376, 0.208219041506706, 0.2443882625960596, 0.1945489034269745, 0.1697074318539742, 0.21881933075993365, 0.21406861802590538, 0.19165740837672196, 0.2003525219158332, 0.19715414442402146, 0.24661857276055554, 0.21272782259900191, 0.22286390322690053, 0.19499765337662223, 0.2267959025508609, 0.21100704736939857, 0.14079706335968822, 0.1543833641329022, 0.9037567270314975, 0.19957714330484444, 0.1718457470044572, 0.11057395586357799, 0.16876003230681058, 0.915221176479845, 0.46221979589289497, 0.20902468753259895, 0.14703353115242213, 0.20776010626884023, 0.16769396273142467, 0.1647695205870332, 0.18929853904038896, 0.19673002944675766, 0.15383156085674476, 0.17338038745454665, 0.20219311813272267, 0.19896482512755143, 0.18981061388359544, 0.21112108705784827, 0.18607644717247374, 0.18012907327155803, 0.1816155132958045, 0.19304321890354226, 0.08686856698886258, 0.086794481845762, 0.07829462510192808, 0.06883075717435005, 0.10701587305717908, 0.08858262993631127, 0.08690933166228065, 0.08113317031836087, 0.08469205429344273]}, "mutation_prompt": null}
{"id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 48, "fitness": 0.5623255857181472, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.29.", "error": "", "parent_id": "1031fba7-e013-4ae5-b07d-46c661608594", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "b5043e34-2b0f-4860-99d9-d8cf1cd7aebf", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "794fc880-e8a6-487c-a65c-deb4c33eff4d", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def rank_based_selection(self):\n        ranked_indices = np.argsort(self.fitness)\n        probabilities = (ranked_indices + 1) / ranked_indices.sum()\n        return np.random.choice(self.pop_size, p=probabilities)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    idx = self.rank_based_selection()\n                    mutant_vec = self.covariance_mutation(idx)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "An enhanced hybrid adaptive DE variant incorporating rank-based selection and stochastic rank-based updates to improve diversity and convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {}, "mutation_prompt": null}
{"id": "a76876fa-555e-4cff-a75d-1eda951b64d2", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "5681108f-2a55-4ffa-87d1-78a1f3be9471", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        n = np.random.randint(0, self.dim)\n        trial = np.copy(target)\n        for i in range(n, self.dim):\n            if np.random.rand() < self.CR:\n                trial[i] = mutant[i]\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            elite_fitness = self.fitness[np.argsort(self.fitness)[:self.elite_count]]\n            success_rate = np.sum(self.fitness <= np.median(elite_fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.25 else -0.15)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.25 else -0.15)), 0.1, 0.95)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.25 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced HybridAdaptiveDE with adaptive scaling and crossover strategies incorporating elitism-based exponential crossover and dynamic exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.201494100253559, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.6161437962412891, 0.5426939104479703, 0.651225931829486, 0.578426631922661, 0.53794037752271, 0.45454257380816987, 0.5754426252027469, 0.583119238355971, 0.5449174557220138, 0.39928449775296604, 0.32256607748861776, 0.31015026637371645, 0.32686468296067506, 0.3928262611306078, 0.3487014909092939, 0.29949407334552003, 0.3611748892639066, 0.2932435474020667, 0.16593746243299135, 0.1469830154550933, 0.17706806195245628, 0.1554861215527762, 0.19934203183586308, 0.1594749749438874, 0.15396614603424974, 0.1410571195046244, 0.2686194045672641, 0.1288985289304142, 0.1371164607011327, 0.11459881464892241, 0.14287472604413598, 0.13551417269271138, 0.1219365762508452, 0.15616207686252914, 0.12728773553212847, 0.10999400798998737, 0.519467899448427, 0.5855372789015052, 0.7796679850842728, 0.8015694363726318, 0.9117415080435477, 0.8880443049450392, 0.8293033878654298, 0.8451535011863271, 0.9655903228543626, 0.1269369728243921, 0.07033693694423149, 0.11677940706272605, 0.12606555419770216, 0.06516987754162551, 0.14372129650356835, 0.17594684307366748, 0.11459990887318161, 0.1534756054581765, 0.21695277735493712, 0.13677214222237877, 0.17846210031600152, 0.24921149366712048, 0.2658945181690838, 0.21202111218582842, 0.15287419452129636, 0.1857592886623587, 0.18820692643463477, 0.15631547837737703, 0.13830059571400866, 0.10642561171292286, 0.10159323202516857, 0.11612733453852975, 0.13843292643859095, 0.1602920830082738, 0.22755434735866054, 0.13180962319938605, 0.12921223547971772, 0.13078135448675654, 0.11729839754237492, 0.11822168481637163, 0.1250562391388237, 0.12749584836540417, 0.1301374583022542, 0.14330386432911746, 0.1230443760949762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11286543716695341, 0.048034415619200965, 0.06883712866264413, 0.04464528302792936, 0.043010458365885795, 0.050964815219763704, 0.0954411440809606, 0.08149157940038254, 0.07839248631894147, 0.014386754075612074, 9.999999999998899e-05, 9.999999999998899e-05, 0.009668508090220018, 0.0036677919798554504, 0.00878229151710841, 0.00777712702837019, 0.01076516123444382, 9.999999999998899e-05, 0.05357885346295044, 0.037610492601802936, 0.06808494746240756, 0.05046105150246494, 0.08263078283507641, 0.04713713357845095, 0.05029110949478477, 0.06210713062341511, 0.05113746054766821, 0.3577726666769585, 0.42085530632616697, 0.42095569669931454, 0.4177055782243657, 0.3700022192429455, 0.42049548909204026, 0.4030773952464568, 0.3582485765048089, 0.4449659914777234, 0.0755099143924779, 0.08696500845167121, 0.08654499634242163, 0.08944294522544427, 0.08979800763310708, 0.07546925144691574, 0.06950001687436602, 0.07841707291303246, 0.09784444287144345, 0.14635240338087918, 0.15181326139807338, 0.1348917777106874, 0.18454541530033708, 0.14281029017253188, 0.1378251821661297, 0.14506955177784808, 0.12989143219130295, 0.17255093105555974, 0.18470717675725934, 0.1838234339665482, 0.21992166222089604, 0.22520140053916315, 0.23977276894858657, 0.22625540160478963, 0.25227028879364255, 0.2793700881158333, 0.22164697513687592, 0.128169132975687, 0.15465502385685448, 0.13555507687699042, 0.17657514666931662, 0.19440909511650484, 0.20442233840531132, 0.1553200670137872, 0.20298372010862054, 0.18071414716283396, 0.18954251632333496, 0.18762820500116362, 0.18886509634847048, 0.19529761893114916, 0.20443921462603143, 0.18080802818254416, 0.1858853533444207, 0.1823348303254606, 0.22021022239849175, 0.18113648222239276, 0.18759802260819924, 0.17338559867052428, 0.19141212365910265, 0.20106020647815137, 0.1818536084971707, 0.18758893899220197, 0.197519218069947, 0.1789356779718726, 0.17796704061531887, 0.1813614876528602, 0.20007702522756932, 0.3735468371385824, 0.1799892185215629, 0.3142136183303119, 0.2650604586079458, 0.21705624884344887, 0.33529552287135833, 0.2670672453408607, 0.2211076922059425, 0.21025815900006328, 0.2210013548310633, 0.18821255700457018, 0.17439733284062808, 0.16732258092098995, 0.260088363495117, 0.17098612562222282, 0.1723119046097754, 0.17292179751263648, 0.1718583083421381, 0.16223541809696618, 0.1798409972677142, 0.17264058944185035, 0.1686698455621497, 0.1866148931698286, 0.17258608170700773, 0.06932829890554637, 0.06336027152477508, 0.08869689383522295, 0.06233390098813507, 0.07783644236261333, 0.06752784308665538, 0.07697681964469227, 0.07067042974298243, 0.08000094102963662]}, "mutation_prompt": null}
{"id": "d1430362-433e-4c6e-8089-44e3a27a0c8a", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.current_pop_size = self.initial_pop_size\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.initial_pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.novelty_archive = []\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.current_pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def novelty_search(self, trial):\n        distances = np.linalg.norm(self.novelty_archive - trial, axis=1)\n        return np.min(distances) if len(self.novelty_archive) > 0 else np.inf\n\n    def resize_population(self, shrink=True):\n        new_size = max(4 * self.dim, int(self.current_pop_size * (0.9 if shrink else 1.1)))\n        self.current_pop_size = min(self.initial_pop_size, new_size)\n        self.population = self.population[:self.current_pop_size]\n        self.fitness = self.fitness[:self.current_pop_size]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.initial_pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.current_pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = np.random.multivariate_normal(np.mean(self.population, axis=0), self.sigma * np.cov(self.population, rowvar=False))\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n\n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                novelty_score = self.novelty_search(trial_vec)\n                if novelty_score > 0.1:\n                    self.novelty_archive.append(trial_vec)\n                \n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.current_pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n            \n            if evaluations % (self.budget // 10) == 0:\n                self.resize_population(shrink=(success_rate < 0.2))\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid DE with Adaptive Population Resizing and Novelty Search to maintain diversity and improve exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (0,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (0,) (5,) ')", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {}, "mutation_prompt": null}
{"id": "b340f24e-3526-45cc-82a6-4fc2e371936a", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_pop_size = 6 * dim  # Reduced initial population size\n        self.min_pop_size = 4 * dim  # Minimum population size to maintain diversity\n        self.max_pop_size = 10 * dim  # Maximum population size to adapt search radius\n        self.current_pop_size = self.init_pop_size\n        self.F = np.random.uniform(0.4, 0.9)\n        self.CR = np.random.uniform(0.5, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.current_pop_size, self.dim))\n        self.fitness = np.full(self.current_pop_size, np.inf)\n        self.elite_ratio = 0.3  # Increased elite ratio\n        self.elite_count = max(1, int(self.current_pop_size * self.elite_ratio))\n        self.sigma = np.random.uniform(0.2, 0.4)\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.current_pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.current_pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.current_pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.current_pop_size\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.2)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.2)), 0.1, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.1, 1.0)\n            # Adjust population size dynamically\n            if success_rate > 0.5:\n                self.current_pop_size = min(self.current_pop_size + 2, self.max_pop_size)\n            else:\n                self.current_pop_size = max(self.current_pop_size - 2, self.min_pop_size)\n            self.population = self.population[:self.current_pop_size]\n            self.fitness = self.fitness[:self.current_pop_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid Adaptive DE with dynamic population size and self-adaptive parameter tuning for improved exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.4183776009553797, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.32.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9321655542439361, 0.6688973869388779, 0.9546048126860697, 0.9509395619738512, 0.932489076832657, 0.5598767369762829, 0.9519889815639608, 0.9415329128720614, 0.9496055277812594, 0.309785805994077, 0.9009414026909152, 0.31197985279059626, 0.31384328015129004, 0.864900325523405, 0.8793793716049906, 0.08259813836439056, 0.911245117884219, 0.8714745928425724, 0.16129971971065593, 0.24542953711999294, 0.14831539429279217, 0.1255215037198213, 0.155333109962566, 0.2233389824634432, 0.10781723568872725, 0.1731107340634036, 0.15405513073244692, 0.05926200412302973, 0.10884219044963916, 0.10657498474659843, 0.055489039169499654, 0.06994559045029058, 0.13930093013422662, 0.14108530641897632, 0.09439914507283886, 0.10336281028432637, 0.9884196987312978, 0.9678047175698392, 0.9864132479817972, 0.990081187020565, 0.9745755111659271, 0.9826705915156952, 0.992042254415521, 0.9806466162495399, 0.9879819823871898, 0.8543702372464009, 0.34878249690480123, 0.302367966971537, 0.8617424039123895, 0.49902857620489616, 0.842772583517595, 0.854390758721959, 0.2580854935764696, 0.5949145359362316, 0.21153348522880178, 0.9502471893566727, 0.22876984603374761, 0.9534513646605862, 0.9612969769731186, 0.3905617125657984, 0.9448647659227412, 0.9581045606297501, 0.9429138108949731, 0.17168514053112505, 0.21158412336730215, 0.1343517244201501, 0.13570866524587233, 0.5090210309966698, 0.14325310549834758, 0.2641483392493762, 0.33683580870554575, 0.36170648120991666, 0.13169659141085088, 0.22107432607393407, 0.2817224694586633, 0.17014104448842604, 0.19138387466621065, 0.31917053879299706, 0.6093176445873527, 0.134580895313146, 0.2243648340231218, 0.8974473466451766, 0.11775769840583161, 0.8950816161932915, 0.8618735146893004, 0.3871908981211044, 0.26786660135552165, 0.2823516491080965, 0.33826698655937193, 0.14423057379404414, 0.8119662075989599, 0.926940347618717, 0.9281084535711845, 0.9159204131676287, 0.8823469662330513, 0.9087205900158816, 0.44210630293063613, 0.911692599592375, 0.6515505803230315, 0.04207245964672879, 0.11544288923800816, 0.1067203131210348, 0.6569248113736923, 0.37922435833018453, 0.6995530111975039, 0.4271998587508551, 0.14741972047101004, 0.45144206041447854, 0.004270575984626879, 0.8729637486706918, 0.3500251997539201, 0.19786788226778396, 0.4742693145904474, 0.8217755739211181, 0.43010199585884645, 0.6281715146005894, 0.6852787979837701, 0.461581509969864, 0.9413964747950092, 0.5395201484505645, 0.6650327801343892, 0.940590777666766, 0.9349881288233609, 0.9399168280211829, 0.9426261654735633, 0.8139351518562699, 0.14495445266874285, 0.14416955149523747, 0.0887860746404745, 0.10736555991009356, 0.11817487435961616, 0.11137173685756274, 0.10133101364943453, 0.07753305446152603, 0.10469927489413144, 0.13022345232084676, 0.19488964626245142, 0.1335106010257483, 0.1935078124852153, 0.1827870480482875, 0.1361863950869756, 0.20317199454268198, 0.1340791400332777, 0.19976493741475831, 0.39194819783766, 0.5154183166844695, 0.4944966342218686, 0.29591251298353494, 0.41344639016672613, 0.38199333781877787, 0.29263898911834507, 0.25789729201812217, 0.3473775583942287, 0.34862182683477205, 0.4078858695323784, 0.24870863853974268, 0.8197073528711829, 0.521941995070285, 0.4857680814883958, 0.236842394672374, 0.22709746310662604, 0.38445283376607264, 0.1992728894169732, 0.18412794601790228, 0.24359456780055544, 0.18631439944563266, 0.25500079257809016, 0.25911495720606603, 0.2340913652794262, 0.23703686463458673, 0.2313931147069579, 0.18169088005515366, 0.2233022445832873, 0.17923457052666003, 0.20912926772009877, 0.22265576409410492, 0.20926793591158666, 0.24050496226427054, 0.18247494093384897, 0.20947286261775278, 0.1889254763826299, 0.9406082586470647, 0.18761138803226596, 0.16694249426353458, 0.14818823949066773, 0.20051699807002865, 0.16699690750933438, 0.9322402043934078, 0.1680179544387087, 0.20922592474569934, 0.16978241955712614, 0.9382172521616979, 0.9085031503888087, 0.16867662201013645, 0.21069400128391913, 0.11266098849614048, 0.21392812615694334, 0.9539602552411584, 0.18868560032455128, 0.20081882166511977, 0.19991547166214985, 0.20841074735404208, 0.2169108063781584, 0.20561729348571312, 0.20039079513993363, 0.19434913499883866, 0.19408558182732194, 0.11035018120401596, 0.07239621580501132, 0.07879267345161767, 0.09764324261346768, 0.10930689808517913, 0.1024435646258014, 0.08014595689793624, 0.11473357578653742, 0.07948155676877233]}, "mutation_prompt": null}
{"id": "3eea3e2b-cef1-49d7-a695-f34ee4a25740", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "989a777b-7293-4ead-bd0d-b9ba8b69fc45", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "c5400a7b-0295-4aae-9b7e-536d855eea42", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "4a855178-8e68-47dc-acb4-dd289c8eb592", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "79f11b19-a277-4e7f-ad2e-2660d54ab541", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.7\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.learning_rate = 0.1\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        direction = np.random.choice([-1, 1])\n        return a + self.F * (b - c) * direction\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def adjust_learning_rate(self, success_rate):\n        if success_rate > 0.25:\n            self.learning_rate *= 1.1\n        else:\n            self.learning_rate *= 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.3:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F + self.learning_rate * (0.2 if success_rate > 0.2 else -0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + self.learning_rate * (0.2 if success_rate > 0.2 else -0.1), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma + self.learning_rate * (0.1 if success_rate > 0.2 else -0.05), 0.1, 1.0)\n            self.adjust_learning_rate(success_rate)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid DE with adaptive learning rates and directional mutation blends global and local search dynamics for enhanced exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.5011196028419123, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.30.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9207660214128395, 0.921990769098624, 0.9222261304397505, 0.9150486984671394, 0.919418029178215, 0.9209453069208967, 0.9040554153545224, 0.9307336241838476, 0.9104302904530687, 0.8329538349806493, 0.8489533233052224, 0.8261682237518856, 0.8131967578775918, 0.7856459963360126, 0.8416815310472652, 0.8172613031855166, 0.7990360005173283, 0.8395657047741198, 0.3587191194159156, 0.124392810141567, 0.1446675400846652, 0.1671568148203696, 0.15072709942741025, 0.14050379830186144, 0.15200142548428208, 0.4683187503798867, 0.18431105961748084, 0.09902891377566525, 0.1224354412158416, 0.07978880676201427, 0.11113429411740294, 0.13306659527593112, 0.0992511466585203, 0.10902921052302006, 0.13072911453144442, 0.11058673116234152, 0.9783280555831633, 0.973047786484379, 0.9646359804673262, 0.9495502590871232, 0.9629360110945695, 0.9867535216829745, 0.9388164631730358, 0.9651729892278816, 0.9787240398322711, 0.6899281091243761, 0.6646743869655057, 0.6591097791731546, 0.700503651392606, 0.68220643925075, 0.6527997721205236, 0.7047739833513489, 0.669187696841732, 0.6835553040740703, 0.22970550928141542, 0.23038719292932808, 0.8724560907653238, 0.8999052046969437, 0.2138312899080964, 0.8321061843049478, 0.2343218700771157, 0.9202594672836906, 0.7897418701095159, 0.7683964010615827, 0.13515076882621246, 0.5931148401822551, 0.6762687180479492, 0.5807209609580701, 0.4337850841126074, 0.5623370708110167, 0.6452005370577154, 0.5212273419701967, 0.6628610222293407, 0.8083140357809415, 0.6272529552331134, 0.5490436636463627, 0.6311311560382733, 0.6361276641482667, 0.6527732532019982, 0.6327359935027697, 0.5885583369174903, 0.6807732138207718, 0.6646554081479397, 0.6714880494812795, 0.7036209345400354, 0.6825513975948023, 0.717656610323411, 0.6309554998181568, 0.7289172824859421, 0.7049047389139804, 0.7238899692091734, 0.7682434215664226, 0.7812558134932808, 0.7257527170720889, 0.7166383089784789, 0.7117778913975462, 0.8097986692004508, 0.7164080299912151, 0.7709762448295807, 0.13714003842518974, 0.5152530388737603, 0.1824475087925571, 0.6251809423383767, 0.6110643502178432, 0.606088955585893, 0.18881931438688848, 0.22672072988390923, 0.29474342794306563, 0.5373691452788254, 0.5719006950589833, 0.5116913188643897, 0.598119527255593, 0.6525728571193271, 0.5895158626011612, 0.5811445969268736, 0.5888208439071223, 0.5513914894772847, 0.8905711269654473, 0.883549600845994, 0.8401393910464203, 0.8601309098056231, 0.8321642678890647, 0.8445022684736326, 0.848465974664137, 0.8665521570565636, 0.8844633141030074, 0.0966007179340379, 0.08665002068088068, 0.14413074903917045, 0.14001760571336452, 0.11165675931042274, 0.10968436548171434, 0.12900181888067686, 0.13075155376976566, 0.13629726881932092, 0.1559765145079689, 0.13244677806353988, 0.14511020847054223, 0.15960094492857246, 0.14560489331003956, 0.1311928290397294, 0.12351081111855089, 0.12379104462018187, 0.15060598627683608, 0.42500397459045103, 0.5685009062033944, 0.6062211718455164, 0.7061844853234183, 0.6686305874259464, 0.7020428719463485, 0.6647911715542999, 0.7062076972767872, 0.5679391051241403, 0.5303388020733826, 0.49043269321992544, 0.4882475882907905, 0.497959604385668, 0.4470334965852222, 0.5550211669449264, 0.44035742705119385, 0.49702209470483205, 0.4188892973592033, 0.2238367233437778, 0.22748434519864924, 0.26576183605878567, 0.23402008752275572, 0.24528288370316387, 0.24504497047437723, 0.22263078623393973, 0.22128729601201447, 0.22962528584819875, 0.1976513235376377, 0.1962338651483725, 0.19890931409937007, 0.2095093187297974, 0.20847017001891177, 0.21180402017499755, 0.19900589297178128, 0.19419524171268954, 0.5112650670464711, 0.8115120964829765, 0.1878554177720584, 0.18773036089627393, 0.8827082340792823, 0.8278459735652508, 0.19805225017410144, 0.856689794124192, 0.16064374940987314, 0.8667419066910151, 0.9392269878254846, 0.7620769876751827, 0.8882966961081898, 0.7693877717321991, 0.21026361441356656, 0.16761161813061787, 0.16601647852813695, 0.8924357720250469, 0.8796221312557839, 0.18928719171435227, 0.1846380006221141, 0.1796945659248138, 0.2060915113381886, 0.18199482334898798, 0.18795043835786862, 0.1769214191699935, 0.1798779622323533, 0.1845466866319142, 0.09039249180319553, 0.09845274602525877, 0.07550965975461876, 0.08916707856959949, 0.08865904449723216, 0.08447471589511513, 0.0909068721313111, 0.10027493131405829, 0.1036705942854278]}, "mutation_prompt": null}
{"id": "a25357be-c25b-44a6-84b2-ad2f4c3aca62", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.dim_adapt_rate = 1.0 / self.dim\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def dimensional_adaptation(self):\n        return np.random.normal(0, self.dim_adapt_rate, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec += self.dimensional_adaptation()\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced hybrid DE with dynamic dimensional adaptation and adaptive selection pressure for improved exploration and convergence.", "configspace": "", "generation": 60, "fitness": 0.22665741310932688, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.4371703119452399, 0.4286886405378383, 0.4369395210939859, 0.42422368637627283, 0.40085174839830995, 0.43012657561125933, 0.44006548321340855, 0.41393109820440455, 0.42405979350747325, 0.037445433422976016, 0.06968271987478802, 0.06155434482376043, 0.04667756587538019, 0.10550653634749307, 0.04692830435993345, 0.04922482096553371, 0.07216592217200157, 0.06472671145207476, 0.13515931493104072, 0.1240682840295333, 0.13908472551645357, 0.11672295257361132, 0.1107132618278105, 0.11494089366120552, 0.11582034850124023, 0.12458977920891412, 0.13401821122571822, 0.12474551294884062, 0.0916373306514946, 0.10807709288038769, 0.10843713587087334, 0.11562033359106882, 0.11662940097580954, 0.09912802800390363, 0.10840801279058054, 0.10404168684807791, 0.9860884228461603, 0.9866750704130899, 0.9904692389509068, 0.9915855300346238, 0.9893478856439761, 0.9858286324208156, 0.9880469634514737, 0.9860034505294197, 0.9945607187161648, 0.2744951848032352, 0.3104160966989633, 0.260151227399546, 0.2856530790715375, 0.2695817085058826, 0.2722609378077957, 0.26992149396389464, 0.26809130169254236, 0.2605040300703466, 0.35741718875542705, 0.3235223584190564, 0.3299140779568078, 0.3656766432747697, 0.33177874423427, 0.5133990473214836, 0.3422402258796845, 0.32104958018925434, 0.29345207774952164, 0.158705649944202, 0.16969921335515992, 0.17101990592590555, 0.155836244255945, 0.1499877703904987, 0.17668409287640185, 0.1739197134675372, 0.15834843862418913, 0.16374876098423952, 0.15853771291998242, 0.1737500363916863, 0.16925591149491648, 0.1551345721076084, 0.16881285776682686, 0.1652595178599744, 0.151888335270296, 0.16686842378748423, 0.16700470306196313, 0.026880752716442302, 0.029601334976417593, 0.024081506851217238, 0.007716349329245142, 0.05435416360406675, 0.00046029685764259476, 0.014307545499282037, 0.006356797683454318, 0.06758472162874385, 0.15532978992619428, 0.09113996072749264, 0.1028522949150894, 0.11509991693227917, 0.08713210397678817, 0.09631692593225982, 0.17784199947235357, 0.15509756187796853, 0.15168262928239984, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09107604362294208, 0.09923751823465266, 0.10654856037171379, 0.11201965147496062, 0.10192476111944693, 0.1010738168007318, 0.10275813462506811, 0.08854888346367173, 0.10271186563326296, 0.3965143806973358, 0.38541792033483857, 0.3944928869351517, 0.40583088408517987, 0.4036486156414637, 0.40751526843894603, 0.40266510035226843, 0.3934154938265154, 0.4037401469140147, 0.09868960418109851, 0.09795594764519466, 0.10658994669649513, 0.11927570865432213, 0.10742893612179871, 0.12999434983011615, 0.10258897873233541, 0.11701114714781347, 0.10294248039941689, 0.13611738826479447, 0.1387049226864323, 0.13420561599147818, 0.12736964557922148, 0.14067835482360624, 0.16206560781216506, 0.1543978994750843, 0.14293271156336962, 0.16576968023737115, 0.28030808478422387, 0.2801400776885892, 0.28340948743788463, 0.2936447653464056, 0.2770285250728197, 0.2904338477057774, 0.30270675552504667, 0.281208833867695, 0.2873957621470573, 0.2122601095445089, 0.23838810041388048, 0.2382912085876432, 0.21782898330643452, 0.21575560576542607, 0.21914612558262148, 0.22162805229999671, 0.22451866149910515, 0.22816786623416319, 0.2198195257572736, 0.2259758010933367, 0.219478007037206, 0.21473039730817722, 0.2287313008495192, 0.19470823614259003, 0.21336761554938255, 0.20586799945988987, 0.22135021094218377, 0.1890483237003221, 0.19213788568938794, 0.1793839669467021, 0.1998840846382085, 0.1926694128708557, 0.18821230851144477, 0.20530936505939967, 0.20951576477438227, 0.17853730993411931, 0.18777046381356743, 0.5966662994649573, 0.15338984480523687, 0.6456849671743387, 0.1997560573731587, 0.11473928408139344, 0.558884608076892, 0.4464687586548495, 0.156904168508902, 0.5637700731043966, 0.504410468847887, 0.5080846340394803, 0.20978028600879317, 0.5676573604207422, 0.20465273022057318, 0.1048141799569976, 0.15533757211659172, 0.21265555916753887, 0.18603838802199368, 0.18825396846306708, 0.18981700475153007, 0.20279058248103943, 0.18557943073754868, 0.19206230022558812, 0.18667265070481376, 0.17462011183161885, 0.18300928036444553, 0.09929695584397435, 0.08036478127417335, 0.0819765467776078, 0.08978020166906375, 0.08424999315796122, 0.07990268573291992, 0.08701586322328692, 0.08240244719556189, 0.08875254214067796]}, "mutation_prompt": null}
{"id": "83422e86-291c-43f0-b575-890eaeb82fb8", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "14604fad-6a31-4772-ae3a-4b0c2290da31", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "8d9f783d-b2f7-4faf-b258-c3e11a86b6a8", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "0b109966-54a2-4a58-b3e3-298b05ee4324", "solution": "import numpy as np\n\nclass DynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Increased population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.15\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.2  # Reduced sigma for more controlled mutation\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n\n    def multi_strategy_mutation(self, idx):\n        if np.random.rand() < 0.5:\n            return self.mutate(idx)\n        return self.covariance_mutation(idx)\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5  # Regularization\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.multi_strategy_mutation(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.adapt_parameters(trial_vec, i, func):\n                    evaluations += 1\n\n            success_rate = np.mean(self.fitness < np.median(self.fitness))\n            self.F = np.clip(self.F * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.4, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.7, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.05 if success_rate > 0.3 else -0.02)), 0.1, 0.5)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DynamicAdaptiveDE", "description": "A dynamic adaptive DE variant with multi-strategy mutation and enhanced parameter adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.456946928844326, "feedback": "The algorithm DynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9369055137484462, 0.927785554787858, 0.9275787796889645, 0.9328074156526386, 0.9245354096285094, 0.9369219640164661, 0.9360699627256531, 0.9057016764729711, 0.9104099767785463, 0.6654604160061974, 0.6366249288782172, 0.4352782209481896, 0.7163603988999632, 0.5634624929926715, 0.7010980244967429, 0.7172235894165606, 0.6773458929879292, 0.5444490814626618, 0.15993145815773258, 0.1628402090433656, 0.159579457421404, 0.18973366939256986, 0.10180554450960777, 0.1619098558384896, 0.12829407394124537, 0.14468465051682666, 0.11906202622580297, 0.17742199006716963, 0.08711885071639736, 0.06436417347391177, 0.09828841148511169, 0.11570316370088896, 0.06130102903232304, 0.10456223005873055, 0.10615933028528468, 0.06073139500755931, 0.9888283723283527, 0.9858269867453043, 0.9894174114388883, 0.9903573239874154, 0.9852573674528242, 0.9881279326955835, 0.9889294258441107, 0.976315720025512, 0.9908597755819069, 0.6706870253437524, 0.5484379734744884, 0.6103989801336271, 0.5785786125034333, 0.5447476192933455, 0.5712323392992511, 0.5288358457885391, 0.5796627833512802, 0.5122298276494286, 0.17286689421750578, 0.2556550535513096, 0.9685402976845667, 0.9594828958605174, 0.1976807246866783, 0.214982500907676, 0.14096139983698863, 0.19742869693920106, 0.9057209058446839, 0.7529443745464726, 0.5935710887519291, 0.13738367936137352, 0.7708126228194587, 0.7165982139684717, 0.7920909559117453, 0.604298215200969, 0.8175790629889564, 0.7332630955469178, 0.754121659301469, 0.6410166993180566, 0.6842421666315717, 0.5868198309860786, 0.7474061312079163, 0.7994353864678364, 0.7676336302236441, 0.8247073412170127, 0.7323980423331389, 0.6975432955196432, 0.45705600859688533, 0.5151125135475769, 0.41943794066494333, 0.608649041322822, 0.5241563436368679, 0.6904883949589719, 0.5743587975827402, 0.5976550353626473, 0.7215951037575041, 0.5792968854458167, 0.7567026294336299, 0.6369309529752946, 0.6172334158797002, 0.6996169285418772, 0.7425653521650704, 0.7151118234234377, 0.7788828970766186, 0.46539385044911774, 0.3997363708572993, 0.5600586038035889, 0.6250410102379036, 0.6089107391008739, 0.395486830407762, 0.38884596795451465, 0.19702648973994352, 0.20818582862483548, 0.5327136003974625, 0.5369248707508372, 0.4624558671105047, 0.3260986808946025, 0.5500576519123344, 0.324509097169154, 0.3824987370445124, 0.3815838288409974, 0.3964966586405917, 0.8883977984283965, 0.7946385638636546, 0.8770795727380776, 0.8842949521463856, 0.8117647259582105, 0.8526519755293442, 0.8768682507216428, 0.6436622789491606, 0.7570871936487265, 0.1357949490469198, 0.11107850486972803, 0.11834904709532679, 0.11155700500149635, 0.1565372071565977, 0.1875107271932368, 0.11143122913440551, 0.1862120366183886, 0.15865081869021802, 0.2327200120091123, 0.13692792824512812, 0.23988971323556174, 0.2550583870572425, 0.6813203806799905, 0.3085752269919615, 0.7101730803914362, 0.5546476707731864, 0.17734641663571515, 0.5490851936908936, 0.45144160615219076, 0.538400289133621, 0.49415866784099893, 0.41058711175836493, 0.27958709783669333, 0.4842031814501211, 0.3087312663435231, 0.4707741989372476, 0.2512405120729615, 0.49218174278551996, 0.4592782094180575, 0.2849655499051501, 0.22283839248574955, 0.4551207133710201, 0.4453473707771468, 0.29792361753913443, 0.2779062139257352, 0.26868227792597377, 0.22880558499079973, 0.21839306836313122, 0.23677030193988258, 0.2366798602610829, 0.23325799815482584, 0.266182422524863, 0.24047749600033208, 0.23921374245898652, 0.22530096795886634, 0.20716797319735003, 0.2105263334962758, 0.21724795949807696, 0.19056285290190145, 0.22373913026160697, 0.19568463029880423, 0.21516806014551892, 0.1889608270618126, 0.18909616428556641, 0.18849306687499578, 0.17591406371240736, 0.1586805258408256, 0.20032571521470832, 0.11493402516855344, 0.14115550444880154, 0.1655765139494184, 0.948251894794067, 0.9498094572698285, 0.929269396317668, 0.2134592792686888, 0.11301719344039118, 0.1672377099879988, 0.1688451257600887, 0.9092931026371047, 0.16884055147751564, 0.9446346001114452, 0.1769147812259746, 0.1871721931102367, 0.19530936743641147, 0.24346885130841645, 0.22891809144058384, 0.2312577791204259, 0.27375552240606704, 0.1899388360901666, 0.1831162232459317, 0.10635088782208824, 0.1295167290610414, 0.15661272780312518, 0.1063889926956606, 0.11082323753518963, 0.09190298246313, 0.1118480690813296, 0.0934243822680757, 0.0878632584853305]}, "mutation_prompt": null}
{"id": "b66c59c7-6914-4b39-85f3-38b7088c6b74", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.dynamic_elite_ratio = 0.1\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_count = max(1, int(self.pop_size * self.dynamic_elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.3 else -0.1)), 0.1, 1.0)\n            self.dynamic_elite_ratio = np.clip(self.dynamic_elite_ratio * (1 + (0.1 if success_rate > 0.3 else -0.1)), 0.05, 0.3)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid DE with dynamic elitism and adaptive mutation scaling to improve balance between exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.5463656506740099, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.33.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.920662600591921, 0.9390787990728958, 0.9236556953674303, 0.9313862757864078, 0.9328440309915215, 0.9364799824519733, 0.9241969837726017, 0.9344597752910759, 0.925237946914667, 0.8500555883956639, 0.8326558989365014, 0.8278592289050904, 0.8284934833684785, 0.8098888484232493, 0.848908741911359, 0.803942644844337, 0.8398558131824776, 0.8156773143551375, 0.15516624719740524, 0.13519218289009183, 0.12063651652861662, 0.113916426512645, 0.17817860392643503, 0.17235553218713828, 0.15648534539565595, 0.6896510578395325, 0.13962757102302714, 0.13553220248294706, 0.14408039159462682, 0.14249287941754496, 0.10684489863065316, 0.1325392428923131, 0.07575955378310573, 0.08733473826713856, 0.09148837241234087, 0.10771350084229447, 0.9954369393692317, 0.9944002400630058, 0.9918853231263095, 0.9918863429134629, 0.9924938094808455, 0.990603005887067, 0.9887965426656036, 0.9912499286863624, 0.9901924501800037, 0.7582230664872586, 0.7244128999578674, 0.7151596994989345, 0.7383372109151919, 0.7290732970890299, 0.7551852253623413, 0.7815540200089266, 0.7499386293631425, 0.7441271235113393, 0.9414158389672681, 0.8993338022025092, 0.22839757882571488, 0.22493932178426734, 0.9490314689253302, 0.2149944763302507, 0.9162701009185586, 0.8758321866064526, 0.9390477194034801, 0.758120514689292, 0.8524763008383331, 0.7632740605251497, 0.7848906788455255, 0.7887539991133838, 0.13563858509571802, 0.7890170827187346, 0.8387904923462605, 0.8151701892897258, 0.8062021799568533, 0.13638193739903104, 0.13611958343029706, 0.7877430495935361, 0.7938738203034095, 0.728885786192418, 0.1364511209345428, 0.8174704299487789, 0.8279112665034349, 0.8127994185593607, 0.806445752826612, 0.8270919595380207, 0.828140388162899, 0.8271470400553893, 0.8334135325035547, 0.8204165515287167, 0.8205130341020122, 0.8402359469448826, 0.8732308197568166, 0.84937403269291, 0.8724664255873007, 0.8594100081072696, 0.8565344547448555, 0.8610460344113902, 0.8657674703788718, 0.8681659160841773, 0.8759980033954615, 0.6653809364626686, 0.6565036046181438, 0.724711158445809, 0.7819036430761817, 0.7689858043389544, 0.7678325159487769, 0.5872789893516686, 0.6558078939482785, 0.6979635522438765, 0.7859041467855177, 0.7614143862200811, 0.7553149385897067, 0.7554800476125759, 0.7547032041572984, 0.7636553694355799, 0.7733392645020805, 0.7531959328802067, 0.7644725597441546, 0.9173440099232647, 0.9213196153595162, 0.9179474526994698, 0.9141671593567587, 0.8939490451151393, 0.9010173303011598, 0.9069595493785865, 0.9137958096705422, 0.9121594614528183, 0.12435049928395259, 0.13523450662413905, 0.12303563942738671, 0.1527746609680315, 0.1492865056270497, 0.1798717334453639, 0.1187458980705205, 0.1224221018816053, 0.17699619050230964, 0.16268061486953755, 0.14508484891444373, 0.13271726730356626, 0.1852303154123549, 0.15469893956647318, 0.1365569913476793, 0.1439560681182267, 0.17348287190887257, 0.12802672556258965, 0.7036373953834574, 0.6855939735660704, 0.21661684336967701, 0.7001301430412381, 0.7449073932553137, 0.7111332108129194, 0.6828507109560265, 0.7155248412675106, 0.7456021711056182, 0.29223742634655325, 0.6582679996484853, 0.6719041072717156, 0.6556236050451614, 0.6335548448939432, 0.6664668689005037, 0.6312828919667033, 0.6319038286784939, 0.6788333898462614, 0.24613849707616708, 0.2356498364969961, 0.19886645067700737, 0.2539834391189484, 0.2361953404187801, 0.27003578482284685, 0.29113395305502376, 0.23295755340554225, 0.28152056850919294, 0.6703296042188924, 0.20566839615481725, 0.20989345637993906, 0.21905800969674338, 0.19335148003673464, 0.23322647515118733, 0.1831286652787517, 0.201634519312356, 0.2029428658311513, 0.1881467552970677, 0.18903348075013926, 0.9168712673969767, 0.9562503518502085, 0.1975089051240625, 0.16186512535839537, 0.8241117049482022, 0.16607776034581168, 0.20886726739146166, 0.9470733361314205, 0.21048164371438438, 0.15600246471902135, 0.20656285238198646, 0.16959777003265486, 0.21135537342951005, 0.9147553336949149, 0.9273083692566739, 0.21373985176608146, 0.19972486903162712, 0.2020902066247835, 0.1680923066624026, 0.20799514565383692, 0.23045615009271725, 0.22843335323057523, 0.21237494287436798, 0.18410276171616757, 0.21149299510899466, 0.11412641740425244, 0.09446001521221237, 0.13683656830112123, 0.10781145425652816, 0.11005336336357008, 0.10553244752568358, 0.09734742108289551, 0.106911480975584, 0.1041616994092106]}, "mutation_prompt": null}
{"id": "fd198cf3-ee89-48db-aafe-08eb5c3ac22b", "solution": "import numpy as np\n\nclass EnhancedEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Increased population size for better diversity\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.9  # Slightly increased crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.3  # Increased elite ratio for stronger exploitation\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.5  # Increased exploration capability\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def neighborhood_mutation(self, idx):\n        local_indices = np.random.choice(self.pop_size, 5, replace=False)  # Local neighborhood search\n        mean = np.mean(self.population[local_indices], axis=0)\n        return np.clip(mean + self.sigma * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.4:  # Increased likelihood of neighborhood mutation\n                    mutant_vec = self.neighborhood_mutation(i)\n                else:\n                    mutant_vec = self.mutate(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedEliteDE", "description": "Enhanced EliteDE: An improved DE variant utilizing adaptive neighborhood exploration and dynamic parameter tuning for robust global optimization.", "configspace": "", "generation": 66, "fitness": 0.3333995694251995, "feedback": "The algorithm EnhancedEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.7363219465240762, 0.7138032477589118, 0.7689190795915737, 0.7213600944104319, 0.7211595764259302, 0.7316528634574583, 0.7505110379953581, 0.719073644308941, 0.7391387076197337, 0.47658165484988235, 0.4537375691468978, 0.4642112363832447, 0.36322722136249486, 0.4687516960741155, 0.4487142418982689, 0.47335995868535197, 0.4810009159627051, 0.4892473393742771, 0.12889477624147838, 0.17416149134443126, 0.12019497292002812, 0.14030033374132111, 0.15563873188669275, 0.15839260429839574, 0.1317043837032028, 0.20220649324004714, 0.1365460821334531, 0.1238514854046231, 0.11725806093173685, 0.12037711497769887, 0.110660082438367, 0.11579389602610624, 0.11379227262008695, 0.10938218227049057, 0.11294076130193442, 0.09234001376865131, 0.9875838496016692, 0.9839446520449293, 0.9915583641928174, 0.9815639027010591, 0.9787351770871053, 0.9906989379932115, 0.9753539646223481, 0.9866909035723772, 0.9880196203919912, 0.3702595806775868, 0.36630369157017095, 0.36528975461044955, 0.3479448334315589, 0.3428787387282186, 0.36175763216889634, 0.38461005099806156, 0.3514094330025863, 0.31210357058835536, 0.7266256010729423, 0.6177819444506361, 0.6552125797096624, 0.6810198565767889, 0.673346337429733, 0.6966169180883928, 0.6412484833767744, 0.6083101469869301, 0.6618094666798877, 0.3047583933300927, 0.3018414283717561, 0.30577485110164304, 0.31830189871412695, 0.3068419359603045, 0.29799467448408845, 0.3361855307591459, 0.3131490989720054, 0.3046383388040945, 0.33703475387102366, 0.30831858141297086, 0.3601237004144041, 0.34991116216214013, 0.34333266406172647, 0.3662668943969868, 0.35856442492852747, 0.32629418979917213, 0.3392439887811636, 0.13642409486996, 0.16690895182080256, 0.18975396242367082, 0.20368495036746304, 0.15870905877888186, 0.24666894022610775, 0.22141399638450998, 0.17562534456075118, 0.23903935644235041, 0.34488232974039024, 0.3067024678215876, 0.34947258794879144, 0.3357191286250104, 0.3614998428625136, 0.31945148460678197, 0.3521913630773571, 0.41001439380402294, 0.39249722371364504, 0.09241419277993923, 0.08345904938916715, 0.05367134738349999, 0.14881492395906193, 0.11324928682362356, 0.1191949395801235, 0.0774012183890227, 0.06581703717521503, 0.05370014045042537, 0.1880134698854251, 0.2164491260748146, 0.21316842067579445, 0.2072367054116686, 0.22093068034391594, 0.2240006339132502, 0.18135560497996672, 0.194925569844972, 0.20087951916747993, 0.5711323876634908, 0.5831719753025835, 0.5706476686773972, 0.5702635445968129, 0.5609223410526771, 0.5607347500476281, 0.5627056988453012, 0.60354292856311, 0.5809428687429433, 0.09242305655205418, 0.10140532560710303, 0.10528020926660686, 0.10105099508302195, 0.0883182182754726, 0.10674355473484953, 0.12784725171484335, 0.10668111197641972, 0.10453558896874748, 0.17840214435154955, 0.1337557073537513, 0.24630227729266851, 0.1814058668748133, 0.1406147680214188, 0.23724852801987228, 0.14637295719272714, 0.14089187405744563, 0.13630962330457297, 0.3407362869795385, 0.32279337589254553, 0.31183170345345634, 0.3201421052809337, 0.3221815025749142, 0.32699213084608736, 0.32243461066843615, 0.3148391065832149, 0.311208398601759, 0.24918239223092753, 0.22556468282532538, 0.2341757568862014, 0.27893225527566523, 0.261984977736168, 0.24107896911151505, 0.27290570080403864, 0.2658914242582735, 0.27312225267476375, 0.20649929388195198, 0.21296744916864763, 0.19168033225159786, 0.21253956665761586, 0.20997665659069897, 0.19462523439022994, 0.2142962288690039, 0.23303331241375713, 0.21961244425102588, 0.19954009279371254, 0.18842568875752363, 0.1831602976014567, 0.20714860472844043, 0.19622525120359946, 0.36264480673145794, 0.21124924918084653, 0.18663505211201026, 0.19725797183396876, 0.18624347369477467, 0.18123922766478218, 0.7154378119756177, 0.8181996917491854, 0.6469013026267632, 0.791138996791827, 0.666684008559265, 0.7565760506674529, 0.7190822768048417, 0.7978513231269936, 0.20710307673540373, 0.696343892413245, 0.20376011434373653, 0.20835990432054297, 0.20396529067882707, 0.20910487507097764, 0.2081660987100098, 0.1666649028304169, 0.18280694425388522, 0.17540382685022737, 0.1805464512476227, 0.18617905705285953, 0.19010384841198158, 0.1903843290594509, 0.1771094474832502, 0.19100871919841145, 0.20036090069999613, 0.07677332725631691, 0.08108521988378503, 0.08759496872136574, 0.08211149451841027, 0.08085720685070175, 0.07694985855657344, 0.0816621618654011, 0.08077768633161575, 0.08879722253449507]}, "mutation_prompt": null}
{"id": "60b29b92-4142-4eb7-a43f-b95e774ba97d", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "b13daf99-4dd3-4ae7-9f4c-5d68cefa343a", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.strategy_prob = [0.5, 0.5]\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def dynamic_strategy_selection(self):\n        if np.random.rand() < self.strategy_prob[0]:\n            return self.mutate\n        else:\n            return self.covariance_mutation\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutation_strategy = self.dynamic_strategy_selection()\n                mutant_vec = mutation_strategy(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            if success_rate > 0.2:\n                self.F = min(self.F * 1.2, 0.9)\n                self.CR = min(self.CR * 1.2, 0.9)\n                self.sigma = min(self.sigma * 1.1, 1.0)\n                self.strategy_prob[0] = min(self.strategy_prob[0] * 1.1, 0.8)\n                self.strategy_prob[1] = max(self.strategy_prob[1] * 0.9, 0.2)\n            else:\n                self.F = max(self.F * 0.9, 0.1)\n                self.CR = max(self.CR * 0.9, 0.1)\n                self.sigma = max(self.sigma * 0.95, 0.1)\n                self.strategy_prob[0] = max(self.strategy_prob[0] * 0.9, 0.2)\n                self.strategy_prob[1] = min(self.strategy_prob[1] * 1.1, 0.8)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "An enhanced hybrid adaptive DE variant that incorporates dynamic strategy selection and adaptive parameters to improve convergence and exploration balance.", "configspace": "", "generation": 68, "fitness": 0.5324544513817209, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9034821540935412, 0.8992067871949936, 0.9133602108956907, 0.89704024318706, 0.9111057050371407, 0.9169683247935124, 0.9125839016219927, 0.9030653336477651, 0.9101597713785397, 0.7962083345242914, 0.8170719802645451, 0.7820419164808081, 0.7907488409000583, 0.8028159465402431, 0.8089607888378161, 0.8068348936474161, 0.8153024530294294, 0.820885698371778, 0.15795867698292154, 0.584972233669206, 0.17651550797836302, 0.5983454883627972, 0.5228275514203506, 0.16262117761857875, 0.628113200346035, 0.1500823151428371, 0.7302694099953908, 0.13170567583898718, 0.14580527531993281, 0.14091993352368792, 0.24578240534142115, 0.15774874035073028, 0.1285997504898918, 0.13691581490776228, 0.14714138193074033, 0.16562920014405913, 0.9920981418616105, 0.9862281317845129, 0.9872261875823104, 0.9896786095145941, 0.987398018118816, 0.9909314430683474, 0.9852018719199538, 0.9905847784447789, 0.9905096457820105, 0.560460744772221, 0.6518023173647303, 0.629399586539183, 0.6478717121648598, 0.6199880830286054, 0.6026802293003245, 0.6194244739577724, 0.6105724692121003, 0.6395469894229957, 0.8971121450359313, 0.8705297682659741, 0.8763966037824333, 0.8914933880942099, 0.8970792427368864, 0.9176618624423336, 0.8753172387387012, 0.9004555520000679, 0.9031289977788127, 0.7344646419244376, 0.7096185918564154, 0.7349629698984104, 0.7162242267030492, 0.7509424784261912, 0.6886602206170753, 0.752047109289103, 0.7266286603384082, 0.6721937753619335, 0.7520337949267855, 0.7409963157947022, 0.7335714844391634, 0.7413064878212997, 0.7186838328106901, 0.6991121201637878, 0.7411634262766571, 0.7374272089285739, 0.7485891172346881, 0.6718859098996112, 0.6618244868174048, 0.6891250716622215, 0.6693663074812013, 0.6776225498958466, 0.6597591332258363, 0.6526221645015757, 0.7052723813817989, 0.6496589208069585, 0.7345109243897091, 0.7450489544166387, 0.7731049369229144, 0.7276189645824191, 0.7372969724926568, 0.7339213172306782, 0.7667172263720387, 0.7812118450981277, 0.7359404514591608, 0.475603652386417, 0.35380341473135146, 0.3979419651681616, 0.5966859704626388, 0.6216319404460562, 0.6227727909263975, 0.42711722075189595, 0.3699396533455269, 0.3649666616188233, 0.610830524378253, 0.551694663750202, 0.5852310544029571, 0.5849288690051453, 0.597598970990477, 0.633836450500747, 0.5749326124977914, 0.5981760350356847, 0.5577179727965509, 0.8580905567937667, 0.8428083931743776, 0.8595509510423716, 0.8449733913922168, 0.8491335707746643, 0.8331205916320125, 0.8567924171966974, 0.8586410265488161, 0.8479098261429765, 0.11202146348368658, 0.13382014858524582, 0.14773557054860653, 0.180770860001766, 0.15444168273986814, 0.16867488076998394, 0.1494210710308327, 0.08628945753765638, 0.13622371658036214, 0.1707984503323252, 0.23911185229698972, 0.18528826641256502, 0.14777072592624296, 0.365574818124355, 0.275515980953996, 0.1461069605359797, 0.1557203601370244, 0.5898643428493855, 0.5907171336636126, 0.6132208222120974, 0.5223236631821624, 0.5545631627331927, 0.504266168264524, 0.5747652303466763, 0.526461405889512, 0.5809797120553037, 0.5810759419272783, 0.434672932239907, 0.4202147013479888, 0.4349688890002328, 0.4416663800332976, 0.4532288813816385, 0.4162051045493086, 0.4817050481607178, 0.5122700491891723, 0.4390850231706406, 0.20491569060662695, 0.2057012664563942, 0.23345315647585707, 0.21750132479329232, 0.22921308402159324, 0.21350145643267204, 0.19359444530322056, 0.2244562277050186, 0.2608425720650699, 0.7050793261425523, 0.24868687567799563, 0.2445786171395018, 0.2193235446227505, 0.23680307980425963, 0.21676863463517082, 0.1981524454107323, 0.21667225525563594, 0.7059260882895956, 0.18900991878262163, 0.18785824903285242, 0.187687738837218, 0.9112493369791451, 0.18694549064811772, 0.20011149151413898, 0.8728709152346861, 0.1675014163017402, 0.8828532597854662, 0.8794595728078455, 0.7892866669408749, 0.893077182510883, 0.16926316807018538, 0.15466518608287005, 0.15583976375327313, 0.16665415753847068, 0.8958572243040892, 0.9103693320573499, 0.18191719882881052, 0.19995164377155294, 0.2108110316969164, 0.19046563578753484, 0.17891402035504966, 0.17622713069626494, 0.20962566899724833, 0.17239965271804392, 0.19408326074339577, 0.0895245575394561, 0.08553246440807127, 0.07619807301066195, 0.09261703199447768, 0.08071598914066636, 0.10354932511175097, 0.09988220444552376, 0.10407832233577119, 0.08225588079007629]}, "mutation_prompt": null}
{"id": "d719ae35-bc06-4d48-97c7-f7c7206a50d4", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.pop_size = self.initial_pop_size\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.array([np.inf] * self.pop_size)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.dynamic_resize = True\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def resize_population(self):\n        if self.dynamic_resize:\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            new_pop_size = max(4 * self.dim, int(self.pop_size * (1 + (0.1 if success_rate > 0.2 else -0.1))))\n            self.pop_size = min(self.initial_pop_size, new_pop_size)\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n            self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n            self.resize_population()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "An enhanced hybrid adaptive DE using dynamic population resizing and adaptive learning rates to improve convergence and solution quality.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 36 is out of bounds for axis 0 with size 36').", "error": "IndexError('index 36 is out of bounds for axis 0 with size 36')", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {}, "mutation_prompt": null}
{"id": "efa32d1a-fc7f-4147-b24a-3fe1ce956822", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "e8cda6a3-136e-4a1a-af4a-0025c59652e3", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Adjusted to increase diversity\n        self.F = 0.5  # Initial scaling factor for exploration\n        self.CR = 0.9  # Higher initial crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.3  # Increased for more elite solutions\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.4  # Broader covariance mutation spread\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def learning_adjustment(self, success_rate):\n        # Dynamic adjustment based on success\n        self.F = np.clip(self.F * (1 + 0.3 * (success_rate - 0.3)), 0.1, 0.9)\n        self.CR = np.clip(self.CR * (1 + 0.2 * (success_rate - 0.3)), 0.1, 0.9)\n        self.sigma = np.clip(self.sigma * (1 + 0.2 * (success_rate - 0.3)), 0.1, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6:  # Increased probability for DE mutation\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n            \n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.learning_adjustment(success_rate)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced hybrid DE with adaptive scaling of exploration-exploitation balance, incorporating a dynamic learning strategy for parameter self-adjustment.", "configspace": "", "generation": 71, "fitness": 0.5052315807138233, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9151215154898057, 0.9023108400827539, 0.9100555523483653, 0.9120858367674963, 0.9088360382024554, 0.9087423121705561, 0.9158905326799028, 0.9020124439006177, 0.9085490138565289, 0.7992508101264149, 0.7973797835733594, 0.8053099721183482, 0.8040354718136038, 0.8037656350221449, 0.7921739043543146, 0.7950057255282224, 0.8096911981584295, 0.7931465031325782, 0.16300727654533365, 0.15374327518820752, 0.15287750103591558, 0.23138846010973302, 0.22444630703770307, 0.377027185391564, 0.14421101329739994, 0.15408153923444756, 0.18201794609380229, 0.129681661770503, 0.12460285748695843, 0.14744407501504242, 0.1814041965780956, 0.14933057012580653, 0.11368475227390429, 0.15796398865655825, 0.14155122602786707, 0.16425785603671883, 0.9690018984545388, 0.9800127991287411, 0.9797193550053905, 0.9789940865959218, 0.9769774797111908, 0.9853538827154268, 0.9779499696736114, 0.9799377466498089, 0.9769389626071876, 0.6093171617939219, 0.6142499476710903, 0.6143698773558364, 0.6266646984689246, 0.5985997772467234, 0.6261639687852187, 0.621353850005048, 0.6410618918568851, 0.6471510190310857, 0.8894573023147714, 0.8999347131086606, 0.9132531627575573, 0.9260874434671648, 0.8986137095755784, 0.9012109679437007, 0.8632331933243591, 0.8945928918877418, 0.9117037219490443, 0.5160463972443281, 0.6535431901724693, 0.7180273955600871, 0.7032136999479053, 0.7001253845363463, 0.6644396241863701, 0.6655738632281496, 0.6974345002232942, 0.7134188336016031, 0.669582425515756, 0.6644342813411512, 0.6723239741369835, 0.6817829332445784, 0.721989472952921, 0.6516707186617765, 0.6707005820018641, 0.675304017000718, 0.6702102316317122, 0.6316590912745654, 0.6618526620809918, 0.6244622662341166, 0.6776198918373636, 0.6287598279065417, 0.6265256152354672, 0.6948075106983109, 0.6506772484516865, 0.6370178012508976, 0.7040041687028507, 0.6937352665375409, 0.7319679639675283, 0.7552176678537568, 0.6957063193352152, 0.7050477898173206, 0.7221894839506431, 0.7408047793351251, 0.7501218014400324, 0.25073658924136655, 0.40105537184341933, 0.2961915074642346, 0.5816045152971587, 0.5437256109696895, 0.5408414119258242, 0.2707783288701653, 0.2647621190155278, 0.1906516687171247, 0.5444387029810621, 0.5179504683513291, 0.5164041963554554, 0.571697264194178, 0.5467296622729974, 0.5675951040351275, 0.5477832588867533, 0.5634667792487663, 0.4870359201477792, 0.8553156861913503, 0.8495365865857893, 0.8432302860860623, 0.8556089572040517, 0.825821972122333, 0.8343083907591132, 0.8638096468057945, 0.8384380054948473, 0.8502753147175393, 0.12690724965852862, 0.13496663871934156, 0.1593960822186189, 0.12392498820646591, 0.14066402561174507, 0.12483377223848269, 0.1378451667937598, 0.1632612766356315, 0.1411601289531873, 0.16882711426123986, 0.1533639695000718, 0.13706549901247822, 0.15468090333634155, 0.16154011694089532, 0.14705657394033567, 0.24085569408663654, 0.14362803563554594, 0.29592068878294964, 0.5036378963309187, 0.5512943576224563, 0.5436615489444248, 0.5792867698607091, 0.5467755790491539, 0.5814199366558197, 0.5853619036331064, 0.6097889756122268, 0.5805937693324612, 0.44295130208408295, 0.419167791248077, 0.4239783340425023, 0.39596834430609995, 0.43568031737520907, 0.4410700974281019, 0.4867393374354013, 0.44776356644590753, 0.4900633452997253, 0.2053019709120324, 0.19908376140274742, 0.21286543014150394, 0.2547497149736948, 0.2361428163299636, 0.21568426855442913, 0.28854406086861073, 0.2157790338985246, 0.2165746992217722, 0.19331348923808522, 0.20511345967420924, 0.21246552981228284, 0.35075123547398424, 0.2185699363187471, 0.19286316716992824, 0.23687985885162832, 0.22770357434392674, 0.19392094170766472, 0.18709347359897177, 0.18870302237907932, 0.822897645781759, 0.8938786684464725, 0.19803793547776527, 0.8330391672858639, 0.7784975503267939, 0.19480187220585954, 0.8976485946313043, 0.905819612093669, 0.21158179375794572, 0.9081949354622523, 0.7688731874588732, 0.19803293150798296, 0.8062980209201436, 0.21241583487890336, 0.2084412764850676, 0.2135523737966587, 0.1819028913376216, 0.19427810385096378, 0.18644918898030494, 0.17916490369233962, 0.18632987847279736, 0.17582944703819425, 0.18183991833989654, 0.2101001723688417, 0.18759852986634806, 0.09428900211049118, 0.08220819171076676, 0.08410179657490824, 0.08132745887745096, 0.08770336857824135, 0.10065463900927496, 0.08113073011363181, 0.08739990035972245, 0.08271510707689667]}, "mutation_prompt": null}
{"id": "4eeb5f8e-2f46-427a-9f61-3a22e5727765", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.min_pop_size = 4 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.archive = []\n        self.archive_size = int(0.5 * self.pop_size)\n        \n    def mutate(self, idx):\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.archive.append(self.population[target_idx].copy())\n            if len(self.archive) > self.archive_size:\n                self.archive.pop(0)\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def archive_mutation(self, idx):\n        if len(self.archive) == 0:\n            return self.mutate(idx)\n        archive_sample = self.archive[np.random.randint(len(self.archive))]\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n        a, b = self.population[idxs]\n        return a + self.F * (b - archive_sample)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.archive_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n\n            if self.pop_size > self.min_pop_size and np.random.rand() < 0.1:\n                self.pop_size = max(self.min_pop_size, int(self.pop_size * 0.9))\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDE", "description": "Enhanced Differential Evolution with dynamic population resizing and archive-based perturbation to improve exploration and exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.3363906320796493, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.7346533947273864, 0.7261931370643728, 0.681384620173819, 0.7433419319657699, 0.7572634738649855, 0.7323452828247496, 0.7385123151944264, 0.7525098161761491, 0.6799216417112153, 0.5827034945188401, 0.5984291463171076, 0.5382449967491683, 0.6091031574466043, 0.6000918843254328, 0.5485863968014231, 0.5902458792091654, 0.6023201525469428, 0.5272262249416875, 0.11987528809857717, 0.11263776102230671, 0.1306892325040797, 0.18898487231890604, 0.18579236610084104, 0.10785655421301421, 0.16324092997839512, 0.12303273733171505, 0.13199441041979676, 0.15143206883418625, 0.12342392846991534, 0.1137176624360976, 0.12384324958111903, 0.10357312344769676, 0.2173714896812302, 0.13824879367116005, 0.11868612501805587, 0.16926756528324838, 0.9783485530186953, 0.9705266120569317, 0.9807264728959408, 0.9684322715979379, 0.9729863818111257, 0.9778536689201053, 0.9768933501687542, 0.9821233463956153, 0.981820666133838, 0.4312354421487494, 0.4988914516788667, 0.3563992254693148, 0.4533058763931833, 0.4405225620203703, 0.4044775155890007, 0.08595444274862818, 0.4711060183691418, 0.40183340431197523, 0.6894996987641235, 0.6249820994845189, 0.5745112944986, 0.6772455389079554, 0.6654311648406428, 0.6460257057876766, 0.6797475436018865, 0.6992497218591263, 0.6122496077491046, 0.33485962577080675, 0.35490688084509414, 0.3084630829745849, 0.347767801976534, 0.3552574944522152, 0.2931550874808905, 0.40601608281474033, 0.36800044502558216, 0.30832779165462265, 0.487669018183001, 0.39183269733992443, 0.40623859475071833, 0.40634784952727643, 0.3420154600449513, 0.24680321193856047, 0.33384902692656837, 0.34550138710045275, 0.2888651581732491, 0.2866412090753081, 0.061843187526538945, 0.21396155663368865, 0.32453891357808706, 0.21981450445717576, 0.15386888986270664, 0.22918019827564395, 0.20778744331350096, 0.1911358157580435, 0.3596355611980654, 0.3887529212548356, 0.3254605615693882, 0.3442570933867304, 0.3770795290538912, 0.3281282667408143, 0.3336905818527395, 0.4409586222462296, 0.39519745983049603, 0.10560110347683638, 0.13414861862923422, 0.08204417787199969, 0.09410204442641679, 0.10481607895113443, 0.12763045767988168, 0.17551192257078185, 0.10865422151664228, 0.09781348211790031, 0.2398747736266812, 0.24506410251893118, 0.17508467803695293, 0.2401334163539659, 0.2306261418085228, 0.1952941025687619, 0.22603272488534354, 0.23161008373059988, 0.20092192954094168, 0.5509643643458624, 0.6263649832649932, 0.5475981452065797, 0.5921618952534589, 0.593003797962034, 0.5306605816863494, 0.6102574244511435, 0.5578203616461768, 0.5365290694931322, 0.1079679337615842, 0.10279457949271198, 0.1043719427249098, 0.22356260557217122, 0.10266204848861105, 0.08019219746386552, 0.101717218035425, 0.08729021219678468, 0.09265877165115544, 0.18832328425331724, 0.13964314069557926, 0.17965935246691733, 0.16926918192452012, 0.17329218521785206, 0.17476125482297433, 0.15695332363061532, 0.1421273861100102, 0.15970214716870523, 0.33302762329684543, 0.30982413247604, 0.29524839796016034, 0.3075494547182269, 0.31653830081500756, 0.2909801828121906, 0.3307343350644636, 0.3580210995661275, 0.323903870968986, 0.24217424801366783, 0.2667929162725564, 0.215803135432869, 0.25698170544447607, 0.23292976415242472, 0.21664575342178405, 0.23954368790846547, 0.27932433572760296, 0.24571241049781856, 0.17008048908797213, 0.17928618619875125, 0.1948426653683759, 0.1699987852546212, 0.1804090269566353, 0.1708617896902701, 0.19243911184127171, 0.16933868684486442, 0.1898698197801264, 0.2630822021814161, 0.20697816502099298, 0.30526118799903024, 0.18368119252616988, 0.4088637502770369, 0.18891368244637408, 0.21656617417612123, 0.21700847667142642, 0.16704038167689417, 0.15302164629970705, 0.7212862510018447, 0.6856938044252192, 0.726841876958262, 0.18768275802720713, 0.5163417210990027, 0.17213384244034569, 0.18239278937731018, 0.627554980133215, 0.5900711104930103, 0.20373351534999795, 0.20069943457630568, 0.550409722986146, 0.12520329456692725, 0.18901813209917195, 0.20629600563316097, 0.20353164104914856, 0.6974150402128221, 0.1870201871375845, 0.16711066027609722, 0.18518705607554753, 0.15579823282466498, 0.1932609693199132, 0.1841515519527287, 0.1920084076579407, 0.18227807335322932, 0.19381771083391808, 0.06491265497276599, 0.06608488209913044, 0.06404967708087639, 0.07090534966681039, 0.06641936621785494, 0.06417184767782469, 0.07166794207074689, 0.07439411028387766, 0.07734595034184599]}, "mutation_prompt": null}
{"id": "ef879381-f71e-4585-8a68-1b8086784c80", "solution": "import numpy as np\n\nclass SynergisticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Slightly increased population size\n        self.F = 0.5\n        self.CR = 0.7\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.15  # Reduced elite ratio\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.25\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), idxs))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def local_search(self, candidate):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(candidate + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n                if successful and evaluations < self.budget:\n                    local_trial = self.local_search(trial_vec)\n                    self.adapt_parameters(local_trial, i, func)\n                    evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.15 if success_rate > 0.3 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.15 if success_rate > 0.3 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.05 if success_rate > 0.3 else -0.03)), 0.1, 0.5)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SynergisticAdaptiveDE", "description": "A synergistic adaptive DE variant with dynamic local search integrating covariance-driven exploration and adaptive selection pressure for enhanced convergence.", "configspace": "", "generation": 73, "fitness": 0.5333864323179487, "feedback": "The algorithm SynergisticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9072846862389752, 0.9028438870300959, 0.9100871034451884, 0.9011211719649354, 0.8982035984220014, 0.8978257433087181, 0.9165812295498104, 0.9026882708193124, 0.9090111713902288, 0.7884066707203291, 0.7829453584074328, 0.7985940763236097, 0.7848358097831001, 0.8050806995877876, 0.7956586632746868, 0.796525973227276, 0.8053816502053057, 0.7734332341541552, 0.38410071953811753, 0.46405397570357154, 0.4804007106209037, 0.1575226036992573, 0.23609489802416916, 0.4319332372761203, 0.1714630380628661, 0.49134510771058826, 0.15378195635594238, 0.14947222472891353, 0.10150972348521303, 0.1209017383436487, 0.14859886470604433, 0.15994945422903706, 0.15904446325947408, 0.23300079513431027, 0.15816780420505638, 0.4477524195358723, 0.9760904978890844, 0.9782345141804321, 0.9771141734839817, 0.98632060443601, 0.9817065515651139, 0.9653682417209299, 0.9924301511793151, 0.9761055980744319, 0.97929797577898, 0.6334929933780105, 0.633782297989319, 0.6141855986724605, 0.606924844875183, 0.6426846583491588, 0.6335445283588061, 0.6203604354054292, 0.6374460795830073, 0.6501768776797505, 0.89248694573974, 0.9255993099636912, 0.8955320960989046, 0.9305646739765427, 0.9252362065597011, 0.9163556919736014, 0.910580221057122, 0.8748692068968501, 0.23565004258817235, 0.6802879585569723, 0.6534484892190556, 0.5591566345204074, 0.134020255508147, 0.6753748569746978, 0.6275569827589252, 0.6713950360559682, 0.13291419121451764, 0.6906102642027924, 0.6366938731504752, 0.6536242077510727, 0.6951070824354719, 0.6901888048766258, 0.6485404049479558, 0.6888381858686473, 0.6196388863509652, 0.6531705805399368, 0.6985063724445981, 0.6943899676380357, 0.5863482081077189, 0.5614504950240653, 0.7224905484089231, 0.7277500775260857, 0.7146980334273814, 0.7452994965530997, 0.6838271810706, 0.6703392915540316, 0.7948491742586934, 0.7412954130218374, 0.7815403149386039, 0.7686041771296954, 0.7559867129074761, 0.6727482395235144, 0.776876478892295, 0.788032671719468, 0.7714068970424351, 0.2210155842220306, 0.3389602796314334, 0.42658405123427423, 0.3931358721054017, 0.6253619566781938, 0.6432234555416441, 0.45745239821968464, 0.5263267469867063, 0.3282768701717119, 0.634703899118594, 0.6369769654712719, 0.6074016191114142, 0.6147853771810246, 0.6440383305921713, 0.6548376319664501, 0.6541233043811218, 0.6454000457091141, 0.6144626595223874, 0.8654680423051402, 0.8598249113450908, 0.8581757543024326, 0.8539517654422315, 0.8492698868816093, 0.852983657551276, 0.8609119325328429, 0.8613770749771884, 0.8629657673576172, 0.16932595939347972, 0.17427175710770137, 0.11924381865897882, 0.1331643755161971, 0.1465889786255491, 0.14444235270317674, 0.13099907158529844, 0.16591662247708627, 0.1534745223440417, 0.14198024811723897, 0.17028952365671923, 0.15354267635986563, 0.3155058753477409, 0.2437687139078395, 0.25355566645304495, 0.16992389393561713, 0.16662913420115966, 0.17103433473552976, 0.6823579748909058, 0.6885106611686761, 0.7130956233880804, 0.7102286676481414, 0.7081108495271476, 0.7182527323965733, 0.6716461088146857, 0.7454958113245866, 0.7187476849297892, 0.31237609372937025, 0.6120633547922854, 0.5877197943262089, 0.649361996302777, 0.5742958908065252, 0.6279841867929761, 0.6600828358951308, 0.5242474080886335, 0.6091079847068365, 0.24051083341867485, 0.2550208922650352, 0.21785614407751008, 0.23343547660480157, 0.2100759157547626, 0.23454910258469008, 0.23179248204515135, 0.22763975753715193, 0.230980526200676, 0.20208518369465434, 0.4694617764423309, 0.20043766338288682, 0.20511173476689515, 0.23811245852940788, 0.18986215527282058, 0.2248593292291715, 0.6371505898388281, 0.5068580693515325, 0.18663156234500788, 0.18529588066441205, 0.8733538099064814, 0.9002744672118428, 0.19909528103202456, 0.1655516463495691, 0.8056425066240291, 0.8477633927376249, 0.8893281596088158, 0.8649347569106186, 0.20827679475655325, 0.8844553930272991, 0.742292404491468, 0.8344976082898486, 0.16677404287001496, 0.1657245948322057, 0.10412305249273546, 0.9040539318414769, 0.19278521442376173, 0.19333261940371804, 0.20123523257015785, 0.17592501955154005, 0.20797894585938304, 0.18559361823854725, 0.19714591530665537, 0.18153378848280344, 0.19204623755350458, 0.09666604166651194, 0.08920879194398146, 0.0946925230761877, 0.11786162567854463, 0.08983846930625372, 0.11192249060982262, 0.10014913526048053, 0.09904500097742619, 0.0865501125360153]}, "mutation_prompt": null}
{"id": "f4a7777f-cf50-4238-9b2c-4dde55ba3259", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "b7346fbc-73bc-46eb-9aee-7b04d0dc89e2", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "14f350dc-4707-4ab6-86f4-db63dbbad019", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Increased population size for diversity\n        self.F = 0.5  # Adjusted initial mutation factor\n        self.CR = 0.9  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.3  # Adjusted elite ratio\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.2  # Adjusted sigma for covariance mutation\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)  # Differential mutation strategy\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.7:  # Adjusted probability for mutation strategy selection\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation()\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.1)), 0.1, 0.9)  # Enhanced adaptation\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.1)), 0.1, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.2 if success_rate > 0.3 else -0.05)), 0.1, 0.5)  # Adjusted range\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedAdaptiveDE", "description": "A refined adaptive DE with dynamic parameter tuning and inclusion of differential mutation strategies to enhance convergence and robustness.", "configspace": "", "generation": 76, "fitness": 0.3602375936821237, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9518712850305374, 0.3138932486468128, 0.8991055309913459, 0.9243362315695943, 0.26006662606180275, 0.9194153187121146, 0.29782888169185806, 0.2179347759329402, 0.6157839224385526, 0.29703764789055875, 0.07734961661940265, 0.4958739594523385, 0.12402955817636463, 0.2789408004615046, 0.1630477504897413, 0.886803644568694, 0.8865202808268686, 0.8664725238860076, 0.12173275869159228, 0.18018207628433813, 0.17708820761443567, 0.13701216271047834, 0.11607820991221929, 0.15748768278568914, 0.12875617922817784, 0.16680695624368358, 0.1283981315356194, 0.09403096265753452, 0.10340808078683805, 0.09415429430031508, 0.15944847038859333, 0.08652909368521289, 0.10130028812011183, 0.09406281553273965, 0.08972548104343936, 0.07950573513708004, 0.08660011233961507, 0.1012341647096564, 0.09636095057104743, 0.09279333336167583, 0.09255976118694575, 0.10449023561300541, 0.0991688021785816, 0.07357130624302755, 0.09532340101497305, 0.21323438986883114, 0.11153827893162893, 0.17638393682022857, 0.023312609931691597, 0.06320430711107383, 0.1803769110403438, 0.2531526029473533, 0.1780313977255068, 0.20903723549015574, 0.942606409014514, 0.9491107373748852, 0.23088173776379373, 0.37130187321961416, 0.9485183908725277, 0.2787182650062794, 0.23804249115266496, 0.9284276762052178, 0.3682045464160947, 0.5698339468282065, 0.13630077923356543, 0.15570733634214606, 0.1621147044354777, 0.16926003746378393, 0.14636855773512203, 0.150266664743812, 0.8486191876597835, 0.45142813842296914, 0.16320270633743128, 0.13703068601248125, 0.32001846374458565, 0.1395372131082373, 0.19345265423236702, 0.15104428571906625, 0.1559388364271368, 0.1349830041745923, 0.2332338275530189, 0.13186711375654447, 0.8792622540741947, 0.20663163852765964, 0.8672467487472093, 0.8841892692047795, 0.8952653246396953, 0.9007623403833304, 0.16640710082883747, 0.8834816260771197, 0.9082867493299177, 0.22635348392878418, 0.916489210517776, 0.8907985041688948, 0.8934589974927176, 0.8626298223136456, 0.9037678273652636, 0.9124385994507149, 0.9115734561282862, 0.16440117723986547, 0.1322249880968055, 9.999999999998899e-05, 0.8382465445430376, 0.13554697040322394, 0.394966913254967, 0.4005195976633178, 0.33311200961836473, 9.999999999998899e-05, 0.8373094016214828, 0.00294764563464045, 9.999999999998899e-05, 0.7952135284180671, 0.8360026673594556, 0.31662878564434427, 0.8319658782791117, 0.3259296557669469, 0.3574045005091552, 0.6546113199004115, 0.7211746102932315, 0.37325258963089947, 0.21452072873913752, 0.31221938253200787, 0.33362383589967226, 0.4870885185088222, 0.9185188733616179, 0.9310218576620368, 0.11407602713959564, 0.1298414397791099, 0.0925128617426968, 0.1410711449352524, 0.12930561333281854, 0.13755241255877104, 0.1256536444325398, 0.1577430754051562, 0.13297798686348739, 0.23742653469142228, 0.23416576611853246, 0.23697853329425034, 0.18180669451883946, 0.20670585481369486, 0.1518236497396691, 0.15326719651961884, 0.17673003257583664, 0.1702699347937301, 0.2534174951660123, 0.8173755332791774, 0.6862036009563164, 0.5868841451152395, 0.7915239791629728, 0.8058602242747315, 0.8009017742172112, 0.5587480403489924, 0.5857988505955182, 0.4317814827858487, 0.3702226441853158, 0.7464464528343209, 0.771270897850118, 0.7785230659814738, 0.4049250651225138, 0.7941166820054252, 0.7567402021910784, 0.6548170419886664, 0.2467563417744354, 0.21992868250166597, 0.27195567390795616, 0.22109969558188836, 0.22107461003657114, 0.2510507402949732, 0.22933498126915997, 0.20457655340802805, 0.2142149817769966, 0.21586861257454493, 0.19866334968061838, 0.17383727742105115, 0.19471843548668766, 0.19016852486907487, 0.2005618459507651, 0.19640887859437683, 0.19097299833262404, 0.20127596935889547, 0.18641750330347917, 0.18846752615272577, 0.17125358687637693, 0.9246285158311371, 0.19926532259104457, 0.19760338954665568, 0.9380511411223093, 0.9385911128252291, 0.9127609044366529, 0.9495084283491394, 0.211158213137277, 0.9354040448680638, 0.4408188689671583, 0.21153658137867992, 0.1551764604055228, 0.3146993380046462, 0.16680511648727736, 0.3702718882133733, 0.18961832316632876, 0.17339086648744195, 0.19396041093848437, 0.22159348698919779, 0.18854310899842197, 0.19210717375035624, 0.17664498858238653, 0.17986596283209633, 0.19723842749064868, 0.09887932401198452, 0.09597440866988183, 0.08678033692388598, 0.10910911068130769, 0.0741375805200214, 0.0915930519375896, 0.10455963610410468, 0.08873453173489831, 0.0820296969808254]}, "mutation_prompt": null}
{"id": "666cdb38-f09b-407e-bb61-caa1ecd2d25d", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Increased population size\n        self.F = 0.7  # Adjusted scaling factor\n        self.CR = 0.9  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.25  # Adjusted elite ratio\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.4  # Adjusted sigma for covariance mutation\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def diversity_control(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        if diversity < 0.1:\n            perturbation = np.random.uniform(-0.1, 0.1, self.population.shape)\n            self.population += perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            self.diversity_control()  # Enhance diversity control\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.6:  # Adjusted probability\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDE", "description": "EnhancedDE: An enhanced DE using dynamic parameter adjustment, adaptive mutation, and diversity control to improve robustness and convergence.", "configspace": "", "generation": 77, "fitness": 0.307065931397739, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.452630666370635, 0.45425566073082013, 0.45428594125354416, 0.47157806634038724, 0.47241077407893695, 0.4978182665965233, 0.4573814564210079, 0.477543071930147, 0.4593596673849236, 0.2726828729760755, 0.25400920831041895, 0.26898070878962144, 0.2539970513583768, 0.24110591726740116, 0.25933292123251916, 0.24741145226434613, 0.2822218046931054, 0.23581683135386033, 0.1501667311983863, 0.15367123250074965, 0.13333330012658295, 0.14517240990096103, 0.15548601475340584, 0.16769097521851128, 0.15018496024989303, 0.17517535040783072, 0.1603831650258557, 0.14577474113222688, 0.18557444281712498, 0.14755074249225764, 0.1393599390573208, 0.1528402759368026, 0.1529626877834357, 0.12788602256111803, 0.1316155991936243, 0.13652012790709145, 0.9854436210588357, 0.9857411071915694, 0.9912808244097182, 0.9840546818274132, 0.9839812705097141, 0.9832682450578026, 0.9901667878780174, 0.988678700287658, 0.9872527629349503, 0.31362786064230697, 0.29873495953096063, 0.3092247772006377, 0.2943809183452408, 0.3209031906753127, 0.29839886350946143, 0.3143303206043312, 0.3206156512246886, 0.3119106876799953, 0.7946587444488155, 0.8013934986308299, 0.6816431587825051, 0.8721555143895788, 0.5759912495440818, 0.7452275000263, 0.8219310517648646, 0.8745504722109986, 0.8503237510299975, 0.2213437286124048, 0.21274379533402366, 0.18923877064175143, 0.2316484328707561, 0.20358885181175124, 0.21016657203540667, 0.22294322562104962, 0.26610503120742746, 0.2726064106896653, 0.19196444170536364, 0.2447647138734702, 0.2279611098440224, 0.2305357812282628, 0.21961600184764407, 0.2149464384399009, 0.22085279080076758, 0.25145026316268837, 0.22381294542942043, 0.28130055986675384, 0.2495970116959857, 0.25662614296398556, 0.2695195712871745, 0.2742272233193891, 0.24949226846581807, 0.2509088453268422, 0.2795753279169203, 0.26726967074965724, 0.34625115653138727, 0.34813441614039553, 0.3626887837283512, 0.36462222331514427, 0.33201599098920065, 0.35005265730499524, 0.36107709152143097, 0.35781234889516256, 0.36079519971610585, 0.14335463763339884, 0.18661764611095655, 0.11790406692805377, 0.2284356904141862, 0.17045820281787805, 0.16289315188380626, 0.17217422534640825, 0.11618119539583183, 0.13991099308542654, 0.19859779383117115, 0.18074619139153825, 0.192519208607155, 0.16814614305631292, 0.1811514573874189, 0.16929774163537825, 0.185906777127531, 0.21943405780213177, 0.20708643733468313, 0.458938025497189, 0.4424018431346668, 0.4252932248625608, 0.4655830132228068, 0.4481705687140235, 0.45134835390117267, 0.42868794896392515, 0.42781532754508245, 0.4411976535406781, 0.11555762783182522, 0.10857517795392546, 0.09750147481921378, 0.11910061597935961, 0.11159611747559739, 0.11484084627547331, 0.12374102996379932, 0.14715346543000452, 0.10679584515521279, 0.12895270264924585, 0.1453448159878843, 0.19931125183600729, 0.14514536134730693, 0.16332011944401748, 0.15893506358828158, 0.1402002205247802, 0.1578582931746163, 0.18302373937470406, 0.3225673400808938, 0.3180203301176102, 0.2966583271141081, 0.3111980393285654, 0.30686039263473375, 0.30835034802085115, 0.2996467331395686, 0.31931019670803384, 0.31475526268283516, 0.2846695678772059, 0.2725398080883139, 0.26593331677005394, 0.28804623548860286, 0.2704003066451214, 0.27769693584583743, 0.2750755437309642, 0.2804599701826431, 0.2598045751561143, 0.20386538654152586, 0.20672012865355116, 0.21540283444225494, 0.22911848486315256, 0.2198919771078568, 0.2223883186241159, 0.1923915980877905, 0.20707907209271537, 0.19888009860135203, 0.28869908431260616, 0.25033337175418235, 0.21056448803387862, 0.2008447691855375, 0.27856600961843536, 0.21262443483365, 0.2519149411411621, 0.2989538640682107, 0.19526967325545852, 0.18367487052829579, 0.666313388085475, 0.18603601030413064, 0.7659416175390678, 0.1968169409162699, 0.653400285293223, 0.15923801475955146, 0.6746200809394746, 0.64198778629255, 0.7090943597386745, 0.2061173556372854, 0.7028310938753952, 0.20588762869039023, 0.6805760257504383, 0.16155400786440133, 0.16745611532574334, 0.2108758530545125, 0.20735608991581322, 0.18718795741356775, 0.19631153533227041, 0.19660629993197476, 0.1740759652186269, 0.18965265732181846, 0.18638494956828788, 0.17955036836610538, 0.19416982291077356, 0.18820730231715188, 0.08552539446702667, 0.08956421011526161, 0.08463910106097716, 0.08193804041496255, 0.09704766485673011, 0.0848173042949778, 0.08548851282103664, 0.08709097366712171, 0.08320146260725814]}, "mutation_prompt": null}
{"id": "0a150534-b799-48fd-8c38-40f1d01eb0bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.25\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.diversity_factor = 0.05\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c) + self.diversity_factor * np.random.uniform(-1, 1, self.dim)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def dynamic_mutation(self):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, 0.2 * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            diversity = np.std(self.population, axis=0).mean()\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 + 0.3 * (diversity < 0.5):\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.dynamic_mutation()\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n            self.diversity_factor = np.clip(self.diversity_factor * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.01, 0.1)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "An enhanced adaptive DE using a diversity-preserving mechanism and dynamic adaptation to boost exploration and robustness.", "configspace": "", "generation": 78, "fitness": 0.3022066441466664, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.6088715260265172, 0.6108620494752637, 0.7068454948523365, 0.729471010131854, 0.659176392829943, 0.6646111064849201, 0.6308019550138446, 0.688854608349996, 0.653430425301416, 0.19023360395087052, 0.1469680521250859, 0.23422233391155378, 0.07978902048488212, 0.0896923772108632, 0.11271015588856281, 0.2401329433002667, 0.19674451885260613, 0.164886471255956, 0.12862230453475187, 0.1676986844832391, 0.09613009108351855, 0.1384395363797285, 0.1606077137247961, 0.19436367226886497, 0.16077929279624548, 0.1422686882636952, 0.15166337166321342, 0.11882557068168875, 0.11874595947303757, 0.12809408865261596, 0.11999952273574122, 0.11760587022489677, 0.11822444937091714, 0.12454208657397015, 0.141866532338638, 0.11682904001057437, 0.9904980596764092, 0.9779297565549411, 0.9890040645597086, 0.9848723827436756, 0.9756604079116092, 0.9873419533761233, 0.9741731820643115, 0.9852561896232419, 0.9908026375385206, 0.3486871230241415, 0.3337488165453437, 0.3632959525892433, 0.34833196365239594, 0.35796261885563685, 0.34919939561408486, 0.35179563861242935, 0.33191883177111126, 0.3535911647924167, 0.9124371502965428, 0.896815524035198, 0.9002581128386139, 0.9328718520322815, 0.9051949423188943, 0.9216212122114951, 0.8461704685760316, 0.9327444230527865, 0.23700698319642366, 0.22755619998235466, 0.13220174593546485, 0.21639635876001173, 0.242258148769403, 0.2535758946212525, 0.2028206148735281, 0.21537182658214393, 0.20236527604174748, 0.19866911682988764, 0.1994431942426922, 0.2209104610427235, 0.19904841085242808, 0.19815296687990902, 0.21415031023917785, 0.18692573269908674, 0.2077185430221099, 0.20274245789355172, 0.19658894964473006, 0.002483250386718261, 0.12691622636250854, 0.010927891286101277, 0.06597169640173528, 0.0543155754603829, 0.009864685525999062, 0.009218556526403021, 0.05240027043851225, 0.1184268807833363, 0.20141826482910397, 0.17021499071954516, 0.1828025539339143, 0.05119301628520112, 0.0326628284240289, 0.05875824066854751, 0.11586004658690419, 0.14812006180159243, 0.21234632468516756, 0.08325714925297611, 0.07733993740697331, 0.0778184610877235, 0.06642892763853836, 0.1365130828077279, 0.12938345580561073, 0.08610348014050473, 0.06145656159074864, 0.10372977820029261, 0.16851244848325386, 0.19789171718512444, 0.1746794683598073, 0.16357701986810624, 0.1840123700486206, 0.16696140556917416, 0.17639663572106368, 0.226084158644694, 0.1962655457750464, 0.521236785781142, 0.6224969134704741, 0.583248273598817, 0.49759580815315907, 0.5409947880601036, 0.5342640095745218, 0.5290646399406158, 0.5092955954343672, 0.5300105078995585, 0.13625725541204647, 0.1299119262211751, 0.10650274761956657, 0.13534111968454487, 0.13668719244075545, 0.13895872425864508, 0.2929167211961967, 0.1273881958446973, 0.12034545005246422, 0.16670976696626827, 0.15322133795066928, 0.16058625885837696, 0.18892911740008922, 0.4012021557631016, 0.17024330684349642, 0.2209860697612187, 0.1614191619259454, 0.16618351123346142, 0.35520608206265347, 0.3705079621803935, 0.3894140252253677, 0.3837312135931782, 0.3679096990255657, 0.39371890258232256, 0.38788787337419794, 0.3996347485075121, 0.36136391044031146, 0.22263967443236943, 0.3426992168332804, 0.3187802579022081, 0.32474385395768857, 0.2831496136572229, 0.3457808893830674, 0.24872777990080663, 0.3362186201545373, 0.30431143544772543, 0.23898188654825203, 0.2325646020021752, 0.21265540399026783, 0.24601759754000352, 0.25172614690753725, 0.22281134899040067, 0.2342708433552687, 0.22083769118804075, 0.24212263202705575, 0.21791097864768294, 0.18416467991714658, 0.24169759719285222, 0.20895752731536243, 0.21887346447471978, 0.21636635669223947, 0.19962616801663002, 0.18442433538727865, 0.18081405694474584, 0.1864284546607753, 0.18712608560271438, 0.1518097941732942, 0.16753941528745142, 0.1994431055821848, 0.1992724092669247, 0.17512965596189312, 0.17095025117323348, 0.8319757588230066, 0.7351932664195078, 0.7521625916975556, 0.8615355519775849, 0.20948945029081034, 0.20785232860565428, 0.15520742266851162, 0.7543960222778836, 0.7649658974221112, 0.8059559856900853, 0.18763989235695322, 0.2104670746463415, 0.19938864793797462, 0.1820762207122142, 0.19214376942681644, 0.17954355652083065, 0.17957048093174832, 0.18428192912699037, 0.18109826704933407, 0.0953525062062015, 0.09812140625187349, 0.08130042616877076, 0.09316480368578672, 0.09991729453754883, 0.0904507959120825, 0.08234889347003427, 0.10227148346440373, 0.0978073201749432]}, "mutation_prompt": null}
{"id": "46851b00-db83-4916-ba6e-0b2b6771f5ba", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "51b31d21-7d1b-4d91-be84-c1742d828833", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.dynamic_strategy_threshold = 0.2  # New parameter for dynamic strategy selection\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def dynamic_strategy_selection(self, idx):\n        # New function to dynamically select between mutation strategies\n        if np.random.rand() < self.dynamic_strategy_threshold:\n            return self.covariance_mutation(idx)\n        return self.mutate(idx)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                mutant_vec = self.dynamic_strategy_selection(i)\n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n            self.dynamic_strategy_threshold = 0.3 if success_rate < 0.15 else 0.2\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "A refined hybrid adaptive DE algorithm with dynamic strategy selection and diversity control to enhance exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.5341896162615725, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.8922879403656938, 0.8946937629339964, 0.8953011776270878, 0.9062278128603907, 0.9065028233841567, 0.8901773236088277, 0.8982254618841414, 0.8946475660201986, 0.8930506035411713, 0.7938048602247644, 0.8048000632772025, 0.7938709429852588, 0.7822108828962856, 0.8071324325073428, 0.8106136848220498, 0.7898293410015614, 0.8326811875426136, 0.819214647572054, 0.1764723312249431, 0.14676372284391515, 0.5219141512193667, 0.5525659095564315, 0.16837861735396542, 0.5933280170666333, 0.5045367552148823, 0.14768975818712737, 0.4585377756221053, 0.14514222172112567, 0.14142204436915595, 0.12841765191225862, 0.15974896675098116, 0.16106091062979155, 0.1424631106297669, 0.16820104405918102, 0.14418381304025663, 0.13284741298556146, 0.9892986141476598, 0.9924667128165452, 0.9926063571460598, 0.9924744458493888, 0.990390351615201, 0.9915875717974505, 0.9915653259537479, 0.9920980314073669, 0.9940681277934126, 0.6301257303386286, 0.6001005364120544, 0.5287707129912255, 0.5930506298918916, 0.6045897836455658, 0.6027968673701125, 0.6302796652838969, 0.6145919920589605, 0.6303373050873198, 0.8634625716730681, 0.8799001604960864, 0.8845797136906226, 0.8949755763495721, 0.8940484848744787, 0.8618983582593913, 0.8544193957715078, 0.8759321397742312, 0.8470014941224621, 0.6823327598565514, 0.7212342247109551, 0.6908407320669667, 0.704106426458438, 0.7275805167846838, 0.6651443859888013, 0.7221295427896988, 0.6913673163510803, 0.7223608412825613, 0.7256635340532986, 0.7102602026928782, 0.6383662323704342, 0.7284331825847967, 0.6941051990603486, 0.6851098713129614, 0.7225862032982294, 0.6803979070641335, 0.6767294263147559, 0.6883107661543297, 0.6748591347892572, 0.6572916947720557, 0.6733421869950641, 0.6584685843890088, 0.6946322275094042, 0.7014325132351426, 0.6960951396475874, 0.6433958742955823, 0.7234583873356067, 0.7708352979638151, 0.7489699743379645, 0.730370633489626, 0.7058602332057624, 0.6878665435187312, 0.7443101302330974, 0.7731417960328898, 0.7664437865650237, 0.4651909028176472, 0.5534973483833039, 0.3623245952318439, 0.5965554395308643, 0.550873577635873, 0.5067573870560951, 0.460929241841772, 0.40599897887520353, 0.45564179525621784, 0.5668262107167276, 0.5676309508971805, 0.5392754497073056, 0.5724136943867055, 0.6050075991148929, 0.6093241872329265, 0.5551177806418097, 0.5934869741773068, 0.576137818622999, 0.829244412715942, 0.8260376341308214, 0.8520231013854723, 0.8348442438710872, 0.8361496333568075, 0.8346984137498246, 0.8288043204676452, 0.8328206063673038, 0.8663225318584518, 0.14512594462645667, 0.10922878398775226, 0.13433677135320954, 0.1423201106239741, 0.15085018431495079, 0.1726570953352955, 0.14886580866005228, 0.12120717449727436, 0.13630905505974222, 0.6105396997496053, 0.16420647625106488, 0.12724172146220902, 0.159539896029676, 0.17940366021480547, 0.13272845123962995, 0.26432487340197497, 0.3384371154033855, 0.19949926020333986, 0.5389045066801771, 0.5843101635605779, 0.5356008866525444, 0.5485184776735625, 0.6254025408820472, 0.5495632853086115, 0.6110580111488594, 0.6703959922077591, 0.604938836850969, 0.3988395305463798, 0.42443803077703923, 0.4429529349015222, 0.4321256471434428, 0.48523500595228874, 0.4535131609467289, 0.49175848650170273, 0.4559279781326856, 0.4572224628623013, 0.18586729566436733, 0.18133419666334316, 0.1950667035298166, 0.18891695305792044, 0.20426340621058348, 0.20038720618083739, 0.20221982388429804, 0.2146486793760639, 0.18939155420711262, 0.23554432916846513, 0.4934666891834426, 0.22820290474110805, 0.7176098931860805, 0.21218833369055035, 0.7573100778266797, 0.21645811945924887, 0.6423631353226904, 0.7489064070476064, 0.894210434198329, 0.8614715201170049, 0.18705677901497697, 0.9083670490889755, 0.1880520793145778, 0.8936043728667319, 0.15771400610745168, 0.8512608912705539, 0.8753857112708608, 0.8691014885571767, 0.21154588810825758, 0.8678826851278243, 0.16606416489068598, 0.20748445086296907, 0.8426640353477197, 0.21191121735039264, 0.15549303630812406, 0.21281984071329474, 0.1812301702426623, 0.1798719633233421, 0.18741634586469236, 0.18533106353246454, 0.20710176283404502, 0.1783264253412069, 0.19135173910449144, 0.18831431281030386, 0.2806735476041462, 0.08463939218562788, 0.08281695122036503, 0.08211223772892517, 0.10453737021405318, 0.08163816037546023, 0.07687393863524572, 0.08139999337071657, 0.08378741462302164, 0.07563931782747291]}, "mutation_prompt": null}
{"id": "7759411f-e384-4f39-9a97-867f0c6fa4d2", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "022efa9e-df1f-468d-a20e-0223221666c8", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "13d21099-4037-428d-a2c1-98bcc53b54ff", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def diversity_preserving_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        direction = self.population[idx] - mean\n        return np.random.multivariate_normal(mean + direction, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.diversity_preserving_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.3 else -0.15)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.3 else -0.15)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.3 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant using self-adaptive control of mutation and crossover rates with diversity preservation to enhance exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.3836804822937083, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.8044528111198964, 0.7801551776922444, 0.7959988661781091, 0.8142839174726297, 0.786183375165157, 0.8049373704458448, 0.7855118535422392, 0.8189049502521761, 0.8030540846004955, 0.6366822463430812, 0.6471715798010529, 0.6720219273890473, 0.6488282478649712, 0.5807318424944131, 0.6640342538037005, 0.6598856019719325, 0.6469804530635612, 0.6778489568633526, 0.2402597588494889, 0.15366841669855313, 0.11768721091173318, 0.14222668567040397, 0.10716273527312292, 0.14625566940979295, 0.1382448942778266, 0.1398271256653063, 0.19569186079192957, 0.1418201056749574, 0.16696066779017638, 0.12630127244673384, 0.10493244715807504, 0.11588970083861949, 0.12167103550491465, 0.13240664389587642, 0.1496784338574444, 0.15330831772047715, 0.9868767140633378, 0.9863789513882997, 0.988402872156191, 0.9901847669787902, 0.9859420907453468, 0.9923542590828766, 0.9902248637903676, 0.9897517053739705, 0.9905863281823737, 0.3908554160572344, 0.43086468625242225, 0.34503501167205575, 0.43581763328913337, 0.4119698319515924, 0.410920648388991, 0.3937615010425102, 0.43172954041712286, 0.4714942691407359, 0.764239771257024, 0.7640057384873372, 0.6837891105443973, 0.7369326248167295, 0.7439446747141032, 0.7598091166129841, 0.7201623546777485, 0.7639961231369219, 0.6874017003309787, 0.4655013795057279, 0.5077094648470466, 0.4622548483942208, 0.49448710642286164, 0.5133744479862183, 0.48044884825832745, 0.4792332594282942, 0.48082215410417906, 0.4083371145885547, 0.4279640582965719, 0.11999552580494333, 0.4110453419067891, 0.4712633730983239, 0.4880170553388814, 0.5222177048126355, 0.47901777903241727, 0.43510968769407254, 0.5012587529358705, 0.4090562165084315, 0.40910114195944003, 0.3678002414559254, 0.3884629861016923, 0.3305508453740925, 0.4346315025947658, 0.3450087318400261, 0.43055964524469226, 0.38721658473957044, 0.5204482418815499, 0.5964605628441466, 0.4553436188449971, 0.566180463705565, 0.4858745638067963, 0.5890032376818415, 0.5054340887156339, 0.4864635132505599, 0.5855341743254008, 0.12467274042417598, 0.1695263276854947, 0.17010243565796934, 0.1395999232413615, 0.23865169670610542, 0.17263807751733729, 0.16743954772985548, 0.1967790880869893, 0.2128404933570195, 0.30032992570367933, 0.2885128554869216, 0.2840474746485643, 0.3165397252089901, 0.3269716252326661, 0.33112289897292535, 0.30091753636726404, 0.3089572629260602, 0.3405348224581306, 0.6759772523290478, 0.7012617631884772, 0.7202855406643824, 0.7242545385143035, 0.6841230681599451, 0.6995179753228025, 0.6878261921266022, 0.7185629120656327, 0.7134743115125097, 0.12347143530920202, 0.1167606747934904, 0.11226905093770911, 0.1219276959643053, 0.15102274112625402, 0.10293466191973222, 0.0889869716507099, 0.108188335169634, 0.09943002613524587, 0.17097417899586165, 0.17037436468142564, 0.1463029808924604, 0.2460531729130374, 0.15125706235850234, 0.14578484972912686, 0.1631095759634883, 0.1603243637799182, 0.1591855986806111, 0.3549586812106299, 0.3348902808349109, 0.337983395522932, 0.34724489424859273, 0.3178458713636574, 0.37413383484898854, 0.36783003251268376, 0.40411044395040985, 0.41181738009073576, 0.2715738583619812, 0.286981869089011, 0.2682504059646561, 0.2892137797385613, 0.2638069295905008, 0.23001064681702532, 0.289093212314234, 0.34668769566345203, 0.31537724766089836, 0.1799102671069024, 0.2206793864983897, 0.17609223215867864, 0.19394992627486884, 0.20701916648315177, 0.18339719857593528, 0.1840980693687152, 0.22159643714135935, 0.16972725890370788, 0.1995512799839002, 0.25167104509676286, 0.17394321670952306, 0.4001517529736268, 0.24617706133401218, 0.20141581365160888, 0.33071992565717834, 0.22949414877566565, 0.20400355269352, 0.20145213577731846, 0.7685539092343152, 0.16473142898500104, 0.7139691378799118, 0.19750162032158447, 0.19105971947646916, 0.18295870427204686, 0.18559132607560336, 0.16691151578008756, 0.7881871834445666, 0.15493024908277508, 0.7644844369522659, 0.2024394807812896, 0.7341914891872727, 0.2037588747144332, 0.2113471006817459, 0.2085613251306212, 0.154863436056341, 0.17694034526154623, 0.18489352324174224, 0.19163274101825367, 0.1706017506750035, 0.18090665573162623, 0.17587083744171084, 0.18233698202294435, 0.2027929971486696, 0.20958582367504064, 0.07342510056799167, 0.0672638445292767, 0.08052645739878261, 0.06568976209678545, 0.06585446029108266, 0.06787386396565342, 0.0750768353456851, 0.09106328110850825, 0.06764082223777701]}, "mutation_prompt": null}
{"id": "93845fde-3c67-4d76-9633-6bd9f2f5de93", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.initial_pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.min_pop_size = 4 * dim\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.initial_pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def stochastic_ranking(self):\n        indices = np.arange(len(self.fitness))\n        np.random.shuffle(indices)\n        sorted_indices = sorted(indices, key=lambda idx: (self.fitness[idx], np.random.rand()))\n        return sorted_indices[:self.elite_count]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.initial_pop_size\n        \n        while evaluations < self.budget:\n            current_pop_size = max(self.min_pop_size, int(self.initial_pop_size * (1 - evaluations / self.budget)))\n            for i in range(current_pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            elites = self.stochastic_ranking()\n            self.F = np.clip(self.F * (1 + (0.2 if len(elites) > 0.2 * current_pop_size else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if len(elites) > 0.2 * current_pop_size else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if len(elites) > 0.2 * current_pop_size else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "An improved adaptive DE algorithm that incorporates dynamic population resizing and stochastic ranking to enhance convergence and robustness.", "configspace": "", "generation": 84, "fitness": 0.36616773067850844, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.8381947086143996, 0.8017170835125595, 0.8019836122813251, 0.805616999367906, 0.7870741629484485, 0.7926151557188958, 0.7850129927136811, 0.7920626463603282, 0.7931662325820523, 0.5426168280001714, 0.49669062916639306, 0.4764241089981184, 0.4941167735752058, 0.5324085999340171, 0.5391704794594874, 0.48556394281528914, 0.5032238802945482, 0.44116168956620727, 0.15455841383671887, 0.16936457296949825, 0.15036517701540886, 0.15092842177711208, 0.16646177019399433, 0.3123201546943243, 0.15142044631881968, 0.15562164799276923, 0.17555126051173997, 0.12382523142074664, 0.12877798647702676, 0.11935056383194864, 0.12709380336256004, 0.1345720865469997, 0.13561845028265707, 0.1355264584627306, 0.23301161128654624, 0.12353347473570464, 0.9891666514871477, 0.9823650539459658, 0.9821652636188216, 0.9886986758372297, 0.981490066892507, 0.9865951045082629, 0.9887843887878826, 0.9839514028241975, 0.9830884075257578, 0.3904092990734257, 0.42776355451969694, 0.38926065035651203, 0.40552954563475485, 0.42424254403740147, 0.4599358120640742, 0.4190619244068726, 0.4196261775944069, 0.40600603224159637, 0.7998916374679838, 0.7897025119966079, 0.8478646719052162, 0.8028656462760253, 0.8056142489849558, 0.8834961298185472, 0.6881738319650845, 0.7571783252646426, 0.7843614093767528, 0.37946418971989526, 0.3364114101938902, 0.3028096033505475, 0.34692193852622943, 0.3683231665245943, 0.3819192646297257, 0.4663168506726303, 0.3507640367077025, 0.44871476324326676, 0.313052256498224, 0.2669965978877822, 0.3189034186911289, 0.37222282952466434, 0.3890896796276162, 0.3312373218695357, 0.3847877315914102, 0.3124285298984141, 0.4313018570359005, 0.1587096334215763, 0.29729742860847896, 0.28427177191801767, 0.19988146179459954, 0.17813822343513042, 0.24219752020028673, 0.2631503530808391, 0.32450297091310243, 0.24108563292740948, 0.3727242132634968, 0.3913624340113129, 0.31486880354395164, 0.2569400876516188, 0.30391726149060994, 0.38421614450789887, 0.36315652666943155, 0.2728430367902057, 0.3268499820233728, 0.16797330695430301, 0.13350541605206434, 0.13960672149675557, 0.11654715331917309, 0.15871704575888002, 0.0882307074138835, 0.082216093863833, 0.08810556549218451, 0.1256364013563711, 0.2572304772931787, 0.2667222930174036, 0.19916980687759078, 0.23920269164099495, 0.2557337649867907, 0.27373134772314733, 0.2104917679199556, 0.2568405332976279, 0.19126863311610076, 0.6807180224394038, 0.6763399712123879, 0.5974223719446099, 0.6504217957776115, 0.6404398149072135, 0.577642308308562, 0.75842188829672, 0.5805470667521015, 0.6212843949100493, 0.10843944030863117, 0.14056223581338434, 0.1283029323639987, 0.17704660291396646, 0.10784911858917168, 0.11387712360840974, 0.11387754552493556, 0.11458999651518464, 0.11010144085886897, 0.14192962057947367, 0.1828532468541233, 0.15656281901819313, 0.15476461131758645, 0.1537328417830327, 0.17491814831366992, 0.13519330593812318, 0.14627113221853272, 0.16665574722818277, 0.2989887732022598, 0.3189336368352941, 0.3744874706592839, 0.36255815854658935, 0.3679813195822318, 0.39589853281479914, 0.35221291753722594, 0.3747467774436519, 0.38418528547068953, 0.30873127478983564, 0.2610958592075636, 0.2736367701650765, 0.27278211265605756, 0.270723946970312, 0.29761323682531704, 0.26247116584382135, 0.3048277372451752, 0.31684392251077964, 0.24387331009429514, 0.2126574143021206, 0.1978997987981831, 0.20913506270104099, 0.21504911253104897, 0.21397238559535947, 0.23089728883615712, 0.2337571134442804, 0.20795695031308636, 0.2097709681299983, 0.21692164903514888, 0.20206853378647205, 0.20718622799250241, 0.20506319124054107, 0.22449186030517243, 0.2084802029684596, 0.39322529231430514, 0.4009556522578718, 0.18907654359161497, 0.18719094940971692, 0.1883728148611442, 0.8291290365223053, 0.8126993942277866, 0.20026447782648038, 0.1414749473273288, 0.7899460550532797, 0.8544891207661109, 0.8657572843333465, 0.7661779795647541, 0.8481754216201933, 0.1685423918914708, 0.20716613665796646, 0.1558674747225801, 0.16792153157076695, 0.8207779397212538, 0.866936920365129, 0.16897308807019595, 0.19439807193739678, 0.1818166680656147, 0.17930132173444358, 0.1879452621300386, 0.1967674814699205, 0.19229511296445057, 0.17945774942692128, 0.190574856811647, 0.09068474220612421, 0.08024544099740705, 0.07957775249227939, 0.0874322766632255, 0.0836548783722979, 0.08231752447512608, 0.08882385192358777, 0.0844326001586807, 0.0879985833136927]}, "mutation_prompt": null}
{"id": "aa4b8847-5a7b-4e4f-8b6b-6c53b4f7340d", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.7\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.4\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def diversity_maintenance(self):\n        worst_idx = np.argmax(self.fitness)\n        self.population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.fitness[worst_idx] = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.6:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                _, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            if np.random.rand() < 0.3:\n                self.diversity_maintenance()\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.2 if success_rate > 0.3 else -0.1)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid DE with an adaptive elite boost and diversity preservation mechanism to improve convergence and robustness.", "configspace": "", "generation": 85, "fitness": 0.5210191636266358, "feedback": "The algorithm EnhancedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.28.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.8857549649090115, 0.8890187805073693, 0.9087623657585807, 0.8814248437837615, 0.8974680336355979, 0.905687269713249, 0.9005860046339532, 0.9009983363069086, 0.892148105936325, 0.8120928550764382, 0.771945596557395, 0.7762100392840879, 0.7953574588965349, 0.8017698557036631, 0.792779530796821, 0.7949335342747585, 0.8063579792573914, 0.7938739127824725, 0.5185749526818788, 0.41268288051122715, 0.23520562578002124, 0.4421643403446228, 0.39793948101051324, 0.34801463981618064, 0.1881984488819578, 0.16633637527576117, 0.18494226089116605, 0.23905710227812726, 0.1566153705094373, 0.2862872147691845, 0.27168843985515745, 0.2652972399713588, 0.28130410260748395, 0.13043703966136422, 0.20721155844173222, 0.14177258720023878, 0.987850023908139, 0.9918849337475064, 0.9849152121681377, 0.9896549732424189, 0.9899482250990753, 0.9904118167216055, 0.98427426229521, 0.9914417753272832, 0.9905200490395596, 0.5755120494531081, 0.6022776442626427, 0.6123590926513032, 0.5818993917780945, 0.6124339352630475, 0.6206102535671145, 0.6142633974635903, 0.6035456185446517, 0.5848176173620979, 0.8884106210086287, 0.8660107687475435, 0.8727075878517712, 0.8869458624352189, 0.8832504753239824, 0.8789888325757107, 0.8899105088631047, 0.8767254607353133, 0.886336598235088, 0.6824265131722516, 0.7239008150535966, 0.6909572051827986, 0.6775450451873353, 0.6789232973820688, 0.6684900420758275, 0.6955156936091844, 0.6892647478524778, 0.7123427452738216, 0.6815517737822226, 0.6867429098647111, 0.6005241275384214, 0.6698537668988191, 0.7140306839893957, 0.6957300071136244, 0.6806589477290541, 0.710000874708185, 0.701559002232195, 0.5779769785810176, 0.6639490482660055, 0.6451477870148974, 0.6229664091938977, 0.6405602559821577, 0.6675621361272148, 0.654278944767271, 0.5735821552120319, 0.6144959781645418, 0.7258527261898227, 0.690612033012134, 0.7177149857080317, 0.7031626839817575, 0.6911164418956744, 0.6857869325391257, 0.7371801576958308, 0.7286838015608532, 0.6936617128390459, 0.21402869529240398, 0.30996191292164965, 0.3978075893571773, 0.529999670437838, 0.537208343446507, 0.3082284412970394, 0.3581116368496753, 0.27238700954252726, 0.4837643130945274, 0.5112755126989206, 0.5280266129306228, 0.5104117991062141, 0.5377008123276438, 0.4759565369000467, 0.5243943275914584, 0.5133321668541884, 0.5188675014791138, 0.5446081874691655, 0.8341251840024366, 0.8397374224991218, 0.824402283323782, 0.8242079206639735, 0.8309734824259662, 0.8189982785106207, 0.8145202993685724, 0.8318150910689484, 0.8389222751787389, 0.14004605240308687, 0.13777618641118383, 0.35803866288100705, 0.15303233643787495, 0.15868682337223694, 0.32856808404035076, 0.12337604018478143, 0.12729022893588426, 0.1214506843005938, 0.1350097955589986, 0.16543371593044853, 0.1444545741590949, 0.130956474847561, 0.1698807432158137, 0.15801511216884445, 0.420847936635667, 0.15112497241654022, 0.17661997490778814, 0.5156671513857101, 0.5540472780852451, 0.522701230001199, 0.5012339585946772, 0.5582665019609536, 0.545246147484105, 0.5634096012539094, 0.5877386589943656, 0.5707657466579923, 0.41213408313128286, 0.40302588585550125, 0.41196723056727624, 0.43733507643859315, 0.4178457827450286, 0.44461877243225967, 0.4979688128804374, 0.4698945430584395, 0.46756512747711065, 0.23199377273507882, 0.24800271099212734, 0.20065584212091736, 0.21239732572460146, 0.23856035385054297, 0.20836253163087626, 0.21318050682836043, 0.2002267516897689, 0.19441972886920278, 0.5920474632510477, 0.5394939991081891, 0.21026500586248487, 0.2359405832868804, 0.19921942277451454, 0.45983164668821164, 0.5373425821797582, 0.2126141143853243, 0.42154428866837945, 0.9090099828183437, 0.8588539040952872, 0.15240678623700643, 0.8946779727531041, 0.9082623245964243, 0.19824337081782395, 0.14048265819729644, 0.814800533044459, 0.8336072586984722, 0.8838180838998911, 0.8566602412515105, 0.8970372971368139, 0.7864074591309487, 0.1667263818824879, 0.2100254478907434, 0.21141039123782768, 0.16691620005714847, 0.21134857142265162, 0.1946179958330555, 0.20820827620914995, 0.18819866150929876, 0.19620993209698978, 0.20647632266516058, 0.18810116211727523, 0.21557118445863666, 0.307251787751758, 0.18623377283938303, 0.0871905412820555, 0.08489965980962078, 0.08565817209864313, 0.07873419680400418, 0.08810960769436738, 0.07517618303926843, 0.08761869459776028, 0.08920647425949213, 0.08695444467220292]}, "mutation_prompt": null}
{"id": "64a08a43-0811-40bd-b89c-b6164da456b0", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "96341dd3-6004-4734-8db9-34b2b6e96855", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.beta = 0.8\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def gaussian_perturbation(self, idx):\n        perturbation = np.random.normal(0, self.sigma, self.dim)\n        return np.clip(self.population[idx] + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < self.beta:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.gaussian_perturbation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n            self.beta = np.clip(self.beta * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.5, 0.9)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid DE integrating self-adaptive parameter control and Gaussian perturbation for improved convergence and robustness.", "configspace": "", "generation": 87, "fitness": 0.471948518348889, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.8519510768210415, 0.8386814103951259, 0.8608596263317545, 0.8450391622557456, 0.8686669188630068, 0.8573889818651443, 0.8522559959698861, 0.8426093851114378, 0.8647153137424668, 0.7510171866403639, 0.7438716241988694, 0.722169442380401, 0.7434588323135017, 0.7540345817234192, 0.4546929724580818, 0.7370595025861572, 0.7371990812311685, 0.7513430806309374, 0.31002125165583905, 0.15755923774394764, 0.45771245216725265, 0.15066020107451383, 0.1396205648402925, 0.10332031354741944, 0.496798030891063, 0.15683164583244757, 0.15994930455539302, 0.3551907617913732, 0.16777533650439547, 0.1543474914894165, 0.6084685418004863, 0.15449661944007642, 0.1391372898648291, 0.15073522040614007, 0.16303435361462548, 0.46380354258494916, 0.9898762613928983, 0.9910399325913883, 0.9920199523795085, 0.9909777738957583, 0.9899805793819086, 0.9883963647919436, 0.9878862884816518, 0.9922803742266277, 0.9939710292977733, 0.6306604213693703, 0.61297167952527, 0.5490657174910248, 0.5876905692296122, 0.6047703504483359, 0.6434215038420175, 0.6141070927643221, 0.6808230613438273, 0.6327221100226218, 0.8312958231364426, 0.832750428808438, 0.7791163357083155, 0.8656331694653849, 0.8248298531982092, 0.838347284822665, 0.8626402620695288, 0.76591461442381, 0.65899499117332, 0.6390882320896469, 0.6370354406865418, 0.6119749805710741, 0.6455612110851099, 0.6130754070482123, 0.12887821055715343, 0.5133829701518233, 0.5509752853022476, 0.6225558166901866, 0.6557145437137855, 0.04962228902021015, 0.6352836015082306, 0.6520564899041608, 0.6550172702630379, 0.6783630467968198, 0.6272709445775216, 0.6344635700148925, 0.5909947056301676, 0.5715452701890044, 0.5043909465741585, 0.4824476181763684, 0.49178184757037247, 0.5397013664727286, 0.5330570118900393, 0.5019631367652475, 0.48183215739474683, 0.5743914232841814, 0.6506445629931215, 0.6670294395389886, 0.45341248326988337, 0.6541132621125303, 0.7019391515281944, 0.6392364699142816, 0.6736286296145515, 0.13088388178458632, 0.7291546776487818, 0.321783960365829, 0.19639763809379673, 0.2277763658497769, 0.2499211332112672, 0.3597232536298025, 0.3125522783874263, 0.09489879048743588, 0.21197012892850786, 0.3048005289902129, 0.3985440160334148, 0.011428586291360121, 0.3874132956501014, 0.46207825542362757, 0.45606569467208136, 0.44532239124877804, 0.4323613372590176, 0.4328173017928162, 0.40730033480595595, 0.7098936008214911, 0.804325648454759, 0.7856516097542184, 0.7147798869642443, 0.8114624413416687, 0.7510092990566108, 0.773358457072211, 0.7769412335058545, 0.7577970956286022, 0.13722852198439506, 0.130573036428275, 0.1143715097078215, 0.13153654329005715, 0.12015174049405597, 0.11805939381145125, 0.12118317179407057, 0.10814444447908822, 0.10623509314810342, 0.15971032748750436, 0.29867525489923663, 0.17017529141122834, 0.45678589545792747, 0.6457498515250777, 0.5301482182061048, 0.37270329654860335, 0.24252063790970346, 0.4182367804866919, 0.5092519307118668, 0.4362351319233745, 0.480768402716757, 0.4606823041447172, 0.47862898183234115, 0.44606640415235466, 0.4326978927342, 0.5107638982301247, 0.4896100374059926, 0.26913614269684427, 0.35768892502393446, 0.3220185853784088, 0.31671264373483876, 0.4077297259980287, 0.32475816907878163, 0.3577290230200608, 0.45929096576576134, 0.350842821418232, 0.22784290226105952, 0.17918054388394156, 0.1848661508301026, 0.17900172016106486, 0.211999255085907, 0.19015322394831735, 0.20336905155854823, 0.19832843116916343, 0.21712386588634347, 0.24419256215973084, 0.6505711711205359, 0.6468063550370184, 0.6156854167057603, 0.5957446038858933, 0.2116125779708974, 0.6445590106873796, 0.6022730911090721, 0.636858129998868, 0.876739954964745, 0.1537142164766241, 0.870001351696598, 0.7864669825357317, 0.1987454516394157, 0.8605559560470658, 0.1833908307042189, 0.17002710536539267, 0.8125789857399766, 0.8543641961655226, 0.20671669143007787, 0.1669356323446307, 0.8693228994992912, 0.20567724706284374, 0.20361723072360172, 0.21195111914871245, 0.20835838923756755, 0.1550571124332295, 0.18951479808798155, 0.19305971617755702, 0.22596362492810917, 0.19512230944098619, 0.20939231452619844, 0.1978158893793488, 0.19076061619009765, 0.22349731891882962, 0.1934989712235532, 0.08172953070728473, 0.0714413517529614, 0.0806909053130005, 0.07839125839505845, 0.06931295469060839, 0.0673658224455288, 0.0756222245939322, 0.07666125729051032, 0.07434661092921435]}, "mutation_prompt": null}
{"id": "d58de763-b611-457e-ad91-177af33d30ed", "solution": "import numpy as np\n\nclass EnhancedExplorationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Increased population size for diversity\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.2\n        self.memory = []\n        self.memory_size = 5  # Number of historical vectors to maintain\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            if len(self.memory) < self.memory_size:\n                self.memory.append(trial)\n            else:\n                worst_idx = np.argmax([func(m) for m in self.memory])\n                if trial_fitness < func(self.memory[worst_idx]):\n                    self.memory[worst_idx] = trial\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def adapt_mutation_with_memory(self):\n        if len(self.memory) > 0:\n            mean_memory = np.mean(self.memory, axis=0)\n            return np.random.normal(mean_memory, 0.1)\n        return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                if np.random.rand() < 0.1:\n                    mutant_vec = self.adapt_mutation_with_memory()\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedExplorationDE", "description": "Enhanced Exploration-Exploitation DE integrates adaptive dynamism with historical memory to improve solution diversity and convergence.", "configspace": "", "generation": 88, "fitness": 0.31007437923957953, "feedback": "The algorithm EnhancedExplorationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.6772592036386633, 0.6579379577636351, 0.7130679178008783, 0.6851741983659854, 0.664854344234425, 0.6992754917989391, 0.658437195432142, 0.6525769922437794, 0.6414804594589185, 0.326705844684995, 0.28876429316302643, 0.29114880729082737, 0.3261045645273415, 0.3064490130882608, 0.3406163894408639, 0.3438647876712324, 0.2784606011267854, 0.26245869016667744, 0.1366980329946086, 0.14377277506853992, 0.20970175162963622, 0.1594311662131006, 0.11403082080627014, 0.10605962698858162, 0.11373928720342774, 0.23903258410192374, 0.16215976814278443, 0.12912418200813003, 0.0995480811326308, 0.0976598409046825, 0.11592672172432217, 0.11871764843674248, 0.08194727333321483, 0.09893657760212704, 0.09017964795356781, 0.13042524815951895, 0.9496446306268326, 0.9080373927280596, 0.9191801017822792, 0.9218620241689315, 0.9141578358511778, 0.9451904548076736, 0.8688684683356191, 0.9145955133796534, 0.9570101118514875, 0.34029338784387964, 0.3275209125023121, 0.2929792890645243, 0.2938025180948459, 0.3093472273841027, 0.33770012657208814, 0.3864142467129609, 0.3102781328729407, 0.3154107321142112, 0.22268409562817515, 0.6922722966839793, 0.6425371605801677, 0.2700816199790008, 0.6937285159684312, 0.7422570470910308, 0.49593106541127496, 0.61308246777269, 0.2305784372870031, 0.28104991380818234, 0.3197409773545723, 0.25649663245133647, 0.16889275389175396, 0.1828072771886433, 0.23634354896758947, 0.2815775025371674, 0.20305766304818695, 0.21934020016647893, 0.2132539465130452, 0.24888437395870167, 0.2444076157991819, 0.20706085501165272, 0.2802224468309058, 0.2004325134324263, 0.2972015664444917, 0.21753215621500244, 0.25066568954604274, 0.16653676755432423, 0.14356214475666984, 0.23301937264097916, 0.24497771665775026, 0.2128670347552295, 0.22150563039879245, 0.2050699476092418, 0.09669275670002409, 0.21772863425869016, 0.3254510362267613, 0.3211482609811456, 0.367988858760811, 0.3362735290285034, 0.2986134826689446, 0.2879931531773151, 0.3421349772094123, 0.3401132786501536, 0.38885271553386547, 0.16847843217317526, 0.05584611258985117, 0.1270130951329751, 0.16769836887850365, 0.13272054922897536, 0.13386910638343685, 0.1365838496854983, 0.14399988440322864, 0.10958442698828308, 0.2185596591040413, 0.22115057345388522, 0.2213287023852738, 0.211617176282621, 0.2076258736859099, 0.2084169458889883, 0.22381542179938962, 0.2348391581429432, 0.20462979500841028, 0.5807231965774129, 0.5543298260482643, 0.5884180542101292, 0.5690640898251226, 0.4406435284468193, 0.5374526261267145, 0.5881345033894798, 0.5990083141110695, 0.5492960549334742, 0.1065873804705505, 0.10823705570220976, 0.11380144330521202, 0.15870223008713746, 0.126657240667724, 0.10407680183563794, 0.10306070978359094, 0.11553408230877471, 0.10634936209703205, 0.1356367089130427, 0.3350486926098245, 0.17621935928356547, 0.1568486929649795, 0.15548000141718243, 0.1392540546092117, 0.1431790689821001, 0.15076270071576126, 0.1273872096094567, 0.35567387053298694, 0.3477654041631818, 0.3664689727808582, 0.3492340234009157, 0.3613966046823499, 0.3653380977081191, 0.36219551474707745, 0.3443470588591443, 0.34249732808101985, 0.22921439362744866, 0.2482637954388045, 0.29981528371730437, 0.2687212906255637, 0.2781519303282989, 0.32945559961587034, 0.2501713048624401, 0.2992516807002066, 0.27511829868871174, 0.2591384395618237, 0.19376031338681055, 0.2147943466310286, 0.20728452682665643, 0.20767796168387098, 0.225606978519572, 0.22384777942858736, 0.23527088891930492, 0.26363943427789394, 0.19264606349131563, 0.32634493211679994, 0.24406332966367228, 0.20500003796589072, 0.20399157937854984, 0.1924298627828155, 0.2258294053832628, 0.29716852261281057, 0.22231007553314475, 0.18118313768664107, 0.1858438990845358, 0.15035057186998402, 0.719251640410751, 0.1669243743206592, 0.19385373591941135, 0.7912120777943747, 0.6487392048388627, 0.16724049857575152, 0.7207128209908571, 0.16440909458939168, 0.7895197126859118, 0.642098582845917, 0.2022681860022284, 0.16400844831833583, 0.8199919404688547, 0.7178263900441334, 0.6078442361842542, 0.18586168007127724, 0.17738454735507625, 0.17413441582166944, 0.1794364418416713, 0.1881758390689101, 0.1759445518577919, 0.17811873021779212, 0.173292596051412, 0.1874354318739282, 0.08605790432041249, 0.08254049266602392, 0.09668760249915298, 0.08530567828984481, 0.08973540576488426, 0.08059894340654117, 0.08195191902852095, 0.07651956069599652, 0.09538004118593058]}, "mutation_prompt": null}
{"id": "9d42aa5d-46b7-4370-9bce-0601643d7827", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "7d48ee19-f396-4410-b907-9d2454f8473f", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.tau = 0.45\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def stochastic_ranking(self):\n        indices = np.arange(self.pop_size)\n        np.random.shuffle(indices)\n        for i in range(self.pop_size - 1):\n            for j in range(i + 1, self.pop_size):\n                p = np.random.rand()\n                if (self.fitness[indices[i]] > self.fitness[indices[j]] and p < self.tau) or self.fitness[indices[i]] > self.fitness[indices[j]]:\n                    indices[i], indices[j] = indices[j], indices[i]\n        self.population = self.population[indices]\n        self.fitness = self.fitness[indices]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            self.stochastic_ranking()  # Incorporate stochastic ranking to handle constraints.\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant incorporating stochastic ranking for constraint handling and differential neighborhood exploration to enhance diversity and convergence.", "configspace": "", "generation": 90, "fitness": 0.5465336514076214, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.29.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9201847178494937, 0.9169962609127112, 0.9179731017930047, 0.9122827167193648, 0.9145236614606294, 0.9169290443204531, 0.9113471877520782, 0.9088878400945513, 0.9085693372701162, 0.8175391855295507, 0.8006623524742463, 0.8077504618904569, 0.8204455395905924, 0.8159864829564059, 0.8276399297553797, 0.8221981149483097, 0.8270293116519714, 0.8133038009122375, 0.39340604104468235, 0.24264349526176632, 0.37324223029166237, 0.36672188763743585, 0.1488637284949873, 0.25233173590744473, 0.15014336407650586, 0.16269399785417715, 0.7036140845319372, 0.14392019443700532, 0.13366463283602292, 0.1494055457742225, 0.32497455848080836, 0.16231966152932198, 0.1375103726635214, 0.15585965083165665, 0.11019094945873953, 0.14701346703670892, 0.9901321041518981, 0.9872075110981198, 0.9926345455607135, 0.9810459672354389, 0.9919163686575907, 0.9912278165460389, 0.9911041901211551, 0.9889766249072043, 0.9886785937396981, 0.6928822302036732, 0.674787748245832, 0.6571202968142249, 0.6999330928488393, 0.6558653047595522, 0.6897479307877621, 0.714474284845897, 0.6846039598285096, 0.7018080838092673, 0.9018133279296975, 0.8693246384077151, 0.8933567158892557, 0.8946292590322639, 0.9043308786893564, 0.8934673532484716, 0.8875834985132476, 0.890100287436704, 0.8979091931599757, 0.7835085585523243, 0.7436416761481979, 0.7359480716609488, 0.7377495630214039, 0.7265119416268025, 0.7616370041453523, 0.7447398849094768, 0.7408011588164898, 0.740714534069112, 0.6824025727874159, 0.7450798849117246, 0.665078223346856, 0.6799261965748125, 0.7582913020954458, 0.7189454924819669, 0.7397023015963511, 0.6664788998035638, 0.737882975443328, 0.6951348184449037, 0.6643515076958213, 0.6989594592031685, 0.7128242237654292, 0.7218717686058687, 0.6993498642431178, 0.7302248215206762, 0.7271100637835788, 0.7074471613882484, 0.7869869880430319, 0.7588679699708749, 0.7727247524440828, 0.7655581329739064, 0.7405323361768028, 0.7607895826146032, 0.7850928393929332, 0.7705995029093593, 0.7735003024746842, 0.5126806360494233, 0.46578377513239033, 0.5042700210818751, 0.5265741033774216, 0.6276310333254671, 0.6358248588369884, 0.43726332931210776, 0.33852961821557126, 0.3354851342776771, 0.6416373368574415, 0.619017696605272, 0.6118561188478852, 0.6129000033035918, 0.6231342702925605, 0.6527237318487045, 0.6209845724289609, 0.6178161636742843, 0.6405745012352353, 0.8682910086775381, 0.8561292780342318, 0.8533134068606798, 0.8567087102154807, 0.8492617855088271, 0.8577552899459601, 0.8748581148927308, 0.8629148350094921, 0.8757049158852179, 0.14273816966875452, 0.4048505000023811, 0.143477305693971, 0.13447672361241236, 0.15966958454078561, 0.12433360143525718, 0.13596943898742997, 0.13436935687615792, 0.12260393558153193, 0.18433003621231314, 0.13830954921955685, 0.14157205703699205, 0.13197090679993706, 0.31046341014985845, 0.2608232397257487, 0.1902788687139657, 0.18499289913905104, 0.18032635439711597, 0.5988682547029243, 0.5976661656186626, 0.6291616437857519, 0.648797497552293, 0.6570324534443062, 0.6239478112118025, 0.6563571330187662, 0.678170545786729, 0.6833173738332596, 0.4792658271285467, 0.4499909043330873, 0.4869520242685689, 0.5126414948130893, 0.45274065643783834, 0.5339557311558951, 0.4842667729941458, 0.5667814504306279, 0.5425850228665801, 0.21893134500662148, 0.21700048197124766, 0.20836582775653856, 0.22190961572841017, 0.2092173057266975, 0.24607657245353098, 0.22223488899628063, 0.22141291134944796, 0.22036265237394181, 0.22981052205712127, 0.226367655078479, 0.21274924000347262, 0.6181287630875186, 0.23779193238619445, 0.19918564654065396, 0.21444998201213872, 0.588411351972255, 0.2198937957024718, 0.187652066120081, 0.18787281833528036, 0.1849085680027054, 0.9342012143786474, 0.1982496987440392, 0.1970963213296425, 0.856050204491339, 0.8052312685476843, 0.8878112239133292, 0.9094823698247368, 0.792081343439163, 0.8148338467110168, 0.21184508506983568, 0.20370177467925898, 0.2096406623945517, 0.8576328576892056, 0.85718604723808, 0.8987668023502915, 0.18992668274117952, 0.20221341667414672, 0.17459907004348973, 0.18347538694292576, 0.18392361645419164, 0.17322851490887914, 0.19374421508159045, 0.1858990920710517, 0.17549470582585236, 0.13019060967056773, 0.08769468438007133, 0.08529252260402687, 0.08491233354989947, 0.0942753168905478, 0.08586989810700996, 0.09209009233786036, 0.10011255593984025, 0.08770558531114259]}, "mutation_prompt": null}
{"id": "d554377f-4fbf-4f13-a933-608ea7001c64", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.7\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_archive = np.zeros((int(self.pop_size * 0.1), self.dim))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        idxs = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n        a, b, c = self.population[idxs]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def archive_elite(self):\n        elite_indices = np.argsort(self.fitness)[:self.elite_archive.shape[0]]\n        self.elite_archive = self.population[elite_indices]\n\n    def covariance_mutation(self):\n        if len(self.elite_archive) > 0:\n            archive_mean = np.mean(self.elite_archive, axis=0)\n            cov = np.cov(self.elite_archive, rowvar=False)\n            return np.random.multivariate_normal(archive_mean, self.sigma * cov)\n        return None\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            self.archive_elite()\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6:\n                    mutant_vec = self.mutate(i)\n                else:\n                    cov_mutation = self.covariance_mutation()\n                    if cov_mutation is not None:\n                        mutant_vec = cov_mutation\n                    else:\n                        mutant_vec = self.mutate(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.4, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.4, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.05 if success_rate > 0.2 else -0.02)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid DE with Differential Elite Archiving, balancing exploration with preserved diversity to refine convergence.", "configspace": "", "generation": 91, "fitness": 0.3242763474610631, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9012206121925934, 0.8871357442611855, 0.8575276444221339, 0.8698908300255938, 0.8785110754930104, 0.8932455682927772, 0.9036275245452474, 0.8728780968076277, 0.882903218549214, 0.8136079210759225, 0.8661647062644489, 0.7148010577085705, 0.8225587220652348, 0.83695442133601, 0.7586631493940084, 0.8125404748530429, 0.8522830929345143, 0.8293699294882861, 0.113016687272805, 0.7712474499889752, 0.13601516603575914, 0.1273812156603884, 0.11846533034471374, 0.19285892825199724, 0.07842448027514493, 0.11834830977863309, 0.14725311797013874, 0.07568568827363464, 0.10090706938100136, 0.10717664342804367, 0.08720078257027997, 0.06403557104474678, 0.08601913608981215, 0.019885301677809886, 0.0708423380258788, 0.11443913985903853, 0.96295298971746, 0.9571785854505482, 0.9596877283194393, 0.9863669805410398, 0.9789285453966531, 0.9316902767289005, 0.9425544116666401, 0.9296275842499212, 0.9088866463597212, 0.631721961535735, 0.7176921420156228, 0.6988738306795912, 0.731755200679161, 0.6307554307904757, 0.6735676338291633, 0.7276091356828882, 0.4855265479480547, 0.7016633250779392, 0.13744801824319453, 0.22968347769339714, 0.14067601274279096, 0.28013336521111776, 0.31127064153232153, 0.12254664977052088, 0.13973505964946575, 0.34029592784935214, 0.1666487060713946, 0.40367757058921006, 0.13632774588447938, 0.38679179579874357, 0.33086547609675077, 0.17990005455644786, 0.20817021366112787, 0.2750073559323669, 0.13276790264415816, 0.13144170536460353, 0.23327980625702072, 0.13674121934428063, 0.13502411550291016, 0.1678925312328049, 0.18362706859218847, 0.2899146245837839, 0.24900439142227548, 0.2510705309856953, 0.1316514061856664, 0.10171797836347019, 0.1352602352879959, 0.03550200795005787, 0.13641006018572166, 0.21365498667812266, 0.03398689151098622, 0.06422428038926642, 0.10639457051335088, 0.11973820790927914, 0.18967689482682404, 0.0796903331106481, 0.1586666414841924, 0.08868266076340092, 0.02402480783292249, 0.07664433052207931, 0.14276208014558034, 0.3120736751433216, 0.13021635386627806, 0.08613473546554251, 0.2399647095263856, 0.16770545994565345, 0.14218001143953296, 0.16311272248131203, 0.3656881540291246, 0.07653825836595729, 0.1409961349293819, 0.20242105562500312, 0.2469960570234654, 0.1582161085144207, 0.2523333355229048, 0.29435610254501166, 0.13876215240167766, 0.3447212645646621, 0.17928163211162496, 0.2500501479088989, 0.1138586603768339, 0.5037813107934511, 0.6058159052703198, 0.5435272966119273, 0.6070424183943499, 0.5897837032643135, 0.5776449497802136, 0.5712666599823357, 0.6652739533360212, 0.5966651795498001, 0.09727228263744148, 0.11532444787833684, 0.12633580297742864, 0.16008516900647118, 0.10884907430490454, 0.14601303745333605, 0.0934528051347524, 0.09730817015916804, 0.09258989026059239, 0.1974678989879889, 0.18668939647607663, 0.1850588565920429, 0.34257350419869304, 0.2568041681875901, 0.20566448779712032, 0.1653444887290796, 0.17182457685055164, 0.21969807226730564, 0.2502235917276233, 0.2786184129315288, 0.18888903864536255, 0.33409879952326704, 0.29236061439724037, 0.27750931352528885, 0.19838535672977797, 0.400731928667436, 0.23239958754302792, 0.18836325903938178, 0.16014425124594522, 0.3351443666442364, 0.16532538405158725, 0.14665515070208235, 0.185689294313773, 0.1940852220823398, 0.22601094934147326, 0.23307600731178535, 0.20549894150294012, 0.21304392601865607, 0.2212080717005982, 0.1943685744551461, 0.22213861410500124, 0.2294699230910906, 0.23116552839681748, 0.2048894680009996, 0.21847923405380265, 0.1810030744332647, 0.19709378571581115, 0.17484306730161803, 0.16680911783645713, 0.19271583293332795, 0.21518602391649566, 0.19159448116780642, 0.1986473019593653, 0.18035993277607543, 0.1654678090510162, 0.8229616609777329, 0.15379785185826622, 0.8495244985075503, 0.20048817134160968, 0.13091744851222598, 0.141529535632701, 0.14207756240286795, 0.8495939667768087, 0.7234011585868781, 0.211453293385781, 0.7085310157724702, 0.868122700452701, 0.1678206972137154, 0.1667560426715956, 0.16962072647516835, 0.20863643664751796, 0.758079250823983, 0.1889466232602125, 0.1995678932362943, 0.18432144080683655, 0.19367926247721567, 0.1958528404989891, 0.18251871820715548, 0.19614162518327094, 0.1671913185078744, 0.17574821768881577, 0.10565302489216921, 0.09675766086451187, 0.11929421254308004, 0.10154445021984959, 0.09815857752719093, 0.09275708660823234, 0.08671586132925913, 0.10281303874372183, 0.07750426226817375]}, "mutation_prompt": null}
{"id": "dd06a9ef-865f-45d1-8033-a6490b2b7139", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive DE variant integrating exploratory covariance matrix adaptation with elite preservation to balance convergence and exploration.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9286731643949573, 0.9253803778563191, 0.9251783712513547, 0.916161355930767, 0.9320578534904873, 0.9271767060380149, 0.9218283299259091, 0.9179932737223163, 0.921782421306997, 0.8438244465383624, 0.837719391645683, 0.8388349854368705, 0.8351571065518103, 0.8460707754379136, 0.8367207240028087, 0.8319441204031544, 0.8434971102733202, 0.8412396011710699, 0.4600516340655013, 0.4480336953340137, 0.4254339234049206, 0.14605127901257653, 0.441300959333769, 0.37126472391870824, 0.42837137843883133, 0.601833498295968, 0.37359125847184027, 0.15288037588855552, 0.09354442554164255, 0.16265741936182243, 0.13918427281782664, 0.4584014904650947, 0.2474753147944747, 0.11938622442152969, 0.1740754265922978, 0.15918398208536055, 0.9899852515926959, 0.9846796109076478, 0.9832938132256351, 0.9902358470315021, 0.9867955344886188, 0.9909314430683474, 0.9872698252623427, 0.9865257913120222, 0.9905096457820105, 0.691799505968657, 0.6958604489420723, 0.6915977573519039, 0.6675724100500761, 0.7155935379651355, 0.6807889548357842, 0.7009474519380507, 0.6561077447650934, 0.6780616882165527, 0.9166608001325968, 0.8922936175819833, 0.9126245591884141, 0.915460942707781, 0.8069901933952554, 0.909462603156977, 0.8783947256779047, 0.900270667641103, 0.9021288495481556, 0.7646887135048028, 0.7369953549885151, 0.7596849512226854, 0.7211733522545327, 0.7533350677290324, 0.7388972956258152, 0.786400555081181, 0.7166456643271826, 0.6712694138951854, 0.7726449656454744, 0.7659819465649521, 0.7417541470934881, 0.6822851055604613, 0.7281150685754165, 0.771017641355487, 0.7485516003190233, 0.7257585212034732, 0.7691026530823132, 0.7100561712356552, 0.7208828538235912, 0.7078360153479307, 0.7200788528110957, 0.7258320664893236, 0.7151973504774843, 0.7442653928780025, 0.7221015401858639, 0.7266731176078702, 0.7718550415980474, 0.7762842144371453, 0.768467640848433, 0.7819339698363128, 0.7659903599337379, 0.7656602167973923, 0.7974366934576961, 0.804694652080587, 0.7929290383215148, 0.593495482319963, 0.42944160445042756, 0.5517498817047566, 0.6633225343387217, 0.4316701654833519, 0.6300887256653773, 0.49772865104612607, 0.4289904173698226, 0.25324833742149044, 0.6324959483766772, 0.6493298022019955, 0.6491143997390162, 0.6665607136649598, 0.6475330185224673, 0.6499725999604811, 0.6482258664316481, 0.6562642449609624, 0.6437154208197245, 0.8741075588955938, 0.872475420803801, 0.8906789861405348, 0.8688408198003932, 0.861596449053879, 0.8744462146145504, 0.8791304233590477, 0.8684185343569586, 0.8711511687852795, 0.11395211167266683, 0.1322865526791699, 0.13229405502273162, 0.1257949399608187, 0.14567875115621243, 0.48922743365958954, 0.16347828338503645, 0.14665854274498835, 0.14013851113464248, 0.41395282131604116, 0.1480548080604973, 0.2514699849435563, 0.1942783901898022, 0.15549197796343794, 0.4547567057779638, 0.14384075326176704, 0.19205910720207697, 0.16537347456823204, 0.6162401855885273, 0.6491355367559448, 0.6405195610812866, 0.6710895160140918, 0.6521622864273737, 0.6742241111381206, 0.6739693919996148, 0.7029757251844665, 0.6382895952582932, 0.44723726599284896, 0.46577192506035003, 0.5104851460153405, 0.5100277994138512, 0.5625911932566663, 0.5235176756445894, 0.5543160566885856, 0.5551761647029434, 0.5229201344024392, 0.2062579029266164, 0.267116368044068, 0.22055863837379241, 0.22967400580026165, 0.21167877730797213, 0.20770536446482835, 0.241144802061797, 0.21691561862890008, 0.2148552249222625, 0.20094085785439664, 0.7151464979479468, 0.3866862240457082, 0.2277589692558194, 0.20832685365562087, 0.47163037873370883, 0.23395677030220563, 0.24182287864883945, 0.21332864714687916, 0.1890584946958629, 0.18798639889304258, 0.1872731261512286, 0.9267292635795066, 0.8554892984634588, 0.20065758340627038, 0.8917615006043271, 0.8727340484650385, 0.9240734690267975, 0.9166300553984931, 0.8209917832629885, 0.9215712713065376, 0.16835219197923257, 0.2062253944908754, 0.8061619328313997, 0.15359185694329136, 0.16703545413470822, 0.9221660836118961, 0.1882379010589551, 0.20189972772053044, 0.19273043633004883, 0.18136344342116928, 0.19814403533093627, 0.17551054551997602, 0.2212066360241891, 0.17695630143112562, 0.17210192546731595, 0.08848090064611391, 0.09414289917076768, 0.08388490092595535, 0.09354422234187498, 0.1072754181107688, 0.08350870307287184, 0.0861489731767986, 0.08994100950182549, 0.08074285733554365]}, "mutation_prompt": null}
{"id": "b0e708e8-01c0-413c-b785-0e2a4b7d3182", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n        self.success_memory = []\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def orthogonal_crossover(self, target, mutant):\n        trial = np.copy(target)\n        indices = np.random.permutation(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == self.dim - 1:\n                trial[indices[j]] = mutant[indices[j]]\n        return trial\n\n    def adapt_parameters(self):\n        if len(self.success_memory) > 5:\n            success_rate = sum(self.success_memory[-5:]) / 5.0\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.1)), 0.1, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.15 if success_rate > 0.3 else -0.05)), 0.1, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.orthogonal_crossover(self.population[i], mutant_vec)\n                \n                trial_fitness = func(trial_vec)\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vec\n                    self.fitness[i] = trial_fitness\n                    self.success_memory.append(1)\n                else:\n                    self.success_memory.append(0)\n                evaluations += 1\n\n            self.adapt_parameters()\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveDE", "description": "Enhanced Hybrid Adaptive DE with dynamic parameter adaptation based on convergence metrics and orthogonal crossover to improve exploration and exploitation balance.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedHybridAdaptiveDE' object has no attribute 'covariance_mutation'\").", "error": "AttributeError(\"'EnhancedHybridAdaptiveDE' object has no attribute 'covariance_mutation'\")", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {}, "mutation_prompt": null}
{"id": "2d8af1de-3c32-423e-ae15-2e4c9af3d4b5", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.pop_size = self.initial_pop_size\n        self.dynamic_factor = 0.9  # Dynamic population factor\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n        self.sigma = 0.3\n\n    def mutate(self, idx):\n        elite_indices = np.argsort(self.fitness)[:self.elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(self.pop_size), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def dynamic_population(self):\n        self.pop_size = max(int(self.pop_size * self.dynamic_factor), 4)\n        self.population = self.population[:self.pop_size]\n        self.fitness = self.fitness[:self.pop_size]\n        self.elite_count = max(1, int(self.pop_size * self.elite_ratio))\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / self.pop_size\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n\n            # Introduce dynamic population adjustment\n            self.dynamic_population()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid DE with Dynamic Population and Adaptive Learning integrating exploration-exploitation balance and online learning from historical information.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {}, "mutation_prompt": null}
{"id": "1214e2d5-534f-48d2-831c-91ec06fc6228", "solution": "import numpy as np\n\nclass ImprovedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.sigma = 0.3\n        self.min_pop_size = 4 * dim\n        self.max_pop_size = 10 * dim\n\n    def mutate(self, idx):\n        elite_count = max(1, int(len(self.population) * self.elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def resize_population(self):\n        performance = np.var(self.fitness)\n        if performance < 0.1:\n            new_size = max(self.min_pop_size, len(self.population) - self.dim)\n        else:\n            new_size = min(self.max_pop_size, len(self.population) + self.dim)\n        self.population = self.population[np.argsort(self.fitness)[:new_size]]\n        self.fitness = self.fitness[np.argsort(self.fitness)[:new_size]]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n        \n        while evaluations < self.budget:\n            self.resize_population()\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / len(self.population)\n            self.F = np.clip(self.F * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.2 if success_rate > 0.2 else -0.1)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedHybridAdaptiveDE", "description": "Improved hybrid adaptive DE with dynamic population resizing and adaptive elitism to enhance exploration and convergence balance.", "configspace": "", "generation": 95, "fitness": 0.5791887935292271, "feedback": "The algorithm ImprovedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.31.", "error": "", "parent_id": "ccf75621-8cef-45d6-884c-c0b58d3059e9", "metadata": {"aucs": [0.9448736888226072, 0.9480507793864822, 0.9491521795795641, 0.9424866109280621, 0.9377835048689054, 0.9417323438588133, 0.9435164931775982, 0.9386856562326371, 0.9400937667221632, 0.8544275186555427, 0.855415948812068, 0.8482287190156098, 0.855167168039332, 0.8419218442007914, 0.8449217611222576, 0.8536296448081436, 0.8499447271112297, 0.8564059914765431, 0.16890805926811914, 0.2967025178301903, 0.4795368777920743, 0.13164252034164659, 0.39273710623180647, 0.11673372736368326, 0.5245918181036493, 0.17741973474242245, 0.5144373612875844, 0.26566972992438553, 0.27695028583898906, 0.32574797446799364, 0.1414140833407802, 0.15194251789104696, 0.4430683171456582, 0.130082924893983, 0.13633080928704788, 0.13888974079573435, 0.9909551319376442, 0.990057070801811, 0.990376167742228, 0.985537986858253, 0.9880763142483252, 0.9875783293234737, 0.9801956634077944, 0.9899373346157857, 0.9920812811686811, 0.7682388530782334, 0.7861042007815082, 0.7645253158512717, 0.7551354481808721, 0.7619662047321596, 0.7904442545010874, 0.804832449176028, 0.7599060038971832, 0.7512811282778558, 0.9063883568899902, 0.9342800520936203, 0.9187830679302661, 0.9247044020394529, 0.9348732503298722, 0.94052903815364, 0.9054224079582373, 0.9292284368266073, 0.9143063036275964, 0.8009086830753265, 0.7771061652507045, 0.7742471638225427, 0.7988316481827259, 0.7559399367692341, 0.7738106271212251, 0.7860606253891346, 0.789809318887714, 0.8019234444584935, 0.752119446957626, 0.7938274864430567, 0.7860567152653577, 0.806872334856592, 0.7709555934487156, 0.7833531568693084, 0.7802886872678062, 0.800966777264187, 0.7845696173783859, 0.7579351789631983, 0.7540299638781705, 0.7543454226439341, 0.781147799011652, 0.7425611488156274, 0.7408133506930831, 0.7620290575754092, 0.7674444273617852, 0.752042125627047, 0.8404598718249978, 0.8398233194548698, 0.796439997546482, 0.7965894168658367, 0.7583805385448099, 0.8091292573257699, 0.8271905642585418, 0.8436277143525837, 0.8411306533678349, 0.27881859744407966, 0.4346274456956134, 0.5092221122352398, 0.6802516434730563, 0.3508327046607851, 0.669591612957285, 0.34895185517195315, 0.2516322917198861, 0.3593539398466796, 0.6886074053423561, 0.5393799015291632, 0.46786777225300846, 0.6541864336042433, 0.6638767549034021, 0.5133579460883048, 0.6735309579331086, 0.4854135147810592, 0.6840972578057077, 0.9109130667660928, 0.9235559169820169, 0.9004315173720068, 0.907280195895925, 0.9207478140691732, 0.7242847479540235, 0.9172846465786785, 0.8902379982462965, 0.9131817568777721, 0.14754033991941418, 0.15968496991220382, 0.14054244933897675, 0.564686521895033, 0.11272683535048822, 0.14787597861448998, 0.13070151779179484, 0.14658064612455168, 0.13170882489822944, 0.13483834959962004, 0.2928196504913805, 0.14667220887175114, 0.5767311106614694, 0.18045432459536803, 0.14055161667050975, 0.131199237704147, 0.152479986653563, 0.7237084511194917, 0.8087423557860546, 0.8269141915237279, 0.6763407086849371, 0.36004919867017693, 0.8164161939394513, 0.6609299336990555, 0.8206826615476805, 0.8361618338540829, 0.834410751720094, 0.7043339554982616, 0.6708178140279992, 0.4977242420135489, 0.6929524288987854, 0.6630057107392688, 0.5045362518530188, 0.5211668019722178, 0.530527637541315, 0.5829191640211493, 0.23729893352643217, 0.24544803962718909, 0.22851641521764954, 0.22038312579403752, 0.2583880142941807, 0.22620205352433254, 0.21391229162209668, 0.22785666192350507, 0.21251146321763392, 0.20504218596653212, 0.21731599386113354, 0.2377283174666429, 0.40446193350910875, 0.18555712067867258, 0.2371541444420916, 0.23859521883176815, 0.612281380404099, 0.20112602994545647, 0.8902005870311522, 0.18814048319151766, 0.15343617404638266, 0.9369708918450106, 0.19878778031344313, 0.19540190642071442, 0.8334225225148733, 0.9050644846090459, 0.9329790458832169, 0.9282323866653108, 0.2101785171903865, 0.12762802310989374, 0.20447675208500027, 0.8919962823456389, 0.8500601702669347, 0.8757916939604952, 0.9303761445746062, 0.89897563646487, 0.1993249912380618, 0.17791838182991415, 0.19944960128832978, 0.19244133690195508, 0.20350100181401354, 0.1899375194931877, 0.2072712440866673, 0.1768942631884476, 0.19534663486545478, 0.08288211345694685, 0.09116433879847952, 0.09193095794606543, 0.09105792300500926, 0.08964513830230791, 0.08626247868365522, 0.09099795455377913, 0.0778060411332383, 0.07963986635186793]}, "mutation_prompt": null}
{"id": "7bc095cd-f254-4082-abbe-f9652227032a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.15\n        self.sigma = 0.2\n        self.min_pop_size = 5 * dim\n        self.max_pop_size = 12 * dim\n\n    def mutate(self, idx):\n        elite_count = max(1, int(len(self.population) * self.elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True\n        return False\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.sigma * cov)\n\n    def resize_population(self):\n        performance = np.var(self.fitness)\n        diversity = np.std(self.population, axis=0).mean()\n        if performance < 0.05 and diversity < 0.1:\n            new_size = max(self.min_pop_size, len(self.population) - 2 * self.dim)\n        else:\n            new_size = min(self.max_pop_size, len(self.population) + 2 * self.dim)\n        self.population = self.population[np.argsort(self.fitness)[:new_size]]\n        self.fitness = self.fitness[np.argsort(self.fitness)[:new_size]]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n        \n        while evaluations < self.budget:\n            self.resize_population()\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.6:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                if self.adapt_parameters(trial_vec, i, func):\n                    success = True\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / len(self.population)\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.25 else -0.15)), 0.2, 0.8)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.25 else -0.15)), 0.2, 0.95)\n            self.sigma = np.clip(self.sigma * (1 + (0.2 if success_rate > 0.25 else -0.1)), 0.05, 0.5)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced adaptive DE with diversity preservation, adaptive mutation strategies, and dynamic parameter tuning to improve convergence.", "configspace": "", "generation": 96, "fitness": 0.5441493500604506, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.33.", "error": "", "parent_id": "1214e2d5-534f-48d2-831c-91ec06fc6228", "metadata": {"aucs": [0.9456872491826577, 0.9466501059934883, 0.9524379924463793, 0.9409424849321419, 0.9466873028488577, 0.9463647858875501, 0.9458075133890764, 0.9454386129791394, 0.9514869201174603, 0.8759220282325278, 0.8824505450040036, 0.8868000450628387, 0.8887858266779455, 0.8862197572107517, 0.8948168555865242, 0.8780549271851407, 0.8866841865968599, 0.8868676109034851, 0.15259114003922858, 0.5909553561543217, 0.17490058756117544, 0.1355094029496513, 0.14633038619970684, 0.16966332395449024, 0.1284121544210366, 0.144479093500946, 0.17818529601470745, 0.11533144576381293, 0.11288296939665543, 0.09574012281043975, 0.11355200304409574, 0.11877818900536607, 0.11729922563912498, 0.14546270110309611, 0.13144328646424197, 0.131168626101565, 0.9906163043491923, 0.9928731504534297, 0.9871622992515132, 0.9899137834403274, 0.9916290175413006, 0.990171656185047, 0.9887605787999661, 0.9916101653263295, 0.9915022806165878, 0.7611935203713185, 0.7701634689391609, 0.775832643463364, 0.7082499028839224, 0.7735798068929123, 0.776394210678638, 0.7615604191346373, 0.759782997867187, 0.7979549554957124, 0.9375896380684333, 0.933765985509097, 0.9370828566055756, 0.9331971740764858, 0.9267882365431849, 0.9449458175955437, 0.9315022731881247, 0.9346998602946784, 0.9319298475898743, 0.8417423660601602, 0.8258310823333508, 0.8657846717646466, 0.8252236572134536, 0.8192849980846449, 0.13664003513289913, 0.8203636201933915, 0.8341595291329502, 0.8161540421122475, 0.7429637153223431, 0.7867211480916559, 0.8634432625699935, 0.8412586678315754, 0.823420999954571, 0.7830753339899184, 0.8412047907586503, 0.7666763883505009, 0.8386588187391089, 0.8517795228822302, 0.32988723366574235, 0.7681269502252238, 0.8227178952937375, 0.7115771153732626, 0.5680436948959533, 0.8508540344588229, 0.811160521009475, 0.3745547746245613, 0.8839640026503051, 0.8690325884505262, 0.8819526299471403, 0.8717828110382809, 0.8757360063538968, 0.6869287035471143, 0.8880176470270533, 0.8798493497938975, 0.8941309858042793, 0.1832535910495121, 0.1647879471852972, 0.2999829956270371, 0.7948889743410736, 0.7340765287089135, 0.7872203984174522, 0.476074673403842, 0.236387968088697, 0.14781396240934608, 0.5144318525296165, 0.3779393322402115, 0.7750783911408288, 0.8306642818389346, 0.5731495352751244, 0.6216146722003992, 0.5555009785960381, 0.623702648457165, 0.5415091675293024, 0.9013468483011123, 0.8981139754551414, 0.7126521123009215, 0.9380939249208813, 0.8511600541834949, 0.7254147938455449, 0.9234862278865518, 0.8995950242861, 0.716290750279447, 0.13667764501774782, 0.13390572312626425, 0.13309791768015766, 0.12717739822386287, 0.1445553991614975, 0.118717000894205, 0.15210153566372064, 0.1326382127714123, 0.1542987287900387, 0.43961416695350275, 0.18596158839910082, 0.6928683728021421, 0.20302427190667194, 0.1744740389810322, 0.20699351470788885, 0.28527258014156365, 0.23689720337470932, 0.17718698252295495, 0.4394886494217908, 0.4712203810644694, 0.40575684343845975, 0.46852104050303034, 0.4243890192760499, 0.520550059764749, 0.45905119318305165, 0.6198490637074698, 0.5711342347405081, 0.3770048180664196, 0.45218137177402296, 0.2943452572197772, 0.3920961166534992, 0.3267858731170926, 0.5567645394475365, 0.48980957765481214, 0.6146301053918977, 0.2827025821957455, 0.2341415614910881, 0.2196537305966061, 0.23083220703491214, 0.23343874813765397, 0.2233742294971014, 0.22644789527131093, 0.21462392619298953, 0.2019944626258816, 0.240706687977708, 0.21615860959410205, 0.20207880067030604, 0.2256972439682824, 0.5806989008045428, 0.21711210482655297, 0.1924582766431584, 0.22295959252783748, 0.7784961454934398, 0.20482408968421373, 0.9421686745369251, 0.8812492944977192, 0.1540510710551498, 0.1728766413670093, 0.18867765769199452, 0.9489614526329961, 0.14299470623501964, 0.16602677165800472, 0.9119657304060049, 0.9443580921891445, 0.2117702313331895, 0.858482824324644, 0.2093097133557812, 0.16841894025440818, 0.8893344961030483, 0.10477049062277966, 0.9038368547644575, 0.9351970167227195, 0.17634285721499376, 0.1792616427490077, 0.18889720008744437, 0.2117998241479666, 0.18047704323151303, 0.2043610920078529, 0.1785238775341581, 0.18721933669333612, 0.22256703249824084, 0.09034307458304414, 0.10396075855409381, 0.09437993505513709, 0.08991440960798425, 0.0919928276566987, 0.14753348131854038, 0.09453183562763534, 0.09077982668535567, 0.10330456057920745]}, "mutation_prompt": null}
{"id": "f60d7a7c-682b-4723-9ff9-73fe287fbcbc", "solution": "import numpy as np\n\nclass ImprovedHybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 8 * dim\n        self.F = 0.7\n        self.CR = 0.9\n        self.learning_rate = 0.1\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.25\n        self.sigma = 0.2\n        self.min_pop_size = 4 * dim\n        self.max_pop_size = 10 * dim\n\n    def mutate(self, idx):\n        elite_count = max(1, int(len(self.population) * self.elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        adapted_cov = cov + self.learning_rate * np.eye(self.dim)\n        return np.random.multivariate_normal(mean, self.sigma * adapted_cov)\n\n    def resize_population(self):\n        performance = np.var(self.fitness)\n        if performance < 0.05:\n            new_size = max(self.min_pop_size, len(self.population) - self.dim)\n        else:\n            new_size = min(self.max_pop_size, len(self.population) + self.dim)\n        self.population = self.population[np.argsort(self.fitness)[:new_size]]\n        self.fitness = self.fitness[np.argsort(self.fitness)[:new_size]]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n        \n        while evaluations < self.budget:\n            self.resize_population()\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / len(self.population)\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.3 else -0.15)), 0.1, 1.0)\n            self.sigma = np.clip(self.sigma * (1 + (0.15 if success_rate > 0.3 else -0.075)), 0.1, 1.0)\n            self.learning_rate = np.clip(self.learning_rate * (1 + (0.05 if success_rate > 0.3 else -0.025)), 0.01, 0.2)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedHybridAdaptiveDE", "description": "Advanced hybrid adaptive DE with enhanced covariance matrix adaptation and dynamic learning rates for improved exploration and convergence.", "configspace": "", "generation": 97, "fitness": 0.2935140173841133, "feedback": "The algorithm ImprovedHybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "1214e2d5-534f-48d2-831c-91ec06fc6228", "metadata": {"aucs": [0.6845774540932591, 0.7591830141013438, 0.7544004470559695, 0.6913127037723625, 0.6929954808179977, 0.692076000175101, 0.7508549535158527, 0.7890731644526754, 0.7220699659153453, 0.28352488060194514, 0.32992567193299427, 0.19223187504970052, 0.1457193456600484, 0.2949110407870884, 0.316432431168839, 0.31070756729681825, 0.3555121832887467, 0.16010682158363743, 0.15335922472231556, 0.15942079238566254, 0.12336061382483954, 0.3578242193123846, 0.10893383185468375, 0.2633860243978372, 0.09859789370921868, 0.12468403053090371, 0.2852817533722326, 0.12583482037967553, 0.11579421303132653, 0.1545832411757816, 0.13323599486880522, 0.26343787428327736, 0.14355513385742924, 0.1423299917117169, 0.11327770008926985, 0.10587219115911572, 0.988940487811231, 0.9870869831296382, 0.992215129773543, 0.991437257389984, 0.987446376303444, 0.9925341776438356, 0.9844268930870016, 0.9887869452448383, 0.99139242436761, 0.3593163451024274, 0.34395828574987886, 0.3097181416380135, 0.2859956331374677, 0.33477049421925453, 0.2811713367466304, 0.3683498928485849, 0.32125154160537206, 0.34064367871817214, 0.348726865269519, 0.6121157739133724, 0.34679461104934106, 0.38341215214446267, 0.5633081075977475, 0.37286722524586435, 0.3611370606172143, 0.38692685169166174, 0.47475513017712423, 0.22722345315766346, 0.1740147755030541, 0.23319317934832906, 0.1899313355903851, 0.13800100060842646, 0.15913997170397143, 0.19876683779743176, 0.19227929757502082, 0.18761016736706093, 0.23537082108813834, 0.28513331606068626, 0.16125259209286236, 0.24224379726310885, 0.2060727911862804, 0.23278221558497458, 0.22983883823196238, 0.192117283174272, 0.1713566566639393, 0.05159955228727109, 0.00989385765575057, 0.10899936091102758, 0.10140047069779634, 0.05025874604289926, 0.03539792227960603, 0.043860644571194984, 0.12893981644299546, 0.022450139070531838, 0.2745795159823381, 0.1434878970930804, 0.1735639843341803, 0.18053541155562436, 0.12212349991413973, 0.16687793418575148, 0.18429459743581222, 0.1976355785870485, 0.26843720080089706, 0.012499740892144118, 0.003452099560689592, 0.03196083776468317, 0.07620503975632487, 0.06976273648889875, 0.019967878530436023, 0.07909337405848094, 0.1309821854404949, 0.001442851438219983, 0.17855229636281678, 0.16176975839917918, 0.12020638210249013, 0.1283934962678519, 0.1958606173039732, 0.14638237484370298, 0.13870112626988906, 0.17740804928114762, 0.18420342005484125, 0.4710526852697746, 0.4219142209936444, 0.5141207667551966, 0.4990952393104504, 0.3770376576765754, 0.44578654199698275, 0.4188113353086652, 0.43426781083315036, 0.6242937226307832, 0.10621732707550835, 0.12748267747857822, 0.154349541050548, 0.12744958742698342, 0.1648335421001802, 0.11368243075600326, 0.1297816679498599, 0.126924661273062, 0.11913012062859563, 0.1590063249862893, 0.14687303529154527, 0.17739275072834548, 0.19562682868001124, 0.1546598893714357, 0.17094522080801378, 0.14804573404968746, 0.19593664911828668, 0.22583971711183382, 0.34319205809998377, 0.303219939621445, 0.3811780548150334, 0.282978594981217, 0.28939142479138313, 0.3272672114332177, 0.31444355068655927, 0.31289112379505934, 0.2993710890886858, 0.21216882498433254, 0.21025495813338646, 0.29663464183208876, 0.2146494316486276, 0.19880836388477607, 0.2643729008989182, 0.24900183537083032, 0.23398424584339372, 0.24113223245821502, 0.2259884592865361, 0.24099252791549608, 0.21179241108710523, 0.2075642415049085, 0.224851070636524, 0.23378763955011994, 0.2202429459997557, 0.2306533824534942, 0.2428455220905914, 0.1807280799320703, 0.1866890643180512, 0.19686722828140957, 0.2297804782422327, 0.21227259901414675, 0.20692335112981752, 0.21537993340675166, 0.23847204791191723, 0.2178310373828476, 0.8181722873607116, 0.18614623403453856, 0.8190984729144226, 0.7241772205341693, 0.6736408423300704, 0.11465817094702924, 0.6260304378716381, 0.16620214099625796, 0.5193464122448528, 0.6504937461261651, 0.5255761072865051, 0.7562521484721114, 0.20729447559246472, 0.16767543511544136, 0.20698294700857534, 0.8535059944615957, 0.7945831314298395, 0.6258227960237452, 0.20539806199820643, 0.18850911435575768, 0.20035234909817912, 0.20287830591632372, 0.19923372726942645, 0.1858536866393936, 0.2039255967853243, 0.22852835044132003, 0.2215114241417585, 0.11785604887503687, 0.09812542178454364, 0.09498732540211696, 0.10581518330325745, 0.0956396178033263, 0.10450226451307976, 0.09521961611355345, 0.08075916045448261, 0.10973423733111975]}, "mutation_prompt": null}
{"id": "853b9bb7-5cd6-4b25-9769-8b38c30b4713", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.7\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.25\n        self.cov_sigma = 0.5\n        self.min_pop_size = 4 * dim\n        self.max_pop_size = 12 * dim\n        \n    def mutate(self, idx):\n        elite_count = max(1, int(len(self.population) * self.elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def covariance_mutation(self, idx):\n        mean = np.mean(self.population, axis=0)\n        cov = np.cov(self.population, rowvar=False)\n        return np.random.multivariate_normal(mean, self.cov_sigma * cov)\n\n    def resize_population(self):\n        performance = np.var(self.fitness)\n        new_size = self.min_pop_size + (self.max_pop_size - self.min_pop_size) * np.tanh(performance)\n        new_size = int(np.clip(new_size, self.min_pop_size, self.max_pop_size))\n        self.population = self.population[np.argsort(self.fitness)[:new_size]]\n        self.fitness = self.fitness[np.argsort(self.fitness)[:new_size]]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n\n        while evaluations < self.budget:\n            self.resize_population()\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.7:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.covariance_mutation(i)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / len(self.population)\n            self.F = np.clip(self.F * (1 + (0.25 if success_rate > 0.25 else -0.15)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.15 if success_rate > 0.25 else -0.1)), 0.1, 0.9)\n            self.cov_sigma = np.clip(self.cov_sigma * (1 + (0.1 if success_rate > 0.25 else -0.05)), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Differential Evolution with adaptive learning rates and dynamic crossover strategies for improved convergence and diversity.", "configspace": "", "generation": 98, "fitness": 0.5507897777972163, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.29.", "error": "", "parent_id": "1214e2d5-534f-48d2-831c-91ec06fc6228", "metadata": {"aucs": [0.921024573811456, 0.9095410845456763, 0.9254519091454099, 0.9251936351457613, 0.9266375477490131, 0.9236512651950453, 0.9332659019766878, 0.91852784815538, 0.9235079396767658, 0.8018473255472931, 0.7932030527345086, 0.789600445004474, 0.8009891976007223, 0.7996851971957717, 0.796011835363637, 0.8040379606960792, 0.7908691537541842, 0.8058618561395797, 0.31533322670043695, 0.36027822594120784, 0.2621068368290488, 0.27723875937486286, 0.16025732672864557, 0.39824812173554314, 0.5127882653127117, 0.47544668804461876, 0.1408663296712651, 0.15780291696941606, 0.20510721097757845, 0.11247034549565793, 0.26026774688009546, 0.24640402623540048, 0.40049010903294446, 0.13509305646476277, 0.1238423896734383, 0.13086842137903965, 0.9862351633201177, 0.9875176020911018, 0.986129419887953, 0.9828397273081793, 0.9866295366045301, 0.9900030162610569, 0.9830567436287874, 0.9879480703820593, 0.9918503118793368, 0.7158823335889587, 0.7058005880332752, 0.7105859829203245, 0.7107373852238283, 0.7077506236368818, 0.7221430042607779, 0.7343808313406013, 0.701531625043227, 0.7244899957858963, 0.8791839558659376, 0.8609164435733612, 0.3781645763107305, 0.8794977060137328, 0.8696672849038418, 0.8814380402517419, 0.8785594363612463, 0.8761717933884995, 0.8715343665903706, 0.728379669591154, 0.7120719929959551, 0.7414922410603966, 0.7654144253376733, 0.6952742325892898, 0.7254352794809307, 0.7123367197324539, 0.7334869275862363, 0.7224128046272464, 0.7484089147572812, 0.6884501794001922, 0.7174120997391764, 0.7226681306978985, 0.7175578875129619, 0.7382243232368145, 0.7096444456985193, 0.7155281561664166, 0.7334365944391172, 0.6990445149407232, 0.6775404295011621, 0.6207187753630649, 0.7114662609366114, 0.6581276087353041, 0.6248810881360843, 0.6471848515844904, 0.6583261923581469, 0.6696091960402237, 0.7618258733541493, 0.6143150526623038, 0.7581772540447845, 0.620285261082334, 0.7499437069456959, 0.7514074111501572, 0.7956635225128643, 0.7795358236627519, 0.7742316522100943, 0.2874501024052277, 0.34062883381038056, 0.38908420577470504, 0.5920607693003429, 0.49955480472737135, 0.5578116267434206, 0.28587174824139205, 0.3754490502198028, 0.30373426576786433, 0.6448575519075213, 0.6628746142287176, 0.6262717435550738, 0.667815361525471, 0.5888980471989724, 0.6320063376208183, 0.6450515959309913, 0.6536789035951105, 0.6285470738681208, 0.9012949013047193, 0.8860301557078222, 0.8832257900308202, 0.90584374156428, 0.8929199041534417, 0.8937736107519061, 0.902396428461955, 0.8724693698963321, 0.9062785754538045, 0.1062505645168138, 0.10551487134781512, 0.10685963472742188, 0.10835475102621417, 0.12657697891338882, 0.40038629014886984, 0.13527184125672598, 0.10683304710535868, 0.11401872429408011, 0.13963728141247667, 0.13507547591920588, 0.1482343591578763, 0.5153982889827429, 0.26559279622065346, 0.1350259591134092, 0.2917469865856517, 0.22359156826353688, 0.17935313459496904, 0.40229592590391283, 0.5230850408861704, 0.35930447738459215, 0.7661848815866891, 0.7211420886006735, 0.562180986739883, 0.5836229846556239, 0.749382132328207, 0.7972277247782846, 0.4176814090089642, 0.4322600516730932, 0.6386563141223094, 0.48228234582637364, 0.4558806378107162, 0.5340709750691581, 0.3741973272457536, 0.7121778367312621, 0.5418060208839826, 0.20131276292903721, 0.2119512655362643, 0.1839246952638608, 0.2110031258650773, 0.2151336863561638, 0.24095724493958914, 0.2049025510014798, 0.216107539759117, 0.2548655881938461, 0.71556163052214, 0.23784285358819857, 0.22847482980990153, 0.23783852712190012, 0.20021970090421914, 0.21797901583597545, 0.21278426377232995, 0.2113589676788592, 0.7586128702092132, 0.8736455414513931, 0.8265636452501085, 0.8882216656506636, 0.8556116416300998, 0.8233759082245106, 0.16731060515914575, 0.8351810024981552, 0.759503006069731, 0.8154413070433202, 0.8788966396065537, 0.8125687094110707, 0.7478225185693196, 0.20480259706236192, 0.20211377730175684, 0.8369360354002371, 0.7938851088426478, 0.12600294967359627, 0.88588058636072, 0.18068303075706715, 0.189617072161119, 0.17483098470588432, 0.19472705516828281, 0.1979722698796329, 0.18676458649193606, 0.1911273051899971, 0.18510047814769415, 0.17921189808621762, 0.08604432172728627, 0.07715194765393185, 0.07426608546264268, 0.07439064493538261, 0.08501630033081908, 0.08100266031332082, 0.08221532529499798, 0.0823605694531363, 0.07609147816642348]}, "mutation_prompt": null}
{"id": "30d8713e-283a-4d28-95cb-751f3e70d8f6", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.elite_ratio = 0.2\n        self.sigma = 0.3\n        self.min_pop_size = 3 * dim\n        self.max_pop_size = 12 * dim\n\n    def mutate(self, idx):\n        elite_count = max(1, int(len(self.population) * self.elite_ratio))\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        idxs = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[idxs]\n        c = self.population[np.random.choice(np.delete(np.arange(len(self.population)), np.concatenate(([idx], idxs))))]\n        return a + self.F * (b - c)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adapt_parameters(self, trial, target_idx, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            return True, trial_fitness\n        return False, self.fitness[target_idx]\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def resize_population(self):\n        performance = np.var(self.fitness)\n        if performance < 0.08:\n            new_size = max(self.min_pop_size, len(self.population) - self.dim)\n        else:\n            new_size = min(self.max_pop_size, len(self.population) + self.dim)\n        self.population = self.population[np.argsort(self.fitness)[:new_size]]\n        self.fitness = self.fitness[np.argsort(self.fitness)[:new_size]]\n\n    def __call__(self, func):\n        evaluations = 0\n        self.fitness = np.array([func(ind) for ind in self.population])\n        evaluations += len(self.population)\n        \n        while evaluations < self.budget:\n            self.resize_population()\n            for i in range(len(self.population)):\n                if evaluations >= self.budget:\n                    break\n                \n                if np.random.rand() < 0.5:\n                    mutant_vec = self.mutate(i)\n                else:\n                    mutant_vec = self.population[i] + self.levy_flight(self.dim)\n                \n                mutant_vec = np.clip(mutant_vec, self.lower_bound, self.upper_bound)\n                trial_vec = self.crossover(self.population[i], mutant_vec)\n                \n                successful, new_fitness = self.adapt_parameters(trial_vec, i, func)\n                evaluations += 1\n\n            success_rate = np.sum(self.fitness < np.median(self.fitness)) / len(self.population)\n            self.F = np.clip(self.F * (1 + (0.3 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n            self.CR = np.clip(self.CR * (1 + (0.3 if success_rate > 0.2 else -0.2)), 0.1, 0.9)\n            self.sigma = np.clip(self.sigma * (1 + (0.1 if success_rate > 0.2 else -0.05)), 0.1, 1.0)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDynamicAdaptiveDE", "description": "Enhanced Dynamic Adaptive DE using self-adaptive parameter tuning and dynamic mutation strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.3319848756276119, "feedback": "The algorithm EnhancedDynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "1214e2d5-534f-48d2-831c-91ec06fc6228", "metadata": {"aucs": [0.7878922518405608, 0.8004089367546265, 0.7705905553425203, 0.8385057974562641, 0.8297269114096019, 0.8477072306966824, 0.8196617665255617, 0.8050733368429295, 0.8115597293385742, 0.5516979025083804, 0.5654543707786144, 0.5408722877034307, 0.5597632382878033, 0.494083548770476, 0.5639767341803403, 0.5498929636029922, 0.5343760724721797, 0.568906527312784, 0.11177306725179137, 0.11377384704527826, 0.13162302115478286, 0.13386982788626378, 0.11265939225848942, 0.12227755041914401, 0.10943012997048407, 0.11907683839945515, 0.11964882326358206, 0.09180915083970542, 0.12383089046642859, 0.11751420802658119, 0.11397754115007852, 0.0913712525775836, 0.09639109417263392, 0.11458983782006904, 0.10948410640006645, 0.11323369061120869, 0.9840326020699016, 0.9861515907484455, 0.9865655804933634, 0.9857525443650553, 0.9888228582106188, 0.9891111790953125, 0.9887891281541433, 0.9885053093972345, 0.9894854969082789, 0.33625309602562803, 0.31696205925223875, 0.31546274347032544, 0.34179447649667305, 0.25466201109122866, 0.44236740909088834, 0.3747640189335909, 0.2624184095586213, 0.4140477104829301, 0.3377756843783569, 0.6432902025059257, 0.3290099265761235, 0.32161740016110485, 0.34325651975695703, 0.3294322708796883, 0.3534368150872247, 0.6934998295513859, 0.3476613451700248, 0.41732959738880104, 0.4087330677802107, 0.3571308537873622, 0.3661409310369922, 0.41168161773302503, 0.25677974134321135, 0.29335756885037223, 0.4108222715719039, 0.3176895303859174, 0.40887143622180877, 0.10771953227013165, 0.37789631311100724, 0.42163111272769216, 0.36285328062069666, 0.3858024066227338, 0.37479031594130807, 0.26158405263770346, 0.27443024881854505, 0.21562154366583441, 0.22518966428778897, 0.20366523517150403, 0.17142069960151618, 0.14682271595732177, 0.21481744641984624, 0.21008699868345515, 0.15093350656128135, 0.16749631447534208, 0.24862557777362104, 0.2948525560227978, 0.29715647220833585, 0.2983979857955301, 0.2315764783340828, 0.2852290948675479, 0.28286351143064037, 0.38001451798830765, 0.29259188456972085, 0.02762566865712346, 0.03633086358463811, 0.03578469610344259, 0.07658566778267539, 0.07935217375271675, 0.06564169075817805, 0.07981898946487054, 0.10041262840766263, 0.06138789102263831, 0.21077692652139746, 0.20606328193474066, 0.2820986464163652, 0.19351417835745144, 0.2093454119960394, 0.21120458971384626, 0.2108385741920228, 0.2096306899314685, 0.1929358876376729, 0.5753657675925985, 0.6279516226362682, 0.6080849312176491, 0.5759984352714974, 0.5792741898479788, 0.5042192372856057, 0.5247396477006651, 0.5229463680911463, 0.6338485899456976, 0.10111619093647473, 0.09974069677359021, 0.11034677243145707, 0.08745759727216396, 0.08652456465886194, 0.0949843341595924, 0.10669911329023651, 0.08491333082601271, 0.08876201485614454, 0.16261336286280892, 0.23561582556585203, 0.3178432421570019, 0.1874396549567131, 0.21621624176173526, 0.16229964161635813, 0.256012719798274, 0.1567823990081315, 0.19525086362751176, 0.3440602495287344, 0.31804962564037453, 0.2775587493208471, 0.3039489156070777, 0.3224345477557905, 0.30073665097185376, 0.3385934527234733, 0.30114663822124754, 0.32072486243107534, 0.2911056619547787, 0.21737557019795029, 0.19980684247019176, 0.2328071577262132, 0.23477912644582777, 0.1970877960495313, 0.22552792423267065, 0.25973077524287547, 0.2986238876769167, 0.19985373945687301, 0.18625442152352123, 0.23339672887672147, 0.23398124053226244, 0.18196748714159605, 0.1860008379665351, 0.1874452504248485, 0.21408276834250306, 0.19353823576060358, 0.19108648284834517, 0.304345192316291, 0.18631262548868455, 0.2029788544585691, 0.390631632571965, 0.19182042100490526, 0.1825198842588135, 0.3688124186540278, 0.18342773486495478, 0.8012951047958548, 0.7301962735412193, 0.7262598639685625, 0.780447370392666, 0.18909793030825783, 0.6993655110658707, 0.7106728733917003, 0.17640142169054784, 0.7093779557882273, 0.6401835243654179, 0.1978314166855868, 0.773996822416012, 0.2036445215138678, 0.20621786283101307, 0.19935064045598005, 0.20853520354024846, 0.749456968882813, 0.7547422738282048, 0.17657239587583407, 0.17574765619739663, 0.17987019223843181, 0.18937767837017683, 0.19171528656452597, 0.1931396393928032, 0.18838367097583453, 0.19084087739911704, 0.18963390619778742, 0.07704158631231517, 0.07537692149851793, 0.08008051881840617, 0.09120167897396225, 0.07433260124687435, 0.08303977195773582, 0.07718588290492256, 0.09149203699026343, 0.06765835900167971]}, "mutation_prompt": null}
