{"id": "603478d6-363a-42dc-bc30-ecec08306b68", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1 = 2.0  # cognitive component\n        self.c2 = 2.0  # social component\n        self.w = 0.5   # inertia weight\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n            if evaluations >= self.budget:\n                break\n\n            # Update velocities and positions for PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + 0.8 * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "HybridPSODE", "description": "A hybrid adaptive strategy combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) for diverse exploration and efficient exploitation in high-dimensional search spaces.", "configspace": "", "generation": 0, "fitness": 0.22141096452197725, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.12644422955650592, 0.12604211551805944, 0.8142610313238082, 0.18953226609173857, 0.1828431430404075, 0.14050924645007834, 0.1820221801322005, 0.7970361269579913, 0.7542513532649695, 0.03803761658348104, 0.5143285939679769, 0.5017856687434022, 0.5984285224686465, 0.04476319404552609, 9.999999999998899e-05, 0.04242825585776333, 0.23912007540113, 0.5166178954786208, 0.1378983846684183, 0.04171620196564896, 0.16368835910723278, 0.14664511813480707, 0.11661690907267641, 0.14969741051761742, 0.12277061791645827, 0.04735571801412841, 0.11506127133179089, 0.12757423921806144, 0.1537675145265679, 0.1088152476980484, 0.13140126957241793, 0.03955157498452644, 0.1506691520845609, 0.13383695368616955, 0.13082959304466946, 0.1246376810670432, 0.990861100953992, 0.9858812984594937, 0.9915604944513873, 0.9907630871614328, 0.9894409704444644, 0.9841052406971545, 0.9908699405567033, 0.9900856739112642, 0.9908044150399398, 0.05428591356436718, 0.05855939843688962, 0.055422936778577236, 0.43101366904805327, 0.32454713495990006, 0.15020579248878074, 0.08757360340880682, 0.08929550471621461, 9.999999999998899e-05, 0.1669146621825892, 0.1907617032726241, 0.21693849073461458, 0.27399808840021855, 0.20615843611179263, 0.18609165246952875, 0.23393586103314123, 0.12988403714178787, 0.12840389553426068, 0.09721233614526914, 0.1198889894144548, 0.11400439735430845, 0.12038827657993789, 0.08966496272997115, 9.999999999998899e-05, 0.19312666323672434, 0.1655123141844661, 0.18539759262554145, 0.16286856427218044, 0.016536337489306385, 0.20406117249550737, 0.19719052517741764, 0.17969099313903303, 0.12600721794497316, 0.20688477464450217, 9.999999999998899e-05, 0.10035269982327444, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007892158662525794, 9.999999999998899e-05, 9.999999999998899e-05, 0.0061957537240936444, 0.002198881511462192, 9.999999999998899e-05, 0.06087328117171786, 0.05190557482555758, 0.005507118181274695, 0.04881164256419557, 0.04584779424488461, 9.999999999998899e-05, 9.999999999998899e-05, 0.18798783552019926, 0.04195230250324167, 0.0358721739827792, 0.04547258572886659, 0.19290392012256086, 9.999999999998899e-05, 0.0685846282952518, 0.07085770760229892, 0.06925058557370234, 0.0847324453250341, 0.06429084397557128, 0.07317894967633709, 0.04165670180266656, 9.999999999998899e-05, 0.19814764080985336, 9.999999999998899e-05, 9.999999999998899e-05, 0.1552781871774026, 9.999999999998899e-05, 0.04647878636298097, 0.07962840130321669, 0.46528516271818254, 0.4600659774849525, 0.5035085167672265, 0.5359688764087429, 0.5631777228685855, 0.4772852048738637, 0.4575768662835741, 0.1254754359198601, 0.4758506096201379, 0.10997428941518794, 0.06278192554903073, 0.055664422018027127, 0.11370230127625602, 0.11088854847451945, 0.10705872223737256, 0.1305130309425353, 0.060344549722800345, 0.10532953067324635, 0.20025720694790927, 0.19664435984211293, 0.15867278942458196, 0.23707184840895457, 0.2326779749065382, 0.12291743356998264, 0.18772006465437907, 0.17164887771467852, 0.2290926947631199, 0.24626452715241898, 0.2312914776382361, 0.37409085461655334, 0.20467051193489583, 0.19249070969031834, 0.28453970138329965, 0.40784228932979505, 0.4095387580485569, 0.17168258858437024, 0.17142179922295142, 0.22738408679422428, 0.3021144474720634, 0.2557401604994447, 0.16209001849209614, 0.22343434261476935, 0.18134049360632765, 0.3123082288357827, 0.07324113648118724, 0.2170071950089364, 0.2315331755796829, 0.18830336259949365, 0.21709927568709353, 0.18565433110918395, 0.20120001917920627, 0.24704373952324155, 0.21899141497791086, 0.20420994376337254, 0.19677326246211435, 0.23381735627578748, 0.19759318236220702, 0.19759308658638675, 0.2242330699596301, 0.18517701083979576, 0.19680302068516597, 0.18901764861861015, 0.4248632038511626, 0.18176033401299163, 0.7962128570842202, 0.11314864992596763, 0.7891054141274618, 0.19859595602381264, 0.8013167108332554, 0.08217560876119079, 0.16900490132916368, 0.17383511396103402, 0.36917651874527335, 0.20804484078508445, 0.40990540921224017, 0.20981876458454363, 0.43406617782233137, 0.6016453514606042, 0.10359797890473454, 0.6881249938676284, 0.1609592511061625, 0.20150114248975237, 0.19728323441451612, 0.20478269007043004, 0.1938658456276786, 0.19554087112550778, 0.19219676050558265, 0.1882985867945487, 0.18012687358259571, 0.20624019619506784, 0.08985490680081165, 0.05036334150033528, 0.09355311722897697, 0.08806094833368949, 0.08012782438457855, 0.08635383912851069, 0.08031544570389182, 0.0839405677317916, 0.07817442906909089]}, "mutation_prompt": null}
{"id": "03e5b427-d74b-4b57-9ac7-a5eeeca7e2f1", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.9  # dynamic inertia weight starting value\n        self.f_min, self.f_max = 0.5, 0.9  # DE scaling factor range\n\n    def adaptive_inertia_weight(self, evaluations):\n        return self.w - 0.4 * (evaluations / self.budget)\n\n    def adaptive_scaling_factor(self, evaluations):\n        return self.f_min + (self.f_max - self.f_min) * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = np.copy(self.particles[i])\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = np.copy(self.particles[i])\n\n            if evaluations >= self.budget:\n                break\n\n            # Update velocities and positions for PSO\n            self.w = self.adaptive_inertia_weight(evaluations)\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with adaptive scaling\n                f = self.adaptive_scaling_factor(evaluations)\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + f * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "Introducing a dynamic parameter adaptation mechanism alongside a memory-based technique to enhance exploration and exploitation balance in the HybridPSODE algorithm.", "configspace": "", "generation": 1, "fitness": 0.15275007954504605, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "603478d6-363a-42dc-bc30-ecec08306b68", "metadata": {"aucs": [0.3267685968450921, 0.12546075444056182, 0.42135692478158615, 0.18914987790630267, 0.3445404541301238, 0.15530550511298857, 0.18122492398303824, 0.1428302224415101, 0.40903061106017047, 0.033549357067503616, 9.999999999998899e-05, 0.0711447835452409, 0.06102413188621869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04894074316317998, 0.08110006744113019, 0.1183645608330115, 0.033884132887906704, 0.09346686531413195, 0.11059951376034538, 0.09242323559815335, 0.06377381369477009, 0.1154949615438623, 0.01945584807453704, 0.045097577618644524, 0.07805620865094609, 0.07231870310115773, 0.06368274742450886, 0.07515438294684595, 0.029668602086191043, 0.04624090351129473, 0.06813382963515702, 0.06062678480906303, 0.09763966527822665, 0.9913861914933799, 0.9872572464329433, 0.9940186078673018, 0.9938671353985936, 0.9907749626990054, 0.9875676094849233, 0.9939653653176197, 0.9904706235978572, 0.994264519070788, 0.0657357189739125, 0.057605948782538885, 0.05361892612599406, 0.062397013651339095, 0.13094622404241363, 0.141133347041422, 0.08248505311681731, 0.08939279793711197, 0.014475600732832161, 0.16916965240625992, 0.09873089324975193, 0.2004919325593435, 0.18662205182058056, 0.11205818775026377, 0.18505456882376525, 0.12159182738302354, 0.12499568198165179, 0.14748193944497112, 0.07522877052888821, 0.11325625898814307, 0.06606652590521223, 0.12117643908698861, 9.999999999998899e-05, 0.06356313795199708, 0.03546933544028419, 9.999999999998899e-05, 0.12740577253687402, 0.12532162769156818, 0.021862484309351005, 0.009907469518640188, 0.0816973207351519, 0.10883462971401137, 0.12659316250602604, 0.16084022217879157, 0.03049261045069529, 0.03321458461189253, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04759097643646948, 9.999999999998899e-05, 0.02699582969583114, 0.014517790094627392, 0.006814706879205157, 9.999999999998899e-05, 0.004613921938420251, 0.09407500718867501, 0.040176358762852526, 0.03312049010331064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0685293360557081, 9.999999999998899e-05, 0.10278306580029561, 9.999999999998899e-05, 9.999999999998899e-05, 0.10402123095549864, 9.999999999998899e-05, 9.999999999998899e-05, 0.058634568628671335, 0.3581461270945687, 0.31395529303980174, 0.4177524989198269, 0.3504301276588083, 0.22052920517249108, 0.3232771386693397, 0.39783616297788915, 0.13549613382620296, 0.3040633416232392, 0.08109613715176145, 0.040044230336148345, 0.04933100159173576, 0.09687844836464088, 0.0630420004303498, 0.07407302796909643, 0.08082598327023638, 0.05003086477704233, 0.09754532935390947, 0.19021494981719467, 0.14161188835336236, 0.16612229781926258, 0.13503796076774888, 0.19712274933280893, 0.1410069640239724, 0.17750827698756222, 0.168915693022901, 0.1831517870578473, 0.25338801114395537, 0.22988801911144852, 0.22602538083431767, 0.14029198100682028, 0.13906213381753751, 0.20791265476356413, 0.23103530146814522, 0.2980951918836213, 0.12495994654205766, 0.14402997541074547, 0.06409816000174129, 0.10778488424212884, 0.160956866787051, 0.13326102064332734, 0.1965765992195042, 0.16771322856962056, 0.19727086687476003, 0.14907439385662635, 0.15898097032073533, 0.15022921401750278, 0.1595825115480891, 0.16387246691740143, 0.14269771030663891, 0.1438912562378466, 0.1448493680913704, 0.15625419525997475, 0.1576579518897646, 0.15859146104531718, 0.15756610597624798, 0.1864870433337703, 0.19014972115389273, 0.2618596637221111, 0.18441950611047686, 0.16337505522702234, 0.15003814262759518, 0.16526256583550092, 0.18125008761174577, 0.16099973682197122, 0.11885837152567003, 0.12236893298604667, 0.18361198307814175, 0.11816783019139343, 0.09660726368066586, 0.16831859603501875, 0.16030709848915836, 0.15010709297465763, 0.15949512088767348, 0.17898563438104287, 0.164446523690424, 0.253522630292223, 0.10905867757185028, 0.1829346301161071, 0.2776276439354656, 0.19708946021414153, 0.18405060896534897, 0.1794254244598853, 0.17746435342140088, 0.1776417508693383, 0.17206987262275797, 0.1822097833298183, 0.18455664306769293, 0.2094284892756476, 0.1928751648348015, 0.06363182853110738, 0.057947419356523144, 0.05752562956494678, 0.04469979281203651, 0.048025060072457326, 0.053201379519262404, 0.06458295055126984, 0.037134074636626435, 0.05268194369376755]}, "mutation_prompt": null}
{"id": "f8d18897-706a-47ae-8723-62729156d2a9", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 30  # Increased population for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid method integrating adaptive parameters for PSO and DE to dynamically balance exploration and exploitation in diverse search spaces.", "configspace": "", "generation": 2, "fitness": 0.22351125964812743, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "603478d6-363a-42dc-bc30-ecec08306b68", "metadata": {"aucs": [0.4553043394079256, 0.4527853723045824, 0.5151915342620941, 0.5330947965298458, 0.48328244787167374, 0.5387701578795989, 0.50580924102028, 0.5778975573224714, 0.552867964514326, 0.16156404223717014, 0.1438208749409483, 9.999999999998899e-05, 0.031133182726038156, 0.1031882567478084, 0.2319204108905687, 0.022759412671326973, 0.17326014768875253, 0.14231495890988066, 0.11387764128114009, 0.1448653260347037, 0.17829533747265125, 0.11390994597282844, 0.11161385205130359, 0.21575716964006075, 0.10244070384399584, 0.093753350224002, 0.11163801975419374, 0.0961410060002934, 0.10969822959370634, 0.124124365006677, 0.1061705745684316, 0.08942203678796123, 0.0957420448499775, 0.0839280601629685, 0.11880709140162293, 0.10724904182761352, 0.9757501082346289, 0.9734742208267657, 0.9843470491369619, 0.9749621409674673, 0.9786278847736399, 0.9809130489903186, 0.9773774654642998, 0.9764202805828602, 0.9802616001563773, 0.2956857560875814, 0.21840371896179622, 0.324873807769954, 0.25723515987004, 0.2840047899339856, 0.39618012510432754, 0.29128654288004086, 0.0879016975811252, 0.0866046791886389, 0.378274347415988, 0.25788764258451125, 0.24827491914494604, 0.2400049163530702, 0.15768388561586766, 0.18671124832519403, 0.5229066805145256, 0.1822298438785399, 0.4598954575136882, 0.09562117129418057, 0.09653920526103488, 0.1386925765476199, 0.06967136528309748, 0.09639745276841927, 0.1352539227069085, 0.10033969807597076, 0.12084942343573934, 0.09960174933362198, 0.11164719231464604, 0.01584577584684488, 0.1950844475268153, 0.12270471647644865, 0.09911379493741079, 0.09274194993446638, 0.13927600629331371, 0.09852040728183709, 0.07833572996227067, 0.03225484954212465, 9.999999999998899e-05, 9.999999999998899e-05, 0.012131183627976494, 0.005257786520379115, 0.0008729912503460113, 0.027274656270692144, 9.999999999998899e-05, 0.0015173550008775738, 0.07663435922868178, 0.07371809070212709, 0.061882666069955294, 0.06112437297008033, 0.03373496407527454, 0.022294369379134316, 0.08247040875416156, 0.04376530759261077, 0.08630481618634167, 9.999999999998899e-05, 0.017726230395178733, 0.027385554740792184, 0.025190339570478004, 0.03169306726014676, 0.039324786470160134, 0.02843663420550091, 0.03658060190354062, 0.03951282686608826, 0.11204196176334047, 0.02204328638605968, 0.1018251167267874, 0.15460506190877155, 0.06888050001482338, 0.12447034793758649, 0.09680300813552489, 0.0879125071841147, 0.08565296967574554, 0.3992190523724173, 0.39466225131428256, 0.3964495101234292, 0.41657182457246256, 0.3981402801578947, 0.4337213582800856, 0.39084441194091124, 0.36591880137250776, 0.39314903120253497, 0.0909003584902428, 0.11002981408799406, 0.09296418603803214, 0.08569512589736628, 0.07761503976075224, 0.08218873297044338, 0.13895979553230808, 0.07960489059716835, 0.11510102002149702, 0.1583798468151354, 0.1475047335107198, 0.2093406374497251, 0.15964739936376737, 0.17888648758692727, 0.18040189105505744, 0.14742447502617528, 0.24040660839949346, 0.16003101569100286, 0.22335095610685052, 0.2919293313334911, 0.3066650432515269, 0.2929482405107836, 0.2637372675244166, 0.32366489004334187, 0.317849407935196, 0.31937046411318937, 0.32432138651891596, 0.1885758704024294, 0.21473340275317565, 0.22187484582231398, 0.21122408297758266, 0.20472603697935987, 0.15770249236824418, 0.219892785069275, 0.21983734123058962, 0.23306881144219083, 0.17952981790695888, 0.17258862006958553, 0.19356856624813046, 0.19537220797499744, 0.17034194352619414, 0.18040438806774928, 0.20671527540927082, 0.18652459785318165, 0.2297551761018406, 0.18130870877714855, 0.17969192779009913, 0.39502480804978923, 0.1894217214021322, 0.33974899367711586, 0.1931086631120854, 0.18470831673002874, 0.30177287358099925, 0.1892052776558386, 0.18810526167983832, 0.502272450828662, 0.14898199176271443, 0.6475753718998548, 0.4808274839271953, 0.5802897260187181, 0.16667530235517825, 0.1626269898752455, 0.6263311105646436, 0.5002640203715777, 0.16160156187220598, 0.44481452418621403, 0.35038958367825646, 0.16482854646481648, 0.4005627581061282, 0.44663051374500806, 0.18190020646349947, 0.194016371555792, 0.19777264209108958, 0.20248330003214265, 0.1822211216872186, 0.19414608521017918, 0.18975151423077774, 0.18878157701183917, 0.19424745284520262, 0.17623945054070078, 0.19187786381371663, 0.08963144847490967, 0.07145394395426607, 0.08376896393892419, 0.07675458087458009, 0.07240189868076463, 0.09426259940519854, 0.07330292435147712, 0.07164728157715383, 0.08233346412087394]}, "mutation_prompt": null}
{"id": "b386c908-5597-4e53-b8b7-86320f7d558f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 30  # Increased population for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid method integrating adaptive parameters for PSO and DE to dynamically balance exploration and exploitation in diverse search spaces.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8d18897-706a-47ae-8723-62729156d2a9", "metadata": {"aucs": [0.4553043394079256, 0.4527853723045824, 0.5151915342620941, 0.5330947965298458, 0.48328244787167374, 0.5387701578795989, 0.50580924102028, 0.5778975573224714, 0.552867964514326, 0.16156404223717014, 0.1438208749409483, 9.999999999998899e-05, 0.031133182726038156, 0.1031882567478084, 0.2319204108905687, 0.022759412671326973, 0.17326014768875253, 0.14231495890988066, 0.11387764128114009, 0.1448653260347037, 0.17829533747265125, 0.11390994597282844, 0.11161385205130359, 0.21575716964006075, 0.10244070384399584, 0.093753350224002, 0.11163801975419374, 0.0961410060002934, 0.10969822959370634, 0.124124365006677, 0.1061705745684316, 0.08942203678796123, 0.0957420448499775, 0.0839280601629685, 0.11880709140162293, 0.10724904182761352, 0.9757501082346289, 0.9734742208267657, 0.9843470491369619, 0.9749621409674673, 0.9786278847736399, 0.9809130489903186, 0.9773774654642998, 0.9764202805828602, 0.9802616001563773, 0.2956857560875814, 0.21840371896179622, 0.324873807769954, 0.25723515987004, 0.2840047899339856, 0.39618012510432754, 0.29128654288004086, 0.0879016975811252, 0.0866046791886389, 0.378274347415988, 0.25788764258451125, 0.24827491914494604, 0.2400049163530702, 0.15768388561586766, 0.18671124832519403, 0.5229066805145256, 0.1822298438785399, 0.4598954575136882, 0.09562117129418057, 0.09653920526103488, 0.1386925765476199, 0.06967136528309748, 0.09639745276841927, 0.1352539227069085, 0.10033969807597076, 0.12084942343573934, 0.09960174933362198, 0.11164719231464604, 0.01584577584684488, 0.1950844475268153, 0.12270471647644865, 0.09911379493741079, 0.09274194993446638, 0.13927600629331371, 0.09852040728183709, 0.07833572996227067, 0.03225484954212465, 9.999999999998899e-05, 9.999999999998899e-05, 0.012131183627976494, 0.005257786520379115, 0.0008729912503460113, 0.027274656270692144, 9.999999999998899e-05, 0.0015173550008775738, 0.07663435922868178, 0.07371809070212709, 0.061882666069955294, 0.06112437297008033, 0.03373496407527454, 0.022294369379134316, 0.08247040875416156, 0.04376530759261077, 0.08630481618634167, 9.999999999998899e-05, 0.017726230395178733, 0.027385554740792184, 0.025190339570478004, 0.03169306726014676, 0.039324786470160134, 0.02843663420550091, 0.03658060190354062, 0.03951282686608826, 0.11204196176334047, 0.02204328638605968, 0.1018251167267874, 0.15460506190877155, 0.06888050001482338, 0.12447034793758649, 0.09680300813552489, 0.0879125071841147, 0.08565296967574554, 0.3992190523724173, 0.39466225131428256, 0.3964495101234292, 0.41657182457246256, 0.3981402801578947, 0.4337213582800856, 0.39084441194091124, 0.36591880137250776, 0.39314903120253497, 0.0909003584902428, 0.11002981408799406, 0.09296418603803214, 0.08569512589736628, 0.07761503976075224, 0.08218873297044338, 0.13895979553230808, 0.07960489059716835, 0.11510102002149702, 0.1583798468151354, 0.1475047335107198, 0.2093406374497251, 0.15964739936376737, 0.17888648758692727, 0.18040189105505744, 0.14742447502617528, 0.24040660839949346, 0.16003101569100286, 0.22335095610685052, 0.2919293313334911, 0.3066650432515269, 0.2929482405107836, 0.2637372675244166, 0.32366489004334187, 0.317849407935196, 0.31937046411318937, 0.32432138651891596, 0.1885758704024294, 0.21473340275317565, 0.22187484582231398, 0.21122408297758266, 0.20472603697935987, 0.15770249236824418, 0.219892785069275, 0.21983734123058962, 0.23306881144219083, 0.17952981790695888, 0.17258862006958553, 0.19356856624813046, 0.19537220797499744, 0.17034194352619414, 0.18040438806774928, 0.20671527540927082, 0.18652459785318165, 0.2297551761018406, 0.18130870877714855, 0.17969192779009913, 0.39502480804978923, 0.1894217214021322, 0.33974899367711586, 0.1931086631120854, 0.18470831673002874, 0.30177287358099925, 0.1892052776558386, 0.18810526167983832, 0.502272450828662, 0.14898199176271443, 0.6475753718998548, 0.4808274839271953, 0.5802897260187181, 0.16667530235517825, 0.1626269898752455, 0.6263311105646436, 0.5002640203715777, 0.16160156187220598, 0.44481452418621403, 0.35038958367825646, 0.16482854646481648, 0.4005627581061282, 0.44663051374500806, 0.18190020646349947, 0.194016371555792, 0.19777264209108958, 0.20248330003214265, 0.1822211216872186, 0.19414608521017918, 0.18975151423077774, 0.18878157701183917, 0.19424745284520262, 0.17623945054070078, 0.19187786381371663, 0.08963144847490967, 0.07145394395426607, 0.08376896393892419, 0.07675458087458009, 0.07240189868076463, 0.09426259940519854, 0.07330292435147712, 0.07164728157715383, 0.08233346412087394]}, "mutation_prompt": null}
{"id": "206e63c9-9944-468f-94ad-29e4b0976cca", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 30  # Increased population for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid method integrating adaptive parameters for PSO and DE to dynamically balance exploration and exploitation in diverse search spaces.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8d18897-706a-47ae-8723-62729156d2a9", "metadata": {"aucs": [0.4553043394079256, 0.4527853723045824, 0.5151915342620941, 0.5330947965298458, 0.48328244787167374, 0.5387701578795989, 0.50580924102028, 0.5778975573224714, 0.552867964514326, 0.16156404223717014, 0.1438208749409483, 9.999999999998899e-05, 0.031133182726038156, 0.1031882567478084, 0.2319204108905687, 0.022759412671326973, 0.17326014768875253, 0.14231495890988066, 0.11387764128114009, 0.1448653260347037, 0.17829533747265125, 0.11390994597282844, 0.11161385205130359, 0.21575716964006075, 0.10244070384399584, 0.093753350224002, 0.11163801975419374, 0.0961410060002934, 0.10969822959370634, 0.124124365006677, 0.1061705745684316, 0.08942203678796123, 0.0957420448499775, 0.0839280601629685, 0.11880709140162293, 0.10724904182761352, 0.9757501082346289, 0.9734742208267657, 0.9843470491369619, 0.9749621409674673, 0.9786278847736399, 0.9809130489903186, 0.9773774654642998, 0.9764202805828602, 0.9802616001563773, 0.2956857560875814, 0.21840371896179622, 0.324873807769954, 0.25723515987004, 0.2840047899339856, 0.39618012510432754, 0.29128654288004086, 0.0879016975811252, 0.0866046791886389, 0.378274347415988, 0.25788764258451125, 0.24827491914494604, 0.2400049163530702, 0.15768388561586766, 0.18671124832519403, 0.5229066805145256, 0.1822298438785399, 0.4598954575136882, 0.09562117129418057, 0.09653920526103488, 0.1386925765476199, 0.06967136528309748, 0.09639745276841927, 0.1352539227069085, 0.10033969807597076, 0.12084942343573934, 0.09960174933362198, 0.11164719231464604, 0.01584577584684488, 0.1950844475268153, 0.12270471647644865, 0.09911379493741079, 0.09274194993446638, 0.13927600629331371, 0.09852040728183709, 0.07833572996227067, 0.03225484954212465, 9.999999999998899e-05, 9.999999999998899e-05, 0.012131183627976494, 0.005257786520379115, 0.0008729912503460113, 0.027274656270692144, 9.999999999998899e-05, 0.0015173550008775738, 0.07663435922868178, 0.07371809070212709, 0.061882666069955294, 0.06112437297008033, 0.03373496407527454, 0.022294369379134316, 0.08247040875416156, 0.04376530759261077, 0.08630481618634167, 9.999999999998899e-05, 0.017726230395178733, 0.027385554740792184, 0.025190339570478004, 0.03169306726014676, 0.039324786470160134, 0.02843663420550091, 0.03658060190354062, 0.03951282686608826, 0.11204196176334047, 0.02204328638605968, 0.1018251167267874, 0.15460506190877155, 0.06888050001482338, 0.12447034793758649, 0.09680300813552489, 0.0879125071841147, 0.08565296967574554, 0.3992190523724173, 0.39466225131428256, 0.3964495101234292, 0.41657182457246256, 0.3981402801578947, 0.4337213582800856, 0.39084441194091124, 0.36591880137250776, 0.39314903120253497, 0.0909003584902428, 0.11002981408799406, 0.09296418603803214, 0.08569512589736628, 0.07761503976075224, 0.08218873297044338, 0.13895979553230808, 0.07960489059716835, 0.11510102002149702, 0.1583798468151354, 0.1475047335107198, 0.2093406374497251, 0.15964739936376737, 0.17888648758692727, 0.18040189105505744, 0.14742447502617528, 0.24040660839949346, 0.16003101569100286, 0.22335095610685052, 0.2919293313334911, 0.3066650432515269, 0.2929482405107836, 0.2637372675244166, 0.32366489004334187, 0.317849407935196, 0.31937046411318937, 0.32432138651891596, 0.1885758704024294, 0.21473340275317565, 0.22187484582231398, 0.21122408297758266, 0.20472603697935987, 0.15770249236824418, 0.219892785069275, 0.21983734123058962, 0.23306881144219083, 0.17952981790695888, 0.17258862006958553, 0.19356856624813046, 0.19537220797499744, 0.17034194352619414, 0.18040438806774928, 0.20671527540927082, 0.18652459785318165, 0.2297551761018406, 0.18130870877714855, 0.17969192779009913, 0.39502480804978923, 0.1894217214021322, 0.33974899367711586, 0.1931086631120854, 0.18470831673002874, 0.30177287358099925, 0.1892052776558386, 0.18810526167983832, 0.502272450828662, 0.14898199176271443, 0.6475753718998548, 0.4808274839271953, 0.5802897260187181, 0.16667530235517825, 0.1626269898752455, 0.6263311105646436, 0.5002640203715777, 0.16160156187220598, 0.44481452418621403, 0.35038958367825646, 0.16482854646481648, 0.4005627581061282, 0.44663051374500806, 0.18190020646349947, 0.194016371555792, 0.19777264209108958, 0.20248330003214265, 0.1822211216872186, 0.19414608521017918, 0.18975151423077774, 0.18878157701183917, 0.19424745284520262, 0.17623945054070078, 0.19187786381371663, 0.08963144847490967, 0.07145394395426607, 0.08376896393892419, 0.07675458087458009, 0.07240189868076463, 0.09426259940519854, 0.07330292435147712, 0.07164728157715383, 0.08233346412087394]}, "mutation_prompt": null}
{"id": "a8256df6-6c53-4fbc-af96-70026e70b59d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 30  # Increased population for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid method integrating adaptive parameters for PSO and DE to dynamically balance exploration and exploitation in diverse search spaces.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f8d18897-706a-47ae-8723-62729156d2a9", "metadata": {"aucs": [0.4553043394079256, 0.4527853723045824, 0.5151915342620941, 0.5330947965298458, 0.48328244787167374, 0.5387701578795989, 0.50580924102028, 0.5778975573224714, 0.552867964514326, 0.16156404223717014, 0.1438208749409483, 9.999999999998899e-05, 0.031133182726038156, 0.1031882567478084, 0.2319204108905687, 0.022759412671326973, 0.17326014768875253, 0.14231495890988066, 0.11387764128114009, 0.1448653260347037, 0.17829533747265125, 0.11390994597282844, 0.11161385205130359, 0.21575716964006075, 0.10244070384399584, 0.093753350224002, 0.11163801975419374, 0.0961410060002934, 0.10969822959370634, 0.124124365006677, 0.1061705745684316, 0.08942203678796123, 0.0957420448499775, 0.0839280601629685, 0.11880709140162293, 0.10724904182761352, 0.9757501082346289, 0.9734742208267657, 0.9843470491369619, 0.9749621409674673, 0.9786278847736399, 0.9809130489903186, 0.9773774654642998, 0.9764202805828602, 0.9802616001563773, 0.2956857560875814, 0.21840371896179622, 0.324873807769954, 0.25723515987004, 0.2840047899339856, 0.39618012510432754, 0.29128654288004086, 0.0879016975811252, 0.0866046791886389, 0.378274347415988, 0.25788764258451125, 0.24827491914494604, 0.2400049163530702, 0.15768388561586766, 0.18671124832519403, 0.5229066805145256, 0.1822298438785399, 0.4598954575136882, 0.09562117129418057, 0.09653920526103488, 0.1386925765476199, 0.06967136528309748, 0.09639745276841927, 0.1352539227069085, 0.10033969807597076, 0.12084942343573934, 0.09960174933362198, 0.11164719231464604, 0.01584577584684488, 0.1950844475268153, 0.12270471647644865, 0.09911379493741079, 0.09274194993446638, 0.13927600629331371, 0.09852040728183709, 0.07833572996227067, 0.03225484954212465, 9.999999999998899e-05, 9.999999999998899e-05, 0.012131183627976494, 0.005257786520379115, 0.0008729912503460113, 0.027274656270692144, 9.999999999998899e-05, 0.0015173550008775738, 0.07663435922868178, 0.07371809070212709, 0.061882666069955294, 0.06112437297008033, 0.03373496407527454, 0.022294369379134316, 0.08247040875416156, 0.04376530759261077, 0.08630481618634167, 9.999999999998899e-05, 0.017726230395178733, 0.027385554740792184, 0.025190339570478004, 0.03169306726014676, 0.039324786470160134, 0.02843663420550091, 0.03658060190354062, 0.03951282686608826, 0.11204196176334047, 0.02204328638605968, 0.1018251167267874, 0.15460506190877155, 0.06888050001482338, 0.12447034793758649, 0.09680300813552489, 0.0879125071841147, 0.08565296967574554, 0.3992190523724173, 0.39466225131428256, 0.3964495101234292, 0.41657182457246256, 0.3981402801578947, 0.4337213582800856, 0.39084441194091124, 0.36591880137250776, 0.39314903120253497, 0.0909003584902428, 0.11002981408799406, 0.09296418603803214, 0.08569512589736628, 0.07761503976075224, 0.08218873297044338, 0.13895979553230808, 0.07960489059716835, 0.11510102002149702, 0.1583798468151354, 0.1475047335107198, 0.2093406374497251, 0.15964739936376737, 0.17888648758692727, 0.18040189105505744, 0.14742447502617528, 0.24040660839949346, 0.16003101569100286, 0.22335095610685052, 0.2919293313334911, 0.3066650432515269, 0.2929482405107836, 0.2637372675244166, 0.32366489004334187, 0.317849407935196, 0.31937046411318937, 0.32432138651891596, 0.1885758704024294, 0.21473340275317565, 0.22187484582231398, 0.21122408297758266, 0.20472603697935987, 0.15770249236824418, 0.219892785069275, 0.21983734123058962, 0.23306881144219083, 0.17952981790695888, 0.17258862006958553, 0.19356856624813046, 0.19537220797499744, 0.17034194352619414, 0.18040438806774928, 0.20671527540927082, 0.18652459785318165, 0.2297551761018406, 0.18130870877714855, 0.17969192779009913, 0.39502480804978923, 0.1894217214021322, 0.33974899367711586, 0.1931086631120854, 0.18470831673002874, 0.30177287358099925, 0.1892052776558386, 0.18810526167983832, 0.502272450828662, 0.14898199176271443, 0.6475753718998548, 0.4808274839271953, 0.5802897260187181, 0.16667530235517825, 0.1626269898752455, 0.6263311105646436, 0.5002640203715777, 0.16160156187220598, 0.44481452418621403, 0.35038958367825646, 0.16482854646481648, 0.4005627581061282, 0.44663051374500806, 0.18190020646349947, 0.194016371555792, 0.19777264209108958, 0.20248330003214265, 0.1822211216872186, 0.19414608521017918, 0.18975151423077774, 0.18878157701183917, 0.19424745284520262, 0.17623945054070078, 0.19187786381371663, 0.08963144847490967, 0.07145394395426607, 0.08376896393892419, 0.07675458087458009, 0.07240189868076463, 0.09426259940519854, 0.07330292435147712, 0.07164728157715383, 0.08233346412087394]}, "mutation_prompt": null}
{"id": "1d664f55-5340-4c83-9c37-f94496ce691f", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Further increased population for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with sigmoid modulation for smoother adaptation\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_min, self.scale_factor_max = 0.6, 1.0  # DE mutation factor range\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters using a sigmoid function\n            progress = evaluations / self.budget\n            sig_progress = 1 / (1 + np.exp(-10 * (progress - 0.5)))\n            self.c1 = self.c1_initial - sig_progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + sig_progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - sig_progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_min + sig_progress * (self.scale_factor_max - self.scale_factor_min)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with adaptive mutation factor\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveHybridPSODE", "description": "A hybrid optimizer that combines adaptive PSO with a novel adaptive DE strategy to enhance convergence speed and accuracy through dynamic parameter tuning.", "configspace": "", "generation": 6, "fitness": 0.18861803957619075, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "f8d18897-706a-47ae-8723-62729156d2a9", "metadata": {"aucs": [0.3683484940619548, 0.41466385587822907, 0.39161519968363623, 0.3531802286079494, 0.4092742018037896, 0.40293952549791534, 0.359443096409902, 0.46926901239008845, 0.3810210302775995, 0.023378848778821903, 0.028678488047382378, 0.04729151853307556, 0.06017974416866401, 0.07861620819066362, 0.0318537905516898, 0.0976560720730899, 0.0946884524860796, 0.027388325087328358, 0.07938197817559234, 0.08178088863577815, 0.08927284534737989, 0.0974405038180004, 0.1052538871749028, 0.0980996186767481, 0.09563837075680515, 0.09088456594407068, 0.10276196761906353, 0.08301924568800001, 0.0799673513367476, 0.07059080646498372, 0.0875394781751, 0.0854427774590818, 0.08780480933713264, 0.0739568199981746, 0.09430245583736419, 0.10525655335130579, 0.9690164810090055, 0.9654212981724652, 0.9677815374073074, 0.9699994944739074, 0.9596519879237044, 0.9591380412870417, 0.9677103313260863, 0.9668132222530892, 0.9619002752156167, 0.21623223740742603, 0.24365387397819538, 0.1453764559837175, 0.17225209020956755, 0.22078386854754573, 0.22328211147196675, 0.1768982908343112, 0.19339664858025485, 0.19828297446757215, 0.23759885775754797, 0.19569126034665474, 0.20160799573141985, 0.19353933934625656, 0.1727861137625306, 0.23426233037467015, 0.39138863949321034, 0.3445470286110778, 0.19452301014060203, 0.08146678812262176, 0.08855913374081648, 0.09551181545917353, 0.0969533685441506, 0.10369235736914906, 0.08742275008942557, 0.10314933809009275, 0.08601078511146565, 0.11338029470623934, 0.011415943424092578, 0.0804645291771916, 0.10781063472637065, 0.07938868299993285, 0.10404176560047396, 0.06660517051894144, 0.0803853636984273, 0.12660245599303177, 0.06846577649320096, 9.999999999998899e-05, 0.008488968655417595, 9.999999999998899e-05, 0.01694562131392574, 0.01293202262964821, 0.006861592517539039, 9.999999999998899e-05, 9.999999999998899e-05, 0.01958341879079739, 0.0709481649508773, 0.04690715139688073, 0.11123917514059956, 0.08444626870526917, 0.017128921594438684, 0.0309833383257776, 0.06739704989758688, 0.06351793226698499, 0.06621917513557218, 0.007414685647181396, 9.999999999998899e-05, 0.032125393441677086, 0.0217351053265622, 0.03125768531784201, 0.022925910034983454, 0.025710680229627192, 0.027119592789504487, 0.024028853953833806, 0.041508049318110585, 0.035220674044436406, 0.05682279744386376, 0.0512215647382358, 0.07828909450716925, 0.06099601336094218, 0.03231020502275228, 0.11220780331570401, 0.047305565283965234, 0.3198502412657247, 0.3645408132369914, 0.3445239207220978, 0.3663419952990442, 0.36266553709573857, 0.262784030692477, 0.3449816041269823, 0.3257970928984617, 0.35445105499739515, 0.08927033713407895, 0.095831280927137, 0.08398172169412665, 0.08325011519842707, 0.10908624736453787, 0.10757897548530948, 0.11275127997806467, 0.09031362480718397, 0.07644330559520784, 0.15010621980379524, 0.18581851457273857, 0.13242269384512761, 0.17597032981535998, 0.13914702420362335, 0.21685824177495105, 0.18831922838088433, 0.16338182666399403, 0.1678394465002302, 0.21586021732108374, 0.21554754129903642, 0.22330965052947527, 0.2307192228329723, 0.22725249309349171, 0.23945070097873145, 0.24646293731916435, 0.25627345381685385, 0.22719899335549076, 0.18148717863706698, 0.17499426726613743, 0.18409010464208164, 0.16861671749088714, 0.15155020165507027, 0.18825271925919662, 0.18182218791700633, 0.18868995336499006, 0.19496560993066347, 0.18640374610985277, 0.1901976068390292, 0.1863912826572277, 0.23339135183639503, 0.1886387750312145, 0.16865212489961945, 0.18498421951931387, 0.1734417421786285, 0.1888023700403355, 0.18322491720217582, 0.17444377223801455, 0.1817315522818974, 0.18687185791982042, 0.16171708542777619, 0.18630486372169064, 0.18237338438083284, 0.17762234092288143, 0.23032202056922202, 0.40312394444410615, 0.17622069418449393, 0.4766453837858867, 0.171187633127743, 0.19257655849673505, 0.18187032244857515, 0.47913760553729534, 0.18309186132830568, 0.4806441245366998, 0.17171947627512285, 0.1908291878408428, 0.17916443469344012, 0.3871780871163103, 0.2321665545977355, 0.26079373561111197, 0.18457735622800242, 0.18999156382433535, 0.1944698213748658, 0.17867946269619717, 0.1894603184185094, 0.1731787666117387, 0.198382259134679, 0.2019097139496091, 0.17721314348930461, 0.17707137187546085, 0.19460312753714348, 0.19022529046746672, 0.06863076806837975, 0.06429787271466025, 0.07023563333465221, 0.06916855875280836, 0.07381601384896219, 0.08560544017148619, 0.07171115376154391, 0.07134770806025703, 0.06916349014836864]}, "mutation_prompt": null}
{"id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 7, "fitness": 0.3042802449867867, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "f8d18897-706a-47ae-8723-62729156d2a9", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "1e36746c-3abf-492c-89fe-0221a59eface", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "ea1d14c7-1041-4ce4-8c8d-88cfc1fe9f38", "solution": "import numpy as np\n\nclass RefinedChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 1.0\n        self.c2_initial, self.c2_final = 1.0, 2.5\n        self.w_initial, self.w_final = 0.9, 0.3\n        self.scale_factor = 0.5  # Adaptive DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_sequence = np.sin(np.linspace(0, 4 * np.pi, self.budget))\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            chaos_index = int(progress * self.budget)\n            chaos_factor = chaotic_sequence[chaos_index]\n\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = chaos_factor * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * chaos_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * chaos_factor\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedChaoticHybridPSODE", "description": "Introduced chaotic maps for parameter adaptation and adaptive DE mutation strategies to enhance exploration and convergence robustness.", "configspace": "", "generation": 9, "fitness": 0.24853627768279704, "feedback": "The algorithm RefinedChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.567899352148293, 0.6544563565859494, 0.7282300016230197, 0.5983647709667312, 0.6958801289198794, 0.6657252372987255, 0.6099739662684882, 0.6418985766094067, 0.6637420327603365, 0.18791735355502048, 0.2406314836546597, 0.286200057798621, 0.26553093756077895, 0.0727317781440664, 0.34282545020112687, 0.1679780519811206, 0.2574459731317321, 0.22238246695413677, 0.12892901581337135, 0.14155040360395255, 0.1300069930464226, 0.1127570060502745, 0.13615095846749314, 0.12250017080251507, 0.1297364121585337, 0.1259670310753419, 0.17476753910772114, 0.09498179970726162, 0.12262397420119775, 0.09525990240301085, 0.09730330504252904, 0.09696921710233852, 0.11558300342995698, 0.12379280265830617, 0.11360543522326794, 0.10731306892536852, 0.9460892629010365, 0.9665687817745694, 0.9465198658148526, 0.9614885088868016, 0.9502784602960468, 0.9359598515133242, 0.9675467301400532, 0.9385417976008164, 0.9482762042915182, 0.28909963768852753, 0.20526111149184922, 0.1744282132772259, 0.3524786253906288, 0.3401256505577843, 0.3555596666733356, 0.29254840933943504, 0.3355707286967575, 0.32325490006654956, 0.8105416480954739, 0.21655836304050657, 0.8102142821487353, 0.21113598402364897, 0.1892085625969513, 0.18602576390815295, 0.20521750782286963, 0.20889537982638084, 0.23587044486602093, 0.1377744342071041, 0.24959839631495173, 0.1396619035490445, 0.12385156747867954, 0.12134753701539125, 0.19718370796132256, 0.14046602263435237, 0.22124112581069144, 0.1765805403531191, 0.12296335327923702, 0.14805430249145335, 0.12368282573036427, 0.16570488676983475, 0.10541546596133544, 0.22226170356583874, 0.21644446474569246, 0.09673936502294822, 0.13274193340428686, 0.007120579093149337, 9.999999999998899e-05, 0.009351529884875753, 0.0112257053707705, 9.999999999998899e-05, 9.999999999998899e-05, 0.006549860396725893, 0.006153491413829815, 9.999999999998899e-05, 0.1157844488952211, 0.08108375607008145, 0.12933712289758426, 0.08242875960577367, 0.012061003287436312, 0.016797920921181153, 0.05301540255449633, 0.09675223424837809, 0.06147611706365874, 0.02394537627367299, 0.0707441430470852, 0.06413198637768125, 0.06559462949159134, 0.05597276798444306, 0.08284187604680904, 0.0901131679406042, 0.13425653998209708, 0.06860656072627402, 0.15800652093860368, 0.10869183643666724, 0.1756669049159928, 0.0072781267025470164, 0.10125626427926948, 0.17829482389679574, 0.04725673585558321, 0.12682002736428655, 0.11698429891192841, 0.4029810689153712, 0.4061808628632161, 0.5497882699988386, 0.4368673479132704, 0.42157561931735055, 0.48146569583646637, 0.4580180736389827, 0.42221417596029875, 0.4811598976017809, 0.138298799543763, 0.10711652748436751, 0.1065999806043888, 0.08663404360123717, 0.11021160465492652, 0.18827682616258545, 0.10105466271722763, 0.10655262009031652, 0.1072738125211754, 0.20980534574404297, 0.13283003159648687, 0.19731087793031143, 0.24532434475096898, 0.2098248104255972, 0.3039348016710054, 0.31775948402446796, 0.24537583280601305, 0.2973523508807764, 0.19997755264437034, 0.27362730100571564, 0.2513854759813451, 0.3176017714774333, 0.29886809180576157, 0.31718030040869327, 0.3059951560718065, 0.3562528047942368, 0.37218258770037926, 0.24602293873103764, 0.25142860585655236, 0.2490846192184779, 0.22559156488432208, 0.1978475089974615, 0.2526116753298707, 0.19941714318538273, 0.2580742547497267, 0.2726632608263996, 0.20834946115576902, 0.2104940068729858, 0.1860608553671188, 0.23803041170427341, 0.18646253730589102, 0.26107840839231955, 0.21374420597571875, 0.22615358405663133, 0.2041644877656349, 0.2119173533156824, 0.3258637297794468, 0.19029134352489874, 0.21047967891213915, 0.2169902632883065, 0.18291132248671338, 0.21028509829015074, 0.19910800745338586, 0.18547685881632647, 0.18748419731735966, 0.17923630642431976, 0.15357014014400427, 0.7333570457261028, 0.2008781582878717, 0.200687143877876, 0.14251291925840381, 0.16887542735083083, 0.8897700000627832, 0.370965963893479, 0.2095634647501522, 0.5580623205931157, 0.4104755462065566, 0.16798268267703875, 0.1541781063512524, 0.16658008334475494, 0.19774511879226375, 0.6331428678170192, 0.18347324614069727, 0.18035471157275385, 0.18308719081248115, 0.1909404390735272, 0.17910277042038347, 0.19023488615100403, 0.17949285130794956, 0.18343508012254828, 0.179305159103609, 0.0853741238332636, 0.08336884354004381, 0.10318158179816206, 0.07519454496341726, 0.08715196530292635, 0.08089042109552302, 0.09727684568932948, 0.08205022009302554, 0.0788011953191724]}, "mutation_prompt": null}
{"id": "1a9d2f72-408f-4ea6-8854-1289adacfa3a", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "52cd34cf-a8a4-446c-ab25-24e106a0e955", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "40a5b910-0173-42bc-a04b-0de29e796196", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # Slight increase in DE mutation factor\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)  # Added velocity clamping\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.6, 0.9)  # Adjusted inertia randomness\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = np.clip(inertia * self.w * self.velocities[i] + cognitive + social, \n                                             -self.velocity_clamp, self.velocity_clamp)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9  # Adjusted crossover rate for balance\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (self.upper_bound - self.lower_bound)\n                    trial += perturbation  # Added random perturbation to escape local minima\n                    trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "Enhanced hybrid PSO-DE with adaptive velocity clamping and random perturbation for improved exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.293431064751756, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7232820978787228, 0.7246324124887841, 0.6989981602928128, 0.7211255511921344, 0.6945944013686093, 0.7717311688295652, 0.7065134416605198, 0.7624802652086269, 0.7378112202546185, 0.19044864489267987, 0.1731319730134504, 0.2269954788268107, 0.2839546622066902, 0.445783857674262, 0.1434188150574811, 0.44187435893807303, 0.46707412370132717, 0.47968137051722026, 0.13307484747771448, 0.37740793017074814, 0.1563461024378967, 0.13576670268515623, 0.1660178160227579, 0.3287015822793399, 0.09108223398059667, 0.1168466076237441, 0.14569586180518768, 0.11371764854551891, 0.12329761332221645, 0.0909951423663844, 0.09478357807235627, 0.10455278882076147, 0.11846534828655042, 0.10424635106860136, 0.12678167402251583, 0.10233516907217077, 0.9211122581751564, 0.9460503013265127, 0.8882249186274023, 0.8968443966550037, 0.8906819476502936, 0.9237089336879956, 0.898050379549055, 0.9217119421934719, 0.9219709141674274, 0.5117953941055715, 0.4996832309389908, 0.42045873361995123, 0.3332670137229157, 0.4916231103872448, 0.4470520715004018, 0.40422578112707397, 0.37275784094224795, 0.4440842209861029, 0.707740694868102, 0.251747752236125, 0.3167451804214191, 0.36520837088278413, 0.3571005543103044, 0.34233959848104756, 0.22553811222716447, 0.5831560961632276, 0.7303754048009228, 0.2054336779941447, 0.17954772982323264, 0.16120689189574278, 0.15202462785363147, 0.15857642221328627, 0.15983570994382768, 0.14437532335956327, 0.16507135124038064, 0.16529688414286414, 0.16091195374316924, 0.16582910348062174, 0.12663514293801925, 0.17821284639290513, 0.1699452213578848, 0.17356662883834562, 0.16880906898622816, 0.1539496690573895, 0.19331415605806934, 0.05957693938252118, 0.029712142382324558, 9.999999999998899e-05, 0.06334289384665259, 0.08763618228711023, 0.035758213535876715, 0.004141075980279685, 0.012123817026549522, 0.0032900344783667324, 0.17764809954819283, 0.1179716957014072, 0.13039722962476719, 0.09641539837640556, 0.05351846541839733, 0.13003042424123146, 0.08747108443100349, 0.08451569390274494, 0.10309973876247802, 0.2207642692582299, 0.09568361490418997, 0.06554724840865944, 0.094542082312015, 0.06970761915156598, 0.051449538532658656, 0.06772941235755114, 0.049700510785171126, 0.18537422337847942, 0.11608663241078354, 0.15828036475991625, 0.1341501150011638, 0.07278165771437928, 0.2517593128499602, 0.09378592860919777, 0.07331290951135283, 0.19914460493094543, 0.07908420287814788, 0.5077585335757954, 0.5265301120448607, 0.4378399019777385, 0.47504645349267505, 0.5180347954935866, 0.490019638007807, 0.5031388812295903, 0.48364719339056306, 0.47258552980339485, 0.10370778761627097, 0.12433538986103287, 0.12005813735985105, 0.13991751576505407, 0.1475488200903372, 0.15147222983537778, 0.11866902679938607, 0.11543185887397889, 0.11113376798129448, 0.21793327222281955, 0.22064514821802927, 0.31680673637219636, 0.16575408905018052, 0.1787740555994184, 0.21460556790577745, 0.21230599747794054, 0.17632249013489854, 0.21680211528443394, 0.39334312166046825, 0.33628929287955966, 0.3039218960351191, 0.37191285436150934, 0.37405789470204165, 0.3128656300944631, 0.31503652663597814, 0.377069517492601, 0.379443518990386, 0.27535650638030373, 0.2145680767361705, 0.2598305629450274, 0.24605067399998704, 0.3025620598346338, 0.20922554120757453, 0.23492254469148333, 0.27317150601651385, 0.2349709290626204, 0.2070698910417954, 0.2369866876105753, 0.20426217494866183, 0.2055810878907851, 0.21464360058230536, 0.24100590336412642, 0.2698436292789341, 0.2761360253656385, 0.2100938875536441, 0.19402367596145487, 0.2253599326947353, 0.20059534156403802, 0.553967155694294, 0.4300760059576466, 0.1944686483884378, 0.2195002237319289, 0.22902356673934288, 0.19819921753165304, 0.17794045262612512, 0.18222642347138762, 0.7503160176139295, 0.7892801078501666, 0.19800647501340707, 0.19823761097688342, 0.7825971118287978, 0.776920868613101, 0.7770244242462926, 0.7824693880752607, 0.5885455101684374, 0.5985814133670387, 0.20747565224063302, 0.3082244790115355, 0.14886665810854027, 0.46961459287858065, 0.6005367123109121, 0.6756709627763045, 0.20119872589193788, 0.19095706905021692, 0.18370816017175584, 0.20589615843236486, 0.20440282025264755, 0.18185095389659045, 0.22555160233104166, 0.18240778600590735, 0.1916945991958816, 0.09831836490030688, 0.09745269599361195, 0.09082446118223853, 0.08710671393239211, 0.09686122160929245, 0.08282292083443987, 0.0945865556379788, 0.09650711767953524, 0.08908890129659319]}, "mutation_prompt": null}
{"id": "f603b5e1-e699-42fb-965e-0a21e6b56b27", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "97793f98-3382-4222-8d42-b3876a3717c0", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "1d5e7b7e-67a8-4399-bca0-282dba47135c", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "ef4d304a-9de2-4cd0-b187-f866c18edee3", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "4c269891-9ce0-4152-aabd-b88c3bd9d7c9", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "6742120e-0c22-453e-97a3-540ba160c19c", "solution": "import numpy as np\n\nclass EnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Adjusted for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 1.5, 0.7\n        self.c2_initial, self.c2_final = 0.7, 1.5\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor_initial, self.scale_factor_final = 0.6, 0.9\n        self.random_immigration_rate = 0.1  # Introduction of random immigrants\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 + 0.1 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n            if np.random.rand() < self.random_immigration_rate:\n                immigrants = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                for immigrant in immigrants:\n                    score = func(immigrant)\n                    evaluations += 1\n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest_position = immigrant\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedPSODE", "description": "Enhanced PSO-DE hybrid with adaptive learning rates and novel exploration-exploitation balance leveraging random immigrants.", "configspace": "", "generation": 18, "fitness": 0.2596373982177294, "feedback": "The algorithm EnhancedPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.5866915435593469, 0.6133254465618079, 0.6533259354680214, 0.6702057938619936, 0.6058142410149323, 0.6195236683662009, 0.6555796425337868, 0.5811184166252861, 0.6326548655025808, 0.3386590691793592, 0.06935711011573675, 0.22474465817431366, 0.39123129176796234, 0.26498036538921743, 0.3386402735628432, 0.07538384517694174, 0.13552891061480044, 0.2781143021695709, 0.13041058405597017, 0.12513428436697416, 0.1381753264079394, 0.1287915810532304, 0.12223021982080517, 0.11765056365602922, 0.11265787675808248, 0.12046246950558814, 0.11791672917614382, 0.10109502819304073, 0.11033137371785029, 0.10685194725331149, 0.11246310748221622, 0.1276565453152645, 0.10261525106634073, 0.11475097439347659, 0.1007340187290432, 0.1016704973243644, 0.9676519928360984, 0.9488012713605524, 0.9675582941252572, 0.9410576140518737, 0.9738834382008836, 0.9658673558180744, 0.966615594804007, 0.9705803112963068, 0.9666465195733328, 0.43377187041631216, 0.44294769321487326, 0.4269911049552637, 0.526001744471833, 0.3606773452042312, 0.15150746248890734, 0.43571306936628684, 0.0858720784615834, 0.4747374178910325, 0.2948539346104816, 0.31295198021406523, 0.6432538951339628, 0.19219242394275848, 0.7076739259746813, 0.20010870438517203, 0.6129508743811553, 0.21262285608260467, 0.31802194260976546, 0.15973132940181478, 0.2282010633871252, 0.15780978434939952, 0.1564833947402745, 0.14853175477805747, 0.1406128169562647, 0.15448532805432258, 0.11736950264033019, 0.16856797939037316, 0.21189694624499822, 0.19722680637960066, 0.16785188133225915, 0.1679548510553539, 0.16482993724841088, 0.1572346182692288, 0.15029468433779258, 0.11420033915697769, 0.1444421714805907, 0.05454195082760327, 9.999999999998899e-05, 0.019895453219654913, 0.00019566379611113405, 0.041334358555478734, 9.999999999998899e-05, 0.020670243913735398, 0.021969786887617415, 0.10726563274958767, 0.05893164681603957, 0.11573369117681775, 0.10346973419978256, 0.053138135329431124, 0.014487507142526557, 0.042384138381587944, 0.04423315466196076, 0.0606450801132129, 0.05335937967157334, 0.14767327967720956, 9.999999999998899e-05, 0.03258708126336385, 0.12184521082773625, 0.05895644949452494, 0.08846628710777804, 0.06024695376079248, 0.059085837556021925, 0.05839627926876312, 0.15278749402487224, 0.04860095406589049, 0.07049226075577064, 0.050588019206693535, 0.09380156240442816, 0.07991709146871506, 0.07299706272442741, 0.06790736138799325, 0.14231112316719174, 0.4659650496789086, 0.45966783668876887, 0.4338260602015537, 0.4647780182639516, 0.445594601354097, 0.454744610818965, 0.45066893495587057, 0.4712098428563838, 0.4886725147085813, 0.11827572598744096, 0.14960664454591555, 0.08610240695407612, 0.10511209831772939, 0.10295359061707676, 0.14300887668389606, 0.11949679885493902, 0.11204910133985835, 0.23365548762651311, 0.21786381803524124, 0.16235149025944884, 0.2629038310617652, 0.15723430528611193, 0.21711770263305297, 0.17852068040000468, 0.2961974891953125, 0.1571769182679147, 0.18656935598655577, 0.2944990550198481, 0.31455566877604313, 0.3277520850242832, 0.36780188479502673, 0.32117525531663016, 0.36889570143649475, 0.44025194647179333, 0.3590071629782817, 0.3466188606097347, 0.2386464768149975, 0.2540956642151876, 0.22046214515542328, 0.2419345929803245, 0.1828962120060733, 0.20257836930708517, 0.2209920700712984, 0.24738165317903626, 0.3180964992587305, 0.23919145623027493, 0.18271332833620668, 0.23479918199413063, 0.1916169931232996, 0.2609163871360515, 0.21250579454099194, 0.21717662989854158, 0.2686972255215969, 0.21855904006961901, 0.20759716599792477, 0.21312889112254507, 0.1988332026292886, 0.431860088020796, 0.20632827367406192, 0.21040795018746816, 0.4886636755803043, 0.22121598960073408, 0.1882457871134261, 0.25632871663031276, 0.19769597265994932, 0.15102155918093707, 0.7834068959627176, 0.19574885158466582, 0.7032098798955801, 0.18367004493968708, 0.16547210430556947, 0.6767595835866804, 0.6610668400985165, 0.207663339245864, 0.19092745177806314, 0.1633938674457064, 0.6383445712341795, 0.1501894724062719, 0.20807933474006646, 0.1975202369640563, 0.5613532315299745, 0.1821665300111842, 0.18842289157105052, 0.20068971390858004, 0.19940409132860792, 0.18156356107633975, 0.20894203808965373, 0.18390394795391463, 0.1852979639986463, 0.19413858507385207, 0.08543859449017166, 0.08617150729738865, 0.09851319177896511, 0.09219966216991904, 0.07532852613735741, 0.08992639690604498, 0.1060957835123969, 0.07663979279924404, 0.09862959836415208]}, "mutation_prompt": null}
{"id": "c70d1a8e-75a0-414f-968e-34999b99707f", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "95432364-27e9-4060-8a3c-f4b7f89edc34", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Slightly increased population for enhanced diversity\n        self.num_swarms = 3  # Introduce multiple sub-swarms for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_positions = [None] * self.num_swarms\n        self.gbest_scores = [np.inf] * self.num_swarms\n        \n        # Adaptive coefficients with swarming dynamics\n        self.c1_initial, self.c1_final = 2.0, 0.6\n        self.c2_initial, self.c2_final = 0.6, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor = 0.8  # Adaptive DE mutation factor\n        self.crossover_rate = 0.9  # Fixed high crossover rate\n\n    def __call__(self, func):\n        evaluations = 0\n        swarm_size = self.population_size // self.num_swarms\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for swarm_id in range(self.num_swarms):\n                start_idx = swarm_id * swarm_size\n                end_idx = start_idx + swarm_size\n                particle_indices = range(start_idx, end_idx)\n                \n                for i in particle_indices:\n                    score = func(self.particles[i])\n                    evaluations += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.particles[i]\n\n                    if score < self.gbest_scores[swarm_id]:\n                        self.gbest_scores[swarm_id] = score\n                        self.gbest_positions[swarm_id] = self.particles[i]\n\n                    if evaluations >= self.budget:\n                        break\n                \n                # Update velocities and positions for adaptive PSO with multi-swarm dynamics\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                for i in particle_indices:\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (self.gbest_positions[swarm_id] - self.particles[i])\n                    self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Differential Evolution mutation and crossover within sub-swarms\n                for i in particle_indices:\n                    indices = [idx for idx in particle_indices if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_scores[swarm_id]:\n                        self.gbest_scores[swarm_id] = trial_score\n                        self.gbest_positions[swarm_id] = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        # Return the best across all swarms\n        best_swarm_idx = np.argmin(self.gbest_scores)\n        return self.gbest_scores[best_swarm_idx], self.gbest_positions[best_swarm_idx]", "name": "AdaptiveMultiSwarmPSODE", "description": "An adaptive multi-swarm approach combining PSO and DE, with exploration-exploitation balance through diversity-aware mutation and adaptive sub-swarm dynamics for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.26441544874574574, "feedback": "The algorithm AdaptiveMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.5717958172289508, 0.5856383497292131, 0.6453071369791418, 0.6305773327596356, 0.6260124719653217, 0.5986733861907537, 0.6090075452203718, 0.6235462697012413, 0.5901849609670171, 0.3043209066923013, 0.19716574937603282, 0.23363017256321716, 0.2230795259441376, 0.20968645594024138, 0.2558711898087562, 0.1422054430381119, 0.2731699104161397, 0.22233691787111398, 0.1917168919645641, 0.12973157283777925, 0.12749716823027124, 0.11624707740988272, 0.11162096742000815, 0.09276456508981368, 0.1241087551581661, 0.12217486553935109, 0.11724304310049682, 0.1071471648418415, 0.08629607933553562, 0.12239544785197054, 0.1094930719391386, 0.0801819432417582, 0.12102841168311096, 0.11276453882327919, 0.10557763145633758, 0.12146333605184867, 0.9698867731885037, 0.9715109438129264, 0.9798794041062802, 0.9697029705200882, 0.9566523454123803, 0.9685277277701593, 0.9627235930675327, 0.959162464718081, 0.9771164416351537, 0.3416471449163777, 0.38447159211581794, 0.38093790915134085, 0.34622395348072, 0.34062038695630537, 0.35057413689418404, 0.36874438286247313, 0.27396510791164075, 0.2917344800211279, 0.31708737714302027, 0.5033191267618409, 0.5739913447204072, 0.25889578514133205, 0.2496552766502298, 0.23773531452245011, 0.6248039915589382, 0.3248965375168975, 0.2720975231417475, 0.19924859663919792, 0.13986715626446689, 0.1351945144177109, 0.11539093298217618, 0.1369962392756806, 0.14587110838536244, 0.14990409257537562, 0.14223185899226787, 0.15712575231614623, 0.18228287477543004, 0.1261084849805595, 0.14988413172487758, 0.15231167654756572, 0.2554960237611055, 0.15156086950637893, 0.1463473325877992, 0.14661171214694346, 0.16827882026841923, 0.00429717107677885, 0.021795725585052383, 9.999999999998899e-05, 0.02761528386202594, 0.038841105769652495, 0.03519118859891768, 0.006124171556647018, 0.0027882126322558154, 0.005566685296073959, 0.08831268615956522, 0.050924408740726124, 0.057785785214413354, 0.08177824962557312, 0.06683987238673617, 0.04405449787776183, 0.07674132265283484, 0.04897083098757027, 0.05791930684522706, 0.07776511251237694, 0.09086985383397173, 0.028548722226638512, 0.067460984809386, 0.13326117245845615, 0.10117235644667832, 0.1840715425351026, 0.0698276257982674, 0.05678011650896497, 0.11321175483939983, 0.059774720853908225, 0.06886481768923791, 0.15806591971079054, 0.08686549164182611, 0.10002724962012544, 0.12869992603076041, 0.06991966993238963, 0.06743278141521547, 0.4288322121677741, 0.4490208705572868, 0.4612849942812194, 0.47287317203643064, 0.44316956874664715, 0.45068063029500505, 0.46214209314707455, 0.4471328875857641, 0.4143891766680625, 0.11345190791617299, 0.09582082048746521, 0.08410763992227799, 0.12257733641373236, 0.1056697936749541, 0.13564562917883327, 0.11408508837862608, 0.10123784131445157, 0.11727353174794664, 0.2071233106524356, 0.17429910682172545, 0.17386848731362514, 0.2679522016186727, 0.24222304052511634, 0.214352876947841, 0.21714060113994282, 0.25965011690401263, 0.29337490936629496, 0.31240658676217625, 0.30782772747251097, 0.29528929139461546, 0.28413744446467826, 0.30216078637015553, 0.34501773831838123, 0.35723602097943585, 0.34390097717087154, 0.30314534724155107, 0.26708806671896224, 0.23939010211697054, 0.2387336321920316, 0.24642556136176408, 0.1995946394595003, 0.2817850713061012, 0.263440287377399, 0.26550433945593355, 0.24701987429265237, 0.2369991431213918, 0.224709301900897, 0.2343008646039637, 0.18234763935689613, 0.19641849113062093, 0.22533178606591786, 0.20292606935635027, 0.20870375036846067, 0.2077864302354897, 0.20263063957568572, 0.34247365447006417, 0.19193801318677628, 0.19383832413638313, 0.19980732987179206, 0.19292907452876618, 0.21687750799290506, 0.3177088576922572, 0.1918559948638735, 0.698363112012826, 0.6237160106735855, 0.614912738161523, 0.6711634267866604, 0.6436010710230462, 0.6889377477170645, 0.6919040937407699, 0.17105201363116684, 0.6206026336807959, 0.3460837396086386, 0.28949597929733795, 0.19597170590722057, 0.4727393504366313, 0.2020306380440271, 0.46138881695557543, 0.2006535367805603, 0.44214451948780453, 0.40328669732777167, 0.19239852242148325, 0.20055553803241233, 0.19125015326773087, 0.20727386014038707, 0.1794077575732077, 0.19038014153038796, 0.19074206595917187, 0.18650235900370038, 0.19489187532178665, 0.07689146502369582, 0.10307166596495243, 0.08346436617672792, 0.09755752662867467, 0.08241824065010184, 0.10877151182724953, 0.0917252214243135, 0.08692868507875606, 0.09518731711618034]}, "mutation_prompt": null}
{"id": "5b35560f-b22f-43f7-a1f0-cc0e9d37192a", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with enhanced strategies\n        self.c1_initial, self.c1_final = 2.2, 0.8\n        self.c2_initial, self.c2_final = 0.8, 2.2\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor_base = 0.5  # Base DE mutation factor\n        self.scale_factor_growth = 0.2  # Growth factor for DE\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.6, 0.9)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    dynamic_scale_factor = self.scale_factor_base + progress * self.scale_factor_growth\n                    mutant = self.particles[a] + dynamic_scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 - 0.3 * (self.pbest_scores[i] / (self.gbest_score + 1e-10))\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE approach introducing adaptive differential mutation and cognitive diversity to improve global exploration and convergence.", "configspace": "", "generation": 21, "fitness": 0.29937666126410734, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7718777718140334, 0.7781793448137777, 0.7684873212794349, 0.7672458953944403, 0.7754084340145491, 0.8129097074760707, 0.801886825589283, 0.7943027310872549, 0.787999528251883, 0.5390483790602616, 0.5861899234592548, 0.5561204087403435, 0.507454623595623, 0.043908184158282015, 0.6271132184686778, 0.5608073069026682, 0.5490007765763694, 0.5794051226229215, 0.14547300608323954, 0.11487616064466277, 0.11721327958600136, 0.13400871820185734, 0.13856402607864493, 0.12495668687972661, 0.14042771327169157, 0.16244150235465915, 0.16904042125749452, 0.10849138742502795, 0.11622283312471338, 0.10297332591570563, 0.11423414811564325, 0.12589836586234526, 0.09783866678083142, 0.10723076077292593, 0.12292802741814979, 0.13408206777682663, 0.9390464085684022, 0.9595170949457119, 0.9667551983040715, 0.9604137884068064, 0.9548452950355958, 0.9595791667294218, 0.9589735640939518, 0.9530917306196335, 0.9723254661900894, 0.6223292125896731, 0.6136174217342796, 0.05611628299493587, 0.6010897586943552, 0.639073410202492, 0.6077887041458112, 0.5966684968700461, 0.5686718832201128, 0.6291932265146831, 0.2297110768798507, 0.2162964914955795, 0.7749556778193942, 0.21159568376247195, 0.18692895518967267, 0.1923999770988465, 0.22649616849042942, 0.2327909224331266, 0.15208581842522306, 0.19042529886351323, 0.21246714472748285, 0.11762916759247022, 0.16253880419984745, 0.21197720900990902, 0.10846377846247668, 0.19365464661690912, 0.12771076667423764, 0.17028052719304, 0.19865897531944376, 0.16679194136281061, 0.30665238755349034, 0.20126351262925146, 0.18462006436326106, 0.2305927818422303, 0.21339219988340452, 0.2522135099998396, 0.11076516778462386, 0.0022147114683218616, 0.09300186937984711, 9.999999999998899e-05, 0.00543443518872444, 0.00010244964608552287, 9.999999999998899e-05, 0.03994132028391251, 9.999999999998899e-05, 0.006840455740865781, 0.08047265425229622, 0.04582896827223448, 0.07198834947261634, 0.07841796693064185, 0.02628608227326601, 0.05419768190275209, 0.05262476416187911, 0.05334416426842237, 0.040480447921883767, 0.16221543393753823, 0.18605496719430503, 0.06428826848178693, 0.17766169325379777, 0.12482160315452218, 0.10607226630861899, 0.11665802168575246, 0.1323899270391734, 0.0884456712020033, 0.11453507636238025, 0.039783098584287524, 0.31230299046837795, 0.09352560470795257, 0.08541286385409219, 0.10310952305892063, 0.13066532135740694, 0.12052307194314438, 0.08130344695878378, 0.5078296415483425, 0.4965467137718328, 0.5534191844990939, 0.5407482935235317, 0.5178629615566269, 0.4839057340906934, 0.5257717999153614, 0.5528695387195237, 0.6024983204317162, 0.1257352940898998, 0.12310400226020268, 0.07601890956281054, 0.10124226604657238, 0.16165949938042212, 0.13884434648422883, 0.1248603331936009, 0.12265378140853389, 0.12901087872930272, 0.22844658634178827, 0.31704261732093586, 0.1800681424030367, 0.25444803610096867, 0.5124293467904872, 0.1683465741882888, 0.2532136810159572, 0.25340265875780776, 0.2022521170071011, 0.47824640318950573, 0.31633241632669984, 0.4068122693523424, 0.4760393256305656, 0.3741231532985301, 0.46007522404279444, 0.44892734863838024, 0.3957083161305115, 0.45903605720197693, 0.20649596557434702, 0.2479878426782458, 0.3152212944366829, 0.2368579000637172, 0.20700984179436355, 0.26432663014096647, 0.2974950795198571, 0.32834951684094105, 0.2621330598427942, 0.21462782270717873, 0.22020480433768874, 0.21710609769390954, 0.1982562662822963, 0.22793790254418567, 0.21466617823160428, 0.2157206955215657, 0.24227527845081454, 0.21708405754385718, 0.20151636716658872, 0.5646394681300633, 0.2033706986672369, 0.24376268784631072, 0.21569834076132888, 0.24046488415711043, 0.21572962511084814, 0.22211645785539635, 0.20197952560104593, 0.17431633978435002, 0.1579011336013738, 0.15328557130468812, 0.8612490810713753, 0.19890514350702593, 0.20000953848985603, 0.7781330772042712, 0.16635181180115866, 0.881125032746544, 0.7541433785367494, 0.2091586031493311, 0.6995152835944795, 0.6422454691685089, 0.16732930270087432, 0.14975421488659524, 0.10463711575739254, 0.20883676655721128, 0.7440705669153895, 0.18338481442051424, 0.19989174872135107, 0.19393803985476, 0.18793200547651667, 0.18731976835179542, 0.18317742376051693, 0.19889842399189106, 0.1965134266142271, 0.18713756622114075, 0.10041900724425068, 0.09720844928454586, 0.0948344166924715, 0.07819180203242537, 0.0937492090281894, 0.09999299331294864, 0.12251408509777173, 0.09080252120695842, 0.0879731014020283]}, "mutation_prompt": null}
{"id": "31d575d9-7be8-4681-95d5-41ce43f7208d", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial, self.scale_factor_final = 0.5, 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                neighbor_indices = np.random.choice(self.population_size, 3, replace=False)\n                best_neighbor = min(neighbor_indices, key=lambda idx: self.pbest_scores[idx])\n                \n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.pbest_positions[best_neighbor] - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "Enhanced hybrid PSO-DE with adaptive neighborhood topology and self-organizing mutation for better exploration-exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.17343854059227798, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.398095452087481, 0.3362042494825519, 0.3945030304038428, 0.42463814736009686, 0.38217385664952275, 0.4270591040771604, 0.3640214015221013, 0.3637449328364968, 0.4006168621878664, 0.11349305554568367, 0.06852605660326516, 0.08796287390311008, 0.08451192811869968, 0.057453919018683686, 0.09664938076901741, 0.10663182955535544, 0.08144990340058589, 0.09494482779983604, 0.08599000911813726, 0.07559533411199704, 0.08692770530115468, 0.07516236302994872, 0.07145813794154876, 0.07415855135535931, 0.07943729513235298, 0.07275254769416406, 0.07381872251601074, 0.06260224085317201, 0.06282787606443307, 0.0780701941073616, 0.07998314898110459, 0.06779075129745782, 0.06238951062759601, 0.06136150626172843, 0.06086886026799854, 0.07546185138090766, 0.9761625346434013, 0.9710260477947031, 0.9637273186246204, 0.9675145820937245, 0.9657961834878198, 0.9558517613697615, 0.9686813240411263, 0.969304220831698, 0.9728661580899679, 0.191974152579228, 0.16098617244037583, 0.18473264865722372, 0.1962262857316327, 0.13901335497788792, 0.2009445335049429, 0.1694806967706287, 0.08358994149516841, 0.207093083971014, 0.18750086309937375, 0.20128609690571742, 0.1928392270859226, 0.21166618497212308, 0.18431344468098887, 0.20984616178536608, 0.1575071283911067, 0.1869177268461112, 0.20600336078754466, 0.09659830341584608, 0.07568211596757368, 0.1212275800069812, 0.1027545292714096, 0.10581857676373185, 0.11211363152662923, 0.11876511488549546, 0.0880645753420829, 0.11459946187880743, 0.09438455635322685, 0.02838080470192872, 0.10230173479774951, 0.08471872603769204, 0.06671900604248493, 0.09214724530036933, 0.09936960205371348, 0.08104733679146103, 0.07680112737146794, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08084381342276648, 0.046511726388261176, 0.06095303121715079, 0.04830404587482573, 0.02150155886356986, 0.036612819011950015, 0.04698600088565086, 0.07218281575996155, 0.07337428621856201, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03401284282521777, 0.03130589736547973, 0.038966890216713734, 0.05015330137884155, 0.030671972384674562, 0.05165279853156357, 0.03730816035542228, 0.03988117542632297, 0.042609277146146596, 0.336316098450525, 0.3120910818033521, 0.3295532973844708, 0.33881648146153265, 0.3360440424889647, 0.34701345944358764, 0.3300648293142645, 0.3094806832514455, 0.35784646447875956, 0.07053836225186771, 0.0848182652265066, 0.08023031431968541, 0.09351621735130944, 0.08359710221396321, 0.07465826013179433, 0.06600433640968206, 0.08000214110555248, 0.062492039982304015, 0.1370732014687308, 0.17401761673602745, 0.15742933840984474, 0.1541990953714798, 0.12183719090696177, 0.17867922750309206, 0.1379662916486737, 0.12543275779944074, 0.1473194249965729, 0.21786394765461614, 0.21702622984992925, 0.24479985172074514, 0.21903067364344553, 0.20521727143496382, 0.2347619468048615, 0.24888762597689773, 0.25106833747482193, 0.25737572577588497, 0.15639161585488814, 0.15540806149835895, 0.16764874064167268, 0.14530962315883877, 0.1321506207381561, 0.15843854667850632, 0.15906153761560726, 0.16682099258420746, 0.16505565832151858, 0.18288687775065238, 0.19759208250853788, 0.1679309939790803, 0.170730023063563, 0.16705364593773142, 0.19380484186037572, 0.2180990534447087, 0.1825484777209494, 0.18978155514239292, 0.16302831947595098, 0.16392375379503465, 0.17227011815571203, 0.18621174603930857, 0.17773638995134733, 0.17782814787304357, 0.1681535554216934, 0.16311998579496245, 0.16533571835645378, 0.2373050511863285, 0.16704514118076896, 0.2798358461308199, 0.23318392243537278, 0.15323888032890043, 0.1627784267886062, 0.17511092743846635, 0.1494207017761735, 0.1473803560575896, 0.1560617026784401, 0.1663775489106214, 0.19993486955731887, 0.19897678941085273, 0.20887748379497784, 0.15117048525211996, 0.20457597182156984, 0.19646858292021696, 0.1985971529123458, 0.19274752972812248, 0.17623533326856322, 0.1787260699032398, 0.1821801321538299, 0.1956286516981116, 0.17141884875823, 0.18742037600211714, 0.17912383772787566, 0.20318155210520705, 0.06227599090320568, 0.06052580995902879, 0.06813921877156659, 0.06062203205579275, 0.07186569966511758, 0.061150417207941565, 0.0754430178956258, 0.06547540069475033, 0.06752003843771637]}, "mutation_prompt": null}
{"id": "d63f426a-87a5-4c00-ab88-3c5a2a4736b4", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Maintain diversity with robust population\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Self-tuning coefficients with chaos-inspired randomness\n        self.c1_initial, self.c1_final = 2.0, 0.6\n        self.c2_initial, self.c2_final = 0.6, 2.0\n        self.w_initial, self.w_final = 0.85, 0.35\n        self.scale_factor = 0.8  # Optimized DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate self-tuning parameters\n            progress = evaluations / self.budget\n            chaos_factor = np.sin(progress * np.pi)  # Chaos-inspired randomness\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with chaos-inspired inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = (self.w + chaos_factor) * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic self-tuning\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 + 0.1 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with self-tuning parameters, introducing chaos-inspired randomness to enhance exploration and convergence stability.", "configspace": "", "generation": 23, "fitness": 0.1326369924935162, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.20730289329222318, 0.2014464116288307, 0.22445953061532298, 0.20011113989894547, 0.17916927534657967, 0.23535621187977462, 0.2241943966660781, 0.1710125546662301, 0.2157881675521338, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04194745076212347, 0.083904501969286, 0.06054927789216413, 0.05759665643935863, 0.03943693522918379, 0.05201697431034846, 0.06401173234898583, 0.05772464482816664, 0.0744472772507786, 0.03019943666410052, 0.05468336777451699, 0.03350047959656599, 0.04700041148466427, 0.015064885713927278, 0.029944238874769824, 0.048930021126798784, 0.033502808865070954, 0.038096366304910756, 0.9721480843741119, 0.9660697869295308, 0.9776142513655091, 0.9731368081804418, 0.9653266816139767, 0.9737587823884865, 0.9738198597999531, 0.9606220979784407, 0.9713732500317256, 0.11685092747232118, 0.13759433413615063, 0.045989648219735724, 0.1271314336502123, 0.09677290515729087, 0.11890912166791856, 0.11196131857280811, 0.08727962553289637, 0.11829763461495313, 0.149633600949573, 0.13314674845944885, 0.1125028289168909, 0.14991679506276345, 0.10293048509182767, 0.16442861927447683, 0.15665486203120182, 0.1329335057150398, 0.10662155134958406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00943387987776334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05204864949024102, 0.0510128576704969, 0.00979141760484381, 0.008185717239300505, 0.03495775922322353, 0.010615072605832943, 0.05976397795278787, 0.051148595640458705, 0.0011428237844433031, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03237672493848476, 9.999999999998899e-05, 0.05632270115587146, 0.04327500427681685, 9.999999999998899e-05, 0.00363397170216484, 0.1282089769978465, 0.02604351737282795, 0.030757480734854847, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01380470307130477, 9.999999999998899e-05, 9.999999999998899e-05, 0.011100392084115063, 0.004963528885316371, 9.999999999998899e-05, 9.999999999998899e-05, 0.1929674366016325, 0.20478511172116654, 0.23190880165632166, 0.20479682712428582, 0.19456571595255678, 0.2367251853491148, 0.2293290237618848, 0.1974038934944733, 0.2139812821425785, 0.04765790180735219, 0.051735775857309485, 0.04707722593800567, 0.04387538558602733, 0.05147113755691257, 0.07673150178163124, 0.04815192369894217, 0.05896930024398883, 0.07684405421233387, 0.12693584207829267, 0.14935417373584425, 0.1340496709024077, 0.13872775077448818, 0.1635540645589164, 0.1319576659257058, 0.1613676148436498, 0.1435357405843617, 0.12580366885201455, 0.16762250762727304, 0.17919698215131907, 0.1712464611286596, 0.1652356676544101, 0.17257526420570324, 0.15067105523144597, 0.16651782534273207, 0.1907555424863132, 0.19859734583124788, 0.08900302477883848, 0.10949459444284915, 0.13993764758009342, 0.13023539509535043, 0.11237639504718422, 0.1421924562114869, 0.11235210217533897, 0.13759658482536563, 0.13804406238884526, 0.1494578644292507, 0.16456559047188202, 0.1525752621689539, 0.1751592743383933, 0.13993248926576018, 0.15042931133407622, 0.18156940728991766, 0.1514218375341052, 0.16031969860304984, 0.14706630820867195, 0.14875593437229984, 0.164062435952409, 0.16165305714155365, 0.14655590386493045, 0.16297635536262045, 0.14509503758115538, 0.1560743285324816, 0.16531442385997597, 0.17942589818234733, 0.15074185442460508, 0.13251175352729283, 0.21902147254373017, 0.16114043208049011, 0.16920635735628253, 0.14192738413437023, 0.13345199612544378, 0.23858533355791234, 0.1685793714698791, 0.18108423281279418, 0.16357771131676802, 0.17281790250865348, 0.1539799142009728, 0.11624627512654839, 0.19796918659112384, 0.17054351052858652, 0.1632826449865712, 0.18716712035174887, 0.18112356392115603, 0.18888858423110855, 0.17793236436598725, 0.17253598894036526, 0.20013346631198425, 0.18763731937684847, 0.17150489674749603, 0.18892530149216213, 0.05497954595616006, 0.048786602925434686, 0.05712663750840552, 0.06912037550390526, 0.0675646825123577, 0.06368187236210066, 0.05473465083778706, 0.06325378208036891, 0.05178993061350268]}, "mutation_prompt": null}
{"id": "8a2c4a3b-4c98-4b4d-9b95-31e6e661beb9", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "c77dfaa7-675e-404f-83bd-c5153acaf5ff", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "86b6f317-a1fb-4562-b707-14c1b507a86b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 45  # Slightly increased population size for better search space exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with increased randomness\n        self.c1_initial, self.c1_final = 2.0, 0.3\n        self.c2_initial, self.c2_final = 0.3, 2.0\n        self.w_initial, self.w_final = 0.8, 0.5\n        self.scale_factor = 0.6  # Adjusted DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for PSO\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Stochastic rank-based selection for DE\n            if evaluations < self.budget:\n                ranks = np.argsort(self.pbest_scores)\n                for i in range(self.population_size):\n                    indices = np.random.choice(ranks[:self.population_size // 2], 3, replace=False)\n                    a, b, c = indices\n                    \n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 + 0.1 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "A hybrid PSO-DE with stochastic rank-based selection and adaptive multi-phase mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.27192485609435196, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6895064978686489, 0.5803990403252068, 0.664619073016248, 0.6206166955895076, 0.6588096038431637, 0.6384517837678481, 0.59854239187877, 0.5815728067830541, 0.61062099916947, 0.27244270820474636, 0.2951320289057643, 0.31169847057960476, 0.25758553067044043, 0.2652544022682193, 0.3010904484168113, 0.2995566378739287, 0.31734199442438127, 0.2062972983508986, 0.13165486624593015, 0.13773790465006097, 0.14153952251453972, 0.1421017354995382, 0.13039143756626403, 0.13766989197686852, 0.10217219610079697, 0.14456168381236478, 0.10395718842285973, 0.1097268276793546, 0.1142238105639628, 0.10552848306912344, 0.11564888531790418, 0.10651463481319534, 0.10370043421704045, 0.10847373875588984, 0.11860395819131286, 0.11870262711788404, 0.960053974919829, 0.9607411720262443, 0.953046114356002, 0.9641074444682225, 0.9665259634797245, 0.9704658779875911, 0.9635163508737454, 0.9603593445896421, 0.9616755143983858, 0.41506512022139974, 0.4332051414028988, 0.39003297524969693, 0.4363711168870743, 0.4090538353855786, 0.38390132209988537, 0.4039793874212131, 0.38795520727080557, 0.41187054176351057, 0.3271884246990797, 0.35034482095319264, 0.5437724681417991, 0.2595424889382373, 0.21040802930874225, 0.24248362546784064, 0.2977025858646166, 0.3441206107975435, 0.6177615890624804, 0.3276760081920089, 0.17944353928818169, 0.17316217685748192, 0.18062089355504363, 0.1519668954748591, 0.11314406619573036, 0.1970757471996688, 0.17451234903096957, 0.1912782838063486, 0.15658738112967419, 0.2014389077833315, 0.16578624049209445, 0.22685798200797636, 0.1222446717781197, 0.20822257842052927, 0.14894138894569586, 0.10633971868051173, 0.17665108502956084, 0.017504403918204847, 0.004984821447202248, 9.999999999998899e-05, 0.021222077601730227, 0.11550170412731642, 9.999999999998899e-05, 0.03060018483685034, 0.004219740354987511, 0.03341403783082564, 0.08327280958850403, 0.07867356547363691, 0.1804992231390672, 0.07953653125095428, 0.06785180724972284, 0.03001269876209467, 0.11646711815501953, 0.09243867385491666, 0.11208937035605726, 0.07169930147579218, 0.09787435174593462, 0.029753382764023395, 0.055819256845380694, 0.13743072080153274, 0.04862973536768678, 0.0744238554731339, 0.10296997253916107, 0.052472449406712474, 0.13702077645534938, 0.161057442128838, 0.16952362093030038, 0.11749859161346554, 0.1058953497554237, 0.0853375378090081, 0.10451264631442359, 0.07338731943473231, 0.07294044109660047, 0.47865468987326965, 0.43641301334461025, 0.45451970851414203, 0.4682991952210571, 0.4390277846788587, 0.45052334853174647, 0.47257658203043107, 0.4851074261423842, 0.4930150669904114, 0.1254828684548398, 0.09709354257869329, 0.11772219449089572, 0.12799552858163188, 0.0940484703217106, 0.12988769036655978, 0.11839490543182496, 0.11142861791927627, 0.12175659589142218, 0.2521244792624211, 0.2136493202282953, 0.2361750689842642, 0.20266282879664954, 0.17219141823660244, 0.240954782812155, 0.16208401032619424, 0.15098216148507637, 0.16431118935258104, 0.34163006119225503, 0.23516628630849945, 0.35743887286836085, 0.31746726143402515, 0.2582044618653093, 0.33999560417480257, 0.34550157946830995, 0.37606404386406034, 0.32176586257363315, 0.2869682299006733, 0.27552900749906617, 0.23370170058739193, 0.2631102775216215, 0.20778303406445442, 0.2848027841280395, 0.26123875947718056, 0.28229706448578484, 0.20210169494055696, 0.20198952008170878, 0.1948560058855504, 0.22252938681639778, 0.20165636980565116, 0.21030226933144436, 0.19855541822068323, 0.21755966757723766, 0.20663939720778712, 0.20444898979760473, 0.1935930390016184, 0.19435766977663615, 0.19028553572370044, 0.3798775440172413, 0.19615085857998404, 0.1889803539452778, 0.19263726913239854, 0.19811140777420533, 0.20781125640819298, 0.7056351335006017, 0.6790345590583029, 0.5458237583211423, 0.6940913984379233, 0.19716475160759683, 0.6217488019624222, 0.6041475478737975, 0.6672930715737146, 0.6760075258931999, 0.5438512631028904, 0.20524937377205266, 0.1931064490618165, 0.5474423668906991, 0.1533341552291455, 0.4223262286705526, 0.20535603204940767, 0.47350865393359376, 0.1987053359373846, 0.18562557219405917, 0.18366992859741982, 0.19253592802448916, 0.18640161010183542, 0.18358669349712486, 0.21815038169645007, 0.23560129774695893, 0.18965149771470924, 0.19562281676145543, 0.09580177054728267, 0.09100927921522739, 0.08864922966826416, 0.08341273744853173, 0.08675064723114378, 0.08266312534867215, 0.07877506603519013, 0.08938468788700049, 0.09007448524365302]}, "mutation_prompt": null}
{"id": "a79094dd-0334-4196-a503-48a6ecd48846", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                # Opposition-based learning\n                if np.random.rand() < 0.2:\n                    opposite = self.lower_bound + self.upper_bound - self.particles[i]\n                    opposite = np.clip(opposite, self.lower_bound, self.upper_bound)\n                    opposite_score = func(opposite)\n                    evaluations += 1\n                    if opposite_score < score:\n                        score = opposite_score\n                        self.particles[i] = opposite\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                chaotic_inertia = 0.5 + (0.5 * np.sin(np.pi * evaluations/self.budget))\n                self.velocities[i] = chaotic_inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = np.random.uniform(0.5, 0.9)\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "Hybrid Adaptive PSO-DE with opposition-based learning and chaotic local search to enhance exploration and escape local optima.", "configspace": "", "generation": 27, "fitness": 0.27058494094497865, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6855410092524727, 0.6591517303117707, 0.6434366675103356, 0.6588158813867984, 0.6493944846984452, 0.5899810543176517, 0.614231198468352, 0.6792112192718188, 0.7415441364083789, 0.3286040154292508, 0.2935428595501849, 0.41034561746427134, 0.2866931891489447, 0.2387746058424337, 0.33211339503024906, 0.39154772266047677, 0.2520040026674504, 0.2686968038137788, 0.166086133985213, 0.11378898975699758, 0.1255117690068981, 0.15127326833382082, 0.11672837757657673, 0.10416421228344674, 0.1528575327914088, 0.3312297772207716, 0.14006813363153192, 0.12310634469515336, 0.10968476437714614, 0.11759990128200404, 0.10007443339194966, 0.09622748725857966, 0.13342062935542343, 0.13435659452587057, 0.11590940328023824, 0.10460539901160204, 0.9539633944240483, 0.9752121598766654, 0.9669859971310177, 0.9714971629812433, 0.9660359379127921, 0.9705643861042472, 0.9707199619880637, 0.9566594666519314, 0.9651161701931674, 0.41577392231290555, 0.3868732880738206, 0.3086285926857587, 0.43137547186902936, 0.37820392136371606, 0.4285099814891128, 0.31397865097109456, 0.3701828418519255, 0.4170932026222558, 0.8019832848066272, 0.32208527901788353, 0.330439926130089, 0.3435319644960987, 0.27305745167517115, 0.2099230012636295, 0.23030501812351567, 0.48215918115031686, 0.22476984477349748, 0.18522619484911407, 0.16216395866883193, 0.10973980894406343, 0.1687184861573905, 0.158079167121827, 0.3379531667366611, 0.186242762115578, 0.1924117008921037, 0.16942448700793888, 0.1594412312316621, 0.14674666374388579, 0.3051968874710921, 0.23197026699845935, 0.18297909794309142, 0.2236322399261047, 0.17438385949392754, 0.2319317154707582, 0.11073513120894729, 9.999999999998899e-05, 0.0027552447939448443, 0.002293931685323547, 0.030044100672724006, 0.006062959712582083, 0.08608418261714346, 0.053358228825140186, 0.012665324690731339, 0.026297118899324734, 0.19577699030485274, 0.04655020127229259, 0.17802899829579277, 0.08174849651156568, 0.025416112910480293, 0.01671296972970815, 0.06126378429221546, 0.11553495551473425, 0.08733191445477584, 0.035198263244824224, 0.029146397775172916, 0.08974322408302338, 0.03624785206933523, 0.07397900998060936, 0.07397187383262482, 0.10644643372346241, 0.061461252669503974, 0.14770541459702435, 0.11973037988712565, 0.1321116644069409, 0.11888067619632825, 0.18801942486259138, 0.10426700628157926, 0.12642245892339, 0.1016490863564472, 0.16147645930641097, 0.08373122232781371, 0.5222789826538795, 0.44748372480128806, 0.49265622693563316, 0.46106715491838035, 0.47568092607619006, 0.45964792585499503, 0.5132645643408191, 0.4315919346142201, 0.4874102575804402, 0.09832587012176408, 0.11705856345192356, 0.11718496360614516, 0.12036964558148122, 0.09773568315107573, 0.2286546079258036, 0.10803686808653035, 0.11586252490380922, 0.10962648538886355, 0.159521178397509, 0.1408408108436704, 0.15523785525914136, 0.29184421659930215, 0.17725959821977233, 0.1520260088783998, 0.1709038306642775, 0.2206957951047701, 0.15296847715647377, 0.36815208837440916, 0.32483740082524826, 0.3586715192263187, 0.32008074509601636, 0.2978699452996826, 0.377833654505894, 0.36401021648682186, 0.3958295688717205, 0.3742087204503468, 0.2301474515166475, 0.234875856012554, 0.2478607122670171, 0.3010907427889593, 0.2680119898230736, 0.284155445426883, 0.19066124815557484, 0.2519839617085302, 0.21426272802419288, 0.19974435411877633, 0.22368468580846923, 0.23745899190744246, 0.19096986613826128, 0.2005969293363058, 0.20873720700398057, 0.24501199594006462, 0.1946202235201424, 0.2136952667244394, 0.19745013662395505, 0.19546463014113724, 0.2035269221337047, 0.4153184212764862, 0.2155706068197002, 0.28087258150765027, 0.20586115614898415, 0.19144963531455805, 0.18752903085396833, 0.19245258906510054, 0.184185234883686, 0.18756666928217347, 0.8398212999674032, 0.19958846815390652, 0.5110099628351663, 0.5476760691955784, 0.1589270175249904, 0.7021077734843041, 0.5581824069629255, 0.20783360211639634, 0.5486620933908488, 0.3426551914072611, 0.20021495922653754, 0.38467711429354157, 0.16080484042766785, 0.561642266335554, 0.3531367585676408, 0.19589739158568287, 0.17187660745583977, 0.1818841199893213, 0.19066232842066788, 0.18233635843580376, 0.18686379189641977, 0.18409740541243091, 0.21247137641792302, 0.2028432022372152, 0.06872703733683372, 0.08957908543398863, 0.06499526310131609, 0.07308607355544938, 0.08087641553051272, 0.07679083611959125, 0.07201559228431065, 0.06931226046768502, 0.0824038153929394]}, "mutation_prompt": null}
{"id": "ff9d7055-e3df-4f1a-9003-ea6cd0d04d11", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "084aa66f-b678-4b15-be8e-ec810c2bca16", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "07bd635d-e1a5-424d-a297-de855557d90d", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1, self.c2 = 2.0, 2.0\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            cluster_count = int(1 + progress * (self.population_size // 2))\n            kmeans = KMeans(n_clusters=cluster_count)\n            kmeans.fit(self.particles)\n            labels = kmeans.labels_\n            \n            inertia_weight = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    cluster_indices = [idx for idx in range(self.population_size) if labels[idx] == labels[i] and idx != i]\n                    if len(cluster_indices) < 3:\n                        continue\n                    a, b, c = np.random.choice(cluster_indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedPSODE", "description": "Enhanced PSO-DE with adaptive population and mutation strategies, leveraging clustering for diversity.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {}, "mutation_prompt": null}
{"id": "a09b9587-b2e5-4d45-aec4-8fa806cd82c5", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "45ff61a4-9028-438e-bdb0-4e66738a6925", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "1a4a61fe-ddb7-4eb0-a472-731f4f20be06", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "5326da78-3c10-4dd0-9636-51ae87a3639b", "solution": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 45  # Adjusted population for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with adjusted dynamics\n        self.c1_initial, self.c1_final = 2.0, 1.0\n        self.c2_initial, self.c2_final = 1.0, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor = 0.9  # Enhanced DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with stochastic velocity adjustment\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.random()  # Stochastic inertia component\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Adaptive neighborhood-based DE mutation with stochastic selection\n                for i in range(self.population_size):\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    a, b, c = np.random.choice(neighbors, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 + 0.1 * (self.gbest_score - self.pbest_scores[i]) / (self.gbest_score + 1e-10)\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "ImprovedHybridPSODE", "description": "Incorporate an adaptive neighborhood-based differential evolution strategy combined with a stochastic velocity adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.2986416740345723, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.8296801037482983, 0.8404685849211264, 0.7892854376565029, 0.8038998253898025, 0.8472133514113624, 0.757291685225629, 0.759759505919869, 0.8488646992261113, 0.8240586959282107, 0.4874730420569643, 0.5972457875079953, 0.6044924764090442, 0.5164264991297438, 0.21597617527034152, 0.6088618856447314, 0.5334594660375988, 0.7072376687552602, 0.6320316976740814, 0.15417721531142092, 0.10282666689346553, 0.13908806344940072, 0.13951879832753278, 0.10938926016598782, 0.16489558905374613, 0.1733390566979095, 0.1600888424222443, 0.1129867249409574, 0.12266833324244164, 0.13550968389883133, 0.13616216865895825, 0.1297471680236122, 0.11079333220743104, 0.11167828561130178, 0.10191744872341901, 0.13769579623309514, 0.10013931891490813, 0.9785506485866675, 0.9353837043528479, 0.9632820593050623, 0.9758044883889443, 0.9580458710380471, 0.978119754126283, 0.9721703287580772, 0.9617985120866428, 0.9700420491087612, 0.6477229518785981, 0.17741101275521376, 0.5657072599293783, 0.6596308316197474, 0.6342877137117826, 0.5728294805079286, 0.5510915788299495, 0.5353397708131755, 0.6505730594747471, 0.8217243879512726, 0.3925417124467854, 0.7720798840819866, 0.21064598830287773, 0.18987489940187907, 0.2716308189506702, 0.7263776923539098, 0.17888669210103236, 0.2098527966470637, 0.2698179835897324, 0.1780542538503863, 0.1750413059767969, 9.999999999998899e-05, 0.17533020970856683, 0.2516218201067981, 0.11781981369438632, 0.17122409478401912, 0.16852111488250843, 0.22139643894122873, 0.2061206127080848, 0.1776245551851755, 0.12457984965759206, 0.15896002787079966, 0.22064581659121119, 0.2302081785230371, 0.12692113583780118, 0.11503689577000953, 9.999999999998899e-05, 0.010156148914464591, 9.999999999998899e-05, 0.043886902145089834, 9.999999999998899e-05, 9.999999999998899e-05, 0.027654087912434955, 9.999999999998899e-05, 9.999999999998899e-05, 0.09444602199952445, 0.09061140346913876, 0.10392445841237408, 0.07234210424793508, 0.017340864847024573, 0.03016856019808767, 0.04684600382092252, 0.14155904168919642, 0.0465036120421386, 0.11233526594852261, 0.035285962308821084, 0.05771489456834589, 0.07339952230484559, 0.10291405655780106, 0.07118051816242255, 0.36764600472421827, 0.16130737817060903, 0.21801080101653492, 0.11595681560894122, 0.07150805231536328, 0.09379727450889819, 0.07205829100642203, 0.0482193544347036, 0.18858462304598866, 0.12532619631738673, 0.12368731927021726, 0.07972540528477823, 0.5932319086903025, 0.5435886444830715, 0.5243082889848942, 0.543130904497894, 0.5111386356556511, 0.5158659608604949, 0.5278773015493083, 0.49489866628438817, 0.5373157319315147, 0.13117935969301198, 0.1132242049421115, 0.11416823578902435, 0.07698458979087186, 0.12701215933796484, 0.12006002039941488, 0.10778865006243943, 0.15047696274173883, 0.08013661464223021, 0.1663847386170222, 0.20344692784754903, 0.21170638421195076, 0.32869017753573626, 0.2677645493287164, 0.17517266013428157, 0.20658970567792045, 0.17260770389947044, 0.2642450656300195, 0.3772656143246993, 0.3030595306245578, 0.3095575550181072, 0.33277149082069624, 0.34217841668092475, 0.40331102543763075, 0.47874337902932407, 0.4451915758309871, 0.4825934801007057, 0.23269800191432755, 0.24077971579251367, 0.324674113097672, 0.286636880026943, 0.19818188408085813, 0.2899234923190579, 0.2473482947707477, 0.2753674261423358, 0.26718240947557526, 0.21879570175583019, 0.26995246231542, 0.23223671252897304, 0.204994511352231, 0.22705714896780216, 0.21749310674862576, 0.2531772857739861, 0.20322633595107387, 0.21763287777146822, 0.2049851125763985, 0.20981955632613514, 0.18577828913357064, 0.21226497995733118, 0.21103160704498547, 0.23411688762382588, 0.2245083405024073, 0.20926551824922845, 0.19649663797499883, 0.8431381631464631, 0.16761383026715992, 0.1535944590300905, 0.880324322272254, 0.20105345689870835, 0.19834499103447512, 0.14170384731610597, 0.16954505237081796, 0.8557206786164091, 0.6080576734964942, 0.21134956901496182, 0.2109735726723725, 0.2094324930609881, 0.1680427069746856, 0.14781853424184233, 0.20731143662031415, 0.8029699976214616, 0.15355651183185315, 0.20405571148931967, 0.18320576103362207, 0.19990958906913814, 0.20223055472161433, 0.19683488483024592, 0.1859483187781319, 0.19812467213948626, 0.21258466227273953, 0.17864316430368476, 0.1145681964481251, 0.10130688843251012, 0.09372531361291114, 0.08901820129777172, 0.09434438696450675, 0.09402145294424558, 0.1266866513359235, 0.09472823075551118, 0.08534620215978006]}, "mutation_prompt": null}
{"id": "a21f7681-bae1-4ba8-adc5-9f067b8b445f", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "3725e7b1-5c2c-429d-b170-f2b8fc1941e8", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population size for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Chaotic maps for parameter adaptation\n        self.scale_factor = 0.8  # Chaotic DE mutation factor\n        self.w_max, self.w_min = 0.9, 0.4\n        \n        self.chaos_factor = np.random.rand()\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Chaotic parameter adaptation\n            self.chaos_factor = (self.chaos_factor * 3.57 * (1 - self.chaos_factor)) % 1\n            self.w = self.w_min + (self.w_max - self.w_min) * self.chaos_factor\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for PSO with chaotic inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = 2.0 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = 2.0 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with chaos-enhanced selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.7 + 0.3 * self.chaos_factor\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm using chaotic maps for parameter adaptation and diversity preservation.", "configspace": "", "generation": 36, "fitness": 0.1556766363703643, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.3213177151856337, 0.34415382740088585, 0.3010408961546097, 0.2649474248093815, 0.28845988090715313, 0.3604639643350238, 0.27406965654589965, 0.2807619735765372, 0.26626366446530947, 0.0032034638630072942, 0.0141730719895371, 9.999999999998899e-05, 9.999999999998899e-05, 0.00844123930491536, 9.999999999998899e-05, 9.999999999998899e-05, 0.02424450552994417, 9.999999999998899e-05, 0.06782278269067266, 0.03751032827734979, 0.06573060433545796, 0.053673135539627936, 0.06940396442278707, 0.08664889997998249, 0.07183797606547282, 0.09801707576843544, 0.05335571352232438, 0.04070229526446112, 0.04407843133191769, 0.0748663705834055, 0.06949357319012084, 0.060522153835980474, 0.06698865787981689, 0.07062919104147491, 0.07745416621957324, 0.08179508165717175, 0.9852005669723208, 0.9768114182980131, 0.9754989556495323, 0.9660699761354782, 0.9774785624272925, 0.9679053376364823, 0.9860205381323787, 0.9775686406982648, 0.9688354329254178, 0.1341509156662447, 0.1964757434949077, 0.05349774390419515, 0.12393236716052047, 0.12214149942989039, 0.1105632547337384, 0.0873172622610704, 0.08741402560028821, 0.1549746166467827, 0.19313262317884505, 0.1345346764366373, 0.14936952145292504, 0.19042611281895228, 0.1700958331328042, 0.1821347897328517, 0.14557033692134846, 0.12886128057371737, 0.21816084854594386, 0.0885385464326579, 0.08995832350917354, 0.004658226594825066, 0.04312859282474002, 9.999999999998899e-05, 0.07865395568824174, 0.07229098914611509, 0.09913900341174464, 0.06668135472643921, 0.06700088996189846, 0.07916463723393641, 0.06183944926903373, 0.046547458694645494, 0.08606916596285186, 0.08809329534815913, 0.0760109507122595, 9.999999999998899e-05, 0.052384607319375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043157230382722456, 0.03758417460431318, 0.04818537635782627, 0.03920430738594238, 9.999999999998899e-05, 0.00011378551867824438, 0.06253802453178992, 0.044752014453131816, 0.04329988945404506, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02496660620253477, 9.999999999998899e-05, 0.027418465086633703, 0.012293524505316733, 0.04622090972263537, 0.04130732712859919, 0.03850956290823415, 9.999999999998899e-05, 0.0318879821275696, 0.2891201493806379, 0.29739220100665376, 0.27106250645796837, 0.18075811908413508, 0.30313279762527523, 0.27435400486373707, 0.2835242437640799, 0.26869139140207965, 0.2886172593888249, 0.08279922054698596, 0.08229799904133417, 0.06365736049454318, 0.0841273715615638, 0.06471366184921412, 0.06543065653760027, 0.06381674342790722, 0.055470799844960506, 0.07574086825450521, 0.1410695248627728, 0.2016307723816979, 0.1516419580017777, 0.1449340765343844, 0.13092997614939772, 0.1558920062814907, 0.1457110141605975, 0.21924318271488297, 0.1780502914926947, 0.2052086583413788, 0.22129085615409416, 0.21092215716094742, 0.18795166084882398, 0.20841635236485823, 0.18772724944974084, 0.21230490519196088, 0.24345673496806486, 0.2342776854187235, 0.15588966346912025, 0.1493826153651927, 0.16499487473362573, 0.1473402846542411, 0.16151232868057253, 0.13832448910939077, 0.14754362158867484, 0.19609602002662818, 0.1790642348224314, 0.1684515173986576, 0.19808320937226986, 0.20003935910160087, 0.17492204961512436, 0.16159342334796567, 0.19952575105927217, 0.18239706044893889, 0.17103641288246363, 0.16230770094439018, 0.16194098588981864, 0.1702227786604058, 0.1621226055995192, 0.1661053036159228, 0.14980826032099337, 0.1661076816295457, 0.15431821694076586, 0.1628467013974394, 0.17083444263741987, 0.15420037425838107, 0.1599175898614067, 0.14961945205880034, 0.2669656422371428, 0.19071240900517827, 0.1859205620685701, 0.135378306193071, 0.174989919278132, 0.4039355232830797, 0.21305127483156316, 0.1608813724665784, 0.15358783257258568, 0.12415424552981769, 0.1597544678576589, 0.1633859190209216, 0.1921614475321486, 0.1933594600355033, 0.19062023221376978, 0.18310217778125348, 0.18357093649238465, 0.17657143529332697, 0.19047037001162037, 0.1920403537436266, 0.19092537077905725, 0.19018427374448998, 0.18217237270438202, 0.1823623238374823, 0.06794838522731739, 0.0689658620106608, 0.0741666234467766, 0.06831316055764836, 0.07574227027630986, 0.06959825659694452, 0.07074926051966468, 0.07253555646888821, 0.06534723243308349]}, "mutation_prompt": null}
{"id": "9ee93e17-cdb2-47f7-81fe-493f7e2a5e1b", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for improved exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor_initial, self.scale_factor_final = 0.9, 0.4\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial - progress * (self.scale_factor_initial - self.scale_factor_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    trial = np.copy(self.particles[i])\n                    cooling_rate = 0.1  # Simulated annealing-inspired adjustment\n                    for d in range(self.dim):\n                        if np.random.rand() < np.exp(-np.abs(mutant[d] - trial[d]) / (cooling_rate * (self.budget - evaluations + 1))):\n                            trial[d] = mutant[d]\n\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "Adaptive PSO-DE with random search and annealing-inspired mutation for enhanced exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.2590612256511631, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.5961945864068564, 0.5592524721449232, 0.6296122711212181, 0.6244245378022646, 0.6114035665950772, 0.6053894950338901, 0.6192742129360984, 0.6443978285602592, 0.6417817651763721, 0.1796044902826539, 0.2964838582810164, 0.3504567672832808, 0.2681770184124289, 0.32269214151696757, 0.2979779896503991, 0.28495038345189183, 0.36977579468380894, 0.33922610560834565, 0.1169401038735266, 0.35223794860574364, 0.11769873226895267, 0.12118978012943749, 0.11461147051861387, 0.1339191090168259, 0.12756776323001318, 0.15031075734777, 0.13310781146895645, 0.10200271115040449, 0.10264195558572187, 0.10120912896616663, 0.11114630488301214, 0.0872363413406736, 0.09294973033902298, 0.08738421668210195, 0.1331926857844955, 0.12190285376724186, 0.9695234838798709, 0.9658771732040571, 0.959181587254632, 0.9704114039022652, 0.9648839864526024, 0.9642260152984851, 0.9629001804087751, 0.9634932575036627, 0.9596495269486107, 0.4244301273184544, 0.4725842161714, 0.34590875464616966, 0.4035571765285779, 0.39098331662715613, 0.43766353716691775, 0.3680524261930027, 0.3841931948139766, 0.3043213689655273, 0.5239044894658709, 0.6621376310393152, 0.3160898536818354, 0.2030051993008415, 0.24524507112745986, 0.25344851322938966, 0.47880398612791997, 0.21864021719442195, 0.5141995635343612, 0.17371516719451008, 0.13848383406722586, 0.13489647100902802, 0.1159251971707832, 0.14043009048882815, 0.16866453060053777, 0.17500830376861254, 0.1626079306759901, 0.17855549120385916, 0.10817786449904432, 0.16347745478900655, 0.1791854191986897, 0.1572695540618323, 0.21604174566267698, 0.16089012984160855, 0.18978147647968047, 0.0766425410190652, 0.16360822681014975, 9.999999999998899e-05, 9.999999999998899e-05, 0.016372913568128755, 0.00010176290689578593, 0.003496323463144324, 9.999999999998899e-05, 0.00014365061257581857, 9.999999999998899e-05, 0.038016840715521916, 0.07263500741786788, 0.10644583272086128, 0.10237669674314132, 0.10659535678960708, 0.05482490569523857, 0.058664124687408004, 0.12116735501842502, 0.13473022742814322, 0.061889040074696644, 0.019808277788346595, 0.023903988303596413, 0.07224336793498787, 0.04617492408202728, 0.041866079602976614, 0.046500142908623476, 0.05313451408022718, 0.10056781712295615, 0.0632129666407738, 0.08035385709082021, 0.15711035555955022, 0.11375503423139144, 0.07912416030429426, 0.21699541599451477, 0.08109774045783302, 0.07297898922705515, 0.08845066305596105, 0.07516953384098579, 0.5135801113051001, 0.4729348250324271, 0.46048725400523915, 0.4679280658996028, 0.4671850755327124, 0.45425237680371544, 0.47467329760086063, 0.4277734266737073, 0.4852022861922962, 0.1274752222587311, 0.08133317220715541, 0.10807148835202351, 0.13434304852307377, 0.12410195815779568, 0.1021768553847563, 0.12451673870118773, 0.1101242115354577, 0.08831837971575807, 0.206600104800011, 0.1899297741815853, 0.22906949924253983, 0.1850034566337071, 0.18418199053264983, 0.20652422517067448, 0.273629003883458, 0.15055650641442064, 0.162429216008794, 0.26544489851819886, 0.2903927370162255, 0.34014975287551874, 0.3776956607864468, 0.3075707752335063, 0.29032046115228527, 0.36249121473306556, 0.31626273709694985, 0.339139355021318, 0.2612017629682346, 0.23124191452216325, 0.22230876811088485, 0.24906830425860949, 0.1875970088709803, 0.2601195504575814, 0.24661164735764474, 0.23717946035550708, 0.23753110058713445, 0.21432849097190354, 0.23067982045271873, 0.19093895206030875, 0.22266857139277985, 0.1831412287253822, 0.21659229390375956, 0.2036328970548842, 0.214975976331223, 0.24981844461880298, 0.1911596113187266, 0.20003897359799794, 0.18720653209183735, 0.19307583936949058, 0.18834475749702584, 0.1887210854949284, 0.1849927859295014, 0.4528336217873974, 0.20129102256036835, 0.15253877572542462, 0.18229121803565373, 0.19745206898751533, 0.17463408302168448, 0.19594355023318122, 0.7195701016583043, 0.166248004546532, 0.6277117900324595, 0.6628451303097405, 0.6809212703538297, 0.20667259929201565, 0.18822044872876553, 0.6053478853298604, 0.16424394279340593, 0.45743996202543113, 0.19800256535036853, 0.44210979913701154, 0.19476982440309065, 0.1917533275907194, 0.19193642230346974, 0.189558441799222, 0.22487665659999034, 0.18810614078798393, 0.19401227146987576, 0.20159986383966688, 0.18186493203024334, 0.1794951388075524, 0.09192205226252448, 0.07781657061467906, 0.07947954809285818, 0.07151931288996871, 0.08982822435583204, 0.08999952056002603, 0.08708689683521353, 0.08466604849462767, 0.08626152302006485]}, "mutation_prompt": null}
{"id": "c2273626-eb2a-490b-a627-c7548753e3b6", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = self._chaotic_initialization()\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.9  # Adaptive DE mutation factor\n\n    def _chaotic_initialization(self):\n        # Using a logistic map for better spread in initialization\n        x = 0.7\n        chaotic_values = []\n        for _ in range(self.population_size):\n            x = 4 * x * (1 - x)  # Logistic map\n            chaotic_values.append(self.lower_bound + (self.upper_bound - self.lower_bound) * x)\n        return np.array(chaotic_values).reshape(self.population_size, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9  # Fixed crossover rate\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced PSO-DE hybrid with chaotic map initialization and adaptive mutation to improve exploration and convergence.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('cannot reshape array of size 40 into shape (40,5)').", "error": "ValueError('cannot reshape array of size 40 into shape (40,5)')", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {}, "mutation_prompt": null}
{"id": "fd772d93-21c2-4ad9-b9cd-68ee5b86a7bc", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "36bebc95-6791-4763-b288-b33b35b476c7", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population size for better coverage\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with improved diversity\n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor = 0.8  # Adjusted DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            elite_indices = np.argsort(self.pbest_scores)[:5]  # Retain top performers\n            \n            for i in range(self.population_size):\n                if i not in elite_indices:  # Protect elite solutions\n                    score = func(self.particles[i])\n                    evaluations += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.particles[i]\n\n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest_position = self.particles[i]\n\n                    if evaluations >= self.budget:\n                        break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                if i in elite_indices:  # Enhanced local exploration for elites\n                    local_factor = np.random.uniform(0.1, 0.3)\n                    self.velocities[i] += local_factor * (self.gbest_position - self.particles[i])\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    if i not in elite_indices:  # Keep elites safe during DE operation\n                        indices = [idx for idx in range(self.population_size) if idx != i]\n                        a, b, c = np.random.choice(indices, 3, replace=False)\n                        mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                        \n                        crossover_rate = 0.9  # Consistent crossover for robustness\n                        crossover_mask = np.random.rand(self.dim) < crossover_rate\n                        trial = np.where(crossover_mask, mutant, self.particles[i])\n                        \n                        trial_score = func(trial)\n                        evaluations += 1\n\n                        if trial_score < self.pbest_scores[i]:\n                            self.pbest_scores[i] = trial_score\n                            self.pbest_positions[i] = trial\n\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial\n\n                        if evaluations >= self.budget:\n                            break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive local exploration and elite retention to improve convergence and solution quality.", "configspace": "", "generation": 40, "fitness": 0.25978977555780886, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6343253221958101, 0.5977797934574924, 0.6302698715642874, 0.6253441141406486, 0.655840964109766, 0.6683394460721479, 0.6226561268727008, 0.6186176787790599, 0.579426118141212, 0.3447514783086253, 0.2658441370766895, 0.2872969670649774, 0.30503900998066824, 0.24394902865976464, 0.27507401075436133, 0.2993406357281344, 0.2328077283119503, 0.3185840287090641, 0.10365249832789925, 0.11408927678782399, 0.13270530964576888, 0.10719041115733785, 0.11589335833105618, 0.0981933443815649, 0.12947007779540876, 0.12312349656128974, 0.11527645296699551, 0.11557571001015998, 0.09476473622307335, 0.12284287034537589, 0.10245142958345099, 0.1027943060308919, 0.09592906815752189, 0.11216622391887254, 0.09184802102780776, 0.10658119782005537, 0.9611919158920492, 0.9691764219565876, 0.9700678246641067, 0.9554282716247816, 0.96818362908587, 0.9637285993879599, 0.9606581968347935, 0.9638240003159189, 0.9744440782213759, 0.36387417470980543, 0.41038700983047893, 0.37492329326515894, 0.41439411879941623, 0.3769259876479204, 0.43534993437392444, 0.40022188938153347, 0.3460912359913325, 0.45225153071004953, 0.5983003366156123, 0.21694044662059164, 0.30021753158963416, 0.5720812693935308, 0.25838434352654205, 0.5950390630629134, 0.2043388257296157, 0.3286756481876344, 0.3062949941570119, 0.19862271014806898, 0.1646590000594781, 0.15013084539427268, 0.18723890560347212, 0.15179045736031294, 0.16641899657213544, 0.14677377995829688, 0.130984817076217, 0.1827708343797958, 0.11644573388685298, 0.18194682528719486, 0.13647630520073417, 0.1265821043222104, 0.1669761346333749, 0.16431830979799267, 0.1598137715589686, 0.12734778564132754, 0.16766693417903022, 0.004625158788964967, 0.002542183405104703, 0.05134908249642811, 0.00043480788647809465, 9.999999999998899e-05, 0.004654420514833557, 0.00664695612514532, 9.999999999998899e-05, 0.017093072325865433, 0.09201005673556761, 0.09715960858278416, 0.08663732906517219, 0.04228699308287409, 0.029264750384290328, 0.012994977652866502, 0.07986732512780104, 0.07219354918423537, 0.08839769123480545, 0.014725196046556088, 0.02744478835182651, 0.03403877837936453, 0.08930529657269526, 0.06142095335188569, 0.046385165978042875, 0.04830771783965171, 0.055130911221853984, 0.11596981480304891, 0.11211451918567672, 0.09434831243866992, 0.12660250939427786, 0.07678189848560268, 0.12923766152491312, 0.17612733818356374, 0.19655014673897686, 0.12250183818087312, 0.09413116379901332, 0.4305559497605569, 0.4637532916530932, 0.44789275090243097, 0.5069104220592787, 0.47978883552926055, 0.4672351506949801, 0.47446750373760493, 0.45813475545847127, 0.4519661124678749, 0.08619785605105312, 0.13121628379941452, 0.1292894425410155, 0.11711828709884808, 0.11152348383175159, 0.11223175143078301, 0.09106519859637974, 0.10747891393489573, 0.12167849672555786, 0.19760007286521397, 0.16907554751890608, 0.16952760203487283, 0.24464901343889245, 0.1656641843592641, 0.15207474642954144, 0.20571350280484124, 0.15660736615872906, 0.15207624945173448, 0.28614520457408443, 0.29846480466175085, 0.32635497102257516, 0.28275966686688836, 0.3522419520744051, 0.3516317523069007, 0.30090943244613344, 0.31928968639637134, 0.32239067731596205, 0.23093093562199807, 0.2260956084983491, 0.21118535570256658, 0.19766960714600013, 0.2713615886252967, 0.23020120511946784, 0.30078590659448357, 0.2563919729411147, 0.210500102342968, 0.21159909461480875, 0.1942863544530372, 0.20219499770119798, 0.19024855920702644, 0.20401197828221473, 0.21023943982486604, 0.21647854832712632, 0.21556400311933033, 0.208573845236948, 0.4307471906659871, 0.21102176797979533, 0.19870120362674237, 0.1964967445966268, 0.22433009659259973, 0.3708960557100007, 0.1956984551865657, 0.1721974974468754, 0.18694471615509956, 0.6622485404263623, 0.18102779327518637, 0.44255040704563975, 0.631230787207613, 0.19538376757913956, 0.6783217498686596, 0.672595389571762, 0.15386385120193302, 0.6543510641171151, 0.12562232786846395, 0.16429220079951756, 0.1959135342027747, 0.5848930044179341, 0.1929452815783652, 0.34166745734777215, 0.20474727583268226, 0.5814229876056513, 0.2003066043393984, 0.1780161076457364, 0.1964442272078506, 0.1889465756605937, 0.20242396411465902, 0.1881515609756934, 0.18329689683660044, 0.19114887518240375, 0.19602209445552343, 0.1877929084672849, 0.0789029996741003, 0.08800914267608329, 0.09555453611203635, 0.08761915185503621, 0.08444210527306373, 0.07987270671853053, 0.07358068230662063, 0.08162371530792112, 0.08465045070628152]}, "mutation_prompt": null}
{"id": "bc1d7f04-5426-4dc1-8d49-60ddad8c5270", "solution": "import numpy as np\n\nclass RefinedHybridPSODE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1, self.c2 = 2.0, 2.0  # Simplified cognitive and social factors\n        self.w = 0.5  # Simplified inertia weight\n        self.scale_factor = 0.6  # Adjusted DE mutation factor\n        self.temperature = 1.0  # Initial temperature for simulated annealing\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Simulated Annealing adjustment\n                if np.random.rand() < np.exp(-abs(score - func(self.particles[i])) / self.temperature):\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.temperature *= 0.99\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE_SA", "description": "A refined hybrid PSO-DE with adaptive temperature-based simulated annealing for enhanced exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.1945089003990049, "feedback": "The algorithm RefinedHybridPSODE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.4093081589965605, 0.45165153683583714, 0.40174545255120675, 0.42811048185726264, 0.4368313840825132, 0.44109171935894875, 0.47650276671270964, 0.4547794989323045, 0.5226535699192942, 0.1012716772069252, 0.10238729284549097, 0.09732980909393951, 0.11549993750446352, 0.03074615970795691, 0.14240239928978093, 0.02676603843519243, 0.045423413858163064, 0.0022055771973795713, 0.08707698796170349, 0.10616956358674723, 0.07320869769756466, 0.08179226339288181, 0.09851654811913302, 0.11153489735907895, 0.11074822087386982, 0.12540073878364688, 0.11373531149641636, 0.07010289488732635, 0.099018818794268, 0.06628401956413876, 0.07541935130294608, 0.08683789354994664, 0.07704945425069509, 0.04936302120472569, 0.09509334933550417, 0.0899646626984435, 0.9649412880327752, 0.981753276084841, 0.9847293464721368, 0.9533550827840598, 0.9722582777784423, 0.9638256080546259, 0.9753862386060649, 0.9736290261676411, 0.9750498722236397, 0.22203768309274274, 0.2101446932754527, 9.999999999998899e-05, 0.25818711890781765, 0.1696883840290786, 0.24428336248588134, 0.1221886505097387, 0.20427753065156007, 0.20455102694615634, 0.20945039359546935, 0.30524272747711134, 0.21597687470441929, 0.20348196028869747, 0.11213422140560036, 0.19144262055656402, 0.15860164961514656, 0.23829965961762878, 0.21386401163980606, 0.1309639968536359, 0.13780403615873182, 0.1334442565279631, 0.0823240919592908, 0.11301319700845147, 0.11292207947624411, 0.10252605169962603, 0.13764410370342284, 0.12919438270235262, 0.12249759744805178, 0.11237737773489953, 0.1595319043686415, 0.15408511235560418, 9.999999999998899e-05, 0.13829442047753637, 0.1876909536581285, 9.999999999998899e-05, 0.11075621244519329, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00040139105913472584, 0.0014826233739846373, 9.999999999998899e-05, 0.03853703925806218, 9.999999999998899e-05, 9.999999999998899e-05, 0.0859713452957862, 0.036378914996687106, 0.08917930879408398, 0.07963516590861364, 0.08145461789446728, 0.000527362875081594, 0.03192478344500538, 0.044140828814846045, 0.05395116968059732, 0.015907222009662325, 9.999999999998899e-05, 0.022159862665468655, 0.055662043803568095, 0.03201254052310998, 0.004262101012763031, 0.06709968069932004, 0.0360541870892499, 0.02862276344457315, 0.0789364147339191, 0.01612874616946225, 0.06210450087939623, 0.005170479162492803, 0.09661850346742396, 0.05027247491470277, 0.06006652363324683, 9.999999999998899e-05, 0.06756169659313493, 0.4046232374464517, 0.3774625791881415, 0.3625548445636566, 0.3929586020194089, 0.3863391791507602, 0.2047045410110251, 0.3913059218525453, 0.35223297084027017, 0.3901384568144335, 0.07572223932440725, 0.10621005785502224, 0.08344185836967266, 0.0797005181986582, 0.09965541528874111, 0.09597546799803836, 0.07581312148349895, 0.08590433682562648, 0.11220862179795854, 0.20157754885761314, 0.1384353976545999, 0.16607964493298966, 0.195602765282066, 0.22813804243782299, 0.10389332183177336, 0.2981342764628654, 0.14573283585226948, 0.1916770859589385, 0.1662167460474071, 0.2213422980934916, 0.29395942312407264, 0.2271321785606304, 0.2835100686254949, 0.26128040275700837, 0.24378674241189469, 0.32484157722155127, 0.18709532813666507, 0.19928715121819496, 0.1833292857058324, 0.2137384451086376, 0.1758814302166818, 0.1901054721046077, 0.14166110811116372, 0.21217696349376258, 0.22461614418340348, 0.1704662867294372, 0.1954943832278695, 0.17984861704218402, 0.19140854921201778, 0.18599415537276787, 0.17891820505610834, 0.200064728990073, 0.1816504652722496, 0.20473899180591348, 0.20061875077076374, 0.20751222259429225, 0.17981999108787206, 0.1722388488421095, 0.19210655669818832, 0.13518136802351055, 0.1829783888041766, 0.19334902667524334, 0.195469365348663, 0.17910507707850665, 0.6065793914891842, 0.38620914604191825, 0.14927491552476135, 0.6447813938163021, 0.19457099677592626, 0.1309703521166673, 0.14028386412057792, 0.16630763054807463, 0.4255754099914635, 0.35997326472606905, 0.1918512679017128, 0.17237394242634707, 0.1902246006153111, 0.23068197175924043, 0.15470727629146952, 0.10304006961815848, 0.1915888282485173, 0.29831680016213413, 0.17918528458713423, 0.18481753934071743, 0.2033390330581516, 0.20202054882508802, 0.19296928741524522, 0.18513789597010288, 0.17056878500327566, 0.1816656866325692, 0.20558760778372887, 0.069214937932216, 0.07754933208561343, 0.07769743914179417, 0.07771947410399749, 0.08275496263346505, 0.06931175235299492, 0.12011324390118183, 0.07392453169306135, 0.058688167475502095]}, "mutation_prompt": null}
{"id": "401ce599-794c-492d-97d5-a803ff0d5183", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "3e5ae2fd-4f9b-421f-a227-745a4e829453", "solution": "import numpy as np\n\nclass QuantumHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Slightly larger population for robust search\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor = 0.6\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Quantum-inspired PSO\n            for i in range(self.population_size):\n                quantum_wave = np.random.uniform(-0.3, 0.3, self.dim)  # Quantum potential well\n                cognitive = self.c1 * r1[i] * (self.pbest_positions[i] + quantum_wave - self.particles[i])\n                social = self.c2 * r2[i] * (self.gbest_position + quantum_wave - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Randomized local search within DE\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    trial_score = func(mutant)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = mutant\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = mutant\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "QuantumHybridPSODE", "description": "A quantum-inspired PSO-DE hybrid with adaptive quantum potential wells and randomized local search for enhanced exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.1790580376800753, "feedback": "The algorithm QuantumHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.3336761605334032, 0.30751491195393466, 0.30203432886074144, 0.3264730273755678, 0.3265016264219134, 0.3155539791770847, 0.3069893628224545, 0.30042464398711355, 0.32448168070986616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016533235655422307, 9.999999999998899e-05, 9.999999999998899e-05, 0.00972239054097157, 0.011747360963626163, 0.00336467419294062, 0.07637581592478526, 0.09064370473332706, 0.08304084669960754, 0.08786104939542072, 0.08927519525253813, 0.09496928520946835, 0.09578150639978522, 0.09843039831404443, 0.08466182740317685, 0.08198538728622518, 0.07181568342369282, 0.08160533179068552, 0.08046970027543776, 0.07357991684391763, 0.07214940446961338, 0.08450473200454056, 0.08056307104032734, 0.08413488782906042, 0.9678405410535619, 0.9586887673763304, 0.9645890614351001, 0.9518030938639249, 0.9615609684160733, 0.9672993813321, 0.9646220351778314, 0.9676932245798459, 0.9645326610787046, 0.1846743481359131, 0.1906382821304743, 0.18828900556784434, 0.18057565821042987, 0.19423156593969615, 0.2140956876421517, 0.19870629975020948, 0.17763430388224732, 0.17253876047686534, 0.21616274259748802, 0.26742653151620366, 0.21798719272046907, 0.24823740379272508, 0.2242848946615288, 0.25848466011595495, 0.2125306701889016, 0.20973042576367218, 0.2206471295550012, 0.10593147063344788, 0.0846908717838607, 0.06998163808011437, 0.11595175263925417, 0.11014225071398542, 0.0650138674313544, 0.0942538791109151, 0.10609045839718279, 0.10746365373049682, 0.07831781950634209, 0.10864247623953271, 0.1114017402232097, 0.11338303250733028, 0.10850803294896227, 0.10363202970791696, 0.10412738111914766, 0.07832970016667584, 0.12257329449499343, 0.002813561833374112, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005285151466730698, 0.0055332246389809825, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0782361954904971, 0.05066891395419115, 0.05925172325425443, 0.08455446070074779, 0.09340165371782516, 0.04166744813231127, 0.06311134868681512, 0.1069038204172632, 0.07637323845021327, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04661494986307613, 0.04496631601188217, 0.04427932426151415, 0.053087419286483195, 0.052694303374571594, 0.05734318770229352, 0.04017965448970828, 0.04264000840192783, 0.03450560647046674, 0.3137098836390012, 0.29684615082659893, 0.3450931258590435, 0.31634137651406846, 0.3093771441076587, 0.30229142701730605, 0.3194511692364985, 0.29761073639697766, 0.32221008667941176, 0.08668715476627964, 0.09279380914588709, 0.0799776965251685, 0.08170321537934144, 0.0942158398667301, 0.09245540793322671, 0.08974875788089542, 0.09557304405239975, 0.08332852794932477, 0.14907350752877124, 0.16958584634876173, 0.13757178218794686, 0.1896846846134883, 0.1539634853213494, 0.15420432519375704, 0.14153208184390131, 0.17456117088210155, 0.13913336141213206, 0.22316527232669492, 0.22484951365587535, 0.25147626421678837, 0.23968399349164593, 0.24244768167795117, 0.2254235002128615, 0.22890757330630507, 0.23778425565575212, 0.23360839477019046, 0.16196072714814658, 0.1711594047757029, 0.16588161305760474, 0.16746542624052163, 0.16993559404827252, 0.17461699646208473, 0.18314446712604626, 0.17646973325003978, 0.179054269936049, 0.19767377909193862, 0.2010363355611896, 0.20733083752239034, 0.17607463700399184, 0.21327402338011747, 0.19853356247020915, 0.2037141142794915, 0.1905926812186014, 0.20121779075425106, 0.18617874661963518, 0.18476678006763603, 0.1743411156862763, 0.18704321022975112, 0.18242182280426755, 0.17502461937346214, 0.18652570098137444, 0.18049699800131025, 0.17249152310482518, 0.34971974389423144, 0.17712316984901666, 0.16897565824660743, 0.3912321451577031, 0.1859892379898832, 0.16419440704848787, 0.16598525491275473, 0.16880634333432476, 0.35180965866831015, 0.3867419902320639, 0.20097111720325633, 0.3318635686040985, 0.30227066509133327, 0.14900160068899881, 0.1488702653062548, 0.2005367253352689, 0.31228654760569907, 0.3152664653380399, 0.18804150319909063, 0.1813103679234218, 0.188232367094895, 0.17564527644444206, 0.18876666502365502, 0.1870848677035981, 0.1899896995468423, 0.1760648643808429, 0.20319599785729558, 0.08146856126974211, 0.08995872621118883, 0.0748658848379653, 0.07470145334415101, 0.07960390293556063, 0.08065386236504124, 0.0712994286292864, 0.07886518191866798, 0.07848455691523015]}, "mutation_prompt": null}
{"id": "4d7d53bd-cff0-4012-97aa-9d07b589609d", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "16b8da91-7482-48d2-9aa0-88dab1344a43", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_sequence = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1 = np.random.rand(self.dim)\n            r2 = chaotic_sequence\n            chaotic_sequence = np.mod(4 * chaotic_sequence * (1 - chaotic_sequence), 1.0)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_mask = np.random.rand(self.dim) < 0.9\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced PSO-DE hybrid that incorporates elitism and chaotic sequences to improve convergence and diversity balance.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (40,) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (40,) (5,) ')", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {}, "mutation_prompt": null}
{"id": "f156d4dd-604c-4ad2-9e16-b4c834951315", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "fea609f5-7037-49cc-8903-6e2a99694df2", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Further increased for better diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Introduce chaotic sequences for parameters\n        self.w_chaos = np.random.uniform(0.4, 0.9)\n        self.f_chaos = np.random.uniform(0.5, 1.0)\n        \n        self.scale_factor = 0.8  # Adjusted DE mutation factor\n        self.c1, self.c2 = 2.0, 2.0  # Use balanced cognitive and social components\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Update chaos-influenced inertia weight\n            self.w_chaos = 0.9 - (0.5 * np.sin(3.14 * evaluations / self.budget))\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for enhanced PSO with chaotic inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w_chaos * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # DE mutation and crossover enhanced with chaotic mutation rate\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    # Use chaotic crossover rate\n                    crossover_rate = 0.9 - (0.4 * np.sin(3.14 * self.pbest_scores[i] / self.gbest_score))\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE approach with adaptive mutation and chaos-based parameter tuning for improved exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.19244753836401374, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.4614977345959682, 0.5329054811491984, 0.4960048277791119, 0.443766203251157, 0.4394079572415607, 0.402066276341403, 0.37552827849419357, 0.5494549240758089, 0.4157961344048141, 0.023068125520325555, 0.02143311019181926, 0.17527966611981483, 0.028797969120706646, 0.1597451587477482, 0.18283598200585693, 0.02891491753424047, 0.16905228292192587, 0.17945341820069194, 0.0818811062416005, 0.09432756600864523, 0.11428523852916828, 0.07832836021960499, 0.11210371308686662, 0.10333599698047835, 0.0993726772454413, 0.13112955992393294, 0.1026855474572379, 0.08623420472560883, 0.09852339950579081, 0.11921975708302401, 0.07978411667308283, 0.08013383790492568, 0.1016901198796637, 0.08767295367496686, 0.12309269393815014, 0.08505463044057993, 0.9765337716418122, 0.9672602839777767, 0.9861525480576027, 0.9859106682663173, 0.974759097561679, 0.9687419453306635, 0.9760086902698603, 0.9764254143057092, 0.9794970579804823, 0.19521193034609796, 0.20943843997739797, 9.999999999998899e-05, 0.19521445838662865, 0.20762050587453662, 0.13771785731377295, 0.18843945955503472, 0.17140321140238357, 0.19254819844499493, 0.1967439906159799, 0.19538175320479256, 0.2596683064650983, 0.18319708860896067, 0.4787350089552538, 0.19269241191515163, 0.2544687575954413, 0.2221415670857203, 0.3985408914373043, 0.09910457678921125, 0.0803522023296227, 0.07489521688692935, 0.08590240159378804, 0.13399319340664884, 0.12463856469598611, 0.20587423777689784, 0.14208392337044773, 0.12329639374535584, 0.09578215312215399, 0.020576901965956296, 0.09171069287505484, 0.10787967184088554, 0.08120281306635901, 0.12007640809950604, 0.10321072511257257, 0.024641105476389202, 0.09145417430515468, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035517461087624103, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05014766153696548, 0.08919664138422834, 0.08936492837682197, 0.08104166478365227, 0.0022798813551025976, 0.0359796665801827, 0.05443896169016571, 0.103533998083714, 0.020480208550456735, 0.016670477850589616, 0.013356105591713296, 0.017677689749400094, 0.04021211453099749, 0.058609510630411976, 0.024117394125458325, 0.025292194227583553, 0.034162342388708966, 0.021189136716510237, 0.007061406354528121, 0.02995848702548809, 0.07661651301430905, 0.004131563619779843, 0.04407108256143433, 0.004248106698516718, 0.0454227804439824, 0.06473488163686747, 0.07839726788060364, 0.38985873991026443, 0.3918337704074579, 0.35896725491790527, 0.35605887534780867, 0.37867714763088967, 0.20320174135542224, 0.3793156418000193, 0.3607466017029055, 0.367834453265634, 0.07442577465940392, 0.06456791604354295, 0.08583301573563362, 0.10188963726202582, 0.0827624053937217, 0.09097366995867784, 0.0627250438502246, 0.07239236938914728, 0.09322619015718936, 0.16123801534288162, 0.21097581227358086, 0.2186186327403229, 0.2191818764318464, 0.1852581371168227, 0.16146615948529885, 0.17621862437425184, 0.17851222104996523, 0.17566439406504264, 0.22190892154709652, 0.26710717545106466, 0.25877395036007766, 0.23032090843911612, 0.1997661755551975, 0.267517976809874, 0.24072439679630087, 0.2906267861548556, 0.32065232203467575, 0.17365153766693842, 0.2063502635036194, 0.2056480223498247, 0.2063494045337836, 0.16651211624310436, 0.14792014513574703, 0.18875290512447274, 0.2076571910911046, 0.19685730902146958, 0.1793451126588187, 0.1452039486586988, 0.18435479800244137, 0.19950721374747926, 0.20124967900742707, 0.1924836072539563, 0.17709830464447163, 0.18375002184282607, 0.18323470163719935, 0.17441402779655601, 0.19510008246396726, 0.19096999198886044, 0.16760576047085285, 0.18640204065011123, 0.17349074994740565, 0.16782600479511944, 0.20604825185908437, 0.1712152433979427, 0.23272483198804483, 0.15374506707272906, 0.14753088068710618, 0.5949049571751441, 0.1907970073268298, 0.1271178402144829, 0.13495919154959757, 0.15096745393028776, 0.1967386289523395, 0.2550171358826032, 0.2067312428920216, 0.1866131491773969, 0.3780901549852491, 0.16478724917573995, 0.14009297915228036, 0.19019522693238555, 0.19520455501777456, 0.1473526392959158, 0.20883457473077383, 0.19557677348791813, 0.18335988371269418, 0.19911063623000713, 0.19976055088486355, 0.19311423743642875, 0.19244252336414813, 0.17908761708216514, 0.20328942503926983, 0.06872366937951524, 0.07031903402597417, 0.08038338878885243, 0.07233697879971224, 0.06870946065220873, 0.07724373628641823, 0.06956710885990125, 0.07531610691026491, 0.08126420749106966]}, "mutation_prompt": null}
{"id": "fd1c7f51-d705-46d6-981c-34dbffeb1d9f", "solution": "import numpy as np\n\nclass EntropyEnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        \n        self.scale_factor_initial = 0.7\n        self.scale_factor_final = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            \n            entropy = -np.sum((self.pbest_scores - np.min(self.pbest_scores)) ** 2) / (np.max(self.pbest_scores) - np.min(self.pbest_scores)) ** 2\n            entropy_factor = 1 + entropy * 0.5\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social * entropy_factor\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EntropyEnhancedHybridPSODE", "description": "Hybrid PSO-DE with adaptive inertia and dynamic learning rates enhanced by entropy-based mutation strategy for improved exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.04143573774803472, "feedback": "The algorithm EntropyEnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.11860917256239101, 0.08099573939876048, 0.0916041897440597, 0.09422175141959488, 0.06204510195655022, 0.07700439226565303, 0.07786194868253338, 0.07422043020494906, 0.06854154161076553, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.005275638633511659, 0.010544468052148481, 0.006493004426635474, 0.006570620486303191, 0.018150078853237717, 0.007693168839173259, 0.010575797721399605, 0.0, 0.0, 0.0, 0.019501673109847295, 0.00039528563299850994, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.042103638301774104, 0.04278205048616679, 0.05324558914821231, 0.04678013722708951, 0.037332462972904934, 0.06379241875032016, 0.048891644393723954, 0.03910579656890856, 0.06265423285317917, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.011194453811883442, 0.0, 0.1001868586914183, 0.03765971698870685, 0.05973037536276371, 0.06661749824786911, 0.027157688250799894, 0.0, 0.026181922062049168, 0.05921649636366422, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1087911925039956, 0.14247653223349865, 0.14829537673711235, 0.10270171191051303, 0.09699835892693354, 0.09571399605654951, 0.16104568613219816, 0.09707379230406277, 0.12096781838999726, 0.0, 0.0, 0.021886321886608107, 0.0325721299095072, 0.0, 0.01750168379108641, 0.0, 0.0, 0.0266683362656992, 0.07028246122685633, 0.08600231476351294, 0.11833361437130152, 0.09846289938816166, 0.10844057434014054, 0.056336845919289225, 0.08799080449358876, 0.08090029113184061, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.14344245626176422, 0.1379205218140116, 0.1137187550761597, 0.10435826762181499, 0.12019368026040667, 0.17369512487615557, 0.11374251144952918, 0.03803356537721447, 0.033911540361439396, 0.05454200626553962, 0.05686290050998832, 0.06397588396999376, 0.06333484497577468, 0.08364015581209883, 0.09968109929816105, 0.06403167692626888, 0.11934558904189418, 0.09379139630447497, 0.13336421106438578, 0.10280083939129603, 0.08643851306196992, 0.10887980745480186, 0.12237199858757541, 0.07863718186214741, 0.12610897469223925, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858711, 0.07457348599177205, 0.08157840845421893, 0.07318573935631267, 0.1207035396655618, 0.06652066617622099, 0.10692837481480588, 0.0963456876397184, 0.0692681884498908, 0.11031370369950688, 0.10258192672273359, 0.024737228551266033, 0.0505908534635271, 0.03728632333816162, 0.05893840155281016, 0.046808452164916026, 0.040094456074314055, 0.04133833534605069, 0.13471522306136396, 0.1282849674499068, 0.1475449842687161, 0.1159064692416708, 0.12243484664342741, 0.13224602528921636, 0.14961211855402412, 0.12496478658923194, 0.14680476350940785, 0.0070419849839145066, 0.015817976510868692, 0.03129662407793532, 0.02691798931623468, 0.03415436066354682, 0.019947514614564676, 0.01612999899170031, 0.011178756046734684, 0.01754558650804161]}, "mutation_prompt": null}
{"id": "73b64930-d50b-440a-a55c-76d3c3269e85", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial = 0.5  # Changed initial scale factor\n        self.scale_factor_final = 0.9  # Added final scale factor\n        self.diversification_probability = 0.1  # New diversification probability\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    if np.random.rand() < self.diversification_probability:\n                        # Randomly reinitialize some particles for diversification\n                        self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    else:\n                        indices = [idx for idx in range(self.population_size) if idx != i]\n                        a, b, c = np.random.choice(indices, 3, replace=False)\n                        mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                        \n                        crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                        crossover_mask = np.random.rand(self.dim) < crossover_rate\n                        trial = np.where(crossover_mask, mutant, self.particles[i])\n                        \n                        trial_score = func(trial)\n                        evaluations += 1\n\n                        if trial_score < self.pbest_scores[i]:\n                            self.pbest_scores[i] = trial_score\n                            self.pbest_positions[i] = trial\n\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial\n\n                        if evaluations >= self.budget:\n                            break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia, dynamic mutation factor, and randomized diversification to enhance convergence speed, solution accuracy, and robustness.", "configspace": "", "generation": 49, "fitness": 0.1980390402730524, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.4751987054618979, 0.36373050264408047, 0.3655070123340294, 0.41980210813791397, 0.35082727037998607, 0.4663077650073806, 0.5411869321687705, 0.47652515941191365, 0.3587555417697601, 0.06404611630939927, 0.02967363703424941, 0.021082174840057255, 0.03889462567456381, 0.019371769956434193, 0.03053056416329858, 0.03472927519712543, 9.999999999998899e-05, 0.11422044176901358, 0.10563747186396244, 0.09770018036068284, 0.07809307566528145, 0.09121171806004791, 0.07395640035957418, 0.09915454213444141, 0.1000070384718652, 0.08505179290926101, 0.08482755180370982, 0.0812651674572189, 0.07155198298908438, 0.07480744150265184, 0.06467994912094577, 0.08660700990357217, 0.09808229751514297, 0.0884755292978815, 0.06003802308958872, 0.08767170515148648, 0.9697364165407528, 0.9712147095734526, 0.9642410820312141, 0.9621466321948466, 0.9703091139768731, 0.9685187201017177, 0.9805759306680961, 0.966077344397372, 0.9681956312167566, 0.2140636736717907, 0.20365114453941824, 0.1855136508078552, 0.18866886463603216, 0.22655896399108622, 0.22629390498661273, 0.12088690772812061, 0.22584167115416454, 0.2515143900866621, 0.21588116151596348, 0.26590633478329584, 0.22169317248789167, 0.23297580774265525, 0.274603029062205, 0.17458263408825347, 0.1856342058425936, 0.276236956825502, 0.2061746258610052, 0.21176133145650755, 0.12460402469167275, 0.13146460516774694, 0.128305502456581, 0.12199731311776307, 0.10097683723799622, 0.12455451764829173, 0.14636469676465536, 0.09847310304780765, 0.11889364558155613, 0.12321545442597859, 0.09177522930706639, 0.11575687878309093, 0.10610419684493555, 0.13476578126642014, 0.07824099702518217, 0.09762461492057062, 0.09901214829381932, 9.999999999998899e-05, 0.026628578844044792, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15295696402441572, 0.05460792272211401, 0.13001455279035212, 0.09924090554423615, 0.029644251219023143, 0.03679438885236819, 0.06211617907921663, 0.08252076488696314, 0.05115330494925252, 0.010811304031469793, 0.0386332529269906, 9.999999999998899e-05, 9.999999999998899e-05, 0.023906314002111184, 9.999999999998899e-05, 0.012986663500434092, 9.999999999998899e-05, 0.008760203738449546, 0.0904076097911799, 0.020480524055458083, 0.04908523376981688, 0.062421818945628704, 0.05329445498343832, 0.0856152419581434, 0.043403247454991134, 0.08443962340784161, 0.055941097439101584, 0.351682856465818, 0.32396701090230307, 0.3558616594353877, 0.3776424044112764, 0.3676457861897199, 0.3348600863519616, 0.3734175044036161, 0.32656522324711346, 0.4022477942951074, 0.10170678235558317, 0.07681550980084861, 0.09124412845881291, 0.09390911504489663, 0.08426751891112838, 0.09878279856711591, 0.08272276500670994, 0.08417156212164623, 0.10996261171206989, 0.21197417467860136, 0.21436829089764442, 0.16146961116075786, 0.19988348780892473, 0.15057926546015843, 0.13646525667808584, 0.19077879914843454, 0.16251167435957692, 0.17629925701744165, 0.24658717333958435, 0.2454285860789841, 0.2365249971458525, 0.2580491945726605, 0.24187556195179216, 0.262787260842293, 0.275253054379877, 0.2526017840441994, 0.2561250752384263, 0.17716627060130163, 0.15820394426523576, 0.20462271445317604, 0.1777506057111513, 0.1477023013938057, 0.15887961628722802, 0.1869303174189343, 0.2126871238415885, 0.16243105641528965, 0.17696354420794136, 0.17023948035700032, 0.18566432426984314, 0.1899638172612842, 0.19762669921611564, 0.19094466570966728, 0.18261642315437943, 0.19125201153645677, 0.1916696953535647, 0.1730336060273956, 0.19287796030953852, 0.17098350828654096, 0.1768426329230055, 0.31125808438245794, 0.17441638967601725, 0.17960152044468158, 0.1972830875445204, 0.18114372076028618, 0.6690543446488546, 0.46020718969709773, 0.34543423246264593, 0.588296320170611, 0.19513529080401237, 0.19454279516848405, 0.1740453758834445, 0.4112132176761383, 0.33107171921325806, 0.3377456704969346, 0.16206998498895842, 0.38257664772038813, 0.38048287257657076, 0.20019655088238997, 0.18805456156586775, 0.1992776401916575, 0.202175679151117, 0.20163983264663032, 0.1854178458032255, 0.21257790437502633, 0.1791331372151046, 0.20535449656341698, 0.20150024627784258, 0.189257137727869, 0.17570194229764424, 0.19016749659751941, 0.18111797532634177, 0.06419096393907042, 0.0786347198695736, 0.07400359885001673, 0.06781648540802632, 0.0761137167163477, 0.08850788760819173, 0.07782888492884066, 0.06497589773276691, 0.06516125012147189]}, "mutation_prompt": null}
{"id": "a453f3c6-3d2d-43b1-86af-d01a8de86d64", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "9f43d5f9-4ffd-43ed-9b03-563dd2a22ff8", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "ba68f498-3ddd-487f-9454-396a86ec9566", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "4a4d10f4-4056-43e3-aa42-a6b25de8cd00", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "d6a795fb-0677-46de-94d5-15661ae8f73a", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population to enhance exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Nonlinear adaptive coefficients\n        self.c1_max, self.c1_min = 2.5, 0.5\n        self.c2_max, self.c2_min = 0.5, 2.5\n        self.w_max, self.w_min = 0.9, 0.4\n        self.scale_factor = 0.8  # Increased DE mutation factor for stronger exploration\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Nonlinear dynamic parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_max - (self.c1_max - self.c1_min) * (progress ** 2)\n            self.c2 = self.c2_min + (self.c2_max - self.c2_min) * (progress ** 2)\n            self.w = self.w_max - (self.w_max - self.w_min) * (progress ** 2)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions with nonlinear inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9  # Fixed crossover rate for consistency\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced PSO-DE hybrid with nonlinear dynamic parameter adjustment and focused exploration for improved global search.", "configspace": "", "generation": 54, "fitness": 0.14313746038186784, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.2626289513786918, 0.26076947201782863, 0.2233244065662412, 0.25686704937578175, 0.25298533805115453, 0.18000118102001395, 0.2556882920406356, 0.2607796503542832, 0.13946880213931767, 0.024489987344934683, 0.028983786727085348, 0.005036665703816445, 0.03544403053719858, 0.005227144393754268, 0.023571117042481604, 0.009796414761911398, 0.008766513831078182, 0.016680502625592952, 0.05889498528771542, 0.07743767357274955, 0.08913883424826508, 0.04955246525002932, 0.0708502993219221, 0.05883162836875455, 0.060418771142699335, 0.06734137924155237, 0.05767625858985215, 0.03764263472710594, 0.04128139746943493, 0.03894383368663279, 0.05278715882844387, 0.059347116847713766, 0.03974888864599779, 0.057163258097530534, 0.04917695720438242, 0.06493096199902926, 0.9859031065534549, 0.9683282593073156, 0.9865647679482583, 0.9676665304557535, 0.9774021431470236, 0.9838966654473792, 0.9859456993925696, 0.9769546394719277, 0.9839937997092926, 0.1359210517112639, 0.07886505704728608, 9.999999999998899e-05, 0.0940869394766638, 0.08791185595514894, 0.13586010784874403, 0.11795483908639892, 0.07941650553708446, 0.08469730773299744, 0.15445870294440833, 0.13648687514527647, 0.1314368881199598, 0.17574679480129285, 0.15571345341379528, 0.10726975632438551, 0.14177423083866836, 0.13486655456192542, 0.1083338871603079, 0.04038227052493626, 0.02864949712506737, 0.021791761871324145, 0.028728555989033344, 0.06494625391903808, 0.05683303467084644, 0.05012198903621379, 0.04466272923235248, 0.04889174463886736, 0.012622163987005997, 0.03735030141214357, 0.009853953100953383, 0.04877139323850754, 0.052998465726601496, 0.04277882384048448, 0.03753922407947574, 0.03705410963313205, 0.009412677774726985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012930937438432322, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016494454264914915, 0.04621439108912051, 0.04225913078168464, 0.08339890628408209, 0.0018459970876750775, 0.0035373464547159283, 0.06236665700816135, 0.023043659953897122, 0.038685519819843694, 0.003803332229363021, 9.999999999998899e-05, 0.005728927525636918, 0.0032029086151098562, 0.005717580342115447, 0.0023893660886288304, 0.009896063772303787, 0.012819242039310619, 0.005171893479760548, 0.0021346755892370783, 9.999999999998899e-05, 0.026824528274131954, 0.014438144677047293, 9.999999999998899e-05, 0.02581684495948322, 0.032049281054484124, 0.023668085436667763, 0.03844702172578396, 0.2427372003258388, 0.2548984608611501, 0.25576549043082797, 0.2687928919808684, 0.2558683356660819, 0.24474613503703246, 0.30170005526014276, 0.23067046234692457, 0.23990717862640154, 0.05271362578443217, 0.06996193975108977, 0.06475482018955714, 0.0586369652627462, 0.0634812666845459, 0.09758787349588915, 0.05086729631654052, 0.07229191817407432, 0.06628362041262681, 0.14830154345735969, 0.16802287206100797, 0.14067792024476222, 0.1796263082406705, 0.21666193872949324, 0.18740720118260923, 0.16530971880557155, 0.15742479670306475, 0.14952259672753332, 0.1685558700582075, 0.17119963794422077, 0.21905688879001806, 0.18388852570877168, 0.17082601200514091, 0.16522791893977484, 0.16389050461758448, 0.22858548396455258, 0.2153235640357437, 0.11751976650066409, 0.13613375954688056, 0.1357173019704061, 0.11090918748875866, 0.12292400643430323, 0.12813974394608063, 0.1179371048748773, 0.1630012646756055, 0.11378923150496789, 0.16317082325903431, 0.12860740500466583, 0.1594342152153425, 0.1488960793442069, 0.14786885613912304, 0.14700762683830437, 0.15313254313320945, 0.1696463241527666, 0.15037855926447807, 0.15962148027543044, 0.15723078710124339, 0.16667638949591113, 0.14386428268558538, 0.1503841329967439, 0.12673108636366637, 0.1514300385665076, 0.13612265007109858, 0.14234519479495633, 0.21742079811167248, 0.2116711995475089, 0.11436877301019754, 0.2940008419295045, 0.15942286566583697, 0.12174719733725436, 0.14953477099513568, 0.15408133046546302, 0.31414707879163384, 0.23109855588915584, 0.17194064273079424, 0.10783328843144468, 0.2298439547469181, 0.19556329040895748, 0.15903423330955269, 0.18302848986861464, 0.19457445574020948, 0.17298714110433588, 0.1987220414640949, 0.195779359262785, 0.18252670881928712, 0.20488349425120278, 0.186016955299793, 0.17842723398867144, 0.18308739089607484, 0.1694039129747904, 0.19498204781576856, 0.06348093957009349, 0.05011096283378469, 0.07046503782089586, 0.05871153694161313, 0.056335371470227824, 0.059220648768947615, 0.051026699232280204, 0.06308435938725965, 0.05272907976151642]}, "mutation_prompt": null}
{"id": "02bbd6bb-38c0-4b99-a47c-f3661317cb54", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "795f51e0-17c2-4c88-a528-7739f2fbf558", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "a6b9f7fc-a902-4331-bbb2-30ffcc233550", "solution": "import numpy as np\nfrom scipy.special import expit\n\nclass AdvancedMemeticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with chaotic influence\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # DE mutation factor\n        self.chaos_factor = 0.1  # Chaotic local search influence\n\n    def chaotic_search(self, particle):\n        return particle + self.chaos_factor * np.sin(1.0 / (np.abs(particle) + 1e-9))\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate progress for dynamic adaptation\n            progress = evaluations / self.budget\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = expit(self.pbest_scores[i] - self.gbest_score)\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    # Apply chaotic local search\n                    trial = self.chaotic_search(trial)\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdvancedMemeticPSODE", "description": "An advanced adaptive memetic PSO-DE algorithm with chaotic local search and enhanced parameter adaptation for improved exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.15713128181658287, "feedback": "The algorithm AdvancedMemeticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.26846523598829886, 0.3318798429072123, 0.27292110212244935, 0.3177809858660048, 0.3833191472455617, 0.34293573401457766, 0.3007241368930692, 0.3248599363653992, 0.29618767015374503, 9.999999999998899e-05, 9.999999999998899e-05, 0.007729380933883867, 0.0050133316132567884, 0.03995595443695621, 0.02437857535379684, 0.0010304793733055817, 0.0043147249366009, 9.999999999998899e-05, 0.056183915123904415, 0.07808981188926023, 0.06642980940422294, 0.07706445319663857, 0.06021545197758804, 0.09079458973141263, 0.07212627746411582, 0.09911697824547938, 0.08732145160326288, 0.036548534081763506, 0.05359264192602964, 0.043505662245391985, 0.061299875473751486, 0.0603796961341051, 0.07498979418984819, 0.06837927842499958, 0.07039510415509342, 0.054582771613461256, 0.9805051559685539, 0.9640151412423007, 0.9823041538316025, 0.9556129846277193, 0.9715774918694733, 0.9733385476147389, 0.9657661267772442, 0.9729220176011705, 0.9723409066102, 0.11684991512518139, 0.1298462955482177, 0.10027620438200702, 0.133795306798574, 0.15411641227539552, 0.1352996386095323, 0.08234449160131785, 0.08436776532708679, 0.15602894096132147, 0.17965648089137454, 0.2073251302474396, 0.1982814159581877, 0.19783600644391885, 0.18770699898688192, 0.15972383427241443, 0.12890874487962012, 0.21211139834241, 0.138399849015162, 0.09445001341249515, 0.045781309479346555, 0.041737221068338326, 0.07038887089546464, 0.06770937180369652, 0.03381295537150053, 0.06986275666445907, 0.10198662023797611, 0.06371529351266714, 0.09173497233106431, 0.01809964371722672, 0.017939768445342286, 0.05317876242065811, 0.0952084530106746, 0.07822950106856208, 0.09319217520484513, 0.017221871368308217, 0.027958733145514114, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005524171668824795, 9.999999999998899e-05, 9.999999999998899e-05, 0.058114692271377666, 0.09423790715935287, 0.03887711347886491, 0.035006859713912486, 0.03753669597537934, 0.00010300697045895202, 0.030049170871192077, 0.028849166797090597, 0.04184199876749006, 9.999999999998899e-05, 9.999999999998899e-05, 0.009238466142338808, 9.999999999998899e-05, 0.015599313004609927, 9.999999999998899e-05, 0.00015493421955325992, 0.001786989486089241, 9.999999999998899e-05, 0.025447834513989465, 0.021173842948614796, 0.010652308770450536, 0.02189756934363174, 0.07238091303350935, 0.005639635661594533, 0.03546552082270049, 0.04137201153509629, 0.03378593986256251, 0.2634491357931015, 0.3086497860892744, 0.3121244852721672, 0.28341548496878355, 0.3179060352948083, 0.2831289587400766, 0.2693917128688377, 0.2730533403547376, 0.2843949961948359, 0.06556967659955593, 0.0806822236282283, 0.07420709071917131, 0.07728596656810938, 0.06570474009971972, 0.07067546941046532, 0.05729021140050394, 0.09045326708141654, 0.058436073147957956, 0.1353435990388221, 0.1375162331545523, 0.15549647653003085, 0.17269273323354606, 0.15672709090827597, 0.18070781679655445, 0.16539257826318376, 0.15239635789648986, 0.17757295753833569, 0.20375308156165306, 0.17779289213692295, 0.21021836017386708, 0.18764352473810475, 0.17986359524515938, 0.19214941859854262, 0.1803630172063757, 0.23905249880113089, 0.22946824954633893, 0.14248870799552482, 0.1620510560164543, 0.14991252333403549, 0.14113780808471166, 0.14338748947650293, 0.1340882115305576, 0.13234815800036082, 0.19372491764160538, 0.1563585598649757, 0.1808165045867316, 0.13076131488003906, 0.16219731077620436, 0.16626513313982194, 0.18640186268038528, 0.1630295810146314, 0.16581332954047467, 0.18229706192153183, 0.16339301035510145, 0.15149317158119624, 0.1635240720185802, 0.15777175542863553, 0.16538482477401262, 0.1530767515167749, 0.17698530250061217, 0.1618867656854872, 0.17317239045321897, 0.14615474912700066, 0.31214846257920914, 0.16295643377372815, 0.14471547676138963, 0.29374801304122067, 0.18311695103382275, 0.1742226547633634, 0.16337317733308043, 0.15041352680415898, 0.18384952729978699, 0.2614842123157287, 0.1888343740761118, 0.15630172802519515, 0.17366432962181244, 0.28613826989874624, 0.2025724603655834, 0.19568623870177349, 0.20562131301996334, 0.18125956302683877, 0.20359210293666696, 0.18308105463808633, 0.19329682926967884, 0.1782776922463699, 0.17483600384811127, 0.18638658871419544, 0.1927969218776907, 0.1885455854910144, 0.17625743234616953, 0.057306938317182365, 0.06391198966463618, 0.061049711451179434, 0.05464689165585257, 0.064694037379604, 0.057949591523197674, 0.057736788915362935, 0.06691640260380449, 0.06573384496840429]}, "mutation_prompt": null}
{"id": "cccfe75b-8679-4f18-a0a3-9501f336cd8f", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for more diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.archive = []  # Maintain an archive of elite solutions\n        self.archive_size = 5\n        \n        # Self-adaptive coefficients for learning rates\n        self.c1, self.c2 = 2.0, 2.0\n        self.w = 0.5 + np.random.rand() / 2  # Dynamic inertia\n        \n        self.scale_factor = 0.8  # Adjusted DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            self.update_adaptive_params(evaluations)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n                    self.archive.append((self.gbest_position, self.gbest_score))\n                    self.archive = sorted(self.archive, key=lambda x: x[1])[:self.archive_size]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position\n\n    def update_adaptive_params(self, evaluations):\n        progress = evaluations / self.budget\n        self.w = 0.4 + 0.5 * (1 - progress)  # Dynamic adaptation of inertia\n        if len(self.archive) > 0:\n            self.c1 = 1.5 + 0.5 * np.random.rand()\n            self.c2 = 1.5 + 0.5 * np.random.rand()", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm integrating self-adaptive learning rates and an elite archiving mechanism to improve exploration-exploitation balance and convergence robustness.", "configspace": "", "generation": 58, "fitness": 0.16269886967733685, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.3180309784494758, 0.30184735316876565, 0.28627574929107114, 0.34165957190790563, 0.3760782441327907, 0.1901647209124071, 0.39446357471819216, 0.138588829542299, 0.3886956827708232, 0.07406334057344321, 9.999999999998899e-05, 9.999999999998899e-05, 0.020331545283788333, 0.04079316618546158, 0.018193923396198297, 0.0027682978725841467, 0.03583158837046463, 0.0511610399786554, 0.07885658678463314, 0.0561866582013274, 0.05903769663892289, 0.10390832606749012, 0.07240253935230723, 0.06692239407426182, 0.047539579364388684, 0.08978650077276618, 0.04818009045647886, 0.08441375298145903, 0.046449389684040776, 0.06695459645729895, 0.06658198248777392, 0.058259493217536096, 0.06798968291014484, 0.06299908069743576, 0.07998942814401067, 0.06643134249785021, 0.9826793682459702, 0.9855369867768721, 0.9856614236711408, 0.9655952689587501, 0.9806050321137432, 0.9768475606309392, 0.9828495894630316, 0.9803411975964222, 0.9755435078207906, 0.21260393508831998, 0.1358819428578497, 9.999999999998899e-05, 0.1156424297571057, 0.1265528135260332, 0.1308962413650857, 0.0778757250223795, 0.08752225915964629, 0.20839335997486874, 0.22943356385186886, 0.16559857516879295, 0.1894601312533346, 0.1796711174070904, 0.15583108887209196, 0.14775746952025404, 0.2433879865545222, 0.12486957667083187, 0.11245350669524812, 0.10693604742896112, 0.058362569833033784, 0.05791358888874709, 0.0746844469080421, 9.999999999998899e-05, 0.08789560989334555, 0.06569611254037411, 0.08536692622153474, 0.09846517582807424, 0.026645586055105697, 0.08639901957435903, 0.06361942125959208, 0.13635116959930893, 0.07607564706115555, 0.08272423406785878, 0.09372403844550736, 0.021881458690548805, 0.07024564905811781, 0.0005916790760819302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013731412101625207, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04224986826231558, 0.04184261864436434, 0.06194111377811129, 0.0607730168530477, 0.02326731989289854, 9.999999999998899e-05, 0.04479741235424939, 0.018997846830816734, 0.02818618167021958, 0.0061971191276929405, 0.0023121351698204284, 0.007758517706700552, 0.004884472732893164, 0.006266828654087342, 0.028153585414862903, 9.999999999998899e-05, 0.008468106180854695, 0.00732086933652043, 0.03729118194236092, 9.999999999998899e-05, 0.06038583411681486, 0.04192609285083704, 0.03778430418149581, 0.047704814069108425, 0.031433010754721935, 0.02935599779770237, 0.04646524703649901, 0.3270533448493641, 0.2901436135765282, 0.32482358814330736, 0.23311857619655107, 0.20554872287970882, 0.31339279017100685, 0.30763270736887205, 0.13382206989781442, 0.331948577060031, 0.07081200532385135, 0.06203147036288825, 0.0886951399163679, 0.07427127253202126, 0.07850686646729244, 0.07337833895576928, 0.08099138519874227, 0.07930683197493726, 0.09131332162285577, 0.16433629342098743, 0.16385623855411835, 0.1362401279153972, 0.1909156694666715, 0.1433003034551602, 0.2173373245082486, 0.19125988480069323, 0.1616721007733648, 0.1901772502808703, 0.18956198800149204, 0.1820482010728357, 0.25069675316182294, 0.213332227698811, 0.2226493656443569, 0.18417085388254995, 0.2085515200278344, 0.23070547176123557, 0.2569118770678718, 0.15096606417125236, 0.17349936902834884, 0.16468474008747203, 0.12442934327299193, 0.1455339242338055, 0.15489144721034498, 0.1859360328533607, 0.1902414959368539, 0.1840190342047775, 0.16153027387431806, 0.16505313326718185, 0.17692189433461447, 0.16718625318346714, 0.1710528867566945, 0.18075143878175604, 0.17019716018121667, 0.17196352056123487, 0.18180462283714127, 0.1480371326011053, 0.17597114409196513, 0.1865666543697262, 0.16147394129801085, 0.1409938905156961, 0.17972220338632106, 0.16721785084469176, 0.15087588264500829, 0.17974496911669213, 0.15807526478240363, 0.15244061061791836, 0.1485594227462187, 0.40516449353463846, 0.19419571039225625, 0.15840121631712534, 0.1495010486607773, 0.17681882612155608, 0.48354667301285337, 0.32992840238661225, 0.1597004196368309, 0.15798626158582496, 0.18382853928441678, 0.20428132472427984, 0.251655581733369, 0.1925211689882964, 0.201128515644046, 0.19377398997276873, 0.20033609697206567, 0.2098195851034078, 0.17849897555595706, 0.18425211804916786, 0.197763059526482, 0.19880239693151502, 0.1807310910471358, 0.2014495087484145, 0.1813540201447139, 0.09657979531315375, 0.044454727770814495, 0.08287280276584863, 0.06201030137420327, 0.07230781262547303, 0.06873793155796071, 0.08908322323561935, 0.06071905596504834, 0.07368792456010564]}, "mutation_prompt": null}
{"id": "6697024e-1254-4db9-9737-32d6ef28da59", "solution": "import numpy as np\n\nclass QuantumInspiredHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.85  # Adjusted DE mutation factor\n        self.quantum_factor = 0.05  # Quantum influence factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Quantum-inspired PSO update\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                quantum = self.quantum_factor * np.random.uniform(-1.0, 1.0, self.dim)\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social + quantum\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Adaptive Differential Evolution mutation and crossover\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 * (1 - progress)  # Adaptive crossover based on progress\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "QuantumInspiredHybridPSODE", "description": "A novel Quantum-Inspired Hybrid PSO-DE algorithm utilizing quantum superposition states for diverse exploration and adaptive DE mutation strategies for enhanced exploitation.", "configspace": "", "generation": 59, "fitness": 0.19370289629443202, "feedback": "The algorithm QuantumInspiredHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.3897710761369676, 0.3370667535171896, 0.355393384375683, 0.3720773354597845, 0.360610943289417, 0.37787586450934507, 0.37563782639645094, 0.40388751033124315, 0.3631818518697092, 0.026795345020086847, 0.015647229247203187, 0.01760273460019779, 0.03617560127799191, 0.01700780027069304, 0.04287987553744044, 0.027073969129201236, 0.017278642103691122, 0.015771856440484067, 0.09949667849549715, 0.09931148286342306, 0.08238271926685614, 0.09053416036980666, 0.10212120797766433, 0.09439251648819569, 0.08337309412318705, 0.09477608471716248, 0.09551529566556749, 0.07233232320140581, 0.08435218681411794, 0.08494479102206098, 0.0809539212735908, 0.08470475962376334, 0.08496028007334677, 0.08016932987590952, 0.0829637298414706, 0.08674471645332682, 0.971695555015984, 0.9765684798083454, 0.9778995534101209, 0.9709202118293008, 0.9676737111149738, 0.9759573831585391, 0.970496000676996, 0.9793371176260944, 0.9751027631575344, 0.2558566218893662, 0.20532993048972248, 0.18847930410012848, 0.250830248907448, 0.21810029811388076, 0.2518164473593977, 0.20879018461812837, 0.2056445452368426, 0.2018600248837702, 0.244991050023878, 0.1875117824378092, 0.1881669279918723, 0.24664544557767654, 0.1682627198975859, 0.19274579326769758, 0.23428651325929117, 0.31065086714727164, 0.26647410541785976, 0.11948392531107443, 0.10938937646484226, 0.11174126854310085, 0.15178735553108058, 0.0935556298016188, 0.12748728009834265, 0.12231056357871262, 0.11586479169825814, 0.12879416503772978, 0.13350132711270668, 0.11376905779675761, 0.0990949896071317, 0.1079966264872837, 0.13640645064050005, 0.11771780875633053, 0.1432686341211774, 0.12476026741350865, 0.106709949740186, 9.999999999998899e-05, 0.019075403213305808, 9.999999999998899e-05, 0.004674266735456345, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012878867541048167, 0.11948157406052051, 0.029491481589069002, 0.12927086554474576, 0.08200302214635691, 0.05011414314429963, 0.05534864318723498, 0.07594551656885429, 0.05263964749981809, 0.08530800623766377, 9.999999999998899e-05, 0.0047150190926513735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002288584620324663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06366562027001821, 0.08084599339029797, 0.0732326061566162, 0.06801767211543686, 0.06372158960085494, 0.08931831148896252, 0.037758875284570004, 0.0834043960290024, 0.06900030805976698, 0.3468133446600721, 0.3485975388047806, 0.3641012804302025, 0.37212393129003163, 0.35484286649036545, 0.35590941708093926, 0.35627977924308507, 0.32963738081213567, 0.3560767328932226, 0.11585691064044423, 0.09511460940045213, 0.0981053072375655, 0.1242552817037218, 0.0929841078896072, 0.11173675367093272, 0.09340184730816037, 0.07895067934526956, 0.10886999830551791, 0.23820611419579607, 0.12293152346645553, 0.13128305609318192, 0.16590508219833333, 0.18890919267330053, 0.14965109892849782, 0.1527450854854362, 0.152031172590554, 0.14185210683540483, 0.2739829692968605, 0.2274443174360704, 0.24153001957266929, 0.2507464497503522, 0.24024233562121045, 0.24233228713042076, 0.248803553768575, 0.2559921663753092, 0.26092155675633777, 0.18630388161429612, 0.17828976931441742, 0.18779003980831366, 0.17700851865899803, 0.15059845551705298, 0.15082486677241247, 0.20062288377895066, 0.20322125680486391, 0.18012625262867965, 0.18413590526036938, 0.2015912368830134, 0.1794294028673854, 0.1874983794437981, 0.20547225772693511, 0.22544031712327306, 0.1844784083338883, 0.18008174516180775, 0.2034617818987522, 0.18384728993764543, 0.16909307523609207, 0.1961299760375651, 0.18849673493270935, 0.1681605102879663, 0.17241455888980928, 0.19607930695033893, 0.2026109229478461, 0.18642410665535258, 0.3594129447651452, 0.4454073832915161, 0.1491970526244113, 0.4890223413689292, 0.20157747509581303, 0.16725857430120794, 0.4118580189251816, 0.5465103308311586, 0.20538836293066842, 0.295007720011479, 0.19407009092176253, 0.3766594788409239, 0.184787820350942, 0.16577395656229832, 0.2814822212557848, 0.199818458409027, 0.3473724844460775, 0.20159738217265, 0.1807102606425518, 0.19327407968003274, 0.18136748890607912, 0.18903081162049962, 0.1791953664452396, 0.18300104199165135, 0.18962132988095504, 0.19722343621733185, 0.17316336937445098, 0.07574269399500788, 0.0729180375125219, 0.07748938010122508, 0.07545304081386417, 0.07556030779618117, 0.0785707601554082, 0.07621451231365428, 0.086796609098302, 0.0705526598580134]}, "mutation_prompt": null}
{"id": "79daad2a-22d1-41e5-b0a4-f45e508b11be", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "2447b80d-a1d2-4d59-8700-267036d8939b", "solution": "import numpy as np\n\nclass QuantumInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n        self.population_size = 40  \n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n\n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  \n\n    def __call__(self, func):\n        evaluations = 0\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                # Quantum-inspired position update\n                quantum_shift = np.random.normal(0, 1, self.dim)\n                self.particles[i] += self.velocities[i] + 0.1 * quantum_shift\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    crossover_rate = 0.9 \n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n\n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "QuantumInspiredPSODE", "description": "Adaptive Quantum-Inspired PSO-DE with dynamic neighborhood strategies and stochastic mutation to enhance exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.18010252857900116, "feedback": "The algorithm QuantumInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.29993202580438805, 0.3084170084274479, 0.32153880971030924, 0.33049167894090903, 0.3303828227874215, 0.34506619419740003, 0.3414383193027829, 0.30066821005247024, 0.34703821514273003, 0.006223323048430762, 0.013774054658194701, 0.004820596361992613, 0.006697291181430809, 0.005840218101818784, 0.006279004334217131, 0.004213345241265265, 0.0025863067445920374, 0.0026516980377898625, 0.07993964953657684, 0.07270394469342933, 0.07558341938964508, 0.08678114325674469, 0.07170916113437575, 0.08824334595322347, 0.08423258660214872, 0.08745364971979275, 0.08041210276752209, 0.09358143288244669, 0.06847992460057883, 0.06385232949224462, 0.07336243402571441, 0.07581641654529181, 0.06583029972793553, 0.07202431383980967, 0.06689914694583698, 0.08084375555888113, 0.9722086254413727, 0.9636105559249009, 0.9761163843514035, 0.9646606057529861, 0.9759851069785008, 0.9671752575120116, 0.9768626154556997, 0.9731618335994671, 0.9766421914417228, 0.18758469314193837, 0.1812404685712199, 0.18974873098433498, 0.1968926816478881, 0.1879104125402027, 0.20582853820504143, 0.21069283371006853, 0.16981521101003294, 0.1918449303287526, 0.27740331246888694, 0.21618582088556326, 0.22086308310206537, 0.19649591892724083, 0.21270301807064296, 0.2357470557259831, 0.21975120286409722, 0.2273265626198292, 0.20582773486721895, 0.07145184042112196, 0.10478538875667764, 0.0598811219285903, 0.10282073429618355, 0.09610221582478129, 0.10945406559529547, 0.12332613123754033, 0.09661703581557535, 0.11064650364869011, 0.10914586149451666, 0.04657430648206029, 0.0955061330843553, 0.09334701371315202, 0.09489533872048272, 0.10875006935682763, 0.10100484569167945, 0.09909540910069392, 0.07141730364796861, 0.005378820873450985, 9.999999999998899e-05, 0.020463114808293215, 9.999999999998899e-05, 0.00011143424183934769, 0.013661706494671466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07660267570717405, 0.06890257319011672, 0.06858507596791097, 0.08048460422188053, 0.06075498950995484, 0.05117521706150041, 0.05650334936217749, 0.09800078693503966, 0.08851843502951562, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042987674281510735, 0.051248485773828345, 0.054542111056251286, 0.056703287616492126, 0.048325041178427064, 0.0510364525580429, 0.034982452447624435, 0.04752407109927914, 0.046669637196779745, 0.3249620771356052, 0.2702184343366014, 0.3263519589979563, 0.30842838907272274, 0.3070280085282934, 0.3168563425864751, 0.311102822647628, 0.30694648290196336, 0.3148947605224336, 0.08706474286584764, 0.08169391112086921, 0.07744968041790745, 0.08036149002734905, 0.0672529753651202, 0.08030886078474819, 0.07973739378860623, 0.0945938771217083, 0.09996396051453937, 0.15812384585392847, 0.12872812217611007, 0.15055135093139138, 0.18643163217815617, 0.1680255956382749, 0.12413045716160742, 0.18032051068535493, 0.19200067656065944, 0.14519866386071467, 0.23237695808897862, 0.19722765899255845, 0.23936431482183096, 0.23560928047030005, 0.22717007031720693, 0.2354363374719035, 0.2320827627096591, 0.24652202382935562, 0.24753884313445917, 0.16748742090287416, 0.1696184191526765, 0.17344196147814706, 0.15858937649751315, 0.16113861500363635, 0.17354680134080647, 0.1785092154149277, 0.18156485808376788, 0.18257455335678474, 0.19866505201382434, 0.18304891761346898, 0.18188237021089293, 0.1852499933462214, 0.1741856706567958, 0.18141023323745575, 0.1905959674711022, 0.1878755442708656, 0.21712664056314912, 0.17206556756301994, 0.16994272560395507, 0.17043394282061797, 0.16631090951412386, 0.16351542204070824, 0.17380884253583373, 0.1677221410619537, 0.16086987859130408, 0.18388923469479057, 0.3071824334794564, 0.4201770742325893, 0.14971226798229587, 0.4026660766917983, 0.40016668802487765, 0.18618352277054906, 0.3786055366892387, 0.18441950008058006, 0.46739531322737593, 0.305386550032276, 0.1937618921349591, 0.3442617898769337, 0.29563361384657694, 0.24896718418995856, 0.14593313180352308, 0.20187671855377087, 0.20145994274262846, 0.19978738376018135, 0.18210790241115515, 0.18414065233776888, 0.18244768537540756, 0.19726295209438982, 0.188158914558893, 0.17954885632667517, 0.18786817943541778, 0.18767236746863258, 0.18611217626867094, 0.07867763365978409, 0.06509412152749705, 0.08227857626506452, 0.08792601535323341, 0.07767992823462988, 0.075508428839417, 0.07543643138120604, 0.07935774231001069, 0.06868856013197289]}, "mutation_prompt": null}
{"id": "0207f3c3-365d-4e0f-b76b-df44a10d1dc0", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "430b51e4-0a9c-4757-a708-aa9d14bdc9c2", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with randomness\n        self.c1_initial, self.c1_final = 2.0, 1.0\n        self.c2_initial, self.c2_final = 1.0, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.base_scale_factor = 0.6\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial + progress * (self.c1_final - self.c1_initial)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, 3, replace=False)\n                best_neighbor = min(neighbors, key=lambda x: self.pbest_scores[x])\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.pbest_positions[i] - self.particles[i]) +\n                                      self.c2 * r2 * (self.pbest_positions[best_neighbor] - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Differential Evolution with self-adaptive mutation factor\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutation_factor = self.base_scale_factor + 0.1 * np.random.rand()\n                mutant = self.particles[a] + mutation_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_rate = 0.8\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, self.particles[i])\n                \n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = trial_score\n                    self.pbest_positions[i] = trial\n\n                if trial_score < self.gbest_score:\n                    self.gbest_score = trial_score\n                    self.gbest_position = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm incorporating adaptive topology and self-adaptive mutation to improve convergence robustness and efficiency.", "configspace": "", "generation": 63, "fitness": 0.20049036823624403, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.54932250813047, 0.5407232226431669, 0.5180902420912203, 0.5438144651355858, 0.5376661298062475, 0.5352692706494411, 0.5023281372206071, 0.5461424997360703, 0.5594701087769651, 0.2021369717962529, 0.20215616474772435, 0.20289391041085814, 0.18305904006777574, 0.18904249726075595, 0.18426078754360842, 0.1932773521890252, 0.21935922240834238, 0.217156654300383, 0.09854769569533184, 0.08813162923221807, 0.10147427854483537, 0.07317446331731114, 0.08622067387395527, 0.07354005749285064, 0.0958991655355419, 0.08747904531241324, 0.09515820997109126, 0.07963833596963144, 0.08154883673724833, 0.07325027146763208, 0.06449086637390478, 0.08781146850802612, 0.07860049141048842, 0.0719313110079689, 0.06914204895745879, 0.06662123037987933, 0.9747211564347913, 0.9690480274505737, 0.9701345131071435, 0.968729793937322, 0.9667496461384415, 0.9579479452789326, 0.9704854635942071, 0.9672309862338007, 0.9789031506446629, 0.2523997062645519, 0.24518690255808628, 0.2699900524504625, 0.21832641260253438, 0.24203286690794923, 0.2488176775483053, 0.2820826885078155, 0.29113927222603575, 0.2449290036289059, 0.22376121368972812, 0.22289274481147459, 0.2173989278110222, 0.22987301943448202, 0.2070653792538596, 0.2502987375627903, 0.20510420226330173, 0.22765969634180439, 0.23748067784327953, 0.12439493256238854, 0.1372139819175796, 0.12034548403641854, 0.09300318845817424, 0.11941991883764025, 0.10582362492268349, 0.11908124288722033, 0.12131614675632518, 0.12437481785756976, 0.11502509947755457, 0.04007443498225771, 0.12257702944387061, 0.12639185854509227, 0.13071525278442042, 0.1374050514314633, 0.11394447717344425, 0.1284333167810915, 0.12245058478266979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0748830793226134, 0.08401224734691604, 0.07451779927052138, 0.042620323249517034, 0.03267830573060093, 0.0436964085594842, 0.06359740934861313, 0.04830108099555197, 0.04149461611640559, 0.006100006401239311, 0.012745463211758734, 9.999999999998899e-05, 0.011749961180545498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01078953492953949, 9.999999999998899e-05, 0.051787408742467234, 0.06421052528708437, 0.06690428261374204, 0.05505664642892194, 0.060266481886257495, 0.08099459847846813, 0.0482584651329625, 0.04078272224127655, 0.06724626247814536, 0.37533403820892286, 0.38342148684307453, 0.3779589358741303, 0.38384346354062804, 0.39563206540458085, 0.39295781402727226, 0.37792010736855386, 0.39077533372114126, 0.38912431221568744, 0.07916261917527845, 0.07677933216102772, 0.09116256649677323, 0.07775238501196802, 0.09240425620900405, 0.09727287211906555, 0.07325540617955828, 0.1098585474862086, 0.07531306833300644, 0.13623784818399343, 0.14764346791233895, 0.12337977814449752, 0.13862813526738194, 0.13878408627441208, 0.13708725740121286, 0.124803611967223, 0.15558407209917646, 0.17011345257124466, 0.2813124729510964, 0.2703682391404093, 0.253974101053407, 0.25085732932542737, 0.2536319012343671, 0.26566436885113676, 0.27360519022341245, 0.29823986843694916, 0.28163381388250086, 0.16707051573481257, 0.18539411389110394, 0.17258445757995655, 0.1793506621133949, 0.14014812530676302, 0.18090440855992806, 0.18996443210605418, 0.1938281147659583, 0.19947931142540443, 0.1874591007987415, 0.17737863645095275, 0.18558669354219948, 0.181686441462531, 0.15617396354615454, 0.17457404632943563, 0.18433983391171715, 0.19342698729300756, 0.1823594176325546, 0.17439154335776297, 0.17784434473123567, 0.1683373979012076, 0.1757981345227836, 0.16603317752093316, 0.17637375558547796, 0.17216405497125453, 0.1683142009310863, 0.18285251088960586, 0.15996497114998942, 0.45129229299677875, 0.18579153490612732, 0.4349123085648523, 0.19919884046004666, 0.18032986987075605, 0.21794595205876532, 0.16361936777824337, 0.19180131131684697, 0.22540844627046186, 0.1615052099235118, 0.18172700729834257, 0.25374783388846556, 0.1522163486009791, 0.21904802803800394, 0.1950127240265882, 0.19039452426754755, 0.2021246590671696, 0.18378844313051235, 0.18173280458639707, 0.1849561556718673, 0.1711976415726063, 0.19163081570262241, 0.17283521004689173, 0.1876714166254082, 0.18463853243897888, 0.18193411686075145, 0.07317986942949106, 0.0772211028324693, 0.07138970968358604, 0.06881588608587497, 0.08550768391271923, 0.06249027242932137, 0.06269899038104998, 0.07127239590501777, 0.06631807127252609]}, "mutation_prompt": null}
{"id": "adb3c825-c2b6-4865-8ca9-3430c5acac3f", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for better search space coverage\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Dynamic learning rates\n        self.c1_initial, self.c1_final = 2.0, 0.3\n        self.c2_initial, self.c2_final = 0.3, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Genetic Algorithm crossover and mutation\n                elite_count = self.population_size // 5  # Elitism strategy\n                elite_indices = np.argsort(self.pbest_scores)[:elite_count]\n                elite_population = self.particles[elite_indices]\n\n                for i in range(self.population_size):\n                    if i not in elite_indices:\n                        parent1, parent2 = np.random.choice(elite_population, 2, replace=False)\n                        cross_point = np.random.randint(1, self.dim)\n                        trial = np.concatenate((parent1[:cross_point], parent2[cross_point:]))\n                        mutation = np.random.normal(0, 0.1, self.dim)\n                        trial += mutation\n                        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                        trial_score = func(trial)\n                        evaluations += 1\n\n                        if trial_score < self.pbest_scores[i]:\n                            self.pbest_scores[i] = trial_score\n                            self.pbest_positions[i] = trial\n\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial\n\n                        if evaluations >= self.budget:\n                            break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveHybridPSOGA", "description": "A robust adaptive hybrid PSO-GA with dynamic learning rates and elitism for improved exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {}, "mutation_prompt": null}
{"id": "0f8f7b9b-9ad8-44ec-81b5-cfababf02a0a", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with self-adaptive mutation\n        self.c1_initial, self.c1_final = 2.0, 0.3\n        self.c2_initial, self.c2_final = 0.3, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor_initial, self.scale_factor_final = 0.5, 0.9  # Self-adaptive mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.3, 0.7)  # Adjust randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with feedback-guided crossover rate\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    feedback = 1.0 - (self.pbest_scores[i] / (self.gbest_score + 1e-9))\n                    crossover_rate = 0.7 + 0.3 * feedback\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced PSO-DE algorithm with self-adaptive mutation and feedback-guided crossover to improve exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.2803150569116706, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.8367595516091455, 0.8122967173506617, 0.8293710909561822, 0.8178551125804895, 0.8149253593092207, 0.8080085336011311, 0.8202086604076352, 0.812842920858394, 0.8095252060599865, 0.047430075472461475, 9.999999999998899e-05, 0.645843331296986, 9.999999999998899e-05, 0.10527385983981696, 0.15035542331413276, 0.11600165218344716, 0.038276449805448864, 0.1459050866419881, 0.1292927682843512, 0.13179652479476556, 0.1710732103179161, 0.11833292178219157, 0.1631407590068853, 0.14144955392625702, 0.14131535118633742, 0.17007919470152533, 0.16576265023517933, 0.10031810584301004, 0.10136108508235397, 0.12906984624311135, 0.141013707684695, 0.10154164686286915, 0.11553332907624503, 0.10949526306891222, 0.17806744712563483, 0.10777525894079554, 0.8357514193059667, 0.16055135444879265, 0.13593748672698058, 0.9491780175367717, 0.9357914394124605, 0.9328883436301955, 0.9320840000604554, 0.9267262962400709, 0.9125666644651992, 0.29851202247318187, 0.373279053743069, 0.5979743004564588, 0.4912548677633092, 0.4303933799710059, 0.5396656322809021, 0.5902367556137281, 0.5466700832178941, 0.35797336866631546, 0.8170787742692143, 0.8029987143915405, 0.22399834292172305, 0.37459411522922814, 0.2738583211611153, 0.36247181303262266, 0.15886296792136423, 0.14691027449712923, 0.21764671874367947, 0.3703503603188866, 0.11879877903030533, 0.10448776937998372, 0.12029716284826175, 0.21430902083332626, 0.05384959661653721, 0.25155811011442375, 0.2638291402147228, 0.19942220633433871, 0.37106085316443993, 0.12624644767200954, 0.11549655710486117, 0.24215325632564322, 0.2803022949040459, 0.17408053930347556, 0.2767996739719869, 0.1258820489343896, 0.13036063911920648, 0.004784121399885821, 0.009726788720234247, 0.029736655870912898, 0.003068794120277607, 0.04974031018050773, 0.008120542865099334, 0.03400163592087224, 9.999999999998899e-05, 0.0637802042990897, 0.12016970426162421, 0.13776582928533354, 0.16411258124194916, 0.08454032407654699, 0.04146512779108891, 0.10868436823138816, 0.07699455943381439, 0.0842829755520712, 0.12613772545659596, 0.2013296932479708, 0.12384872353439658, 9.999999999998899e-05, 0.09493197949279675, 0.18575527260675795, 0.216570970912506, 0.13217701235142953, 0.01826540847762903, 0.1556742308518304, 0.10151064117277941, 0.08732816599107462, 0.20163820964714352, 0.1065918787769744, 0.08084517397795554, 0.06436802147227139, 0.15476602349089064, 0.11231062202447806, 0.11682563576590288, 0.5359342548181354, 0.4494448321587494, 0.48218343030571376, 0.5057769864076044, 0.5612276093178895, 0.5004753308955945, 0.5288739633160137, 0.5161357434331624, 0.5069128708858226, 0.12796317098424403, 0.13400534442690804, 0.1242427234378678, 0.14422707425442882, 0.1399216564131468, 0.12341907940275654, 0.13889519349414292, 0.13920053206654082, 0.10391094830220904, 0.17692615657521238, 0.18594422613269257, 0.21269685559383789, 0.20870366450096411, 0.21486337881215245, 0.19486368919056918, 0.2156669375486333, 0.1682424229865268, 0.18529924533453146, 0.43303683701221074, 0.43188959959506024, 0.3457161556314522, 0.3619006776223497, 0.3136088843604995, 0.41551600501638386, 0.5358480774314109, 0.3423903028073264, 0.5219337162893666, 0.29619261371938044, 0.33660450391632735, 0.38297621271745486, 0.2930490881128279, 0.2756450235424338, 0.27499562278744694, 0.2956397185922901, 0.23623115363314717, 0.2730025551141977, 0.20181230716948617, 0.22382751012792323, 0.24398735844458996, 0.239071710232994, 0.2282741346288638, 0.2555552124426034, 0.2262552581186782, 0.2247648027601905, 0.20995190769954408, 0.2054747086191363, 0.217890332807814, 0.2050279025938485, 0.22084819435467506, 0.712315898933353, 0.18235991671291962, 0.204906114029358, 0.19016778356218333, 0.18857190972723226, 0.8121576544291991, 0.18536998457245857, 0.17278062228910496, 0.171725429809522, 0.19359629848377824, 0.8395074028451204, 0.1600306294369226, 0.7534037439902534, 0.1727773802791982, 0.7168892818336721, 0.7393234145730567, 0.40124084403394134, 0.34948221256976353, 0.599526378012731, 0.3948230968870827, 0.21047196742916596, 0.47295807630282305, 0.16577321056056993, 0.19286902631083125, 0.18396206015858485, 0.1813313586228733, 0.18124156628708576, 0.19253187142836126, 0.19365184419070058, 0.22020356998791535, 0.19306242246546323, 0.17999116053354824, 0.08972607740467686, 0.09392387646212685, 0.09981558108250244, 0.0961336303764676, 0.09382798236839895, 0.11415988425525392, 0.08856358040986323, 0.0865383104824663, 0.08679727756888755]}, "mutation_prompt": null}
{"id": "7abddbe9-5a44-46b8-9307-291faeb5cad5", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "746bdc80-559d-432b-a626-b96a055eb597", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "f3ccbd13-380f-4785-b3f9-377dfdce627d", "solution": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40  # Increased population for diversity and robustness\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7  # Modified DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(0.5, 1.0)  # Added randomness to inertia\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with dynamic selection\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.2 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "RefinedHybridPSODE", "description": "A refined hybrid PSO-DE approach with adaptive inertia and dynamic selection strategies to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.7614264415505113, 0.7368896716039894, 0.7755441104416901, 0.7114882529357918, 0.7139553208545937, 0.7683366062233551, 0.7480694438988444, 0.7102912807148928, 0.7537545657296961, 0.4597927800581413, 0.5046927056309132, 0.48025031101129867, 0.4231419447694037, 0.04451232173408137, 0.5214394175014352, 0.4319399006149791, 0.45029702245605374, 0.432118849210934, 0.13545603210210289, 0.15281146312945582, 0.1276307324875312, 0.36334987456828227, 0.35654475589696966, 0.159249376318376, 0.1517551118961954, 0.14132087760356493, 0.14725536650173054, 0.10846123278410302, 0.12020010392759828, 0.1453370225808157, 0.13200688634874913, 0.14516053484098224, 0.0972134458739301, 0.10347602962449454, 0.11394224564564703, 0.1057304173471677, 0.9600602380815154, 0.9512627663632672, 0.963614134638727, 0.9670781179440877, 0.9591217152850195, 0.9531708890219608, 0.9590511186963461, 0.9720158933487991, 0.9664342873200672, 0.49397576085013406, 0.5862061722902898, 0.5241135120213924, 0.5271383803991664, 0.519249976246471, 0.5536155929495256, 0.1215800408962967, 0.49068312415292925, 0.49710871879321183, 0.3198611969789057, 0.6607637785816596, 0.6907146794749421, 0.2657230489001243, 0.26969006689866515, 0.20970931055985076, 0.7294131010918017, 0.3528479163976119, 0.20261334638495354, 0.1968436886008833, 0.11657726317182948, 0.11034574891411741, 0.17975343929920817, 0.2970853566223842, 0.2011391057408647, 0.23496416204299997, 0.12108429586512615, 0.21068406519694316, 0.21963060939533707, 0.13198209684589002, 0.11686465428864334, 0.19835348019042354, 0.11742979977729318, 0.21278332175436943, 0.23996739438699288, 0.11207585926041375, 0.11219766158923794, 0.010620198034964279, 0.010122471284769174, 9.999999999998899e-05, 0.0099160885323345, 0.0214914168590693, 0.003866356745600541, 0.0029691211380687976, 0.005094754931478929, 0.09393745470316972, 0.1609869483142765, 0.07386535213173173, 0.11775435848146842, 0.08373774745789309, 0.03403989817414388, 0.039340666763904464, 0.07340989182299851, 0.11488113734077654, 0.04970767897018524, 0.14111767532841857, 0.1363037255271905, 0.065637630942879, 0.25131587183408255, 0.09422501317738663, 0.09169031572322695, 0.09573791303143064, 0.249847456400493, 0.10085438412061554, 0.1843001511677439, 0.1672582409836486, 0.2531375188951279, 0.17733289634617155, 0.15187332869406434, 0.19510416440728773, 0.1524018457089198, 0.12180295163687571, 0.08193602528210231, 0.4688018234226211, 0.4607832788989058, 0.5248226160438789, 0.5135742806030786, 0.5018284349597287, 0.5223156791898788, 0.5415863809098904, 0.504179365958223, 0.5166436689160416, 0.13970899979043805, 0.09789052185953473, 0.11518595403723653, 0.12153309653622268, 0.09759312741047976, 0.16276460582629038, 0.12708231434239647, 0.09896711401395075, 0.10264811793529405, 0.20036166467799266, 0.18737241499102397, 0.26471327526078225, 0.27781730925070336, 0.2093572832453291, 0.1851687729596303, 0.18063866454477906, 0.16756966038997012, 0.19376111386602435, 0.3161607969610708, 0.2934827451180778, 0.36427301910553234, 0.3714220332442041, 0.3374347458460295, 0.2873907658063778, 0.3841017514595536, 0.438352507332897, 0.42558159327442313, 0.23601420363151304, 0.28118524834758274, 0.2589725257031452, 0.2413041817079571, 0.20947186570632925, 0.34536773588442515, 0.2724102440970656, 0.31202073707322886, 0.23661377654715698, 0.22385362446781676, 0.24461868061844994, 0.23183934558941133, 0.188810065062747, 0.21450228698148144, 0.218168717448888, 0.21591343918096606, 0.22619520264965276, 0.2154114551052203, 0.20089872811290432, 0.24236162821734375, 0.20879383903147475, 0.4947040940122962, 0.6215883332286787, 0.20242398403779605, 0.19258617707908043, 0.2172605165641902, 0.24132376951168022, 0.7656800558597072, 0.7313892089013665, 0.761018001485062, 0.8606265175249203, 0.7367612784130997, 0.19748312192740713, 0.7418025500939913, 0.16472291400172856, 0.8137868651524321, 0.4888786194454675, 0.19217372048330195, 0.7753236049097653, 0.20743408015617681, 0.16748102330985315, 0.20721982126988625, 0.19906742216401418, 0.2028018919151947, 0.6360729205220574, 0.1891993996960457, 0.18274649164315593, 0.19543037403089025, 0.1952673709833821, 0.19578486805800144, 0.18148100135709944, 0.18269162757889834, 0.18622666908726737, 0.19188888784148062, 0.08551528373279982, 0.0899683185868031, 0.08286401004675592, 0.08846793721290558, 0.08642903879127839, 0.0883354268556612, 0.13135063808201608, 0.08229059204534583, 0.0922474655702552]}, "mutation_prompt": null}
{"id": "7c92bc70-558b-4bfd-bf44-c4ca0c809946", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for improved diversity\n        self.particles = self._chaotic_initialization(self.population_size, self.dim)\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with dynamic perturbation\n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial, self.scale_factor_final = 0.8, 0.3\n\n    def _chaotic_initialization(self, size, dim):\n        # Logistic map for chaotic initialization\n        x = np.random.rand(size, dim)\n        return 4 * x * (1 - x) * (self.upper_bound - self.lower_bound) + self.lower_bound\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            scale_factor = self.scale_factor_initial - progress * (self.scale_factor_initial - self.scale_factor_final)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions using dynamic cognitive and social components\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = 0.5 + np.random.rand() * 0.5  # Random inertia within [0.5, 1.0]\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with scaling perturbation\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 - 0.2 * progress  # Dynamic crossover rate\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with dynamic learning strategies and chaotic initialization to improve exploration and convergence.", "configspace": "", "generation": 69, "fitness": 0.2597575872562271, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6960891394894233, 0.6791625634512043, 0.6196553284205235, 0.6736040378744095, 0.6567746954597852, 0.628141102292039, 0.6594360682864431, 0.6584550607996498, 0.6306186979552961, 0.3518829386742839, 0.34740189568392044, 0.3170751843995234, 0.374049548181663, 0.050784001484043384, 0.27445651085923295, 0.038015926062329175, 0.27753231069768103, 0.32320085348754846, 0.150195252247315, 0.15327361134873863, 0.12072577135634477, 0.13551137806352176, 0.13200697728398414, 0.14414236693517957, 0.10753005739677368, 0.11758393967484404, 0.11089280427351333, 0.08608036160935839, 0.11309639765107693, 0.10499983143454084, 0.11952586580690172, 0.10580215219367861, 0.12090345651102996, 0.116723622922562, 0.10015976495430501, 0.10081881619099875, 0.9632484790462129, 0.9737021589714551, 0.9683397640343194, 0.9594620454379337, 0.9685767730585398, 0.9527639853364934, 0.9677488436687944, 0.9679126153034329, 0.9481894476529377, 0.43294623935635757, 0.4804338947435447, 0.42246610648008265, 0.4210971975823107, 0.3884865663083258, 0.39195646422689057, 0.481138248353536, 0.4699877520263628, 0.40351690363528037, 0.3339074311819148, 0.6414820645865749, 0.34483355630191137, 0.7155765280797062, 0.5389450091116426, 0.2651548941148425, 0.2270073974355563, 0.29359603839405124, 0.22709778025442195, 0.15323581753489757, 0.14987394603471826, 0.10096601199959021, 0.10219211147213647, 0.17966231842285996, 0.10253430856704127, 0.365671232646016, 0.10877884123739967, 0.16197590224818736, 0.04728478645404777, 0.18065868427872933, 0.12769240804312898, 0.11512065343044431, 0.15404020561011145, 0.17673477900131618, 0.19750589069782565, 0.1768623129471475, 0.1809280626582268, 0.0019363460957593226, 9.999999999998899e-05, 0.012508436865155681, 0.031384599255367185, 0.00039452189309430175, 0.0071221263452639905, 0.005315794724313316, 0.002486166740574336, 0.007387836216559696, 0.0444393969766701, 0.06509368293804652, 0.06965448812777608, 0.1075231094807505, 0.06748157342044592, 0.09270998800520303, 0.04773787535197238, 0.06533725276656221, 0.15896936995535038, 0.03881521563416224, 0.03154651129496289, 0.06603976002422463, 0.0665523148752063, 0.044869169408930376, 0.04152523809420583, 0.050851956154518985, 0.10825860454943614, 0.05058196862999087, 0.11998833609262638, 0.013930770708240225, 0.08603050200335038, 0.15064562304567353, 0.04063421359187014, 0.10217249020445396, 0.0821947130166274, 0.06971273357333685, 0.08278824604412005, 0.43862530744683303, 0.4883171119519376, 0.45787432064224587, 0.4872804335742562, 0.5240579790569251, 0.4724322561797293, 0.5036962950757113, 0.4472905364311689, 0.43034972312067976, 0.11477338194919562, 0.13390846545403146, 0.11938172795166224, 0.10156139060524605, 0.10854119750885316, 0.07433601670350076, 0.09454281730725067, 0.10047843378313082, 0.09454479680752736, 0.21036392880968602, 0.1519739739507271, 0.16689789977880132, 0.1923795739326256, 0.2076410897506492, 0.18114125663707592, 0.2234722314556309, 0.2294954734102046, 0.1557755548508023, 0.3697976655349303, 0.31150720867081405, 0.38114026446979155, 0.3532118478656393, 0.31086070901957297, 0.3199887120224073, 0.3909963215935691, 0.3524992055239269, 0.38102270762165324, 0.2646179955732525, 0.2406738123509813, 0.25858735193817695, 0.2173075526343745, 0.28011523881358324, 0.23754288325409645, 0.2461604088028344, 0.175921961494656, 0.22557241825093965, 0.21411463486228488, 0.19481093764602453, 0.20343441522269567, 0.1914985227269873, 0.21750391656761625, 0.20554506511626003, 0.20464468765333255, 0.20378739779303068, 0.20949456188356153, 0.1974886977514969, 0.2109269229234474, 0.21693554380891233, 0.23399276820474446, 0.1715611168861515, 0.30353440281582145, 0.2174036076047745, 0.2004087687674765, 0.2195604020343166, 0.1688542874788529, 0.16628232128493659, 0.5086258655870741, 0.19478469014106126, 0.6632237692245821, 0.6249858531648476, 0.1705754628994004, 0.18583565589376516, 0.16286335814799224, 0.4155836907297277, 0.7033091982602795, 0.3784983587269457, 0.19471035403605663, 0.1500714247374333, 0.3029670570191819, 0.48176253837826855, 0.21049160047239612, 0.45121631221431646, 0.19005129550574817, 0.19921782958510093, 0.1811639322940124, 0.2182660514725826, 0.18010962471477265, 0.20841583963608568, 0.18849295051524118, 0.20050126047785877, 0.19765135168170422, 0.08727727576926192, 0.08733668486150059, 0.0875720119293153, 0.0813464002692903, 0.09834061946490547, 0.08268932800874607, 0.0916365923917829, 0.07864646640894568, 0.10665604264514006]}, "mutation_prompt": null}
{"id": "cf4caa57-530f-44a5-882b-2b8797e108a8", "solution": "import numpy as np\n\nclass DualAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for enhanced exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.9, 0.3\n        self.scale_factor_initial, self.scale_factor_final = 0.8, 0.4  # Dynamic scale factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial - progress * (self.scale_factor_initial - self.scale_factor_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 - 0.5 * (self.gbest_score - self.pbest_scores[i]) / self.gbest_score\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "DualAdaptiveHybridPSODE", "description": "A dual-layer adaptive hybrid PSO-DE with enhanced exploration and exploitation via dynamic population adjustments.", "configspace": "", "generation": 70, "fitness": 0.22590405024241664, "feedback": "The algorithm DualAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.5171506306103628, 0.5529927885002366, 0.5614420177158316, 0.5092521048400008, 0.5618047333867388, 0.5464220378477989, 0.498887530884902, 0.5813339388854002, 0.5726548699515518, 0.08557677805333574, 0.18742665604755837, 0.28220369358056474, 0.06457424502945941, 0.19251553490529716, 0.27234203302812676, 0.04809397957962247, 0.18547192546787583, 0.26289405208288985, 0.12695279073617116, 0.0914879120858686, 0.11505094074776456, 0.09706524222280954, 0.10487565627678719, 0.12297981864672969, 0.12572952216453936, 0.10403300236229374, 0.10490896842792974, 0.10511328189885993, 0.11339995080924203, 0.10764216434667617, 0.09339724641203173, 0.11173812320114795, 0.08672430626388705, 0.09431746103496153, 0.12055924110913763, 0.1063227689735784, 0.9696639915678897, 0.9670396359720411, 0.9627506218144788, 0.964925383440654, 0.9643473258437237, 0.9655737142282786, 0.9645054987437204, 0.9635847893790662, 0.9598550604580535, 0.3131861908899084, 0.330395001576652, 0.2551271150712695, 0.31574810374672113, 0.3106002907989174, 0.3337754266150582, 0.2848331162747859, 0.3823641605993614, 0.351799399225057, 0.47224111788252343, 0.4739113537841625, 0.2670296809066318, 0.4426770096919598, 0.1836251539855348, 0.2297223808403569, 0.20081607324545858, 0.4392459118951223, 0.207121946329348, 0.15926472518437862, 0.14041457911838773, 0.13785992261254665, 0.10988065864864605, 0.14964417606863756, 0.13917934240452245, 0.1631625353916597, 0.22680532555241584, 0.11110268694963721, 0.16391074432258623, 0.11169585466290843, 0.14713295673820614, 0.09928992904480816, 0.12761709496655127, 0.11109988964488982, 0.11952278182843512, 0.09687921224483542, 0.16658680848789242, 0.028041992188631237, 0.0009031318421816037, 0.0109432726264449, 0.014420462343015639, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0741629214714965, 0.06104772089074473, 0.07644281623650773, 0.07852075618385479, 0.09404937099725208, 0.07871198074770802, 0.08863257848651684, 0.05029963536464643, 0.10041872341705727, 0.0176032996012504, 0.018185555375714868, 0.021806672745864897, 0.052594522225162255, 0.04707485877414075, 0.02721501606098986, 0.03748800491732507, 0.07798885500334196, 0.04270627367129687, 0.06836201171261347, 0.06769831285648709, 0.06155754358533905, 0.06866019277510405, 0.1005712626041031, 0.12603341913421606, 0.11772707588183351, 0.1329100669896225, 0.06799437746963155, 0.4096180120182614, 0.40157199620079576, 0.40666158769329963, 0.38019826782097854, 0.41989591926132896, 0.4079667651223463, 0.40775176563937343, 0.40026784586128883, 0.44093566985951205, 0.11040326339926965, 0.11047741004171563, 0.12699933889572457, 0.11737169330837383, 0.10883947595299326, 0.10501715380168664, 0.10198173904855157, 0.09930983544042704, 0.10983312719603999, 0.23034999517956156, 0.15404457626424406, 0.1882791826760758, 0.27979115821995326, 0.17934593409672595, 0.17709516069727893, 0.20858514932546568, 0.19062961560277614, 0.18277784569539857, 0.3055570929484135, 0.2940418137038713, 0.2395304636907899, 0.27755309809462403, 0.24747428604885058, 0.24788009035275238, 0.29109818559565415, 0.32560767363721965, 0.27827016749991507, 0.19750453298871118, 0.20633151551069817, 0.25464175841094805, 0.20387957178078586, 0.1689509561390531, 0.18286484696541183, 0.2079975635558743, 0.202785150517949, 0.22369652629567194, 0.2083008803241183, 0.18901412923594685, 0.1874214007013616, 0.19353575802952905, 0.19043574716743394, 0.19444267157628214, 0.198976278545122, 0.2029857739372819, 0.21639359440137018, 0.19807342026579577, 0.18311513194334617, 0.20251935162457801, 0.17465063366932032, 0.20648810185494104, 0.18788247864515462, 0.19802848703516351, 0.20607324396994298, 0.17430439019637145, 0.14573640997552917, 0.1922093227302395, 0.14161494720717605, 0.22740471870751067, 0.18940272219884446, 0.4460402891725973, 0.1684215193209091, 0.16827732963362318, 0.5677489979126895, 0.4716029447236303, 0.20695576260158688, 0.1583270844413881, 0.528096784386071, 0.15977863021116723, 0.1576991197907368, 0.19910343536797714, 0.19317421116425026, 0.40224112468462103, 0.2058011437153029, 0.1984057470640147, 0.1954442776758245, 0.19408108796106605, 0.18803418232854407, 0.18214317933295576, 0.18749422318467446, 0.18425249557880596, 0.1821647062296966, 0.08146891680111801, 0.08892162339300225, 0.07919897862824887, 0.09230656352962974, 0.08208585214250819, 0.07361493551872955, 0.0862595172843248, 0.08075217209632268, 0.08057833351022547]}, "mutation_prompt": null}
{"id": "66a105cd-dd86-48eb-8998-bd51aff7c8bd", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Adjusted for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Balanced velocity range\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # Adjusted to enhance mutation diversity\n\n    def __call__(self, func):\n        evaluations = 0\n        cluster_threshold = 0.1  # Threshold for clustering effect\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive PSO with dynamic clustering-based inertia\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            inertia = np.random.uniform(self.w * cluster_threshold, 1.0)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Dynamic DE mutation and crossover with multi-scale perturbations\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim) * (1 - progress)\n                    mutant += perturbation\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with Dynamic Clustering and Multi-Scale Perturbations for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 71, "fitness": 0.2946469652623596, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6863881336265032, 0.7444777584053011, 0.7670795809315142, 0.6837496984880874, 0.7503990838079075, 0.8020544129547593, 0.7125288784368822, 0.7237453714352742, 0.7078987586894622, 0.3334441673658838, 0.19276164406111806, 0.35117876721434305, 0.41269237505078105, 0.36992849350753254, 0.46416001129423945, 0.32034686043803917, 0.29627960869792835, 0.3960414260972396, 0.12390595882126887, 0.21493441842163918, 0.13217794908070557, 0.15587855228162317, 0.1356067040944765, 0.13588137345190576, 0.13542435544633447, 0.15680092056766315, 0.1552170905215987, 0.11151565031123989, 0.12599224262832487, 0.10568252646725851, 0.1270417297082136, 0.10845986155515353, 0.11307241102286025, 0.12499671004823498, 0.11559755736104438, 0.1258893497622523, 0.9459114983620037, 0.9560282012265239, 0.9378899598651136, 0.9374460853213529, 0.9433371217086883, 0.9288379115288697, 0.9453234653140377, 0.9669186001300415, 0.933656298934329, 0.3694394185796034, 0.3927664150018686, 0.40309563019102856, 0.3893397273080741, 0.33517101149266426, 0.4744903117796604, 0.3818312095902403, 0.386215713625328, 0.42323603494218087, 0.5895335618125039, 0.6531722082428442, 0.7052907723788171, 0.2663487030618925, 0.35019587904825344, 0.6959657936332961, 0.6918973653215963, 0.46096854630789064, 0.5546042156192523, 0.41681495180695516, 0.17337200532930874, 0.16886742276798028, 0.18948919279255383, 0.1632317143949642, 0.18427676490653433, 0.16597481814659454, 0.21388695203442143, 0.18556676723922116, 0.2115311322663067, 0.16734815668617575, 0.15899241827081367, 0.2432888651928632, 0.12472017792675705, 0.1266028285037757, 0.1851131528147295, 0.1794881512991907, 0.1777952144276136, 0.010267506509734292, 0.05243657501952925, 0.00617422776830967, 0.0615645029429408, 9.999999999998899e-05, 0.018057865510694993, 0.005222849645746264, 9.999999999998899e-05, 0.1778331873806328, 0.13086947253792858, 0.09355719769951243, 0.12732527454441556, 0.07424222205345099, 0.07600573368997887, 0.08715035721124298, 0.09076974847284491, 0.061110841731237486, 0.1278447398706819, 0.15257165263703842, 0.1226853785411316, 0.059372682798101595, 0.09706785239158056, 0.06316903855906497, 0.15116905627518007, 0.09379679361807935, 0.1830344588319054, 0.141370020824795, 0.11089487782638774, 0.09426023465925315, 0.1395899326622695, 0.11677164326904588, 0.12626237347075275, 0.2130792488993427, 0.08142979819642548, 0.08780336360748164, 0.07672449677464976, 0.4766764242260364, 0.46386601091218094, 0.5184266027459441, 0.490859343842285, 0.49184506925690585, 0.5048711773244879, 0.5271284466785275, 0.4327348502175965, 0.47984709707407114, 0.1589974280026616, 0.11802230341302256, 0.12103581736858438, 0.14065271676433422, 0.1400026506877433, 0.1337778564853359, 0.1350478175843578, 0.09909485333829637, 0.13057150113069238, 0.20015153061402047, 0.2241241675954765, 0.16020849390777947, 0.2745272513168755, 0.2965003722892141, 0.14773771099273514, 0.2069358950388196, 0.16589603817349763, 0.2173581223582851, 0.30619780644315897, 0.36946221295290915, 0.3657030285908405, 0.38034679354393786, 0.34177339994900147, 0.36229574999547387, 0.36339917414329936, 0.3532385909905602, 0.3946403615967091, 0.26373074905785787, 0.19545739701256892, 0.275833589883719, 0.2563149315380361, 0.21375012183429576, 0.3128820421033812, 0.18939368817425162, 0.29909246843319526, 0.318492028525174, 0.2294662259630763, 0.1924035821146749, 0.22697058749838228, 0.25024953425443264, 0.2300834375763331, 0.20917004955434604, 0.20772475147395209, 0.19319395528455785, 0.2468288000210752, 0.20649083174770733, 0.257870729484981, 0.19945510428309488, 0.23785018917950018, 0.2997115145766518, 0.23076130079571755, 0.3688182720288198, 0.38118513300679624, 0.21156444779895778, 0.15926859864667708, 0.71045731669879, 0.18224404209977008, 0.1955563849931543, 0.19849844401752137, 0.8378201781365451, 0.7775369140068779, 0.6751172886739287, 0.8436165351375138, 0.5237403816594934, 0.2096245852637848, 0.388733897116217, 0.7051774521833529, 0.3793232122843345, 0.15996208219368468, 0.20850426771199226, 0.20697495957141432, 0.5299622468052387, 0.197534464597523, 0.18801353139357324, 0.19009762542346176, 0.197836207897376, 0.19838356068687046, 0.1852035912663188, 0.17546945341246478, 0.1868521131901082, 0.18245658231765416, 0.09067160890225989, 0.08438967038701417, 0.08003207045278482, 0.09145341437079246, 0.08345192327840445, 0.08283777203815912, 0.09014993999049825, 0.07465541434935619, 0.0872486891428993]}, "mutation_prompt": null}
{"id": "d6238a84-30b2-43d2-b46d-ccc2df60751d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population for diversity\n        self.sub_pop_size = 10  # Divide into sub-swarms\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8  # Adjusted DE factor\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            # Divide population into sub-swarms for enhanced exploration\n            for sub_idx in range(0, self.population_size, self.sub_pop_size):\n                sub_particles = slice(sub_idx, sub_idx + self.sub_pop_size)\n                best_sub_score = np.inf\n                best_sub_position = None\n                \n                for i in range(sub_particles.start, sub_particles.stop):\n                    score = func(self.particles[i])\n                    evaluations += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.particles[i]\n\n                    if score < best_sub_score:\n                        best_sub_score = score\n                        best_sub_position = self.particles[i]\n                    \n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest_position = self.particles[i]\n\n                    if evaluations >= self.budget:\n                        return self.gbest_score, self.gbest_position\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = np.random.uniform(0.5, 1.0)\n                for i in range(sub_particles.start, sub_particles.stop):\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (best_sub_position - self.particles[i])\n                    self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, self.particles[i])\n                \n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = trial_score\n                    self.pbest_positions[i] = trial\n\n                if trial_score < self.gbest_score:\n                    self.gbest_score = trial_score\n                    self.gbest_position = trial\n\n                if evaluations >= self.budget:\n                    return self.gbest_score, self.gbest_position\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveMultiSwarmPSODE", "description": "Adaptive multi-swarm PSO-DE with dynamic inertia and enhanced DE strategies for improved exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.263564858765034, "feedback": "The algorithm AdaptiveMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.671870285886408, 0.675862993493771, 0.6992940329029707, 0.6906501445969058, 0.6816691579950345, 0.7142592560155907, 0.7215122614363176, 0.6742990450979092, 0.7330234968927072, 0.3888119373709473, 0.3542718209247223, 0.29028799277076445, 0.3591372183474184, 0.32196027927097837, 0.3630322275587584, 0.3343636556780587, 0.37346480522650294, 0.326597876891191, 0.1310416486378212, 0.11265200992054292, 0.12399651150769586, 0.14487735106674027, 0.1130591392812812, 0.12534897934262568, 0.121994573124112, 0.11621782448137563, 0.1350147679904783, 0.11265128432331117, 0.09892950317188298, 0.10485447385430036, 0.11395257307395457, 0.10710235022361758, 0.10484307727799769, 0.10296896413288104, 0.09340315073894723, 0.09276669221137057, 0.949701440901011, 0.9615366539300794, 0.9516364950983283, 0.9593582147892473, 0.961662605203997, 0.9543277982097359, 0.954065613400235, 0.9672108286213893, 0.9589309040694313, 0.37384874383379907, 0.34757344735829987, 0.3425734586235599, 0.3457307323141191, 0.31699574143268616, 0.3368064011334655, 0.33284661909654256, 0.3177861098402156, 0.3582961970166828, 0.46950037669597355, 0.622817198807042, 0.3706738237211916, 0.2806119237194932, 0.4898523903149151, 0.2750800356096891, 0.4435199863629994, 0.3423631537661923, 0.49071413861036406, 0.18875266212997477, 0.15821427969756774, 0.1845234769519688, 0.17696246821248374, 0.17360052788381108, 0.13648857165480788, 0.16594348612644683, 0.21597936282758934, 0.15873926392009674, 0.16915975381944048, 0.1662027428211209, 0.2213037363124527, 0.16105488012758595, 0.15543897008361507, 0.14240956091655865, 0.177411734100128, 0.15796996681050968, 0.18992798488612583, 9.999999999998899e-05, 0.011806332353698212, 0.013740910099643067, 0.0021135553594842094, 0.003086786756390958, 0.002451925454382997, 0.015438973574753101, 9.999999999998899e-05, 0.0405379422368225, 0.09956817592133771, 0.07398004397887525, 0.09651433932777309, 0.037354168980658464, 0.06092975390101707, 0.038947956158318586, 0.08642446575537865, 0.08160101442946033, 0.07775946698923586, 0.05509945490868362, 0.10515917720022738, 0.08482135147917547, 0.13945424194923106, 0.10881155974212309, 0.13107099395645216, 0.15861964937663164, 0.1283495136087044, 0.10410174304083375, 0.16336382042191233, 0.1446817146751611, 0.13487720854597696, 0.17100146233804803, 0.11771113726066074, 0.10972593017867638, 0.14065247908349032, 0.0790845071273768, 0.1251752697581282, 0.4685684170009725, 0.4612733110923618, 0.4971915577360272, 0.48955786985332583, 0.461316492031984, 0.47847737610723584, 0.4888418824689328, 0.47029139880276083, 0.5013358692344054, 0.09595642283380912, 0.1144679639482431, 0.09704931323476573, 0.09631061338975855, 0.0979426055592959, 0.11890167229861692, 0.11254367623397465, 0.12897815470828577, 0.10772703473870837, 0.1453546669618332, 0.1395731559129234, 0.16091247936460262, 0.14860216047117303, 0.16503839416472166, 0.17811287362723982, 0.17557282532291596, 0.1505204100926688, 0.14389815346537094, 0.33381886702034236, 0.334664864488034, 0.29557464892016017, 0.32738983060389126, 0.30196078556313133, 0.32757707404495695, 0.3741433671835491, 0.3914822673150651, 0.35297030814893693, 0.26185872980059244, 0.2131020763170699, 0.23907199408854118, 0.19793003204817194, 0.22300062017749156, 0.24217797378933414, 0.2693769634304207, 0.2940788544790448, 0.22652553840731682, 0.19983708684512735, 0.18774167925387442, 0.188599213600517, 0.18754559594367204, 0.22701123549820745, 0.2074492695950697, 0.20853498210927557, 0.19206831330414076, 0.18931444340462888, 0.18682442330647409, 0.18070722610765366, 0.19103756083060008, 0.2547052623499664, 0.18216359854408637, 0.21408017611992525, 0.18040328214025936, 0.20079637051034738, 0.17946374290490252, 0.2298655116146292, 0.39386694551536183, 0.18235548469436913, 0.5300716348740535, 0.19088247887454068, 0.6432794431037596, 0.4423175104224827, 0.46925796385571594, 0.6944014583820816, 0.29032687073497854, 0.20873902478480977, 0.41590643787250925, 0.3627134774377566, 0.18758678149967278, 0.20015725548846752, 0.20386652702020636, 0.26120953588069007, 0.19063567713277285, 0.17884092910572946, 0.18928017655220042, 0.18060814919163293, 0.1880277551093117, 0.18386694972743933, 0.1932760892371823, 0.18732199786978465, 0.18547503676910448, 0.20658766464375589, 0.09813650579232724, 0.07902387771056185, 0.07371430919570376, 0.08038354664937564, 0.08237418705295363, 0.08052626160528509, 0.08727553205736205, 0.07476372962654654, 0.07341691690094321]}, "mutation_prompt": null}
{"id": "2c0f0794-3217-4928-be16-59c481f69419", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population size for better search space exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        # Adaptive coefficients with added randomness\n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor = 0.8  # Adjusted DE mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Calculate adaptive parameters\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions for adaptive PSO with inertia\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            for i in range(self.population_size):\n                cognitive = self.c1 * r1[i] * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2[i] * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                # Differential Evolution mutation and crossover with elite selection\n                for i in range(self.population_size):\n                    indices = np.argsort(self.pbest_scores)[:10]  # Elite selection from top 10\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9  # Fixed higher crossover rate\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive random walks and elite selection to improve exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.272416591918182, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.6779792381519201, 0.6175645238962515, 0.6628667446415564, 0.6136068552885465, 0.6566161121960699, 0.5475974252877207, 0.6347985772568803, 0.6937223394968421, 0.6439619611722054, 0.36278933660771406, 0.28071413967578396, 0.25535202970455495, 0.28626542705436464, 0.3663911073218924, 0.2337542971962735, 0.33477146398305213, 0.29757109680477245, 0.31991865212254933, 0.1216044591867611, 0.10759023992358852, 0.10842674145468523, 0.1210643278651321, 0.11413450026508032, 0.12395478517638325, 0.12769506718206725, 0.12797184947513984, 0.13325462990973413, 0.09665884526513868, 0.10769767341663483, 0.10174157103848225, 0.14601053008813047, 0.12362208366049177, 0.09862493663912231, 0.14392196246215205, 0.12233858642037432, 0.11457883308430306, 0.9727131195886516, 0.9762917638981062, 0.9762565953431792, 0.9649735228336758, 0.9733087847337588, 0.9778694803251519, 0.9676076018269154, 0.9766368075628318, 0.9669639303572672, 0.41858657776830355, 0.44778351804794514, 0.4140101015315063, 0.4351592318675087, 0.4272948428924789, 0.47589130491173304, 0.42658772284966007, 0.39838929104856946, 0.46496935821573393, 0.6108351153246406, 0.583262601910969, 0.6303323519278259, 0.19153968353296336, 0.2501504186864941, 0.19536055103283045, 0.7116690517025126, 0.230396846789372, 0.5653216860904671, 0.19444387510199768, 0.17401782076096095, 0.17366541483422748, 0.16220816265167992, 0.22269503091353948, 0.11016584695029485, 0.17459818168295682, 0.19002326261537106, 0.18864749474334364, 0.3224261899955865, 0.16352414287466288, 0.13756556701084044, 0.16406176339968748, 0.1810718545193598, 0.1971897744913701, 0.2394202168944234, 0.17816305304435587, 0.1835351855215408, 9.999999999998899e-05, 0.029574332291473326, 0.0229025793972365, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005063345850603307, 0.004268506381360226, 0.03301761742409637, 0.0934564089485257, 0.05531371826459708, 0.06995373867116106, 0.0392673694178578, 0.02796221889909467, 0.05350871594832318, 0.0772569343643037, 0.12556368567786647, 0.14048645464180298, 0.05478552231051814, 0.028401623262454323, 0.0326033322446192, 0.04584199995555005, 0.06301302321040725, 0.050754843255643944, 0.06154422802851389, 0.08917324041256725, 0.06200901915708379, 0.14936024974182294, 0.07421169995153809, 0.1692989335673154, 0.14872956557557204, 0.09677888921539202, 0.06445110455639735, 0.0454430162974655, 0.1471189011048174, 0.07417991665686963, 0.4655969380872108, 0.4981662048897363, 0.4691183974824572, 0.47482947505446316, 0.4849347914295131, 0.4850242121748367, 0.49835286945265045, 0.4514775318243881, 0.4632657287366395, 0.1073404849113263, 0.09238637088654378, 0.13021503211951913, 0.09477024736614059, 0.11941453989788953, 0.1304693517154143, 0.12172108255413461, 0.11258991820375885, 0.13112007982932172, 0.2073219905614404, 0.23300645312863688, 0.21986684080624253, 0.19593112792807588, 0.1763735853724243, 0.19299563970151357, 0.18228048742691005, 0.13536172098974186, 0.17593108105715727, 0.3277265070715769, 0.3748808376498334, 0.363774672846355, 0.3782846878096381, 0.39116262807819224, 0.3532565303822166, 0.4049756513829007, 0.33935698617261223, 0.33593634197075006, 0.23535436288151734, 0.2639979637317953, 0.23995718953896517, 0.22401974373090905, 0.1707193988108736, 0.22066073678718423, 0.2537108090371999, 0.2925715526774755, 0.2557446371265266, 0.20994826562026858, 0.20320677282316724, 0.19443242268737948, 0.20582774151917305, 0.21391930492503541, 0.21790698827986876, 0.19328084692705738, 0.19819264624366484, 0.21884983739003117, 0.1989775616342988, 0.19336592224142268, 0.20081723755210001, 0.19075438912364684, 0.406041889152829, 0.22926810569570977, 0.20384033063010099, 0.1960476194029357, 0.36425589699629923, 0.1623090234216601, 0.612908792481861, 0.14995375990012305, 0.7676456519067549, 0.19446959793391227, 0.19394140495706547, 0.19107239338074722, 0.5457580863230338, 0.7275341934381658, 0.63597843650515, 0.2085221127358624, 0.20523376787911496, 0.543525343657879, 0.47186104760380343, 0.37769829186294224, 0.1933803585223195, 0.20101365077383992, 0.5802331978878431, 0.2211893728576244, 0.18720431937471527, 0.19465488995720193, 0.188310390043941, 0.19388414264920228, 0.20874703904476988, 0.1767686557594097, 0.1846055149591863, 0.18190611786596256, 0.08252844895695821, 0.09686034847623615, 0.07759856810823562, 0.08036560758713962, 0.07834974813184836, 0.07912599965371958, 0.11415168279992682, 0.08410996974195606, 0.08784135267068705]}, "mutation_prompt": null}
{"id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A self-adaptive hybrid PSO-DE with chaotic mapping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.327159790486864, "feedback": "The algorithm AdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "f1b25dce-a287-44c1-ae82-28e8ef2b1530", "metadata": {"aucs": [0.8123846353719377, 0.8273395699437496, 0.866715624114302, 0.7900625463783781, 0.8458814637238938, 0.848271902151461, 0.8111966446361627, 0.8477831085162477, 0.8322081121400627, 0.5865506838469909, 0.6875306241682639, 0.6987819217703368, 0.5999667111575573, 0.6234930545918129, 0.6890536455865667, 0.6306436522021819, 0.650771750282064, 0.7252387348858683, 0.1607697242133761, 0.14408864101549657, 0.1716740665700499, 0.1491913315225991, 0.16179388965233743, 0.4464011808949019, 0.1579131038447844, 0.11659363518090615, 0.16449137417589876, 0.10325982731044225, 0.13244600549348384, 0.11222983261254305, 0.1374755566496002, 0.10647116371568044, 0.13812026312651038, 0.12451946415916604, 0.12204675912070195, 0.10601774239603257, 0.9693759321574814, 0.9510724509565366, 0.9707052043033023, 0.9736933166652405, 0.9803587023111814, 0.9740229023756408, 0.971153858387497, 0.945385939350902, 0.9508659087112127, 0.5699047578840767, 0.5444071970732796, 0.5638877461918343, 0.6228244076987617, 0.5942971286880754, 0.552778164681849, 0.49860782499205936, 0.6122614240444534, 0.5671519978783988, 0.8018589025719924, 0.218981463548377, 0.3551710924961833, 0.7966034902093948, 0.3663435083577915, 0.692761978048759, 0.23075000948210123, 0.6762549133358448, 0.7918970212962553, 0.21337490452924035, 0.12838820900334613, 0.21483715461573516, 0.24225805053673488, 0.12995524404858316, 0.29662553868501307, 0.18316642860191268, 0.2120793110436674, 0.19750540081327495, 0.19670988883603813, 0.23322083457225296, 0.19739827835467993, 0.19473688629372232, 0.1406209919916266, 0.22710996786497573, 0.2234158617559907, 0.21798877877631417, 0.22992853446152772, 0.022562099206959618, 0.15986780777095788, 0.012178540667405868, 9.999999999998899e-05, 9.999999999998899e-05, 0.030521118652637735, 0.005327779946864397, 0.039372752176436765, 0.1257014593649738, 0.06493664535738841, 0.09102065206785626, 0.12222231622289814, 0.07268422028465249, 0.16852560304814435, 0.06571985299627392, 0.1893703188684116, 0.1370799350222791, 0.05822240044767857, 0.12473466450426096, 0.2749582901079469, 0.13563626426792652, 0.0832325175494032, 0.1637345764626187, 0.0790493625393428, 0.15089730154368808, 0.14674639068139628, 0.13885011253874258, 0.1483199741812521, 0.20799441646565442, 0.15940943931732943, 0.3130287081075438, 0.12086289658511018, 0.14948081273379699, 0.10191138348248863, 0.12214246135964235, 0.08448729849046455, 0.5153033571417667, 0.5401741981878698, 0.5474348752228999, 0.5482646321229265, 0.5416391431729919, 0.5542685914559013, 0.5879490927306654, 0.5224975209215981, 0.5483132247282705, 0.10696937636244896, 0.12017068368975237, 0.09866926461239578, 0.10562359128017196, 0.10491037751394794, 0.14299795604885257, 0.114613546019531, 0.12540857030904462, 0.1395637465852697, 0.13936506996797793, 0.17408596788614372, 0.17076622454038803, 0.23977551065092484, 0.14358804234155886, 0.19966141504404733, 0.18409951488762089, 0.16624196306999983, 0.22888460739642258, 0.4076388296383252, 0.5125707675166723, 0.4229830315858718, 0.3689957636148615, 0.348991228064639, 0.30332922341016033, 0.4415459129462217, 0.4541815929633297, 0.3549684230928907, 0.3467985957792379, 0.28356545453622306, 0.32556290516588005, 0.2188497051889341, 0.2418107539248976, 0.24368097413467638, 0.23607526147585145, 0.31593998105334, 0.23239235865136088, 0.20352998790523702, 0.21774492540776402, 0.22415110298028362, 0.2195826876981739, 0.2064251018944928, 0.21745074484594673, 0.19958333876451295, 0.22900745878728945, 0.22044283687663413, 0.5946481664186042, 0.19398659209192115, 0.18970511251178757, 0.24883289253440577, 0.20709802905034902, 0.18459443440113832, 0.6798750065674051, 0.2240282023268375, 0.19845407718030117, 0.18509663303751245, 0.18710974420680715, 0.18039277587016822, 0.849833090498924, 0.8507391484175055, 0.19636050835226393, 0.16980631538886426, 0.16256495020797734, 0.8685660402109949, 0.600063938976556, 0.20957816572803833, 0.6965015549525937, 0.7269132966570104, 0.167201597342172, 0.16702193586490155, 0.15364799519923522, 0.6188670183946332, 0.16753291289362082, 0.18858977273946453, 0.18973945625638933, 0.19348944863099693, 0.18432711928247003, 0.1908367428529919, 0.20395156172625317, 0.19631251807758754, 0.19278102620381576, 0.18876174749672747, 0.08675304673639295, 0.08894252751994713, 0.11953306184243406, 0.08984920100857507, 0.0884159518086719, 0.08111148948508906, 0.09340065943666054, 0.07881180566370094, 0.09978263269094079]}, "mutation_prompt": null}
{"id": "fd811d27-9b67-437c-998a-6fcdb3259c9f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.subpop_count = 3\n        self.subpop_size = self.population_size // self.subpop_count\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n\n            for s in range(self.subpop_count):\n                subpop_start = s * self.subpop_size\n                subpop_end = subpop_start + self.subpop_size\n\n                for i in range(subpop_start, subpop_end):\n                    score = func(self.particles[i])\n                    evaluations += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.particles[i]\n\n                    if score < self.gbest_score:\n                        self.gbest_score = score\n                        self.gbest_position = self.particles[i]\n\n                    if evaluations >= self.budget:\n                        break\n\n                chaotic_factor = self.chaotic_mapping(chaotic_factor)\n                for i in range(subpop_start, subpop_end):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    inertia = chaotic_factor  # Using chaotic factor as inertia\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                    self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                for i in range(subpop_start, subpop_end):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "An enhanced multi-population AdaptiveChaoticHybridPSODE leveraging competitive learning and diverse subpopulations for robust exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.3231533501411362, "feedback": "The algorithm EnhancedAdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8231453578798898, 0.8550709967059644, 0.8607409854184949, 0.8328265869698996, 0.8194514773874173, 0.8469701664744245, 0.8232270783525253, 0.8537017151050201, 0.8324105499117822, 0.631341198069046, 0.6920825335711577, 0.677530830278466, 0.6391208878245771, 0.6010476344176598, 0.6954769140909198, 0.6286544344063663, 0.6791742196966483, 0.607078972543531, 0.1512434195825625, 0.12494797773470945, 0.17445321157926608, 0.15406431797171372, 0.16687588003425458, 0.14933125836196037, 0.3514902103056442, 0.4726859970713556, 0.15396678510481798, 0.11167661502749848, 0.12587929097461203, 0.12511230942320417, 0.10434674219476525, 0.12059199223282635, 0.10637393247628801, 0.10409060617319577, 0.09737809303760536, 0.1301694024179546, 0.9545042181197705, 0.9556240191102349, 0.9615932910573766, 0.9718593554422188, 0.9548063137716699, 0.9614951210593323, 0.9679393238363708, 0.9584574989118236, 0.9711516918799884, 0.5585342268370646, 0.6141741448438829, 0.6227624539264844, 0.5799633711547699, 0.5319390767351522, 0.5669506330427286, 0.5964511210172471, 0.6202336912904036, 0.624196879992672, 0.37583166684346814, 0.34296521534673907, 0.3670546299601023, 0.27579492703532793, 0.27946843315479275, 0.6846781615816926, 0.3552068875118808, 0.2316805703635224, 0.3642365629916351, 0.20844853367845517, 0.20082870063497815, 0.19312897549684238, 0.22999846598948748, 0.2808916578412206, 0.24821389295394902, 0.23258878046710307, 0.27942864083826735, 0.20085741193897577, 0.2596761737991178, 0.17892227055113563, 0.1229432389379086, 0.1275551707077469, 0.13144026397986253, 0.21814251117843497, 0.2227188181313592, 0.1210070408226005, 0.13262082175717516, 0.010005916519910008, 9.999999999998899e-05, 9.999999999998899e-05, 0.052002404990274975, 0.001308234364007732, 0.03284292429282376, 0.0024864548426783983, 0.00010517041156377083, 9.999999999998899e-05, 0.08957151461735391, 0.05855842281171586, 0.09025845974351854, 0.07311233917000715, 0.06427076684516342, 0.09223903609876305, 0.11260402492385624, 0.0875523758689053, 0.08436615962528016, 0.1278401079760051, 0.057368207535860916, 0.04613376717120754, 0.28590009707944997, 0.07561162466491367, 0.2901892792888372, 0.238706324931384, 0.11450995276408793, 0.1583743383044408, 0.18341269205704325, 0.1732464870057584, 0.17092892488039013, 0.06536828874994738, 0.04055216494650127, 0.12411565824995796, 0.07853074405051341, 0.13116382799556792, 0.08565407187188123, 0.49399833131884696, 0.5111019880757823, 0.5145573554276146, 0.5500865514766412, 0.5069836161218606, 0.5503415909044147, 0.5646247397910691, 0.56661014452393, 0.5674987256470649, 0.11522783278495985, 0.11827216702847132, 0.13278039047452717, 0.14479945123562865, 0.09488318560152076, 0.13234683535789826, 0.12322143753707226, 0.12214503038971247, 0.12274387426582833, 0.19343034668572134, 0.20243412520365678, 0.15484197424292434, 0.2491269037534526, 0.18611873874801, 0.17573587550231262, 0.24517480871605024, 0.20514559278932032, 0.20777738149022162, 0.4247182881319438, 0.3592947481667962, 0.25742710106734, 0.4952914526953781, 0.3328895559982087, 0.3037796885503614, 0.3201585212945671, 0.3685709296014773, 0.46456921126193906, 0.2523350910596919, 0.24582053525021108, 0.22815895201380987, 0.22176732845150204, 0.2604572554810648, 0.2522480537004703, 0.22315357595317997, 0.30592317415734605, 0.21730451240556536, 0.20934362045089472, 0.2003611480810078, 0.20635296265579162, 0.21757753144002845, 0.22273338914916074, 0.2313471138753258, 0.20344155482216186, 0.23644154499407521, 0.24880458985371623, 0.18284786498220673, 0.22876656547048346, 0.21650158059704216, 0.24468276429867875, 0.6046432754086164, 0.23417081599622902, 0.21287206531086345, 0.18150957561366343, 0.2004966895264142, 0.18419411418864795, 0.8138491551550915, 0.6497556973183285, 0.848013435855466, 0.1985010274400284, 0.8452753439969306, 0.7287087510158915, 0.6941133652215031, 0.7000869433693991, 0.5587917188107321, 0.1545256677971405, 0.7139421944753312, 0.6937523847030793, 0.1636253698376804, 0.7756347018812704, 0.19334742467175137, 0.20896035832752013, 0.15367468404702866, 0.18996786317792225, 0.19354008820618696, 0.1890244489705334, 0.1813830743920677, 0.1892907494417625, 0.18514557977550572, 0.19770517348162087, 0.1879659964162339, 0.19561109118920728, 0.0917647095124241, 0.08290363716225635, 0.08689121139304312, 0.09678359433076733, 0.0943561894448589, 0.07689115511621125, 0.08588037069249044, 0.0849780942522641, 0.08163044057494662]}, "mutation_prompt": null}
{"id": "0280da15-608c-4666-9672-5707d15faa00", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increased population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjusted cognitive coefficient\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjusted social coefficient\n        self.w_initial, self.w_final = 0.8, 0.3  # Adjusted inertia weight\n        self.scale_factor = 0.6  # Adjusted scale factor\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x) * np.sin(np.pi * x)  # Enhanced logistic map with sine\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor ** 2  # Nonlinear influence of chaotic factor\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.7 + 0.2 * chaotic_factor  # Dynamic crossover controlled by chaos\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "An enhanced PSO-DE hybrid with dynamic adaptive parameters and nonlinear chaotic mapping for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.30980085580912964, "feedback": "The algorithm AdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8638977470916416, 0.8643854413863239, 0.8747176606407174, 0.8590742042802227, 0.8593091075597575, 0.8569099477319704, 0.8457680160787883, 0.856668768043163, 0.8520988424926131, 0.7376673458653964, 0.7529661717229806, 0.7380741641158877, 0.7471665772022952, 0.7368203031986702, 0.7422096341386349, 0.7346005192637475, 0.7416016549242544, 0.6855519502125542, 0.17012068156203863, 0.14250414418283475, 0.4844299341839744, 0.14379203473253455, 0.12963547250817353, 0.13275066357974896, 0.5800852372411436, 0.17501599977616478, 0.17541335569781036, 0.12404998224173136, 0.10827677737871888, 0.09205132148215378, 0.13004569113695674, 0.14642956237146787, 0.10975642665450269, 0.1226820130212527, 0.11285119052097647, 0.10078443067240983, 0.9263608526155935, 0.828964125415521, 0.9104859268401999, 0.9516190654814846, 0.8444811839715403, 0.8468985729091271, 0.9496006355148253, 0.834469837398597, 0.8766445793126674, 0.33787564575795315, 0.25980185452293003, 0.22818495423623042, 0.3061062198690393, 0.30944335942826284, 0.345152957380792, 0.30830696636590915, 0.29155220710749663, 0.29425576213437654, 0.36064543615746525, 0.8797350910501004, 0.6999442669211081, 0.27357057153138487, 0.2744520032013317, 0.2721642083535065, 0.16456920821987986, 0.22790760522473774, 0.23979064630670854, 0.23107354242532419, 0.26789089900369156, 0.14376521815792764, 0.18631830612612899, 0.12594778071909296, 0.16513196483975046, 0.14865498566566893, 0.20885194696895037, 0.15674943933440122, 0.12756216963859768, 0.20098293610317508, 0.11968038336442333, 0.1419853592501018, 0.15482644510911592, 0.16476102000597015, 0.1936121385592201, 0.12575758591608688, 0.16596668691421113, 0.009308836836201206, 0.217962765786735, 0.09924549034549035, 0.051151857514067145, 0.06310305112782066, 0.032950590984164085, 0.0850895344443241, 9.999999999998899e-05, 9.999999999998899e-05, 0.1582799996497819, 0.11587012178107037, 0.12220643770730133, 0.0910095790143245, 0.054739057147057846, 0.06377586941379654, 0.15663045251233576, 0.14853034506230556, 0.06907549600730545, 0.1112751933308247, 0.12584478758313067, 0.13497469043439447, 0.1276924668783035, 0.13465633056768656, 0.1511174122621054, 0.15916526427364608, 0.08637303773301175, 0.13048600913227115, 0.14246361089674353, 0.2134081185344867, 0.08626610440461158, 0.16453058421116962, 0.09808044050282172, 0.10433712108846682, 0.3735337284855692, 0.11731502620360557, 0.14212933103335512, 0.4662841184714248, 0.5673523950297107, 0.45797329331979975, 0.5245370943760546, 0.4952206341814871, 0.4970548670130981, 0.4624007377959649, 0.4920774054214734, 0.5269558847448952, 0.15308107794204784, 0.11577358650140035, 0.14298921715138513, 0.11062374467224367, 0.11815315488452705, 0.12045680511069856, 0.13633119549257777, 0.09098556040963701, 0.10059750119862854, 0.24312282523873185, 0.20956546205210014, 0.24202075419445312, 0.21462732873783985, 0.1855519532384371, 0.24494117490143674, 0.15929202785539476, 0.22271218901490042, 0.23137384571914088, 0.2514393843545486, 0.3467831693739356, 0.3981255863861134, 0.42018884284970115, 0.2700613302662602, 0.42925628439831376, 0.5616635608200241, 0.5127170694697301, 0.3710972884725683, 0.22670851830615024, 0.3521740648577022, 0.30191898631901004, 0.28107391661978476, 0.25033539840374464, 0.23897647903673847, 0.30067925738098744, 0.260893582781933, 0.3041834992895358, 0.25332561499751427, 0.2125188340890748, 0.24696652248901785, 0.2336310244186096, 0.2320685807706202, 0.21599984103539593, 0.20184884558108063, 0.2526678013810614, 0.22013120653375373, 0.19170621630523876, 0.19121337206358435, 0.19008818724555565, 0.599708816400714, 0.22040918007589505, 0.2160757601096952, 0.2084106197526019, 0.19214248588159166, 0.18819743774298514, 0.18600526750701651, 0.18469612714699013, 0.18504681387043764, 0.8916160818192429, 0.19642497578847462, 0.7290290415484604, 0.17499618946952833, 0.829995854097666, 0.7789490782173598, 0.5396405529759462, 0.5637178200127485, 0.43221344369071735, 0.6916078662805525, 0.15099743454515024, 0.16544526149851246, 0.2728520047342651, 0.40444779205893977, 0.31097332769571995, 0.18122753971406758, 0.18804119171932965, 0.19936917921929376, 0.18104044107854222, 0.1900597599903574, 0.205227267108544, 0.1875835453357091, 0.19578202041071224, 0.1682628134881643, 0.16536225687804784, 0.09488014991057003, 0.08576106253443483, 0.09674881006991654, 0.09973590188269266, 0.09719805583656727, 0.0853481695487206, 0.09453256498482154, 0.08928252205841092]}, "mutation_prompt": null}
{"id": "c9ffb586-ec5e-41b9-8d3f-cc1ea9b53813", "solution": "import numpy as np\n\nclass DecentralizedDualInertiaChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping1(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def chaotic_mapping2(self, x):\n        return 1 - 2 * x ** 2  # Tent map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor1 = np.random.rand()\n        chaotic_factor2 = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor1 = self.chaotic_mapping1(chaotic_factor1)\n            chaotic_factor2 = self.chaotic_mapping2(chaotic_factor2)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor1 if i % 2 == 0 else chaotic_factor2\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor1:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "DecentralizedDualInertiaChaoticPSODE", "description": "A Decentralized Dual-Inertia Chaotic PSO-DE hybrid, introducing swarm diversity and dual-chaotic mapping for enhanced robustness.", "configspace": "", "generation": 77, "fitness": 0.3056914806824071, "feedback": "The algorithm DecentralizedDualInertiaChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8192248854967882, 0.7735478070553872, 0.8487456155507442, 0.8298801336883517, 0.8293734946791312, 0.8361708352320671, 0.8327930084719272, 0.8301886982662221, 0.8020333878959569, 0.5665320340902633, 0.6156079551448024, 0.6876710644958763, 0.5805948342276457, 0.5772197349255708, 0.5058461340652072, 0.5503081445879536, 0.5995555432579747, 0.5469694278481201, 0.13865055577284457, 0.14536367879885803, 0.13644528456546157, 0.2912002355043354, 0.13514403701291267, 0.4837251060057748, 0.1313316468386081, 0.1404063315298023, 0.1634570636196404, 0.14121800190854283, 0.17913053456291272, 0.09704639307675811, 0.12915116973943186, 0.12490903938748743, 0.13787077188586738, 0.11888801924339454, 0.11510704673780092, 0.1400353399817411, 0.9628517675648547, 0.9473193918571817, 0.9521589146110542, 0.9768251282495053, 0.9561536860803058, 0.9693480228937333, 0.9718641422148805, 0.9595255887631658, 0.973024342029044, 0.48149655222726473, 0.45666160272666934, 0.4224582015115459, 0.3775173117888012, 0.5201271374450273, 0.4451020153012446, 0.3631529791395014, 0.47793226639000497, 0.42847631056186375, 0.3507210382017636, 0.1685306411002503, 0.6815649426238095, 0.7746707521516843, 0.2102356069073268, 0.21318466095838762, 0.5325327772020253, 0.687085433260237, 0.6851254634757784, 0.16255057625079883, 0.11238785940539697, 0.1673048819123122, 0.2442304048315358, 0.17677517336314064, 0.1272436378207995, 0.15914874732111517, 0.3117068662789939, 0.18655850236844285, 0.14810251080858639, 0.18055440327122874, 0.12856883663486218, 0.16172907004613368, 0.15945251095467206, 0.3879179433726274, 0.2213678040676238, 0.20826376831602889, 0.3964243155043735, 0.05890815965063989, 0.004439490229959819, 0.03769492083968684, 0.00764685887454819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025537185721514977, 0.08504975325734832, 0.07550751604150008, 0.11246277858779063, 0.09055671378507779, 0.07797987987986399, 0.07049171518500297, 0.1395109200954544, 0.12882970365354063, 0.06354760505945556, 0.04370761578679028, 0.1105045728047156, 0.17590241645560234, 0.08478192930451622, 0.12106393310274544, 0.09559380514621774, 0.07292707838441115, 0.10270522926850523, 0.13787003651440066, 0.10156650518287114, 0.11905293515890314, 0.22815903243091706, 0.1662583389369502, 0.1914365833252939, 0.14412844828578164, 0.09878129636433441, 0.12383920306488505, 0.09436411521099675, 0.5727898196968026, 0.49362167343528285, 0.5353510205626646, 0.4936155838915357, 0.48202253558207275, 0.5077902222701899, 0.5245309628889245, 0.5098221527672329, 0.6252039416167429, 0.10172730507158445, 0.10086442190273115, 0.11592508831229209, 0.1324814600460157, 0.14618148518662144, 0.14259434247468994, 0.12455948061692212, 0.13565060413746377, 0.1088136576621288, 0.25037243781127094, 0.19650473617069542, 0.16915026663441912, 0.14702048016731406, 0.2435041691088775, 0.2420165360604991, 0.17393135617240585, 0.15428485471662168, 0.19620635308338286, 0.2553142866031659, 0.5058737319954121, 0.26175726484467, 0.2916890351210992, 0.3157081669461038, 0.296064004155289, 0.37453455746391484, 0.4097897215427212, 0.37984380798729966, 0.23681813645506433, 0.2679180471274394, 0.22278131312198846, 0.19024370132000046, 0.20877423668680362, 0.2505568097643177, 0.2266002825024962, 0.24260884328413235, 0.2631697892623075, 0.19585616556319363, 0.2167141311395152, 0.21626231267406848, 0.20447739365772144, 0.19941047174446502, 0.18577404468776426, 0.24695587688034382, 0.2319677372167206, 0.22741913972012362, 0.20845513722276587, 0.2094810036718313, 0.1965857000346024, 0.19978908375197613, 0.1913135219604719, 0.2047222868563091, 0.22219874969017905, 0.21620862666384, 0.2053078538170544, 0.18543469903798548, 0.1731356036328281, 0.2048182702392941, 0.8079218508046608, 0.6462865961196532, 0.8613752117802699, 0.5425989175002663, 0.16776282419370325, 0.15872315446449825, 0.5051728745119931, 0.21041881373668592, 0.5614215533915862, 0.43403347714312956, 0.2046065074494301, 0.47348785046012143, 0.6565906307089988, 0.5519213548788818, 0.20337987787253764, 0.19126012002755266, 0.20704423273997363, 0.1874873864568527, 0.18283118087366967, 0.1822294542792302, 0.19040865911722205, 0.1904718034316938, 0.19101902057446674, 0.19559111262442452, 0.08171223705302144, 0.09254421853350125, 0.08544874563772153, 0.09199529148717045, 0.08940326147210109, 0.08890778644836062, 0.09626936189997082, 0.08007489867332784, 0.09160530645062204]}, "mutation_prompt": null}
{"id": "84c7fb0d-1745-4bd7-975a-2a924635ac45", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial, self.scale_factor_final = 0.7, 1.0\n\n    def chaotic_mapping(self, x):\n        return np.sin(np.pi * x)  # Sine map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced AdaptiveChaoticHybridPSODE with diffused chaotic mapping and dynamic scale factor for improved optimization stability and convergence.", "configspace": "", "generation": 78, "fitness": 0.3245292909460163, "feedback": "The algorithm EnhancedAdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.847350331842927, 0.8236853651096029, 0.8355724096942276, 0.8629000492753407, 0.8642672617996593, 0.858342646974865, 0.8580380370230588, 0.8618696720662478, 0.8154225635643124, 0.6475646173381973, 0.6904379596100467, 0.676195314481711, 0.6602378277013401, 0.6566499041071711, 0.6155538353080796, 0.658328154747867, 0.7181725729702707, 0.6718823002511403, 0.12405630225924413, 0.1697416725524421, 0.13183950156426183, 0.13378168391236123, 0.3219570187492192, 0.16280782009600603, 0.16995960746812866, 0.1688478525743491, 0.14042849631251753, 0.13043428615005326, 0.11849873587489024, 0.12230467341990114, 0.13265843685004053, 0.10167197712252507, 0.13678336826517024, 0.12868854488857118, 0.1758208598963673, 0.1059490890398661, 0.9693654811012278, 0.9629347436012718, 0.9647500586267255, 0.9736300277583813, 0.9801487021798235, 0.968915708478189, 0.9704077627272252, 0.9674160525974848, 0.9686824333066373, 0.6655030484142113, 0.5442105622288265, 0.5589748837974622, 0.5484820404342827, 0.5200186152577018, 0.5903333636736245, 0.609776682801652, 0.5877225618626376, 0.5997329260267013, 0.36453283432340067, 0.6253408956664989, 0.3178842149544404, 0.7857851976599126, 0.2724494283036337, 0.2101786518172274, 0.3801106704359085, 0.23406225557309823, 0.3188069301184975, 0.1937780764351974, 0.2167646603257779, 0.19651945403469917, 0.19666753199082254, 0.12974467063430295, 0.12207993486735669, 0.1950517552782427, 0.21210963455436327, 0.1977156497281014, 0.3352360761335612, 0.18518199320730133, 0.18541160084091457, 0.20220057708405736, 0.1288919684915778, 0.16802510573733198, 0.23235097266313998, 0.22151594412771392, 0.11839250330361606, 0.04892646240112153, 9.999999999998899e-05, 0.054459123353017835, 0.06571456596294123, 0.04438680493828362, 0.033778571354572184, 0.013738190570415476, 9.999999999998899e-05, 0.10028257510347482, 0.10212571171387153, 0.08296700652845213, 0.13570291728644857, 0.10371910041883825, 0.06931012648218582, 0.0734909266608691, 0.13808890631055526, 0.0520841718946462, 0.128678717735063, 0.09412436703003857, 0.17881653711805778, 0.14131576546187807, 0.11057793466708588, 0.10869470161219763, 0.0892368586907536, 0.32403673419726287, 0.07712042032787159, 0.21532994045121157, 0.27970733373596524, 0.20765637028048556, 0.2339433791190515, 0.27535116863346587, 0.11253405868673294, 0.08305724181252605, 0.1511924340150239, 0.1747467172554178, 0.0887672168235536, 0.5105958343043964, 0.5805209199456186, 0.5183226053084586, 0.5164596909071877, 0.5158691381062717, 0.5465070733762831, 0.5531961057165575, 0.6261925861769565, 0.5651122637772925, 0.13583851768059796, 0.1281187936790531, 0.11378643232074814, 0.12609343584110133, 0.12315898866156583, 0.15992722119186165, 0.1555076258371879, 0.10475112925391172, 0.12315639916823673, 0.23100548562352352, 0.268439195635949, 0.19278045051409876, 0.22532036611406925, 0.23717827205146536, 0.2255556480753509, 0.21886779810580248, 0.13790604858651134, 0.20055585913052432, 0.28372612020620036, 0.3130307774711839, 0.3411915618503174, 0.3370712132980408, 0.3430290077204261, 0.2103604021654505, 0.36649311820289776, 0.44848464123310583, 0.4134606751326939, 0.2653470103102803, 0.2649755486649401, 0.25475587425727275, 0.20860699693487716, 0.26931059815904146, 0.25028775943998927, 0.2981724538406687, 0.2803448246094854, 0.2532212189488948, 0.23204615520946692, 0.22758039191963442, 0.20218630422032347, 0.21501148135936476, 0.21259730208489014, 0.23463544870718012, 0.20829028657474513, 0.2212929876372468, 0.23570935555226735, 0.5838174496824381, 0.21887829164011363, 0.21365597035760386, 0.20743895908058507, 0.19647787552587392, 0.21831644466877076, 0.19135116028863752, 0.22110007057137004, 0.21583696462714075, 0.1833515843356499, 0.7732763002814935, 0.7604516359781972, 0.8524062405013798, 0.19757051009433002, 0.16656374002710783, 0.14091766473130596, 0.8272583580237812, 0.857511091126324, 0.7815553703861033, 0.21055677933399775, 0.6760241891484183, 0.6295595664589767, 0.16739459999945816, 0.1663019969230165, 0.16014848431450046, 0.20565236701501666, 0.6860204248898834, 0.18761426245846702, 0.19354683297269182, 0.1859510911688823, 0.21934607750427937, 0.19355473661147626, 0.18771193451515078, 0.19651497006617769, 0.18684056145574668, 0.2016886609726043, 0.09465180761777559, 0.08965933012777028, 0.08187450160973675, 0.08584164269061512, 0.09582159065778872, 0.08867796942981854, 0.09908934113785417, 0.09251641729630466, 0.08572897257336154]}, "mutation_prompt": null}
{"id": "af5f79ae-626c-4560-ba5e-7c2acd022f84", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A self-adaptive hybrid PSO-DE with chaotic mapping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8123846353719377, 0.8273395699437496, 0.866715624114302, 0.7900625463783781, 0.8458814637238938, 0.848271902151461, 0.8111966446361627, 0.8477831085162477, 0.8322081121400627, 0.5865506838469909, 0.6875306241682639, 0.6987819217703368, 0.5999667111575573, 0.6234930545918129, 0.6890536455865667, 0.6306436522021819, 0.650771750282064, 0.7252387348858683, 0.1607697242133761, 0.14408864101549657, 0.1716740665700499, 0.1491913315225991, 0.16179388965233743, 0.4464011808949019, 0.1579131038447844, 0.11659363518090615, 0.16449137417589876, 0.10325982731044225, 0.13244600549348384, 0.11222983261254305, 0.1374755566496002, 0.10647116371568044, 0.13812026312651038, 0.12451946415916604, 0.12204675912070195, 0.10601774239603257, 0.9693759321574814, 0.9510724509565366, 0.9707052043033023, 0.9736933166652405, 0.9803587023111814, 0.9740229023756408, 0.971153858387497, 0.945385939350902, 0.9508659087112127, 0.5699047578840767, 0.5444071970732796, 0.5638877461918343, 0.6228244076987617, 0.5942971286880754, 0.552778164681849, 0.49860782499205936, 0.6122614240444534, 0.5671519978783988, 0.8018589025719924, 0.218981463548377, 0.3551710924961833, 0.7966034902093948, 0.3663435083577915, 0.692761978048759, 0.23075000948210123, 0.6762549133358448, 0.7918970212962553, 0.21337490452924035, 0.12838820900334613, 0.21483715461573516, 0.24225805053673488, 0.12995524404858316, 0.29662553868501307, 0.18316642860191268, 0.2120793110436674, 0.19750540081327495, 0.19670988883603813, 0.23322083457225296, 0.19739827835467993, 0.19473688629372232, 0.1406209919916266, 0.22710996786497573, 0.2234158617559907, 0.21798877877631417, 0.22992853446152772, 0.022562099206959618, 0.15986780777095788, 0.012178540667405868, 9.999999999998899e-05, 9.999999999998899e-05, 0.030521118652637735, 0.005327779946864397, 0.039372752176436765, 0.1257014593649738, 0.06493664535738841, 0.09102065206785626, 0.12222231622289814, 0.07268422028465249, 0.16852560304814435, 0.06571985299627392, 0.1893703188684116, 0.1370799350222791, 0.05822240044767857, 0.12473466450426096, 0.2749582901079469, 0.13563626426792652, 0.0832325175494032, 0.1637345764626187, 0.0790493625393428, 0.15089730154368808, 0.14674639068139628, 0.13885011253874258, 0.1483199741812521, 0.20799441646565442, 0.15940943931732943, 0.3130287081075438, 0.12086289658511018, 0.14948081273379699, 0.10191138348248863, 0.12214246135964235, 0.08448729849046455, 0.5153033571417667, 0.5401741981878698, 0.5474348752228999, 0.5482646321229265, 0.5416391431729919, 0.5542685914559013, 0.5879490927306654, 0.5224975209215981, 0.5483132247282705, 0.10696937636244896, 0.12017068368975237, 0.09866926461239578, 0.10562359128017196, 0.10491037751394794, 0.14299795604885257, 0.114613546019531, 0.12540857030904462, 0.1395637465852697, 0.13936506996797793, 0.17408596788614372, 0.17076622454038803, 0.23977551065092484, 0.14358804234155886, 0.19966141504404733, 0.18409951488762089, 0.16624196306999983, 0.22888460739642258, 0.4076388296383252, 0.5125707675166723, 0.4229830315858718, 0.3689957636148615, 0.348991228064639, 0.30332922341016033, 0.4415459129462217, 0.4541815929633297, 0.3549684230928907, 0.3467985957792379, 0.28356545453622306, 0.32556290516588005, 0.2188497051889341, 0.2418107539248976, 0.24368097413467638, 0.23607526147585145, 0.31593998105334, 0.23239235865136088, 0.20352998790523702, 0.21774492540776402, 0.22415110298028362, 0.2195826876981739, 0.2064251018944928, 0.21745074484594673, 0.19958333876451295, 0.22900745878728945, 0.22044283687663413, 0.5946481664186042, 0.19398659209192115, 0.18970511251178757, 0.24883289253440577, 0.20709802905034902, 0.18459443440113832, 0.6798750065674051, 0.2240282023268375, 0.19845407718030117, 0.18509663303751245, 0.18710974420680715, 0.18039277587016822, 0.849833090498924, 0.8507391484175055, 0.19636050835226393, 0.16980631538886426, 0.16256495020797734, 0.8685660402109949, 0.600063938976556, 0.20957816572803833, 0.6965015549525937, 0.7269132966570104, 0.167201597342172, 0.16702193586490155, 0.15364799519923522, 0.6188670183946332, 0.16753291289362082, 0.18858977273946453, 0.18973945625638933, 0.19348944863099693, 0.18432711928247003, 0.1908367428529919, 0.20395156172625317, 0.19631251807758754, 0.19278102620381576, 0.18876174749672747, 0.08675304673639295, 0.08894252751994713, 0.11953306184243406, 0.08984920100857507, 0.0884159518086719, 0.08111148948508906, 0.09340065943666054, 0.07881180566370094, 0.09978263269094079]}, "mutation_prompt": null}
{"id": "e26c993f-38d2-4761-8266-86463863472c", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial, self.scale_factor_final = 0.8, 0.4\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_initial - self.c2_final)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial - progress * (self.scale_factor_initial - self.scale_factor_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            sub_swarm_size = self.population_size // 2\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(sub_swarm_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8 + 0.1 * chaotic_factor\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "DynamicMultiSwarmPSODE", "description": "A dynamic multi-swarm PSO-DE hybrid with adaptive momentum and stochastic bounded learning for improved exploration-exploitation dynamics.", "configspace": "", "generation": 80, "fitness": 0.2608319478439417, "feedback": "The algorithm DynamicMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.6142739075062846, 0.6223263642507859, 0.7046121935556247, 0.6985740166817664, 0.6706995121208812, 0.7021631589612164, 0.7337877193105076, 0.7876209831129437, 0.5440450001441497, 0.31417223383694026, 0.27767773346866165, 0.27603393387410446, 0.19996518391768126, 0.20890570514546558, 0.26706478193953476, 0.30878071003378516, 0.20880987616775515, 0.2804459530416299, 0.10902857277764721, 0.1217188556763995, 0.1316154273123944, 0.13448142789128814, 0.10736774799573301, 0.1201329548811082, 0.09574417276522307, 0.16866692822447782, 0.1092163650855904, 0.10313240366145926, 0.10862170148412842, 0.09547228529990004, 0.11741756360251399, 0.087750015562432, 0.08792702261161789, 0.12898216790249895, 0.12463393102816755, 0.07339159956071195, 0.9738189513124659, 0.9799134058946755, 0.9567459754543263, 0.9765239625529119, 0.932606205542474, 0.9586195324415395, 0.9477375181703396, 0.9329756382845646, 0.9787994211781063, 0.27397773028046035, 0.250198855609608, 0.3353374621834314, 0.31571791141514505, 0.28955875476045867, 0.3435719537853903, 0.290163099213386, 0.23346879970491585, 0.3386892843508278, 0.2791906262014371, 0.26401316846445566, 0.27237435454025916, 0.29274342281399235, 0.2805271357660394, 0.2968189061535438, 0.3122498490784881, 0.2727318611792632, 0.3727287801030449, 0.20553518219296474, 0.19585124732560932, 0.16283375066972672, 0.14955227908678592, 0.16281887245090076, 0.1442573800075988, 0.20703757632015707, 0.41488889253859007, 0.14396742504490956, 0.17235136896239434, 0.17812098454776548, 0.16527674746494725, 0.15289320563133202, 0.13798604918664636, 0.13579938681061032, 0.185322257757234, 0.1571196228998144, 0.11334981572572345, 0.012769613410786973, 0.00023544719857748753, 0.06483711727341179, 0.016828123642465997, 0.05211929647069524, 0.01277926375051941, 0.0641450756416645, 0.056963858333927586, 0.109716590910091, 0.11922647103584727, 0.07064028874717077, 0.2046821882772184, 0.09395703526824595, 0.07624848523757044, 0.06493032168357382, 0.1900271245616899, 0.08986019871882567, 0.12849891426146154, 0.19140483808418063, 0.17612527731095784, 0.08960805480650091, 0.1597609059088163, 0.169640826575855, 0.10367777135472811, 0.23174288892592254, 0.19151170602750756, 0.11006938818716794, 0.09791425355073569, 0.1532738987582114, 0.14808192265593967, 0.11275074624494741, 0.1808029477464208, 0.14654841591720358, 0.22842653704220617, 0.18762831182295092, 0.09187370204684397, 0.46951357412778283, 0.5513197799709804, 0.48902309208706907, 0.48539917341027217, 0.4982917153664054, 0.5263084326866077, 0.509130326839331, 0.4957304179774372, 0.5883731314733449, 0.1316078834018536, 0.10323842706547826, 0.11180880894895273, 0.1099581355187016, 0.14239737613716608, 0.13076828258353146, 0.10314026324536352, 0.11775912342683881, 0.09870487606834999, 0.15668121747208807, 0.15946874126165989, 0.17360168918608576, 0.17448840459191817, 0.2228456093227461, 0.1578376774371505, 0.19414062987352232, 0.1800178513854902, 0.18778825601419957, 0.23708310363772933, 0.289198333562399, 0.26674745463688665, 0.2300265486506542, 0.25006579259806105, 0.29871532914483967, 0.2576790016549668, 0.3060154637401762, 0.25062276025295604, 0.19029827590963688, 0.21469718422437922, 0.19662451371089673, 0.18975610037854962, 0.17220307245643962, 0.23226337170091804, 0.1800254973601575, 0.2455188397170629, 0.22520534351303345, 0.2275946582693965, 0.19435359210434788, 0.1933780235575283, 0.2288302760254718, 0.19955980273979712, 0.20227146081615688, 0.2118492696568256, 0.21897480733090602, 0.2501146443081729, 0.2136581729894126, 0.19435258208302408, 0.19308771351786602, 0.22646652934582912, 0.22103223763289748, 0.17931608241049557, 0.1829862463153753, 0.1860798177109002, 0.1934541024171147, 0.7545486186581557, 0.35930941997919497, 0.18422939287980655, 0.7945734063772271, 0.35211044355525334, 0.4926334751784023, 0.16519318169595176, 0.32056967712816054, 0.5590526276210042, 0.48579174696183847, 0.21166321258486298, 0.4538986979701465, 0.4024067421074704, 0.16750905543840167, 0.2179000621620888, 0.3046184374947577, 0.34855835392182766, 0.24362754342062853, 0.17355262489284595, 0.1836616978575737, 0.186300589450748, 0.17568629178459738, 0.20657431027659212, 0.18578180291271218, 0.19354243376733216, 0.19123306802984008, 0.21169894286864332, 0.09194364024316515, 0.10459042958636533, 0.08735039046698279, 0.08018804103610833, 0.08019236834891941, 0.08630440838038345, 0.08889747876327525, 0.0911345470572602, 0.10209214162819713]}, "mutation_prompt": null}
{"id": "946afb8a-5b13-4c21-a06f-320b4c6a2815", "solution": "import numpy as np\n\nclass DynamicChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial = 0.8\n        self.scale_factor_final = 0.5\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def diversity_control(self, particles):\n        distance_matrix = np.linalg.norm(particles[:, np.newaxis] - particles, axis=-1)\n        avg_distance = np.mean(distance_matrix)\n        return avg_distance\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_initial - self.c2_final)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n            self.scale_factor = self.scale_factor_initial - progress * (self.scale_factor_initial - self.scale_factor_final)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            diversity = self.diversity_control(self.particles)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.velocities[i] *= (1 + diversity / self.dim)  # Enhance exploration with diversity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "DynamicChaoticHybridPSODE", "description": "A dynamically constricted chaotic PSO-DE hybrid with adaptive exploration leveraging multi-objective-inspired diversity control.", "configspace": "", "generation": 81, "fitness": 0.11796778935419237, "feedback": "The algorithm DynamicChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.17778420311447862, 0.1434127001771216, 0.14124452912670837, 0.18146198407568537, 0.19635155179072405, 0.23192783274357232, 0.19755666807703076, 0.1731252643301463, 0.16692876844615767, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026050044584326693, 0.03503825387444415, 0.04897925610759435, 0.03092342327751796, 0.03590789074678813, 0.03393429801685233, 0.026405334986588924, 0.04245021930558157, 0.03095322609787654, 0.014502588056395704, 0.013444180828137697, 0.02650136533711467, 0.028154765841068907, 0.01794226309833935, 0.026848562706721202, 0.012933305727550581, 0.02106525452670316, 0.013960419971314142, 0.9848234721805307, 0.986931672900874, 0.9849238540374604, 0.981956006590181, 0.9865541379484184, 0.9806370032058234, 0.9857561106921161, 0.9807023398523106, 0.984316966545443, 0.06291608755727118, 0.06558567046642694, 0.04712017569123472, 0.06993414621772498, 0.06506318011778689, 0.03618111562756443, 0.08228471705806095, 0.0753502058662352, 0.0850732522329567, 0.10027683525177622, 0.08220567421330893, 0.08640504187277187, 0.10293385885374196, 0.1321851593336273, 0.10643574639381204, 0.11072880447177735, 0.10199185458609772, 0.10762725876348778, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021090208500421648, 9.999999999998899e-05, 0.03304932603957533, 0.021386238694554804, 9.999999999998899e-05, 9.999999999998899e-05, 0.008726000710489679, 0.007851218560964157, 0.009241445929647152, 0.005328192087269201, 9.999999999998899e-05, 9.999999999998899e-05, 0.008400092087749944, 0.0018287194837408594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03997595497871809, 0.0008671318097495107, 0.03320384613158334, 0.03840652971372516, 9.999999999998899e-05, 0.044507359907580035, 0.021441744532057605, 0.04413596840352951, 0.01603581850902025, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002676446906958452, 0.022245174102012988, 0.17869902852161546, 0.18102965071129506, 0.24510137436342327, 0.15024991281651512, 0.17486613596825606, 0.16138511997669502, 0.19105046215095656, 0.17106816619263976, 0.17661220249116982, 0.047516440756799616, 0.050731382386278945, 0.07512785527715038, 0.03308208731642315, 0.021638119133648215, 0.04696318413449552, 0.0416619060015615, 0.060236114414779385, 0.027543235044723224, 0.14531741153969557, 0.1447465317346086, 0.1373769873621482, 0.13121040982761845, 0.13641937889569367, 0.13473663220662857, 0.1384451906393004, 0.1273687543314188, 0.1370736507470408, 0.14380452671587152, 0.1826000628613743, 0.1442794887183041, 0.14418990163015966, 0.17599819222995827, 0.1487266765857066, 0.16724545179425954, 0.17377774300845283, 0.1688549515026896, 0.07012812162223181, 0.08618856945194797, 0.09009839468149972, 0.10996664939755096, 0.08470460166442406, 0.09014949133106342, 0.09289573090121483, 0.0997711199450243, 0.11484097207556332, 0.1625674156179977, 0.13082351367771972, 0.14775204782560236, 0.1441615982822082, 0.12732192512316465, 0.13226261253183202, 0.12270498999280666, 0.12475032160154964, 0.1261963614278906, 0.1365181415794301, 0.15061892523472364, 0.14279488514544303, 0.11628377911751975, 0.15546363042508926, 0.14889658854381982, 0.1303387538344054, 0.14805205082858208, 0.13331083918795705, 0.17640911595361908, 0.11220646940441126, 0.10558070103633532, 0.16094418380060538, 0.16107742060522945, 0.12365276533088798, 0.12613079917902792, 0.13450753255571146, 0.14514584983437018, 0.15241409172700537, 0.1387123072256634, 0.11344375282526253, 0.1669836525793006, 0.07077729641212904, 0.09837804222972679, 0.1996824848536085, 0.18790519548486895, 0.19228061548447328, 0.17832188521422665, 0.18300664731021732, 0.18922783809992738, 0.17797556984175877, 0.19488956723605577, 0.19722037801295278, 0.18089390172391273, 0.178887213553507, 0.18016098522284973, 0.051399524651496775, 0.02775193963258593, 0.03981354352140565, 0.041604511164311964, 0.05442463505248618, 0.03898401682655972, 0.03310355709787216, 0.04976854476335646, 0.04498368329614533]}, "mutation_prompt": null}
{"id": "dcd1df59-23c4-4198-bb52-e2e8bcad3e34", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A self-adaptive hybrid PSO-DE with chaotic mapping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8123846353719377, 0.8273395699437496, 0.866715624114302, 0.7900625463783781, 0.8458814637238938, 0.848271902151461, 0.8111966446361627, 0.8477831085162477, 0.8322081121400627, 0.5865506838469909, 0.6875306241682639, 0.6987819217703368, 0.5999667111575573, 0.6234930545918129, 0.6890536455865667, 0.6306436522021819, 0.650771750282064, 0.7252387348858683, 0.1607697242133761, 0.14408864101549657, 0.1716740665700499, 0.1491913315225991, 0.16179388965233743, 0.4464011808949019, 0.1579131038447844, 0.11659363518090615, 0.16449137417589876, 0.10325982731044225, 0.13244600549348384, 0.11222983261254305, 0.1374755566496002, 0.10647116371568044, 0.13812026312651038, 0.12451946415916604, 0.12204675912070195, 0.10601774239603257, 0.9693759321574814, 0.9510724509565366, 0.9707052043033023, 0.9736933166652405, 0.9803587023111814, 0.9740229023756408, 0.971153858387497, 0.945385939350902, 0.9508659087112127, 0.5699047578840767, 0.5444071970732796, 0.5638877461918343, 0.6228244076987617, 0.5942971286880754, 0.552778164681849, 0.49860782499205936, 0.6122614240444534, 0.5671519978783988, 0.8018589025719924, 0.218981463548377, 0.3551710924961833, 0.7966034902093948, 0.3663435083577915, 0.692761978048759, 0.23075000948210123, 0.6762549133358448, 0.7918970212962553, 0.21337490452924035, 0.12838820900334613, 0.21483715461573516, 0.24225805053673488, 0.12995524404858316, 0.29662553868501307, 0.18316642860191268, 0.2120793110436674, 0.19750540081327495, 0.19670988883603813, 0.23322083457225296, 0.19739827835467993, 0.19473688629372232, 0.1406209919916266, 0.22710996786497573, 0.2234158617559907, 0.21798877877631417, 0.22992853446152772, 0.022562099206959618, 0.15986780777095788, 0.012178540667405868, 9.999999999998899e-05, 9.999999999998899e-05, 0.030521118652637735, 0.005327779946864397, 0.039372752176436765, 0.1257014593649738, 0.06493664535738841, 0.09102065206785626, 0.12222231622289814, 0.07268422028465249, 0.16852560304814435, 0.06571985299627392, 0.1893703188684116, 0.1370799350222791, 0.05822240044767857, 0.12473466450426096, 0.2749582901079469, 0.13563626426792652, 0.0832325175494032, 0.1637345764626187, 0.0790493625393428, 0.15089730154368808, 0.14674639068139628, 0.13885011253874258, 0.1483199741812521, 0.20799441646565442, 0.15940943931732943, 0.3130287081075438, 0.12086289658511018, 0.14948081273379699, 0.10191138348248863, 0.12214246135964235, 0.08448729849046455, 0.5153033571417667, 0.5401741981878698, 0.5474348752228999, 0.5482646321229265, 0.5416391431729919, 0.5542685914559013, 0.5879490927306654, 0.5224975209215981, 0.5483132247282705, 0.10696937636244896, 0.12017068368975237, 0.09866926461239578, 0.10562359128017196, 0.10491037751394794, 0.14299795604885257, 0.114613546019531, 0.12540857030904462, 0.1395637465852697, 0.13936506996797793, 0.17408596788614372, 0.17076622454038803, 0.23977551065092484, 0.14358804234155886, 0.19966141504404733, 0.18409951488762089, 0.16624196306999983, 0.22888460739642258, 0.4076388296383252, 0.5125707675166723, 0.4229830315858718, 0.3689957636148615, 0.348991228064639, 0.30332922341016033, 0.4415459129462217, 0.4541815929633297, 0.3549684230928907, 0.3467985957792379, 0.28356545453622306, 0.32556290516588005, 0.2188497051889341, 0.2418107539248976, 0.24368097413467638, 0.23607526147585145, 0.31593998105334, 0.23239235865136088, 0.20352998790523702, 0.21774492540776402, 0.22415110298028362, 0.2195826876981739, 0.2064251018944928, 0.21745074484594673, 0.19958333876451295, 0.22900745878728945, 0.22044283687663413, 0.5946481664186042, 0.19398659209192115, 0.18970511251178757, 0.24883289253440577, 0.20709802905034902, 0.18459443440113832, 0.6798750065674051, 0.2240282023268375, 0.19845407718030117, 0.18509663303751245, 0.18710974420680715, 0.18039277587016822, 0.849833090498924, 0.8507391484175055, 0.19636050835226393, 0.16980631538886426, 0.16256495020797734, 0.8685660402109949, 0.600063938976556, 0.20957816572803833, 0.6965015549525937, 0.7269132966570104, 0.167201597342172, 0.16702193586490155, 0.15364799519923522, 0.6188670183946332, 0.16753291289362082, 0.18858977273946453, 0.18973945625638933, 0.19348944863099693, 0.18432711928247003, 0.1908367428529919, 0.20395156172625317, 0.19631251807758754, 0.19278102620381576, 0.18876174749672747, 0.08675304673639295, 0.08894252751994713, 0.11953306184243406, 0.08984920100857507, 0.0884159518086719, 0.08111148948508906, 0.09340065943666054, 0.07881180566370094, 0.09978263269094079]}, "mutation_prompt": null}
{"id": "5649d528-8f12-4468-8454-f70bd8f3024b", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A self-adaptive hybrid PSO-DE with chaotic mapping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8123846353719377, 0.8273395699437496, 0.866715624114302, 0.7900625463783781, 0.8458814637238938, 0.848271902151461, 0.8111966446361627, 0.8477831085162477, 0.8322081121400627, 0.5865506838469909, 0.6875306241682639, 0.6987819217703368, 0.5999667111575573, 0.6234930545918129, 0.6890536455865667, 0.6306436522021819, 0.650771750282064, 0.7252387348858683, 0.1607697242133761, 0.14408864101549657, 0.1716740665700499, 0.1491913315225991, 0.16179388965233743, 0.4464011808949019, 0.1579131038447844, 0.11659363518090615, 0.16449137417589876, 0.10325982731044225, 0.13244600549348384, 0.11222983261254305, 0.1374755566496002, 0.10647116371568044, 0.13812026312651038, 0.12451946415916604, 0.12204675912070195, 0.10601774239603257, 0.9693759321574814, 0.9510724509565366, 0.9707052043033023, 0.9736933166652405, 0.9803587023111814, 0.9740229023756408, 0.971153858387497, 0.945385939350902, 0.9508659087112127, 0.5699047578840767, 0.5444071970732796, 0.5638877461918343, 0.6228244076987617, 0.5942971286880754, 0.552778164681849, 0.49860782499205936, 0.6122614240444534, 0.5671519978783988, 0.8018589025719924, 0.218981463548377, 0.3551710924961833, 0.7966034902093948, 0.3663435083577915, 0.692761978048759, 0.23075000948210123, 0.6762549133358448, 0.7918970212962553, 0.21337490452924035, 0.12838820900334613, 0.21483715461573516, 0.24225805053673488, 0.12995524404858316, 0.29662553868501307, 0.18316642860191268, 0.2120793110436674, 0.19750540081327495, 0.19670988883603813, 0.23322083457225296, 0.19739827835467993, 0.19473688629372232, 0.1406209919916266, 0.22710996786497573, 0.2234158617559907, 0.21798877877631417, 0.22992853446152772, 0.022562099206959618, 0.15986780777095788, 0.012178540667405868, 9.999999999998899e-05, 9.999999999998899e-05, 0.030521118652637735, 0.005327779946864397, 0.039372752176436765, 0.1257014593649738, 0.06493664535738841, 0.09102065206785626, 0.12222231622289814, 0.07268422028465249, 0.16852560304814435, 0.06571985299627392, 0.1893703188684116, 0.1370799350222791, 0.05822240044767857, 0.12473466450426096, 0.2749582901079469, 0.13563626426792652, 0.0832325175494032, 0.1637345764626187, 0.0790493625393428, 0.15089730154368808, 0.14674639068139628, 0.13885011253874258, 0.1483199741812521, 0.20799441646565442, 0.15940943931732943, 0.3130287081075438, 0.12086289658511018, 0.14948081273379699, 0.10191138348248863, 0.12214246135964235, 0.08448729849046455, 0.5153033571417667, 0.5401741981878698, 0.5474348752228999, 0.5482646321229265, 0.5416391431729919, 0.5542685914559013, 0.5879490927306654, 0.5224975209215981, 0.5483132247282705, 0.10696937636244896, 0.12017068368975237, 0.09866926461239578, 0.10562359128017196, 0.10491037751394794, 0.14299795604885257, 0.114613546019531, 0.12540857030904462, 0.1395637465852697, 0.13936506996797793, 0.17408596788614372, 0.17076622454038803, 0.23977551065092484, 0.14358804234155886, 0.19966141504404733, 0.18409951488762089, 0.16624196306999983, 0.22888460739642258, 0.4076388296383252, 0.5125707675166723, 0.4229830315858718, 0.3689957636148615, 0.348991228064639, 0.30332922341016033, 0.4415459129462217, 0.4541815929633297, 0.3549684230928907, 0.3467985957792379, 0.28356545453622306, 0.32556290516588005, 0.2188497051889341, 0.2418107539248976, 0.24368097413467638, 0.23607526147585145, 0.31593998105334, 0.23239235865136088, 0.20352998790523702, 0.21774492540776402, 0.22415110298028362, 0.2195826876981739, 0.2064251018944928, 0.21745074484594673, 0.19958333876451295, 0.22900745878728945, 0.22044283687663413, 0.5946481664186042, 0.19398659209192115, 0.18970511251178757, 0.24883289253440577, 0.20709802905034902, 0.18459443440113832, 0.6798750065674051, 0.2240282023268375, 0.19845407718030117, 0.18509663303751245, 0.18710974420680715, 0.18039277587016822, 0.849833090498924, 0.8507391484175055, 0.19636050835226393, 0.16980631538886426, 0.16256495020797734, 0.8685660402109949, 0.600063938976556, 0.20957816572803833, 0.6965015549525937, 0.7269132966570104, 0.167201597342172, 0.16702193586490155, 0.15364799519923522, 0.6188670183946332, 0.16753291289362082, 0.18858977273946453, 0.18973945625638933, 0.19348944863099693, 0.18432711928247003, 0.1908367428529919, 0.20395156172625317, 0.19631251807758754, 0.19278102620381576, 0.18876174749672747, 0.08675304673639295, 0.08894252751994713, 0.11953306184243406, 0.08984920100857507, 0.0884159518086719, 0.08111148948508906, 0.09340065943666054, 0.07881180566370094, 0.09978263269094079]}, "mutation_prompt": null}
{"id": "ea3e9152-ed19-4a09-a9bf-57d786d3f579", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if np.random.rand() < chaotic_factor:  # Chaotic control of crossover\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A self-adaptive hybrid PSO-DE with chaotic mapping and adaptive inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8123846353719377, 0.8273395699437496, 0.866715624114302, 0.7900625463783781, 0.8458814637238938, 0.848271902151461, 0.8111966446361627, 0.8477831085162477, 0.8322081121400627, 0.5865506838469909, 0.6875306241682639, 0.6987819217703368, 0.5999667111575573, 0.6234930545918129, 0.6890536455865667, 0.6306436522021819, 0.650771750282064, 0.7252387348858683, 0.1607697242133761, 0.14408864101549657, 0.1716740665700499, 0.1491913315225991, 0.16179388965233743, 0.4464011808949019, 0.1579131038447844, 0.11659363518090615, 0.16449137417589876, 0.10325982731044225, 0.13244600549348384, 0.11222983261254305, 0.1374755566496002, 0.10647116371568044, 0.13812026312651038, 0.12451946415916604, 0.12204675912070195, 0.10601774239603257, 0.9693759321574814, 0.9510724509565366, 0.9707052043033023, 0.9736933166652405, 0.9803587023111814, 0.9740229023756408, 0.971153858387497, 0.945385939350902, 0.9508659087112127, 0.5699047578840767, 0.5444071970732796, 0.5638877461918343, 0.6228244076987617, 0.5942971286880754, 0.552778164681849, 0.49860782499205936, 0.6122614240444534, 0.5671519978783988, 0.8018589025719924, 0.218981463548377, 0.3551710924961833, 0.7966034902093948, 0.3663435083577915, 0.692761978048759, 0.23075000948210123, 0.6762549133358448, 0.7918970212962553, 0.21337490452924035, 0.12838820900334613, 0.21483715461573516, 0.24225805053673488, 0.12995524404858316, 0.29662553868501307, 0.18316642860191268, 0.2120793110436674, 0.19750540081327495, 0.19670988883603813, 0.23322083457225296, 0.19739827835467993, 0.19473688629372232, 0.1406209919916266, 0.22710996786497573, 0.2234158617559907, 0.21798877877631417, 0.22992853446152772, 0.022562099206959618, 0.15986780777095788, 0.012178540667405868, 9.999999999998899e-05, 9.999999999998899e-05, 0.030521118652637735, 0.005327779946864397, 0.039372752176436765, 0.1257014593649738, 0.06493664535738841, 0.09102065206785626, 0.12222231622289814, 0.07268422028465249, 0.16852560304814435, 0.06571985299627392, 0.1893703188684116, 0.1370799350222791, 0.05822240044767857, 0.12473466450426096, 0.2749582901079469, 0.13563626426792652, 0.0832325175494032, 0.1637345764626187, 0.0790493625393428, 0.15089730154368808, 0.14674639068139628, 0.13885011253874258, 0.1483199741812521, 0.20799441646565442, 0.15940943931732943, 0.3130287081075438, 0.12086289658511018, 0.14948081273379699, 0.10191138348248863, 0.12214246135964235, 0.08448729849046455, 0.5153033571417667, 0.5401741981878698, 0.5474348752228999, 0.5482646321229265, 0.5416391431729919, 0.5542685914559013, 0.5879490927306654, 0.5224975209215981, 0.5483132247282705, 0.10696937636244896, 0.12017068368975237, 0.09866926461239578, 0.10562359128017196, 0.10491037751394794, 0.14299795604885257, 0.114613546019531, 0.12540857030904462, 0.1395637465852697, 0.13936506996797793, 0.17408596788614372, 0.17076622454038803, 0.23977551065092484, 0.14358804234155886, 0.19966141504404733, 0.18409951488762089, 0.16624196306999983, 0.22888460739642258, 0.4076388296383252, 0.5125707675166723, 0.4229830315858718, 0.3689957636148615, 0.348991228064639, 0.30332922341016033, 0.4415459129462217, 0.4541815929633297, 0.3549684230928907, 0.3467985957792379, 0.28356545453622306, 0.32556290516588005, 0.2188497051889341, 0.2418107539248976, 0.24368097413467638, 0.23607526147585145, 0.31593998105334, 0.23239235865136088, 0.20352998790523702, 0.21774492540776402, 0.22415110298028362, 0.2195826876981739, 0.2064251018944928, 0.21745074484594673, 0.19958333876451295, 0.22900745878728945, 0.22044283687663413, 0.5946481664186042, 0.19398659209192115, 0.18970511251178757, 0.24883289253440577, 0.20709802905034902, 0.18459443440113832, 0.6798750065674051, 0.2240282023268375, 0.19845407718030117, 0.18509663303751245, 0.18710974420680715, 0.18039277587016822, 0.849833090498924, 0.8507391484175055, 0.19636050835226393, 0.16980631538886426, 0.16256495020797734, 0.8685660402109949, 0.600063938976556, 0.20957816572803833, 0.6965015549525937, 0.7269132966570104, 0.167201597342172, 0.16702193586490155, 0.15364799519923522, 0.6188670183946332, 0.16753291289362082, 0.18858977273946453, 0.18973945625638933, 0.19348944863099693, 0.18432711928247003, 0.1908367428529919, 0.20395156172625317, 0.19631251807758754, 0.19278102620381576, 0.18876174749672747, 0.08675304673639295, 0.08894252751994713, 0.11953306184243406, 0.08984920100857507, 0.0884159518086719, 0.08111148948508906, 0.09340065943666054, 0.07881180566370094, 0.09978263269094079]}, "mutation_prompt": null}
{"id": "57794e16-3db5-41df-864b-fd6fdb790265", "solution": "import numpy as np\n\nclass AdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = (0.5 + chaotic_factor) * self.w  # Reduced inertia weight influence\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9 if chaotic_factor > 0.5 else 0.7  # Dynamic crossover rate\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "AdaptiveChaoticHybridPSODE", "description": "A dynamic hybrid PSO-DE algorithm with chaotic influence and adaptive inertia for improved convergence and diversity.", "configspace": "", "generation": 85, "fitness": 0.21200382469969664, "feedback": "The algorithm AdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.4195031182822013, 0.507588519799497, 0.41298722112374175, 0.4375190202421133, 0.5194504419713059, 0.5286062163459961, 0.45937642435152826, 0.5152737363856943, 0.5390004220056981, 0.11546714148965564, 0.05308617202044663, 0.15160431697376697, 0.05390338413953799, 0.02835025544411529, 0.10629331281991583, 0.02836141807477177, 0.07554080817840436, 0.2526196627874132, 0.08931509946561833, 0.119822401629747, 0.1120902084243286, 0.12294177794779138, 0.1079962058243511, 0.098140716440283, 0.11102574872373261, 0.1614901295923431, 0.12222904139297353, 0.08425238593921547, 0.08204642397519113, 0.10427428657745275, 0.10142615215151307, 0.08813031993514109, 0.10401098048126589, 0.07316984986561459, 0.11355266092128691, 0.11730933002087529, 0.972564547363507, 0.9777923647632161, 0.9768945748484281, 0.9770299349254526, 0.9753726233975372, 0.9729534343288702, 0.9741873809389997, 0.971497333881202, 0.9795743830761441, 0.22883059401494832, 0.2259144283785347, 0.25180887692076337, 0.2032293202964146, 0.2481476828340876, 0.2684192201823936, 0.22124206758064469, 0.08657478685936026, 0.23239831153132184, 0.2608996355675808, 0.16983181317935891, 0.21161910779029447, 0.1825048905477228, 0.2031827154343253, 0.199358829644547, 0.25109417202508044, 0.405564468399085, 0.2788324333564304, 0.10720702616120359, 0.13880384015673386, 0.12609932047996464, 0.09937270304164736, 0.1325802353517187, 0.08143724527051999, 0.12337070934385175, 0.10555528957285365, 0.12174360440340604, 0.10670789404028469, 0.09929032176572783, 0.12847798820550993, 0.12515313607311707, 0.11849988779276899, 0.180701055163498, 0.1417810131333952, 0.12161820092806297, 0.06426608889910146, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00022961525957398976, 9.999999999998899e-05, 9.999999999998899e-05, 0.007909915658748101, 0.0068225760458319185, 0.04018702929419182, 0.10147894282511383, 0.07536812404379156, 0.059475605669204956, 0.07326331620809035, 0.021277953568332175, 0.0718840676454745, 0.11327938703847462, 0.060776744980414854, 0.0773758556594748, 0.009047615426196698, 0.0805531624038558, 0.04678624455586777, 0.017813323754960364, 0.046194772322579625, 0.06351168045772393, 0.022979085672422683, 0.02716582218018737, 0.05484997305320083, 0.07197718756049853, 0.07642861410056845, 0.040570696884142166, 0.1143239677246789, 0.09704366726053792, 0.10497317062094136, 0.054776857262655354, 0.09318013002242764, 0.14405555932561276, 0.36966994263352626, 0.4069557496608951, 0.40003954123763297, 0.3461319666900945, 0.4437078146827613, 0.4283718678899068, 0.35312366419207697, 0.39214045613993587, 0.40567209658181325, 0.09709308495630664, 0.10562764924211787, 0.12065223859833407, 0.10616399819406852, 0.10556806938070751, 0.1009352356836054, 0.11960729384411173, 0.10814362472726258, 0.09765937149372605, 0.16533674898699524, 0.16571092293799372, 0.16567904000437716, 0.2061283952883206, 0.209624071964844, 0.20333047493031275, 0.18130897211417396, 0.17482842581480296, 0.20458154693132524, 0.24188709625132399, 0.28999617383493403, 0.2986576155505779, 0.24213542049731818, 0.29695042559962415, 0.29170740551485586, 0.27996928575310376, 0.3101227046012174, 0.2840957333048013, 0.16806805706424877, 0.18124931098630992, 0.20575251351981938, 0.1893884968083681, 0.19666845559073076, 0.17396405911282198, 0.20901995996483747, 0.2178668863012586, 0.18372778282688285, 0.1833458497037681, 0.17544097463236885, 0.19123552255287368, 0.19272249913651907, 0.261742698387623, 0.18396313992003688, 0.1882447511762495, 0.19881394678015363, 0.1837647372563227, 0.1942674643985196, 0.17938617755572972, 0.18505227892689757, 0.19141012145319458, 0.22005940265399893, 0.21047129068471582, 0.17376165582304037, 0.17810821795911924, 0.18563020671955355, 0.4553303335549297, 0.18010627378110478, 0.148903958518792, 0.17355527407100835, 0.1890328282017525, 0.5955846079935319, 0.48566368314632635, 0.16406902926644218, 0.42216126264610754, 0.3265911435473553, 0.20616087689753526, 0.4032456458641508, 0.49769338486559966, 0.1625404454054835, 0.18713136403069908, 0.1905353921258447, 0.19781048250893996, 0.4247962994618979, 0.1867311267248476, 0.18639894639778443, 0.18212515390979056, 0.2082284631844743, 0.20355351054017723, 0.18739252007480034, 0.16698460794690184, 0.2160767495996807, 0.19053063787974678, 0.07333503847281486, 0.08064639600139234, 0.07221657873462539, 0.07731660954570829, 0.07517116033643256, 0.08257083419690048, 0.076873402514957, 0.08401335678149502, 0.08550670471877997]}, "mutation_prompt": null}
{"id": "606ac9ab-3ed0-4b69-b187-09e255a0f447", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.num_swarms = 4\n        self.swarm_size = self.population_size // self.num_swarms\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_positions = [None] * self.num_swarms\n        self.gbest_scores = [np.inf] * self.num_swarms\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor = 0.7\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for swarm_id in range(self.num_swarms):\n                swarm_start = swarm_id * self.swarm_size\n                swarm_end = swarm_start + self.swarm_size\n\n                for i in range(swarm_start, swarm_end):\n                    score = func(self.particles[i])\n                    evaluations += 1\n\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.particles[i]\n\n                    if score < self.gbest_scores[swarm_id]:\n                        self.gbest_scores[swarm_id] = score\n                        self.gbest_positions[swarm_id] = self.particles[i]\n\n                    if evaluations >= self.budget:\n                        break\n\n                for i in range(swarm_start, swarm_end):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    inertia = chaotic_factor\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (self.gbest_positions[swarm_id] - self.particles[i])\n                    self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                if evaluations < self.budget:\n                    for i in range(swarm_start, swarm_end):\n                        indices = [idx for idx in range(swarm_start, swarm_end) if idx != i]\n                        a, b, c = np.random.choice(indices, 3, replace=False)\n                        mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                        \n                        crossover_rate = 0.8 + 0.1 * chaotic_factor\n                        crossover_mask = np.random.rand(self.dim) < crossover_rate\n                        trial = np.where(crossover_mask, mutant, self.particles[i])\n                        \n                        trial_score = func(trial)\n                        evaluations += 1\n\n                        if trial_score < self.pbest_scores[i]:\n                            self.pbest_scores[i] = trial_score\n                            self.pbest_positions[i] = trial\n\n                        if trial_score < self.gbest_scores[swarm_id]:\n                            self.gbest_scores[swarm_id] = trial_score\n                            self.gbest_positions[swarm_id] = trial\n\n                        if evaluations >= self.budget:\n                            break\n\n        overall_best_score = min(self.gbest_scores)\n        overall_best_position = self.gbest_positions[np.argmin(self.gbest_scores)]\n        return overall_best_score, overall_best_position", "name": "DynamicMultiSwarmPSODE", "description": "Dynamic Multi-Swarm Hybrid PSO-DE with Chaotic Dynamics: Employs multi-swarm strategies and dynamic parameter tuning using chaotic variables for enhanced convergence.", "configspace": "", "generation": 86, "fitness": 0.30641145771485845, "feedback": "The algorithm DynamicMultiSwarmPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.7526078947092515, 0.7855940990035026, 0.7894071737400603, 0.7865067380937962, 0.7858369398000723, 0.8010082643131542, 0.8007274824997048, 0.8050177986470358, 0.7805050546288219, 0.4908820762768905, 0.588973059487897, 0.5844824825763946, 0.5257699803297653, 0.6037986215204267, 0.596769975612451, 0.5261036944347752, 0.5455376744894469, 0.5667635255888795, 0.395518041487282, 0.13595042223257459, 0.15608593757654377, 0.13924213342107228, 0.14330428211455015, 0.1633971777522507, 0.15863161652522395, 0.11881705135728149, 0.1348711249223521, 0.10046911309443274, 0.12299122190727485, 0.1028763180889739, 0.10498588285384436, 0.12605502855013728, 0.09839848830373721, 0.12454811803408483, 0.14167616317869702, 0.11209795555475499, 0.9662227692246076, 0.9419830525522134, 0.9315631688852022, 0.9709834598270997, 0.9455813103959603, 0.9687441701847856, 0.9666929647246616, 0.9564145236680367, 0.9572802212945393, 0.48334165087782477, 0.4886722485417283, 0.5414917558568011, 0.4927290107317466, 0.46176350495401697, 0.4570052432055244, 0.45771503416198267, 0.5098665612734751, 0.47289351720512574, 0.34736610474489515, 0.36393360919873574, 0.33867295946291553, 0.2596444265363903, 0.2622523511902177, 0.2657140995759544, 0.586789245757394, 0.33339944734223936, 0.3147031240316486, 0.16406836788607615, 0.15476631711197153, 0.16156458313926614, 0.2134164110756871, 0.15738838493059681, 0.29335656509256924, 0.2777980202408745, 0.22987270031452478, 0.1479170135557466, 0.1828574482167401, 0.16322259306581421, 0.2837303614987289, 0.1775695411222843, 0.252421807704319, 0.2288341801824938, 0.3937474623117543, 0.21266315295903826, 0.2261260935206605, 0.0034210938073802044, 0.015557093246184373, 0.031890368242025735, 0.029156483420886836, 0.01046909824575526, 0.003360170135681795, 0.05885460914791507, 0.013225294209233462, 0.031070943194537404, 0.06411318234357566, 0.04705914062946759, 0.09151593135551317, 0.06837326153362477, 0.0549168725660798, 0.056059154584363724, 0.05356815295430484, 0.12788282543094998, 0.09854920392312727, 0.08507229436613983, 0.2340626009707938, 0.11653751213081798, 0.10496866857601184, 0.20037899123104796, 0.1592501114347029, 0.14941893736496803, 0.1339921769796798, 0.18424429845564738, 0.26192106875505916, 0.13753871314561017, 0.2137273687782022, 0.12460268333126934, 0.14264087985051377, 0.23555425274644248, 0.10613691368188793, 0.27911853316559143, 0.15365981212304702, 0.47021705401664815, 0.4810950547753099, 0.48955795730727003, 0.531802580190224, 0.5077930222729148, 0.5124736700656962, 0.49521198696490754, 0.4826395753442947, 0.5092575798961598, 0.1008579049706474, 0.12316306974770874, 0.12504699001763253, 0.10602169603087752, 0.24579920878938688, 0.12658096126661533, 0.14582210890897462, 0.12022792884728983, 0.10967059730164253, 0.15965734912132923, 0.2293699318083955, 0.3037536527194089, 0.22698310289284718, 0.1874293165652131, 0.2429162088148492, 0.21832514454707275, 0.16113681295419846, 0.20717499431405917, 0.3423860277759563, 0.2983420790294641, 0.3329884388753561, 0.313953275197418, 0.40875844820348417, 0.27984075230915384, 0.365931896638642, 0.36650881897401333, 0.3462722944480522, 0.2561810254356668, 0.20900350613958585, 0.30326794757442044, 0.2431865143830254, 0.24572845892865747, 0.24501617148819566, 0.23147324585552975, 0.2858583982172812, 0.2369388745952311, 0.2270798616985188, 0.21853077485782446, 0.24676058951116298, 0.21416197953018667, 0.2215676480936426, 0.2153223287582131, 0.21389635616421254, 0.23647640587541074, 0.24220315718091334, 0.1938266772996946, 0.20759857430081752, 0.20348695401887684, 0.22974589151419722, 0.2140244769006744, 0.21467292221476542, 0.1829780399123372, 0.21702665993832138, 0.1965911082138847, 0.19579042746432407, 0.5930751089961768, 0.6461900369912821, 0.7684342623442606, 0.7191316728649997, 0.7912476383683875, 0.1725698756392987, 0.17437265393704582, 0.6682621454789323, 0.5583605980079904, 0.2083348328542719, 0.47406363521790995, 0.400366787938499, 0.32750879657751986, 0.30283758777254466, 0.3473439834665929, 0.39730695204188926, 0.47014407614966336, 0.18791349436486937, 0.18228961800958332, 0.18950815875875826, 0.20193917532277061, 0.22347245393392112, 0.21013115482796152, 0.1749260427765128, 0.22080354850881234, 0.19465422001349453, 0.09734256881564529, 0.08422636030389608, 0.08246652899678208, 0.09851733586660172, 0.09099145080028737, 0.08463699690814541, 0.08921581929739308, 0.10329666900783796, 0.0828123091798969]}, "mutation_prompt": null}
{"id": "9fde781d-a420-4357-8d51-8361cac25a05", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial = 0.7\n        self.scale_factor_final = 0.9\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if chaotic_factor > 0.7:\n                        crossover_rate = 0.95\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "An enhanced PSO-DE algorithm with adaptive chaos-driven mutation and crossover strategies for improved convergence.", "configspace": "", "generation": 87, "fitness": 0.3321928380823368, "feedback": "The algorithm EnhancedAdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "d7157bd9-b6ef-44fb-b2e2-30398212f5e9", "metadata": {"aucs": [0.8513058006042155, 0.8308938040275569, 0.8475640552261914, 0.8295032018467265, 0.8633754388533107, 0.8683100732594082, 0.8410523099400489, 0.8405047851488153, 0.8132618704432787, 0.6894855883112657, 0.7192872722732038, 0.6317638913261475, 0.6285993249108237, 0.6960552354711032, 0.7014249732667424, 0.6073244352086298, 0.6807546069504229, 0.6686570919479535, 0.15089643650866924, 0.1538385967410384, 0.15481247382642527, 0.15761073200566045, 0.16295183778528444, 0.16797344616979548, 0.1719810494947076, 0.1620511118396758, 0.17137752320008115, 0.13112941735192252, 0.11720260211148048, 0.13233118814994782, 0.14615698860963622, 0.12845932725411913, 0.11098721238577836, 0.13909620242340826, 0.13043400276150263, 0.12933406544135362, 0.9542582969187429, 0.9489186342300109, 0.969254904358815, 0.9745725746372188, 0.9402351265040134, 0.9657023839194914, 0.9666399936244763, 0.9506280288613715, 0.9728132525010508, 0.5897875639503581, 0.5807335043066102, 0.5701516483988986, 0.6047976671686327, 0.5912295334248665, 0.6277853481180182, 0.5904892043288615, 0.571761811106748, 0.5889124769709067, 0.6956472653725658, 0.7465841020190925, 0.7725392027048646, 0.21511542346683676, 0.2526932551321657, 0.19135334966627027, 0.22451281085842034, 0.3542670545699752, 0.7701844345604476, 0.123351150665298, 0.12612712537554527, 0.18809238504413017, 0.12531732425869557, 0.22647685190770894, 0.12906560189079974, 0.21309919679653688, 0.31490662507634826, 0.2070885110844739, 0.18969438392436755, 0.3598192142973642, 0.1276643984403819, 0.22685185906722338, 0.1630920701466786, 0.21448306684195484, 0.23499930241092326, 0.1901397407056884, 0.18917666048611914, 0.05702149526027678, 0.005249829241253834, 0.016999013581666667, 9.999999999998899e-05, 0.010891313733964125, 0.018496950650467858, 0.03857295861443222, 0.003206160538479108, 0.08560881650520036, 0.09257502660446115, 0.08822158631190324, 0.10770722136547572, 0.0989881404442613, 0.11662584280628885, 0.08756392500978383, 0.0944360274942726, 0.1335469756033415, 0.10376480960235346, 0.2606875582968662, 0.13383887695597896, 0.1371880694263844, 0.13121243341796962, 0.19540044621252495, 0.1746775885408881, 0.10827203238935523, 0.14167299678172163, 0.08937862645415151, 0.29582378502591455, 0.05057173226137346, 0.12356014461745579, 0.16182778467805126, 0.04946619592939405, 0.23156152376042205, 0.17690912360970046, 0.11958256069272888, 0.2230534538392458, 0.5200289775430155, 0.5363276299940998, 0.5218226014702242, 0.5588764802959345, 0.5513763509117562, 0.5177517590938931, 0.551890839998546, 0.5742881200093334, 0.5451386171932737, 0.11400121374705507, 0.14068442681109394, 0.13091398345163563, 0.14889159761021675, 0.13718162862743133, 0.11758302695926703, 0.10909586039567754, 0.1027863914024929, 0.1287130989960158, 0.2373757200622898, 0.3053293600853838, 0.17080619078266845, 0.2567948455884591, 0.29146898879768235, 0.27540516248712266, 0.224353632135613, 0.18596260403002784, 0.1823278669898467, 0.27453728897190854, 0.41149056655489535, 0.2756109878130236, 0.35194593061037527, 0.40697865204242756, 0.28567847703015703, 0.4175958359004528, 0.44176274592687803, 0.4629118636875694, 0.22057179061416876, 0.1912135308506957, 0.3133631623090304, 0.2935574624155495, 0.2687684109613968, 0.24571374106931898, 0.30860528713413615, 0.27927318775872945, 0.22084964424227738, 0.2156256849696071, 0.24703209187185016, 0.23611169887661854, 0.20937515344782864, 0.18458918944858205, 0.22529095339970473, 0.2633374786615512, 0.19153263120262254, 0.22300975503635811, 0.2327571357416055, 0.2145526168356119, 0.205925603818102, 0.19664587719603066, 0.2401606412547005, 0.23129255143283822, 0.18334177207531477, 0.19474806321279026, 0.2059577719297877, 0.7802543408987682, 0.5682698025738092, 0.20944421838041138, 0.8592177703698552, 0.7402122034372836, 0.7592173360378112, 0.8016107028375397, 0.1670923097544319, 0.8358954860738197, 0.6670574157114173, 0.21016258533237875, 0.7574020663107375, 0.2079404422028669, 0.30599111974002713, 0.20477003241613256, 0.20829114874654042, 0.7019961588383166, 0.5859210178377897, 0.18458554324425835, 0.19360519360329376, 0.19039230346324798, 0.19462534305527734, 0.2040795532821721, 0.18221272521110266, 0.2212451418212641, 0.182954777728784, 0.1925819132135147, 0.09097293296330733, 0.08963409834740466, 0.08561541751302304, 0.09066974530882144, 0.08566001146415492, 0.08703364647376843, 0.09689044471427455, 0.08501496330410518, 0.09321758236417554]}, "mutation_prompt": null}
{"id": "fa0a3aa4-9af0-42ca-83c5-f9412d2acc0b", "solution": "import numpy as np\n\nclass EnhancedQuantumAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial = 0.7\n        self.scale_factor_final = 0.9\n\n    def quantum_superposition(self, particle, gbest):\n        delta = np.random.uniform(-1.0, 1.0, self.dim)\n        return 0.5 * (particle + gbest) + delta\n\n    def __call__(self, func):\n        evaluations = 0\n        omega = 0.5  # Quantum-inspired coefficient\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                self.particles[i] = self.quantum_superposition(self.particles[i], self.gbest_position)\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedQuantumAdaptiveHybridPSODE", "description": "An Adaptive Quantum-Inspired PSO-DE Hybrid Algorithm utilizing quantum superposition and crossover to enhance search space exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.15359436054007491, "feedback": "The algorithm EnhancedQuantumAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.15.", "error": "", "parent_id": "9fde781d-a420-4357-8d51-8361cac25a05", "metadata": {"aucs": [0.22830606787005703, 0.26134511470742516, 0.2680173669545537, 0.2456238580505946, 0.2920595379882017, 0.2630973106960628, 0.26676132834749655, 0.2684063012506054, 0.290729369475086, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0820394282597321, 0.09812731845287381, 0.1022751721297438, 0.053331747672280105, 0.07420093141895956, 0.07336293896442037, 0.07012605487428081, 0.10996282308788763, 0.0765358385673861, 0.0762017422145127, 0.07506984070274814, 0.07580711871460732, 0.06300406842973516, 0.04926061357969613, 0.0775657232260395, 0.05239474917053666, 0.045916212861869976, 0.057156382604610756, 0.880238629577455, 0.3125044074032497, 0.8815583224603445, 0.1938953624580385, 0.8858024508839436, 0.9047294979900442, 0.8884703300000064, 0.9017308017673388, 0.2609449850331541, 0.16859364417354916, 0.12317122869824271, 0.15236357093120168, 0.14894923169553365, 0.17675264170255345, 0.1639833883422419, 0.13027209587814992, 0.17795242294929137, 0.1487294456607844, 0.20967551983216548, 0.15152649787923167, 0.18721819115962357, 0.2160334504314707, 0.17263428902620148, 0.22766616136231543, 0.17415232918478019, 0.21336408417383879, 0.13656267346985873, 0.08535280405715151, 0.07632736181049826, 0.07889547457225776, 0.030778322648561507, 0.1035585276152613, 9.999999999998899e-05, 0.09454484048790635, 0.11267606116186812, 0.08081516263534883, 0.11896086397269734, 0.11490952220386841, 0.09403328155480961, 0.13286641403689992, 0.09529005611826413, 0.08490463473980503, 0.05841316906929028, 0.02057375147242091, 0.06202555311322211, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08579909946402164, 0.13697348836794299, 0.10118826724033336, 0.08892923815068121, 0.09535388649715404, 0.03050643274431586, 0.11494226301683352, 0.12982666887265515, 0.04544643778887236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038153525080046324, 0.003091872764959036, 0.055536975265837674, 0.04213763871737808, 0.03337252822030545, 0.03130031629360075, 0.06065653171954688, 0.031282295185523834, 0.026093372508028234, 0.28164231449725996, 0.32669424037494466, 0.2960592496200496, 0.28755394176619997, 0.2682620331229082, 0.2390882707219062, 0.32638319372490365, 0.28396364487765546, 0.2890025137242135, 0.07554548753471102, 0.06909676134240073, 0.07053099588661493, 0.05962026676338683, 0.08147629511910437, 0.0896451931547475, 0.06695390492652442, 0.07368473528496089, 0.09423736388282755, 0.14183818088858702, 0.15565373011604555, 0.14483590233809196, 0.14709682284683623, 0.15008757463904443, 0.12641338568633165, 0.1553012702558494, 0.12836000692792437, 0.17946810860848306, 0.18196546135190306, 0.20957322039523296, 0.22199048171294, 0.23072805116430473, 0.19860282206554047, 0.19208364809563983, 0.2262717677278071, 0.222248981767042, 0.24186562946963486, 0.13516298408887473, 0.11266790948913807, 0.146944597519179, 0.138906630410489, 0.14735147781204416, 0.16147135473058827, 0.16236127741462625, 0.1814393485799526, 0.15298872050303458, 0.17491599386012624, 0.19203915293921248, 0.2080641278229015, 0.17756374338870629, 0.18828195073351472, 0.19191631651387697, 0.19546934201204114, 0.2281283958820436, 0.18128357694126263, 0.16975375014372818, 0.17369197375424772, 0.17977997917453337, 0.16421926916429197, 0.18885395669332317, 0.15835734110579147, 0.1676133520554104, 0.16332134395084852, 0.16895164924047346, 0.33090892034109165, 0.17430186042417628, 0.13851340845323779, 0.24318525159735993, 0.17681250296180984, 0.17927625963321192, 0.1270406540208815, 0.19890365965322276, 0.3104314958274903, 0.3210847501496229, 0.23358504083828835, 0.3041738861796467, 0.27173944702880726, 0.2627272283423092, 0.14146075634689625, 0.28002813722256037, 0.28682574393957516, 0.2529001456483154, 0.19745892968302947, 0.1772340723491982, 0.17457626041298968, 0.18832891871520663, 0.19088538897476748, 0.1928886968874216, 0.1765326966524181, 0.1838051882063101, 0.18354099562065218, 0.05117407312369382, 0.07090739268554902, 0.0697558593336769, 0.08520325348854918, 0.07502168519009633, 0.08722510548520002, 0.07468537032966882, 0.06618044547775603, 0.06727617355989701]}, "mutation_prompt": null}
{"id": "53c3172e-e3e3-4610-a4ab-6cbd27ec8195", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 40\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.5, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.5\n        self.w_initial, self.w_final = 0.9, 0.4\n        self.scale_factor_initial = 0.7\n        self.scale_factor_final = 0.9\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.8\n                    if chaotic_factor > 0.7:\n                        crossover_rate = 0.95\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "An enhanced PSO-DE algorithm with adaptive chaos-driven mutation and crossover strategies for improved convergence.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fde781d-a420-4357-8d51-8361cac25a05", "metadata": {"aucs": [0.8513058006042155, 0.8308938040275569, 0.8475640552261914, 0.8295032018467265, 0.8633754388533107, 0.8683100732594082, 0.8410523099400489, 0.8405047851488153, 0.8132618704432787, 0.6894855883112657, 0.7192872722732038, 0.6317638913261475, 0.6285993249108237, 0.6960552354711032, 0.7014249732667424, 0.6073244352086298, 0.6807546069504229, 0.6686570919479535, 0.15089643650866924, 0.1538385967410384, 0.15481247382642527, 0.15761073200566045, 0.16295183778528444, 0.16797344616979548, 0.1719810494947076, 0.1620511118396758, 0.17137752320008115, 0.13112941735192252, 0.11720260211148048, 0.13233118814994782, 0.14615698860963622, 0.12845932725411913, 0.11098721238577836, 0.13909620242340826, 0.13043400276150263, 0.12933406544135362, 0.9542582969187429, 0.9489186342300109, 0.969254904358815, 0.9745725746372188, 0.9402351265040134, 0.9657023839194914, 0.9666399936244763, 0.9506280288613715, 0.9728132525010508, 0.5897875639503581, 0.5807335043066102, 0.5701516483988986, 0.6047976671686327, 0.5912295334248665, 0.6277853481180182, 0.5904892043288615, 0.571761811106748, 0.5889124769709067, 0.6956472653725658, 0.7465841020190925, 0.7725392027048646, 0.21511542346683676, 0.2526932551321657, 0.19135334966627027, 0.22451281085842034, 0.3542670545699752, 0.7701844345604476, 0.123351150665298, 0.12612712537554527, 0.18809238504413017, 0.12531732425869557, 0.22647685190770894, 0.12906560189079974, 0.21309919679653688, 0.31490662507634826, 0.2070885110844739, 0.18969438392436755, 0.3598192142973642, 0.1276643984403819, 0.22685185906722338, 0.1630920701466786, 0.21448306684195484, 0.23499930241092326, 0.1901397407056884, 0.18917666048611914, 0.05702149526027678, 0.005249829241253834, 0.016999013581666667, 9.999999999998899e-05, 0.010891313733964125, 0.018496950650467858, 0.03857295861443222, 0.003206160538479108, 0.08560881650520036, 0.09257502660446115, 0.08822158631190324, 0.10770722136547572, 0.0989881404442613, 0.11662584280628885, 0.08756392500978383, 0.0944360274942726, 0.1335469756033415, 0.10376480960235346, 0.2606875582968662, 0.13383887695597896, 0.1371880694263844, 0.13121243341796962, 0.19540044621252495, 0.1746775885408881, 0.10827203238935523, 0.14167299678172163, 0.08937862645415151, 0.29582378502591455, 0.05057173226137346, 0.12356014461745579, 0.16182778467805126, 0.04946619592939405, 0.23156152376042205, 0.17690912360970046, 0.11958256069272888, 0.2230534538392458, 0.5200289775430155, 0.5363276299940998, 0.5218226014702242, 0.5588764802959345, 0.5513763509117562, 0.5177517590938931, 0.551890839998546, 0.5742881200093334, 0.5451386171932737, 0.11400121374705507, 0.14068442681109394, 0.13091398345163563, 0.14889159761021675, 0.13718162862743133, 0.11758302695926703, 0.10909586039567754, 0.1027863914024929, 0.1287130989960158, 0.2373757200622898, 0.3053293600853838, 0.17080619078266845, 0.2567948455884591, 0.29146898879768235, 0.27540516248712266, 0.224353632135613, 0.18596260403002784, 0.1823278669898467, 0.27453728897190854, 0.41149056655489535, 0.2756109878130236, 0.35194593061037527, 0.40697865204242756, 0.28567847703015703, 0.4175958359004528, 0.44176274592687803, 0.4629118636875694, 0.22057179061416876, 0.1912135308506957, 0.3133631623090304, 0.2935574624155495, 0.2687684109613968, 0.24571374106931898, 0.30860528713413615, 0.27927318775872945, 0.22084964424227738, 0.2156256849696071, 0.24703209187185016, 0.23611169887661854, 0.20937515344782864, 0.18458918944858205, 0.22529095339970473, 0.2633374786615512, 0.19153263120262254, 0.22300975503635811, 0.2327571357416055, 0.2145526168356119, 0.205925603818102, 0.19664587719603066, 0.2401606412547005, 0.23129255143283822, 0.18334177207531477, 0.19474806321279026, 0.2059577719297877, 0.7802543408987682, 0.5682698025738092, 0.20944421838041138, 0.8592177703698552, 0.7402122034372836, 0.7592173360378112, 0.8016107028375397, 0.1670923097544319, 0.8358954860738197, 0.6670574157114173, 0.21016258533237875, 0.7574020663107375, 0.2079404422028669, 0.30599111974002713, 0.20477003241613256, 0.20829114874654042, 0.7019961588383166, 0.5859210178377897, 0.18458554324425835, 0.19360519360329376, 0.19039230346324798, 0.19462534305527734, 0.2040795532821721, 0.18221272521110266, 0.2212451418212641, 0.182954777728784, 0.1925819132135147, 0.09097293296330733, 0.08963409834740466, 0.08561541751302304, 0.09066974530882144, 0.08566001146415492, 0.08703364647376843, 0.09689044471427455, 0.08501496330410518, 0.09321758236417554]}, "mutation_prompt": null}
{"id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 90, "fitness": 0.3388963224840045, "feedback": "The algorithm EnhancedAdaptiveChaoticHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "9fde781d-a420-4357-8d51-8361cac25a05", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "b3e08fac-ea40-4a23-ae9f-a185bfdc3e4b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "7712b6cd-e3c7-46af-a56c-d62c7fc715e8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "6a2477cb-04e6-42ce-b116-8481010f25f8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "d9001218-a2ff-4d91-a735-215b4e9c105f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "b4db9182-113b-4697-b5c6-421dec216354", "solution": "import numpy as np\n\nclass DynamicEnsembleChaoticPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 60  # Adjusted population size for dynamic ensemble\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.3  # Slightly reduced velocity scaling\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1, self.c2 = 2.0, 2.0  # Fixed cognitive and social parameters for simplicity\n        self.w_initial, self.w_final = 0.9, 0.4    # Broadened inertia weight range\n        self.scale_factor_initial = 0.6\n        self.scale_factor_final = 0.9\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            if evaluations < 0.3 * self.budget:  # Use PSO in the initial phase\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    inertia = chaotic_factor\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                    self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            else:  # Switch to DE in the latter phase\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    crossover_rate = 0.8\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n            # Adaptive re-initialization strategy\n            if evaluations / self.budget > 0.7 and np.all(np.abs(self.velocities) < 0.01):\n                self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.3\n\n        return self.gbest_score, self.gbest_position", "name": "DynamicEnsembleChaoticPSODE", "description": "Dynamic ensemble approach combining chaotic PSO and DE with adaptive re-initialization for enhanced exploration and exploitation trade-off.", "configspace": "", "generation": 95, "fitness": 0.21404210679522068, "feedback": "The algorithm DynamicEnsembleChaoticPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.5930806237828523, 0.7186460782092373, 0.5434665255169971, 0.6462873400677095, 0.6397391440432989, 0.47570318905989795, 0.523947707081869, 0.5817418334797086, 0.5273688156649288, 0.039000151756634294, 0.03927866215162923, 0.19408118058632973, 0.14444893973320172, 0.03614796476616633, 9.999999999998899e-05, 0.23332153774090925, 0.16012162162843202, 0.043790291163647965, 0.12928325556550446, 0.1223874193750053, 0.08099468283144284, 0.10651999203509765, 0.13389229482651577, 0.11998089985963234, 0.09245279889802527, 0.14296895770826923, 0.11808522850458503, 0.0774134188773723, 0.04939031077089984, 0.10010366356068567, 0.09448670373589918, 0.10675273229119087, 0.10105211966940264, 0.1332090114920106, 0.1345539091901914, 0.09096105236145335, 0.9860370871103993, 0.9780305997733925, 0.9838824747456898, 0.9679826214650921, 0.9785640834631839, 0.9821962642968827, 0.9888868321487502, 0.9887164735942819, 0.9782083096579887, 0.1680838185475706, 0.29427336280086225, 0.11816577212309332, 0.21367759944831055, 0.2619328861404804, 0.24499646987751456, 0.08676386897724919, 0.08859737607210316, 0.08820406307227746, 0.22433233216085857, 0.17050827370461774, 0.2971987587198166, 0.2104140339432814, 0.19239876117587384, 0.2710149360798897, 0.3178036300083257, 0.18847849959303709, 0.30641132687363193, 0.14817383034709497, 0.13609356924821714, 0.10253000536195611, 0.09708939905331682, 0.1463368926653117, 0.103725020530542, 0.1322171835267233, 0.13061892210510018, 0.14723137237515582, 0.14334020522914293, 0.08228392349262681, 0.1295276933190973, 0.12683695707836518, 0.1474134878462775, 0.13853338766973355, 0.14953383893941408, 0.2774092805473839, 0.11906371582196429, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03170745255016805, 9.999999999998899e-05, 0.03550032772409939, 0.0006860336523534238, 9.999999999998899e-05, 9.999999999998899e-05, 0.04519533164114731, 0.05423738473151041, 0.08391415215848597, 0.09727251509890189, 0.03999285379804174, 0.02008292133082268, 0.0578105472275916, 0.05217817061471686, 0.04892359108686872, 0.12186795102552628, 0.04864347062663088, 0.09558812689111074, 0.10993623477885317, 0.08695026736522393, 0.06493225384903345, 0.05498363325819611, 0.15828313881048106, 0.05425489936742067, 0.10680543866451209, 9.999999999998899e-05, 0.010422814456296337, 0.0866956611248696, 0.1403045030580754, 0.03348596313849517, 0.04896159500670183, 0.0505206925767836, 0.07771930711186703, 0.4073159281713361, 0.4309997737160782, 0.43914175489866625, 0.47478847121490964, 0.41323722131396823, 0.3907522760304104, 0.43670885767054846, 0.49039946121783173, 0.41680869577844726, 0.07103044272007042, 0.059298190674639595, 0.13428208979782152, 0.06618297265574347, 0.09761559356616634, 0.11079938065904849, 0.08222684173948547, 0.09901998181571503, 0.06195946765850602, 0.14645368518460877, 0.2361434847985372, 0.18472478753587596, 0.1825399873219914, 0.25408926049526637, 0.17609301457541437, 0.28288324577000745, 0.1373097987857982, 0.19319191694048432, 0.2548341173567855, 0.2743987780191883, 0.26083878144572914, 0.20620292685634845, 0.27509882446252865, 0.24073996632515504, 0.29069034286370277, 0.33273460026659485, 0.29229442532188254, 0.20322024463586352, 0.18698619357549984, 0.188668197803045, 0.18077305749231543, 0.18756530408398842, 0.17045464890969886, 0.23334219813472368, 0.25088492607199187, 0.12257496059059014, 0.17644453381036962, 0.16870968217728477, 0.21971357618919085, 0.17785287398351102, 0.1865921924384174, 0.19879285922853906, 0.19672092074464564, 0.1704903156922708, 0.20865364492026572, 0.19339040407025, 0.19476489397541596, 0.18235401636711845, 0.19483645548310802, 0.24698023052283025, 0.20487409366222697, 0.1799166649477293, 0.23129832613024115, 0.19800428298592743, 0.8148822455410062, 0.16801559904905317, 0.22523718950655336, 0.17536614737237, 0.19952660514524911, 0.1637021027824137, 0.14273102017902184, 0.6133674302245011, 0.501382681993868, 0.26100080811105064, 0.2119190650190288, 0.17083910452732254, 0.2451561755180025, 0.2324474387685318, 0.15486063384624904, 0.1037846855154847, 0.10445786339165442, 0.20834621455377011, 0.18410192361448308, 0.2028966497953596, 0.17236273770057509, 0.1719583760639949, 0.180133446700805, 0.18998646922812956, 0.17678784768359168, 0.19485633147729808, 0.21368596659121997, 0.05647486547690406, 0.08239224666808609, 0.08273716436326595, 0.0721945017339427, 0.07643131805746761, 0.07999550021925772, 0.06249320832991612, 0.0869747015715544, 0.0638832657510322]}, "mutation_prompt": null}
{"id": "489eac93-fd37-4cca-97a2-fdddc3bdad67", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "a0f96b34-2a1b-459f-b659-8b0c9b876494", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "f3ad0a7f-6be5-4400-908c-c4d79ed6ba45", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50  # Increase population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5  # Start with slower velocities\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5  # Adjust cognitive parameter range\n        self.c2_initial, self.c2_final = 0.5, 2.0  # Adjust social parameter range\n        self.w_initial, self.w_final = 0.8, 0.3    # Adjust inertia weight range\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = chaotic_factor  # Using chaotic factor as inertia to adaptively adjust exploration\n                cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.85  # Adjust crossover rate\n                    if chaotic_factor > 0.6:  # Change crossover condition\n                        crossover_rate = 0.9\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "EnhancedAdaptiveChaoticHybridPSODE", "description": "Enhanced adaptive PSO-DE algorithm with chaos-driven velocity and mutation adjustments to balance exploration and exploitation more efficiently.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {"aucs": [0.8350507278303274, 0.8208977549423667, 0.844565468913087, 0.84373676713439, 0.8533468143140805, 0.8335048196093094, 0.8350557464551396, 0.8395317301230947, 0.8310681471368903, 0.6372141882951612, 0.6192195608674469, 0.6157654169225073, 0.6805669609332221, 0.6508266833730465, 0.6452748928487506, 0.6322694734549879, 0.6488073357563775, 0.6653973760387843, 0.14469087135832703, 0.16782464253360818, 0.14140640737277843, 0.137821733701184, 0.1434153183108292, 0.13639865446680155, 0.17566519175990358, 0.600974385492024, 0.14067164408862487, 0.13979458211743845, 0.12022901361939786, 0.4684405893132576, 0.138846520107484, 0.10246754227043053, 0.10809828405778332, 0.10974389009815844, 0.13329963322106886, 0.11128107430377021, 0.9163383320413246, 0.944621982456223, 0.9725726702940194, 0.9176082749290555, 0.9390552540392371, 0.9535304560616424, 0.928570934257248, 0.9604476494103348, 0.9542473490124, 0.6584023485864616, 0.6071139709114376, 0.6518622523828419, 0.661597293832177, 0.6191207144194544, 0.6344443911785937, 0.6356068127369705, 0.6016162720308562, 0.6320317750190261, 0.36635989469895447, 0.7945895559269026, 0.2185065533025654, 0.27473476548026243, 0.3662693298200277, 0.8231186262063637, 0.1503900655499507, 0.3790848032182952, 0.22852152253792002, 0.19190847470153882, 0.1686790850421066, 0.11769467561323599, 0.20531835009181498, 0.19330178842751322, 0.20130542841198784, 0.17033493031404978, 0.2642075254195514, 0.17978835879584043, 0.1285039146682766, 0.18905203436227191, 0.19885572369518467, 0.1632376419673447, 0.20483089855064573, 0.303577883723433, 0.2299633001617557, 0.10699426275934454, 0.2131881977671678, 0.0873792665346953, 0.1394713541633128, 0.07593824217207235, 0.006778562530801668, 0.08624203144411746, 9.999999999998899e-05, 0.07988102586243329, 9.999999999998899e-05, 0.08928242402866893, 0.17442637776636583, 0.11388327842369816, 0.11847610678082443, 0.08019667990300094, 0.07182535510068078, 0.06239716219678326, 0.10289455407822112, 0.1256026033328902, 0.17212640298260906, 0.11120831228726091, 0.09437487473861161, 0.11208012503499942, 0.09204420392049162, 0.10828232311450481, 0.11073104531418887, 0.11692424284078828, 0.07069651508612462, 0.20072030510873828, 0.154679259901071, 0.08316658632119633, 0.12384117483034973, 0.07558458178195504, 0.14209099391084745, 0.13137646100657363, 0.24997369701895533, 0.2107544616840008, 0.0791580729993977, 0.5773892735298165, 0.5473088268752857, 0.4892540346016865, 0.6015068603703428, 0.6222187728913278, 0.6079775199374028, 0.562432026473006, 0.580115657680454, 0.5355846161224479, 0.09962780277933492, 0.14753302603492935, 0.10566707444443324, 0.10699809814408545, 0.13447733425714692, 0.12344911515847601, 0.13001319948333567, 0.1430888555693649, 0.11239736318195415, 0.32116788819147624, 0.21764181473138755, 0.19447587247607512, 0.21844210544143328, 0.20356169424880677, 0.2205586806402967, 0.23964376286923939, 0.3134472403582266, 0.1474680295500359, 0.42816010654453907, 0.34438005611835165, 0.3513707389569817, 0.48052234564529195, 0.2325377275456031, 0.35459564583026326, 0.5960727712210092, 0.44898875934384097, 0.4836869223193686, 0.21530721476547177, 0.2908634857928668, 0.27855913901868024, 0.2517360646729453, 0.20305764660110137, 0.21318094072186333, 0.3415619718031434, 0.25691817938759665, 0.2711370550692336, 0.2444004183674806, 0.1924006175205688, 0.23105815173440047, 0.2073190992463002, 0.24589920429208167, 0.2420934054332332, 0.21369415930417357, 0.2125457637872109, 0.2284658687647776, 0.23572757346966744, 0.6688671506301951, 0.1985005878913888, 0.21704992988355476, 0.24427906428358948, 0.203280776002412, 0.19500158076537277, 0.21914141178474422, 0.2182593024778534, 0.18492031626064265, 0.18306618267573904, 0.8040359100451234, 0.876618016348524, 0.7276217100934426, 0.7968465689031489, 0.8194472453867568, 0.16222114097257578, 0.8233740819266591, 0.7904662282659184, 0.8120460567325813, 0.6661172250282592, 0.7443624278656051, 0.1654937581413748, 0.1536808865897349, 0.20468851048668935, 0.6320864512505637, 0.6547708039307625, 0.20993790482271557, 0.1890266816080417, 0.1975571963747631, 0.19245614727104698, 0.21022216104298486, 0.1931778315823206, 0.18840330084756718, 0.18831759850201457, 0.18849046770823374, 0.09662976820095626, 0.09289064004041958, 0.07995554069989597, 0.09790112250324456, 0.08492987922723949, 0.11022228109839194, 0.09381421950620172, 0.09910480869140847, 0.09367237071777257]}, "mutation_prompt": null}
{"id": "ca332aa6-c304-4cb4-a643-3dee6d722ef7", "solution": "import numpy as np\n\nclass DynamicHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.population_size = 50\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim)) * 0.5\n        \n        self.pbest_positions = np.copy(self.particles)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        \n        self.gbest_position = None\n        self.gbest_score = np.inf\n        \n        self.c1_initial, self.c1_final = 2.0, 0.5\n        self.c2_initial, self.c2_final = 0.5, 2.0\n        self.w_initial, self.w_final = 0.8, 0.3\n        self.scale_factor_initial = 0.5\n        self.scale_factor_final = 0.8\n\n    def chaotic_mapping(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand()\n\n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            self.c1 = self.c1_initial - progress * (self.c1_initial - self.c1_final)\n            self.c2 = self.c2_initial + progress * (self.c2_final - self.c2_initial)\n            self.w = self.w_initial - progress * (self.w_initial - self.w_final)\n            self.scale_factor = self.scale_factor_initial + progress * (self.scale_factor_final - self.scale_factor_initial)\n            chaotic_factor = self.chaotic_mapping(chaotic_factor)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.particles[i]\n\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.population_size):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    inertia = chaotic_factor\n                    cognitive = self.c1 * r1 * (self.pbest_positions[i] - self.particles[i])\n                    social = self.c2 * r2 * (self.gbest_position - self.particles[i])\n                    self.velocities[i] = inertia * self.w * self.velocities[i] + cognitive + social\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                active_population = int(self.population_size * (1 - progress)) + 10\n\n                for i in range(active_population):\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant = self.particles[a] + self.scale_factor * (self.particles[b] - self.particles[c])\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                    \n                    crossover_rate = 0.75 + 0.15 * chaotic_factor\n                    crossover_mask = np.random.rand(self.dim) < crossover_rate\n                    trial = np.where(crossover_mask, mutant, self.particles[i])\n                    \n                    trial_score = func(trial)\n                    evaluations += 1\n\n                    if trial_score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = trial_score\n                        self.pbest_positions[i] = trial\n\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n        return self.gbest_score, self.gbest_position", "name": "DynamicHybridPSODE", "description": "Hybrid PSO-DE with dynamic population size and adaptive learning rates leveraging both chaotic influence and diversity control for efficient optimization.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "40c3c524-a0c8-4acc-88ea-4212800d3f35", "metadata": {}, "mutation_prompt": null}
