{"id": "a5ca1afc-d951-44e8-9764-a773896eed3b", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "aa052584-12f6-42b2-b6a2-787feda40903", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 1, "fitness": 0.2726450162580366, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "a5ca1afc-d951-44e8-9764-a773896eed3b", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "8d9cbfec-8f3a-4fbf-a2be-5c15c8a36d35", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "0eaaffae-e81d-4e89-b0fd-aff62242b354", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self, population):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        diversity = np.mean(np.std(population, axis=0))\n        self.CR = np.clip(0.9 - 0.5 * diversity / 5.0, 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters(population)  # Adaptive parameters with diversity\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Optimized Adaptive Differential Evolution with dynamic crossover probability adjustment based on population diversity.", "configspace": "", "generation": 3, "fitness": 0.24409034189240147, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.6065340532136165, 0.6390275878516606, 0.634081553618157, 0.6430511482125736, 0.6739573933333904, 0.6888011281411413, 0.6773437440210432, 0.6487728656136751, 0.6454129675915063, 0.39337041058736755, 0.3960316892257596, 0.3899390629292826, 0.35199611973426614, 0.44040642511283645, 0.42143437981410703, 0.3788154586557947, 0.38185542263839356, 0.4059722116363633, 0.11078724852889987, 0.10813186747499126, 0.10649987207742473, 0.10901514540234658, 0.10808416603245896, 0.10356142171772731, 0.10975913729137987, 0.12259339873032526, 0.10556917089544204, 0.08753975849920281, 0.09349140684739232, 0.08937754596690206, 0.08573611017526728, 0.0911224841006113, 0.09952861646311051, 0.09396580926068476, 0.10728403111866414, 0.09658179857568994, 0.9711584929053301, 0.9661717970545269, 0.9628096149708049, 0.9794346961891179, 0.9530525054885942, 0.9698446963261422, 0.9602621219698865, 0.9548790639433581, 0.9752127808975398, 0.24432253210928045, 0.27711275903306054, 0.27984469403508716, 0.2803043646614767, 0.2830074196731326, 0.2979971272681118, 0.3300426120149087, 0.2976778238984251, 0.2783031781959454, 0.42064237325489573, 0.37730093958310085, 0.4082589653829193, 0.4721574639687569, 0.40570408811226977, 0.4784163411422543, 0.39307194069137663, 0.5133549348389828, 0.4903489699333351, 0.19472169830395192, 0.2122170137833228, 0.19764700649134215, 0.20130465123630825, 0.19944856217696894, 0.16733189646480018, 0.21925488610167287, 0.22075006181978774, 0.17700328414064292, 0.14544814646686666, 0.12995474345737035, 0.16100045313979394, 0.21125118415010602, 0.17496347735008255, 0.22896199192950473, 0.18154793486584653, 0.14670333351401132, 0.15752585264993446, 0.010822524169096903, 0.01273757440308565, 0.02415318983314174, 0.018050956810155894, 0.03531486168502174, 0.0255624971597328, 0.013251944082028455, 0.01951696024981797, 0.0315025917352727, 0.12292279855775123, 0.10926330697059061, 0.08088258802874226, 0.07291756479558587, 0.08310658357779555, 0.0784441728292955, 0.136941538522379, 0.11982121774756249, 0.10568001736544863, 0.0020127317454087246, 0.0018503287455478024, 0.015175296794685877, 0.014983189412093867, 0.022871220239026102, 0.004553231811720404, 0.009307832370747615, 0.01658961021089178, 0.03760756558013345, 0.1544419088940786, 0.12962235955008805, 0.16186964180330177, 0.16311995927166278, 0.1416522497019167, 0.17098548443632355, 0.14371873932356283, 0.14828052693907046, 0.135403769765017, 0.4971462396270163, 0.49372009084383794, 0.4956691903927811, 0.4663667541891451, 0.495963662205656, 0.4780115260173303, 0.49166362595652713, 0.47450993263363317, 0.5018982788774131, 0.08906278565590309, 0.10495038078616703, 0.09532625386771254, 0.07925531723653845, 0.0761059884897668, 0.10306997304825438, 0.08534900315620164, 0.09313963456907037, 0.0886390936142496, 0.1674507366112431, 0.13299285764377278, 0.18085605557375162, 0.16251613595174208, 0.15973289661594714, 0.15784892978462617, 0.1387950916000309, 0.13010509888290345, 0.14149077374797558, 0.2733137851222278, 0.276762021142841, 0.2808152612309206, 0.24297901167426827, 0.24452139422698094, 0.25380975158824226, 0.2895462526979602, 0.2884507414785966, 0.29352031380770716, 0.2041794687649251, 0.19088488361780231, 0.19008321691258612, 0.18488577154043928, 0.1942990369428813, 0.18652580470643887, 0.1995721982006422, 0.21643485422576003, 0.17956022098961677, 0.20272561990921345, 0.19402066153355046, 0.181877698493901, 0.18910711623280085, 0.19364367110561675, 0.1937741926441804, 0.1888458471179928, 0.18435483897045946, 0.1935294142385322, 0.17665657193397566, 0.1791916918914791, 0.17757861247843743, 0.1826344732561802, 0.16847586251925728, 0.17777345530407507, 0.18765418498304398, 0.18755045343007726, 0.1812379023534929, 0.26088442983321825, 0.3883484196326161, 0.16283550134836255, 0.2121312426955021, 0.24147641870091563, 0.3649050653316349, 0.15663280165731375, 0.2222740286461543, 0.22507872995205336, 0.1661547135688335, 0.18862163987306357, 0.19111785592185537, 0.22009270419874205, 0.17669805138701322, 0.20038857746494898, 0.20610050843898664, 0.19990215763217667, 0.20666983238622472, 0.18423516485362101, 0.1792026923017549, 0.17547655155742614, 0.17770001583441886, 0.18894038546690506, 0.1728595759475029, 0.1933194470463877, 0.18072972725652925, 0.1676833266119575, 0.07366902604759673, 0.06912451236914474, 0.06865777470666601, 0.06847428362570351, 0.07013220690255151, 0.06498968957187246, 0.07118433095992682, 0.07461509429542335, 0.0716931780952369]}, "mutation_prompt": null}
{"id": "3f132885-d3fe-4b5c-8d59-5e3496b0a527", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 8 * dim  # Reduced initial population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n        self.pop_size = min(max(4 * self.dim, int(10 * self.dim * ((self.budget - self.evaluations) / self.budget))), 10 * self.dim)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution with adaptive step sizes and dynamic population sizing to efficiently explore and refine solutions.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 40')", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {}, "mutation_prompt": null}
{"id": "092474b8-e171-4ef7-a538-f2d4b71a0d80", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "d0dafa31-15c7-4192-be73-9caaf73e7e1b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "032c1d88-c201-4309-869c-0526832f7a40", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "2202fb90-845d-4924-a5d1-9dfb26c1bec1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "656cd391-8cd5-4feb-8cef-23a968585078", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "7c589962-3238-4ed1-bf23-e024f3335443", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "be45ee78-297f-4b03-be22-250af7f4b2cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "0f9ed606-3799-46a7-9af0-bb70d9570c7a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "ab11f9b5-e8b9-4ed7-bd6a-721dbb01da97", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "0f3edb7b-278f-4289-a732-032b09a08881", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "fa5439eb-fb54-4e7d-b5c7-6b90875d1531", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "b02bfb9f-d89e-497f-928f-262b0fc3541e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "b9a4e2ed-7d7a-4859-8ef9-bd4ae9ca95e4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "79da3ede-04fc-4d63-832b-6bdd1642e4df", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "8977446c-16f9-4a48-9304-1f7a22992800", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "f7c7dc04-4424-4f97-89e6-71ec91205e48", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "dcbde73c-9e08-4419-a2b9-5aea229e0a5c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "6403447c-2b22-486d-b34e-546a27b9f8ad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "c71b34c7-6f07-454d-a143-d4fc67b78dc9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "c7b1db06-5737-47ab-b82e-96cb8876d8e8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n            # Gradually reduce population size\n            self.pop_size = max(4, int(self.pop_size * 0.99))\n            population = population[:self.pop_size]\n            fitness = fitness[:self.pop_size]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm with dynamic population size reduction to enhance exploitation as convergence progresses.", "configspace": "", "generation": 24, "fitness": 0.2090507957395961, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.41915139951032265, 0.3351001419887142, 0.3360471693350007, 0.4647426911922099, 0.3859266779455772, 0.46903350992967585, 0.36997732479462053, 0.48062903264687684, 0.4085195385888505, 0.07329626271305079, 0.22154966462518444, 0.22487169240894578, 0.2858779059289501, 0.08071480573277545, 0.21810386135524773, 0.14829699704200516, 0.13235980418284565, 0.24631523018810075, 0.12231813879990228, 0.11730341603381644, 0.12750229847966188, 0.11899520332240388, 0.1166289700339801, 0.12279807859682257, 0.11041479559370604, 0.1237159693565234, 0.12181576895179846, 0.12343529813573118, 0.10141361900058332, 0.1261958104446923, 0.0979242119274184, 0.1089473324639808, 0.10885744354975413, 0.09907505790027404, 0.09701649607630247, 0.09357211553185485, 0.961530857131035, 0.9472802766175403, 0.5290237379389237, 0.9280567321109539, 0.9360818583498726, 0.9090639346803864, 0.921618966015385, 0.9406287028649807, 0.9624455420180621, 0.15386322665355778, 0.21553337223227187, 0.19449678475859034, 0.1603034073350882, 0.1902415320751516, 0.14921172564633056, 0.1845231425231697, 0.14827240060329694, 0.16717311806385626, 0.22003661300062272, 0.3633662384784616, 0.17937971996663205, 0.2158028421488397, 0.21071164840077217, 0.8665296291964585, 0.3426085310909158, 0.3420515929635207, 0.335278555302983, 0.10210303888013972, 0.12022768835530528, 0.1632967419806235, 0.1191458678460382, 0.10648353777777664, 0.12693886136947696, 0.16741807679374177, 0.11480047355729239, 0.12734415785372966, 0.1371483242783308, 0.12197025058458999, 0.11617599391263123, 0.14227245333967387, 0.12061242282504503, 0.12188947749718992, 0.13446689210636664, 0.10293425660079958, 0.10117313456209254, 9.999999999998899e-05, 0.0005797352752581197, 0.06220036518098804, 9.999999999998899e-05, 0.013923024797453998, 0.0076610368495881875, 9.999999999998899e-05, 9.999999999998899e-05, 0.06880520567055992, 0.09983407645545261, 0.12360776088224867, 0.10061739800961478, 0.09213263971692087, 0.0654254307339992, 0.10138883364167284, 0.11326841526187925, 0.13151904525480584, 0.09536362002456644, 9.999999999998899e-05, 0.08740316208619292, 0.003924690499738204, 9.999999999998899e-05, 0.1754014838344905, 0.15590631184354098, 0.07864241481964762, 0.1718187355864127, 0.008689583922158794, 0.12545739879574702, 0.06898103021485402, 0.1292328185426972, 0.09981858205278982, 0.2251583666764737, 0.1508489600106988, 0.08319770629392864, 0.07420827691947851, 0.1332516638814505, 0.43653891782816, 0.38918491245694165, 0.3672172870075068, 0.33715951312073733, 0.39867817242119286, 0.395185008194023, 0.3160406886913081, 0.42401393705246493, 0.35423840423995356, 0.12935233246295608, 0.11277020198186205, 0.09113724173881677, 0.10761825607511477, 0.09123608226428603, 0.11416298746439513, 0.09192762726226011, 0.10019365862492358, 0.09160344519834229, 0.1346107992311676, 0.13355060084275994, 0.14559694597226958, 0.1513732339638606, 0.14550449018597245, 0.16374729491076612, 0.12383619185093686, 0.18392749786643092, 0.14356614099981035, 0.2275077263388503, 0.23626512575280545, 0.3099580708603292, 0.24690792276794782, 0.41511743430781056, 0.21173823747411213, 0.31514545075839706, 0.3186410856427485, 0.2739842441101321, 0.3304378431264853, 0.19886809843982745, 0.2081493712916015, 0.21173969908126644, 0.17112887829654122, 0.1856446877409137, 0.3400307927921674, 0.20374333781380238, 0.19109422840397305, 0.21167560553797637, 0.20786400400753557, 0.20743759497062542, 0.18580136171702066, 0.31457141626803486, 0.23181674113711948, 0.1894399136350251, 0.20813134297440927, 0.20022958930762247, 0.18442908885265685, 0.2147424679962332, 0.1757567538738496, 0.18420050636145446, 0.1967438278123752, 0.19495158918077526, 0.2099624689662828, 0.18627609929311872, 0.20412740389856643, 0.1572373976968634, 0.1638369047807139, 0.16494946165522628, 0.2678907970819401, 0.16683669977896365, 0.14611544596875226, 0.1292170925984032, 0.16362494714065634, 0.26666196831300815, 0.18664053112319257, 0.16665232036125288, 0.36019029734296304, 0.1927485251964609, 0.16207679665207653, 0.10912899285247801, 0.19583277844909042, 0.20811482193531727, 0.3340253416402006, 0.1986215078028093, 0.19097633826016747, 0.18469988410729243, 0.19415272636464742, 0.17445491373404953, 0.18507127836820336, 0.21031945918692596, 0.21102672381493937, 0.20840333051326265, 0.08725688931290698, 0.08378565548445271, 0.09255773721720018, 0.08222653245374967, 0.0893799664611934, 0.09608735955602621, 0.07142029583954501, 0.07583761984880255, 0.08985281382744192]}, "mutation_prompt": null}
{"id": "741ba568-1568-4232-95ca-937877d5e996", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution algorithm with adaptive step sizes to efficiently explore the search space and refine solutions.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "b176c65a-1ce9-49c8-9652-5587d6c5e1b5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.7, 1.0)\n\n    def dynamic_population_size(self):\n        if self.budget - self.evaluations < self.pop_size:\n            self.pop_size = max(5, (self.budget - self.evaluations) // 2)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            self.dynamic_population_size()  # Dynamic resizing\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using dynamic population resizing for efficient exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.2726450162580366, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.638579371083047, 0.6241767838402551, 0.6170756601084626, 0.6324955777362317, 0.6662830504772521, 0.6602637593817902, 0.6487752360160667, 0.6625215430697935, 0.6453271140557392, 0.4283528620866659, 0.4048883986348949, 0.4136049624849717, 0.4009957345984402, 0.4012517189532584, 0.44451701554509104, 0.4383311006253777, 0.41561478981895483, 0.4133689949427327, 0.1038694409399995, 0.10269164577371925, 0.09992272234203448, 0.1017979090736042, 0.10015071220579252, 0.09501060555948337, 0.10095257439149774, 0.09624804686070842, 0.09936987982852863, 0.1035517265375775, 0.08340320102519128, 0.10136833310654547, 0.08936458016951743, 0.09032786247323732, 0.09190049613855023, 0.09241940860402187, 0.07765996983457357, 0.083875378400188, 0.9684093332909515, 0.9139112667966861, 0.9410168350981235, 0.9375683854923322, 0.9079815186628675, 0.9010755595568055, 0.922940459311137, 0.9480615274339623, 0.9550412154738888, 0.27291498964866245, 0.27740991078711397, 0.29974817926053954, 0.3086254111541449, 0.29852496417324115, 0.31892525061979715, 0.29285267372219315, 0.3129305233394285, 0.28466465199871704, 0.5762340392379376, 0.5083365546316062, 0.5525075260462357, 0.5458481046602762, 0.6427446900533522, 0.5755420418681063, 0.5331981026547679, 0.5609247969206237, 0.5117559081830345, 0.20334314845470647, 0.1760193948512675, 0.1905619347684797, 0.22509043608390245, 0.22141084982142756, 0.22064201240121273, 0.2590844251411972, 0.21019849346339026, 0.2346174240646014, 0.021206995932397832, 0.22094234213602926, 0.02042539154287315, 0.19913843967934675, 0.21308774228216998, 0.17879150697543678, 0.17901752188872155, 0.20456092330952635, 0.20533142826101447, 0.13695927713930944, 0.1363361236115923, 0.14895835313022854, 0.1493295267426027, 0.14478973253955396, 0.12613755016596662, 0.12938868606664766, 0.14962748177118224, 0.1279082576583963, 0.21239075198783752, 0.2600974287524431, 0.2869072050034144, 0.3170602653384521, 0.2927130698267516, 0.25043289097116184, 0.3101363355221771, 0.29815703183611386, 0.3081354302170045, 0.02842734848395323, 0.0322427943388357, 0.0562156087974125, 0.04264946610754761, 0.06573498294394198, 0.04950721562990934, 0.025557012223092146, 0.03995752958589205, 0.03775872039451855, 0.17032254174481865, 0.15409940795567567, 0.16363508054425802, 0.19181799560089285, 0.1783809467356694, 0.1832151110182283, 0.1775151116588578, 0.15632886319787487, 0.16410466251753275, 0.4919354721717878, 0.47636000540153267, 0.49445730107011776, 0.48845099135205705, 0.4976947569872444, 0.48551986945285663, 0.47107828525409023, 0.5039914879381941, 0.5082589924986247, 0.09153677421128326, 0.08976443748431995, 0.09143805330944854, 0.08334776627525076, 0.0813161587866269, 0.09042563716286989, 0.07816023471987721, 0.07480405450974048, 0.09419308801618176, 0.14422218337914505, 0.14239258277968925, 0.1355685576408021, 0.16730550052647486, 0.15795124169586994, 0.18510983886798427, 0.15482333767217538, 0.18649391501551382, 0.1733799049893633, 0.27088064414252433, 0.29148409907788675, 0.29384558095194147, 0.2597579867720293, 0.2542029927729059, 0.2786423242758783, 0.2853647009170899, 0.28230074427172636, 0.2937473988600612, 0.19446751650167837, 0.2194945819244407, 0.20015992797219728, 0.19324235555923552, 0.2045773437138394, 0.19595673477814934, 0.2252119891089035, 0.24138500187075673, 0.23069751450755238, 0.20582997070225018, 0.20039010374253552, 0.17448957745491955, 0.17264531509628522, 0.1997414586128855, 0.17703893863593567, 0.1852947565819162, 0.18962847760925805, 0.19718954736218253, 0.18050644861443865, 0.1748965883411654, 0.17964559659627188, 0.16352082879955454, 0.1968145710082222, 0.17726836753071407, 0.16908946425443194, 0.1708153809187568, 0.17949005789607908, 0.6082856445763801, 0.17170728892040443, 0.1511290585310473, 0.5081291552461347, 0.41806130666350405, 0.4679903519464139, 0.31454633232785567, 0.4164227978340872, 0.19221656001221532, 0.5712460204445574, 0.1966456486200766, 0.19437975926998052, 0.1733522765064558, 0.18692929875745312, 0.1883536685730316, 0.19953490529229212, 0.20579551286324982, 0.6546034595265202, 0.19830482300120966, 0.1816171467197366, 0.16778467656033902, 0.18179665704037673, 0.1788546779442005, 0.17884965882303971, 0.18648340915989825, 0.17176702462230276, 0.20622176157476202, 0.07101199758293475, 0.06581464570827644, 0.075683279120204, 0.06675725171574087, 0.07083349318218368, 0.0680761707982519, 0.0722198013462535, 0.07669941120760926, 0.07711446719343817]}, "mutation_prompt": null}
{"id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.28161447163421677, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "aa052584-12f6-42b2-b6a2-787feda40903", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "866ff9af-5ba5-463a-a729-b555260dacac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "464fa9c9-7379-4c8e-a2a5-c90c3ca8a674", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "7121a4f5-8b35-48f2-bab9-18404ffe8757", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "d1d1e9f8-ed16-4d70-8847-6d4f28362c1e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "6c12ef0c-349e-41d6-8263-56fd4c63b28c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "6398306e-5894-4474-bed3-167cc31607b2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "69db1b54-41a1-42d4-ab9b-5360ad12d78d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "604ebc0b-2049-4b33-be9d-d6b49e6a3b59", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "07b5f514-d003-4d23-873f-6b71a9180aad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "e433ee6b-9560-4d89-a167-b90a870ba997", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "03c67023-6973-49ca-8de6-b3ccf07c7a9c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "4aff86ef-1f1f-4d88-bd31-ef8c04500f67", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "d4dc1fd3-8cc5-4855-a8a1-6396b1a587e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "488571ac-1b39-4a27-90d2-0da54248d69c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "af9b5d74-ba1d-4e6e-a04a-d1671c860dfc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)  # Self-adaptive mutation scaling\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An improved Adaptive Differential Evolution with self-adaptive mutation scaling for enhanced exploration.", "configspace": "", "generation": 42, "fitness": 0.2695234435448174, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.650631301566246, 0.6162933083071105, 0.65374436686243, 0.6412284030597729, 0.6480917227576033, 0.651854306534309, 0.6614274548434054, 0.6654503586101259, 0.6591789423546732, 0.4100490901699838, 0.43748453388900865, 0.3944391617232156, 0.3871228969878403, 0.3498243633273802, 0.389421805668432, 0.3818831025526843, 0.3774813757905322, 0.42005260583826975, 0.09489195676433759, 0.09384270876031298, 0.10460280703955382, 0.0966202538755373, 0.10111456033783228, 0.0952488212746484, 0.09604548394191426, 0.1050151660223333, 0.09729692847323201, 0.085224447788665, 0.08995331997455502, 0.0896686272280649, 0.09000800408777798, 0.09409742309061131, 0.08961452616633214, 0.08218915187493081, 0.09806282288278345, 0.09390861254687766, 0.9384124118728859, 0.9408508183722348, 0.9450879314585061, 0.9610984463975667, 0.9647287786290786, 0.9338209662009193, 0.9809857380528516, 0.926092687052925, 0.9386321485582659, 0.2824641459180879, 0.2876706296679524, 0.319761404460185, 0.295240975682895, 0.27531064537601824, 0.2893123170950921, 0.28022757789762287, 0.3051612824769553, 0.2934645267078214, 0.524774368775722, 0.5630240756429412, 0.5717169519204734, 0.5239998003055379, 0.5962581679657178, 0.611457867698257, 0.6215684927728078, 0.5750695544408464, 0.5821565738962073, 0.20063409127692666, 0.20256949533397717, 0.19327539994723508, 0.23603517320447398, 0.2532539024844179, 0.215264406378178, 0.17472267617631332, 0.17835320943561384, 0.19819709440016398, 0.32974507069255243, 0.22611931393147278, 0.05095254674805383, 0.1881770198843934, 0.2148126394910208, 0.18960206688375825, 0.18740555322023633, 0.22354923065188115, 0.18861396695800337, 0.15961903122448562, 0.1309899504023886, 0.16944173220041103, 0.14477209713365446, 0.1705837761694018, 0.14950449511054498, 0.14825130941837084, 0.15632858586198983, 0.13132245790636976, 0.2499468526892954, 0.24161867813980242, 0.2392538317866676, 0.2662009795487209, 0.2608863560899748, 0.26477229320072815, 0.32576895823438357, 0.32989224441567244, 0.2970348109888692, 0.025462330266543542, 0.029052306676341177, 0.043084434365140756, 0.055683755524432166, 0.0575743447517989, 0.03976273832623434, 0.01971501100824824, 0.03962433275706623, 0.075732746957893, 0.16960521878637158, 0.18828504489580355, 0.15822323806694372, 0.17682656079249737, 0.1583818678164518, 0.16360413279875374, 0.1662078540028773, 0.16322426703210624, 0.16316125103784362, 0.5179155767754031, 0.4838155212256312, 0.5028941025045797, 0.48608492321390084, 0.5011270601397585, 0.5123552651764305, 0.508468977533965, 0.4989175230185353, 0.4881108520635902, 0.08668108193866775, 0.09125862649341199, 0.09263842314792015, 0.09751964862264961, 0.09042993001079558, 0.0858972102568496, 0.08049965814480187, 0.09010825853407256, 0.09227808117816749, 0.16786077079834028, 0.14486417580985267, 0.1757457986085592, 0.1347177919685304, 0.13896254411449194, 0.15875804022295037, 0.22982152130153422, 0.15324984868755187, 0.13586753934163864, 0.26044659599726794, 0.27684219799673815, 0.27518457283770936, 0.2663198446575601, 0.2681059799539115, 0.2620575798655336, 0.29227798484770484, 0.2823190397601023, 0.2836959454387158, 0.2143526100570663, 0.21000679247880116, 0.22508003406282373, 0.2026841297965919, 0.22397518366429525, 0.20609251379752946, 0.2164544727034019, 0.22911105726380443, 0.2304312209237217, 0.18979130933454125, 0.16462489331359065, 0.18445535074670316, 0.1712841767614076, 0.18748141973463373, 0.17987429096405905, 0.18609456243749045, 0.17548588212254868, 0.24344029308980264, 0.17975053726484946, 0.17489082378545484, 0.17701402619690254, 0.18606820850498662, 0.19395081718964413, 0.1753078954990771, 0.17558005704169177, 0.18701652913993672, 0.1813102529961922, 0.4685020812965145, 0.2921686345979435, 0.18785462268526276, 0.39938770321252004, 0.1815473360707961, 0.2600391419298217, 0.1788710088563401, 0.24726751585271645, 0.1835682318333831, 0.19690483989009877, 0.18922106059933286, 0.45562200998872326, 0.40928752023643233, 0.19847801936175213, 0.18121050206591904, 0.20357937246309132, 0.1972126162329344, 0.20339059378659052, 0.18577422038780977, 0.1792631479631246, 0.18360152430360255, 0.19182214446641288, 0.20054294729558075, 0.1730112959835497, 0.17881152473380169, 0.19210765194435775, 0.1836887163841432, 0.07126954656953854, 0.07290416456362969, 0.06917399730371476, 0.07417496684174929, 0.06319672205031457, 0.06836017877590583, 0.0706196276701967, 0.06867040794899926, 0.06815363472112312]}, "mutation_prompt": null}
{"id": "4b09aef7-ba0d-4d3d-98e8-926a44a593c6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "b16d785a-abd7-4335-9a50-5db9a5a9ba82", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "e011b87b-a3fa-4834-aad8-559b5cd99117", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "91f03818-b1e5-4dfd-abcd-664efa25eea8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(np.random.normal(0.8, 0.1), 0.5, 1.0)\n        self.CR = np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # Adjusted for tighter range\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced Differential Evolution with adaptive crossover probabilistic adjustment for improved convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.664403070517419, 0.6591459418381143, 0.6400379725743581, 0.6491102015460927, 0.6714359269230159, 0.6611451960142347, 0.6635360081430866, 0.6732667817941658, 0.6307176874375546, 0.37094620116088206, 0.37722936339134416, 0.3886651538504231, 0.4041458318349217, 0.4208469149421393, 0.4212393210870995, 0.42366952637363553, 0.3991702117096998, 0.4353521546834106, 0.09623631519079023, 0.1026969773209574, 0.09591257262776742, 0.10171799293728312, 0.10604932684913071, 0.09704649217298289, 0.09059909873043293, 0.09830304368734377, 0.10972087125989927, 0.09209306490886593, 0.09787928109607513, 0.09489692694903318, 0.09599102544477334, 0.0952904816018234, 0.09054380317072541, 0.09930332014364773, 0.09308432135448708, 0.09092123117759421, 0.9776110210398126, 0.9209024448581651, 0.9359700654027872, 0.9545043778707356, 0.9421780612929357, 0.8652743929818649, 0.9617287053970291, 0.9393308395121296, 0.9560234867814326, 0.30132234630823707, 0.3002814816945366, 0.2935555613751746, 0.2864465477532997, 0.2756638214083965, 0.28163616308329764, 0.30431632770511274, 0.30272241216521056, 0.32608185273259926, 0.5994701728856138, 0.46886849758920957, 0.5571223805614525, 0.5763095990652995, 0.5744196258152635, 0.6424023693305763, 0.6928456635113603, 0.5525834473567757, 0.682237285890314, 0.22036102102239896, 0.1880005368536417, 0.19069784687611335, 0.26701855790837015, 0.18582027013847646, 0.191894133086982, 0.19314855276204257, 0.2151198086697722, 0.19146624353021835, 0.19352280771724728, 0.18721770935507687, 0.2269294924934957, 0.17125259991258013, 0.2394267828943768, 0.18362724664096808, 0.209788154261643, 0.2009603306566955, 0.20404304189374023, 0.1280653135560076, 0.1493246892252268, 0.14643913522525165, 0.18762612717223504, 0.11924262782349293, 0.1522588727074864, 0.1341149317044763, 0.1475951501796633, 0.16837424910657317, 0.2704549601601943, 0.30008537276917846, 0.28298727571739557, 0.26303012029814177, 0.2628216485308281, 0.22793779538534076, 0.32624842212431093, 0.29520975532868765, 0.2726928668523052, 0.05447468786860443, 0.04680853959890663, 0.042101887604053756, 0.037312985008913335, 0.030004593419956982, 0.04317476967645539, 0.03955287798179674, 0.02948713119080204, 0.050977084061419875, 0.16298073025975623, 0.16939822851485242, 0.15742972444363534, 0.1661763563071974, 0.18816098603845, 0.1741144007876233, 0.1738074258994271, 0.16075043766391228, 0.16923030978723597, 0.529144420921736, 0.4832195862071672, 0.5228052841392077, 0.5161580297147729, 0.47901512875251284, 0.5032772506328413, 0.4651384807138065, 0.49788513772744103, 0.49463930070719064, 0.09241989594360855, 0.0935496803317597, 0.09646013016095967, 0.10158397260028307, 0.08769166803315698, 0.09399684139373221, 0.08480668635886301, 0.08347412712155511, 0.08489679685034646, 0.1780121648198587, 0.1444613500179479, 0.1378250340530267, 0.1405061194354401, 0.15703955001304382, 0.17724673440569472, 0.14348691632484933, 0.12360732767613936, 0.1323270891122269, 0.27073815087821773, 0.2625080894251173, 0.26218597509352815, 0.26922404464307337, 0.2786882942406502, 0.24190737943439133, 0.2930670324064666, 0.30581740236108057, 0.31418874549932274, 0.2134008254581058, 0.20571952444108643, 0.22113044836707518, 0.19443510026443633, 0.19537556380484156, 0.19871355188056783, 0.2160620132060359, 0.21042459191447693, 0.2025663687377276, 0.21610656981777976, 0.18269091321363018, 0.18038900418653214, 0.18405663220368418, 0.17733432127907012, 0.1826993665505453, 0.1903644474786731, 0.22023028756632823, 0.1737865425816708, 0.17527592046549467, 0.17611575361062803, 0.17716055590684265, 0.17999589522052006, 0.17862480141425063, 0.1824923941244564, 0.1836128317165161, 0.18293627944320856, 0.17714204674986067, 0.16172209376585378, 0.5617687401548039, 0.4677621449286542, 0.4946401106440247, 0.34509368885032665, 0.48408464622531766, 0.1894859002302285, 0.48959079968913144, 0.4718745222305102, 0.5646060466459357, 0.4571168317997023, 0.20052229633207908, 0.17491778838112126, 0.16427147902217953, 0.29746022169325004, 0.6651221935791649, 0.20516540567164543, 0.6586714029174849, 0.18857676806079393, 0.19449463920054522, 0.19093339182700608, 0.18656558716200555, 0.16891032742466672, 0.17347450333979597, 0.17603161821835178, 0.17801043608477174, 0.18313707744116436, 0.06748967758991653, 0.07224024555862218, 0.07407367655402686, 0.07783250988647505, 0.06314406276596762, 0.07284151589906285, 0.07457382771568988, 0.0700228771963759, 0.07574827808163687]}, "mutation_prompt": null}
{"id": "e3ecb613-b6ff-42c2-8d8f-bd4cdf2096c1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate for adaptive parameters and fine-tuned crossover adaptation to balance exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.3055436414020499, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "67f5f172-33b2-4235-b7ff-a0808d5bc249", "metadata": {"aucs": [0.7026208116082568, 0.6842819875150106, 0.6457925593295306, 0.7042977415570684, 0.705334539081313, 0.6837696734383572, 0.683731962188643, 0.7058999416730023, 0.6471721497833673, 0.44171274432816354, 0.4758180362181672, 0.3920334722881812, 0.47735849195624247, 0.46890566994062777, 0.3974407756090321, 0.4376389466045786, 0.502914034742859, 0.3981363595837788, 0.09297128812252509, 0.09777183323883964, 0.10095402021150823, 0.08689689966023795, 0.09156226783443178, 0.11242762562111108, 0.10547333423914806, 0.09023884110728686, 0.0969619895417767, 0.08329206881351692, 0.08634271020229012, 0.0939786681964444, 0.09004013469205818, 0.08778854797325619, 0.09947389475175206, 0.10455363924237504, 0.09407065514353741, 0.09072836832193731, 0.9425882616718941, 0.9317463190473654, 0.9320027222211638, 0.9169811133675289, 0.9336535316751864, 0.8803175728167487, 0.9456793731711489, 0.8446835252542662, 0.971690651238045, 0.30701006470925896, 0.3005810791339685, 0.27226689297700923, 0.331731234558015, 0.3928993745955276, 0.32085916899876643, 0.33609551722881426, 0.36761282255079164, 0.31177277756227517, 0.6232921744671538, 0.6490268805485488, 0.6306865496688232, 0.5862330574441341, 0.6299468115970646, 0.6879452007443431, 0.6032016891907986, 0.6907994907602427, 0.5884109645984621, 0.2822779634614925, 0.29692826951867124, 0.20881089826655774, 0.21255861617171334, 0.24222951538734128, 0.17235234606702432, 0.25944487973862806, 0.27523559787921226, 0.20471881296628813, 0.3230352585568175, 0.24016943232831778, 0.22781044155170416, 0.2493011233674426, 0.2678938590985678, 0.1945357194519156, 0.2620813352768061, 0.2508383528732393, 0.21742860997045443, 0.20749421435167692, 0.267423038894571, 0.16311150652641082, 0.22961312272886691, 0.2413506667269708, 0.2119042958182985, 0.1873980090168723, 0.24404987763503128, 0.2107303533016066, 0.3241602851775327, 0.37998614473756465, 0.32068026968785346, 0.355431853031311, 0.3866677022437254, 0.326125883987361, 0.3512865913172144, 0.37348816904100157, 0.3580583081083367, 0.1024592693269839, 0.08947000899308155, 0.06082544813665769, 0.05339672078891433, 0.16313233369780222, 0.06625461484118111, 0.07760266143025152, 0.15207540908333217, 0.06560428195947021, 0.20372087417195472, 0.2142233871215371, 0.16311230235865715, 0.21489032485449655, 0.21562973054643986, 0.1824923220129382, 0.2256795242092159, 0.2452928773384011, 0.20522931307574543, 0.5545088176727697, 0.5893253601064259, 0.5090495083255314, 0.5566181991249947, 0.595663115157463, 0.5039836557159281, 0.5929137586640782, 0.5834472842696212, 0.4757863783182025, 0.0930543216721691, 0.08846256082412329, 0.0826328594487753, 0.08396443864479441, 0.0937760740657343, 0.0824216240136657, 0.10349947218948763, 0.08611677487222336, 0.08403776481803393, 0.14282090544488546, 0.15854681141676008, 0.14039478233459435, 0.16722003219189863, 0.16275937898937642, 0.15926197980209633, 0.16732782883066988, 0.15912469260402873, 0.17763758264458485, 0.28154082457597873, 0.3041852306595815, 0.27627613533901507, 0.3143779246872547, 0.2886096790055047, 0.2775278697550806, 0.31399347120884824, 0.3361040524747697, 0.3108023422668582, 0.2405733925139325, 0.24072018776153126, 0.22239894613215472, 0.2500456425933527, 0.22877135115563152, 0.21857939052989628, 0.23847368323147689, 0.24269696793232942, 0.2490342413067187, 0.18768065670729717, 0.18608659624759916, 0.1747501022194723, 0.18170888178218325, 0.20951323660045462, 0.2060613001073741, 0.18347864636568567, 0.17864415906515618, 0.17825727526881452, 0.1949095049522993, 0.17889210384507626, 0.18466953538789, 0.16962486204565574, 0.1861891692054658, 0.1776730588969242, 0.17248899090495085, 0.17703890922549526, 0.17291690028952456, 0.5553519318879003, 0.5905183861708884, 0.18291995611644174, 0.5968543431973345, 0.5458567358230774, 0.43469389912088263, 0.4054551089004853, 0.25871070921708283, 0.2014068418411994, 0.6159455307012244, 0.20507310195374095, 0.48399323121881976, 0.18502231987959705, 0.3516370306880737, 0.48933833697398843, 0.5851633953607898, 0.20368151529638878, 0.4952853049207011, 0.1713003141651579, 0.18708955569034036, 0.1905309411064895, 0.17620967945055055, 0.16767052369923963, 0.17631530512285387, 0.20687630318647643, 0.17818649816691956, 0.17439234332357245, 0.062261047934355385, 0.07283173240181473, 0.07064192616289433, 0.06199088367725103, 0.07110280076552677, 0.06845718006995194, 0.06883580921927768, 0.08906117514290768, 0.0693094255094302]}, "mutation_prompt": null}
{"id": "8e45ea1b-7bb8-4045-8276-f075cffb737c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate for adaptive parameters and fine-tuned crossover adaptation to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e3ecb613-b6ff-42c2-8d8f-bd4cdf2096c1", "metadata": {"aucs": [0.7026208116082568, 0.6842819875150106, 0.6457925593295306, 0.7042977415570684, 0.705334539081313, 0.6837696734383572, 0.683731962188643, 0.7058999416730023, 0.6471721497833673, 0.44171274432816354, 0.4758180362181672, 0.3920334722881812, 0.47735849195624247, 0.46890566994062777, 0.3974407756090321, 0.4376389466045786, 0.502914034742859, 0.3981363595837788, 0.09297128812252509, 0.09777183323883964, 0.10095402021150823, 0.08689689966023795, 0.09156226783443178, 0.11242762562111108, 0.10547333423914806, 0.09023884110728686, 0.0969619895417767, 0.08329206881351692, 0.08634271020229012, 0.0939786681964444, 0.09004013469205818, 0.08778854797325619, 0.09947389475175206, 0.10455363924237504, 0.09407065514353741, 0.09072836832193731, 0.9425882616718941, 0.9317463190473654, 0.9320027222211638, 0.9169811133675289, 0.9336535316751864, 0.8803175728167487, 0.9456793731711489, 0.8446835252542662, 0.971690651238045, 0.30701006470925896, 0.3005810791339685, 0.27226689297700923, 0.331731234558015, 0.3928993745955276, 0.32085916899876643, 0.33609551722881426, 0.36761282255079164, 0.31177277756227517, 0.6232921744671538, 0.6490268805485488, 0.6306865496688232, 0.5862330574441341, 0.6299468115970646, 0.6879452007443431, 0.6032016891907986, 0.6907994907602427, 0.5884109645984621, 0.2822779634614925, 0.29692826951867124, 0.20881089826655774, 0.21255861617171334, 0.24222951538734128, 0.17235234606702432, 0.25944487973862806, 0.27523559787921226, 0.20471881296628813, 0.3230352585568175, 0.24016943232831778, 0.22781044155170416, 0.2493011233674426, 0.2678938590985678, 0.1945357194519156, 0.2620813352768061, 0.2508383528732393, 0.21742860997045443, 0.20749421435167692, 0.267423038894571, 0.16311150652641082, 0.22961312272886691, 0.2413506667269708, 0.2119042958182985, 0.1873980090168723, 0.24404987763503128, 0.2107303533016066, 0.3241602851775327, 0.37998614473756465, 0.32068026968785346, 0.355431853031311, 0.3866677022437254, 0.326125883987361, 0.3512865913172144, 0.37348816904100157, 0.3580583081083367, 0.1024592693269839, 0.08947000899308155, 0.06082544813665769, 0.05339672078891433, 0.16313233369780222, 0.06625461484118111, 0.07760266143025152, 0.15207540908333217, 0.06560428195947021, 0.20372087417195472, 0.2142233871215371, 0.16311230235865715, 0.21489032485449655, 0.21562973054643986, 0.1824923220129382, 0.2256795242092159, 0.2452928773384011, 0.20522931307574543, 0.5545088176727697, 0.5893253601064259, 0.5090495083255314, 0.5566181991249947, 0.595663115157463, 0.5039836557159281, 0.5929137586640782, 0.5834472842696212, 0.4757863783182025, 0.0930543216721691, 0.08846256082412329, 0.0826328594487753, 0.08396443864479441, 0.0937760740657343, 0.0824216240136657, 0.10349947218948763, 0.08611677487222336, 0.08403776481803393, 0.14282090544488546, 0.15854681141676008, 0.14039478233459435, 0.16722003219189863, 0.16275937898937642, 0.15926197980209633, 0.16732782883066988, 0.15912469260402873, 0.17763758264458485, 0.28154082457597873, 0.3041852306595815, 0.27627613533901507, 0.3143779246872547, 0.2886096790055047, 0.2775278697550806, 0.31399347120884824, 0.3361040524747697, 0.3108023422668582, 0.2405733925139325, 0.24072018776153126, 0.22239894613215472, 0.2500456425933527, 0.22877135115563152, 0.21857939052989628, 0.23847368323147689, 0.24269696793232942, 0.2490342413067187, 0.18768065670729717, 0.18608659624759916, 0.1747501022194723, 0.18170888178218325, 0.20951323660045462, 0.2060613001073741, 0.18347864636568567, 0.17864415906515618, 0.17825727526881452, 0.1949095049522993, 0.17889210384507626, 0.18466953538789, 0.16962486204565574, 0.1861891692054658, 0.1776730588969242, 0.17248899090495085, 0.17703890922549526, 0.17291690028952456, 0.5553519318879003, 0.5905183861708884, 0.18291995611644174, 0.5968543431973345, 0.5458567358230774, 0.43469389912088263, 0.4054551089004853, 0.25871070921708283, 0.2014068418411994, 0.6159455307012244, 0.20507310195374095, 0.48399323121881976, 0.18502231987959705, 0.3516370306880737, 0.48933833697398843, 0.5851633953607898, 0.20368151529638878, 0.4952853049207011, 0.1713003141651579, 0.18708955569034036, 0.1905309411064895, 0.17620967945055055, 0.16767052369923963, 0.17631530512285387, 0.20687630318647643, 0.17818649816691956, 0.17439234332357245, 0.062261047934355385, 0.07283173240181473, 0.07064192616289433, 0.06199088367725103, 0.07110280076552677, 0.06845718006995194, 0.06883580921927768, 0.08906117514290768, 0.0693094255094302]}, "mutation_prompt": null}
{"id": "bc1010ff-b41d-454d-a7b5-f1c23d8c481b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = np.clip(population[a] + self.F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate for adaptive parameters and fine-tuned crossover adaptation to balance exploration and exploitation.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e3ecb613-b6ff-42c2-8d8f-bd4cdf2096c1", "metadata": {"aucs": [0.7026208116082568, 0.6842819875150106, 0.6457925593295306, 0.7042977415570684, 0.705334539081313, 0.6837696734383572, 0.683731962188643, 0.7058999416730023, 0.6471721497833673, 0.44171274432816354, 0.4758180362181672, 0.3920334722881812, 0.47735849195624247, 0.46890566994062777, 0.3974407756090321, 0.4376389466045786, 0.502914034742859, 0.3981363595837788, 0.09297128812252509, 0.09777183323883964, 0.10095402021150823, 0.08689689966023795, 0.09156226783443178, 0.11242762562111108, 0.10547333423914806, 0.09023884110728686, 0.0969619895417767, 0.08329206881351692, 0.08634271020229012, 0.0939786681964444, 0.09004013469205818, 0.08778854797325619, 0.09947389475175206, 0.10455363924237504, 0.09407065514353741, 0.09072836832193731, 0.9425882616718941, 0.9317463190473654, 0.9320027222211638, 0.9169811133675289, 0.9336535316751864, 0.8803175728167487, 0.9456793731711489, 0.8446835252542662, 0.971690651238045, 0.30701006470925896, 0.3005810791339685, 0.27226689297700923, 0.331731234558015, 0.3928993745955276, 0.32085916899876643, 0.33609551722881426, 0.36761282255079164, 0.31177277756227517, 0.6232921744671538, 0.6490268805485488, 0.6306865496688232, 0.5862330574441341, 0.6299468115970646, 0.6879452007443431, 0.6032016891907986, 0.6907994907602427, 0.5884109645984621, 0.2822779634614925, 0.29692826951867124, 0.20881089826655774, 0.21255861617171334, 0.24222951538734128, 0.17235234606702432, 0.25944487973862806, 0.27523559787921226, 0.20471881296628813, 0.3230352585568175, 0.24016943232831778, 0.22781044155170416, 0.2493011233674426, 0.2678938590985678, 0.1945357194519156, 0.2620813352768061, 0.2508383528732393, 0.21742860997045443, 0.20749421435167692, 0.267423038894571, 0.16311150652641082, 0.22961312272886691, 0.2413506667269708, 0.2119042958182985, 0.1873980090168723, 0.24404987763503128, 0.2107303533016066, 0.3241602851775327, 0.37998614473756465, 0.32068026968785346, 0.355431853031311, 0.3866677022437254, 0.326125883987361, 0.3512865913172144, 0.37348816904100157, 0.3580583081083367, 0.1024592693269839, 0.08947000899308155, 0.06082544813665769, 0.05339672078891433, 0.16313233369780222, 0.06625461484118111, 0.07760266143025152, 0.15207540908333217, 0.06560428195947021, 0.20372087417195472, 0.2142233871215371, 0.16311230235865715, 0.21489032485449655, 0.21562973054643986, 0.1824923220129382, 0.2256795242092159, 0.2452928773384011, 0.20522931307574543, 0.5545088176727697, 0.5893253601064259, 0.5090495083255314, 0.5566181991249947, 0.595663115157463, 0.5039836557159281, 0.5929137586640782, 0.5834472842696212, 0.4757863783182025, 0.0930543216721691, 0.08846256082412329, 0.0826328594487753, 0.08396443864479441, 0.0937760740657343, 0.0824216240136657, 0.10349947218948763, 0.08611677487222336, 0.08403776481803393, 0.14282090544488546, 0.15854681141676008, 0.14039478233459435, 0.16722003219189863, 0.16275937898937642, 0.15926197980209633, 0.16732782883066988, 0.15912469260402873, 0.17763758264458485, 0.28154082457597873, 0.3041852306595815, 0.27627613533901507, 0.3143779246872547, 0.2886096790055047, 0.2775278697550806, 0.31399347120884824, 0.3361040524747697, 0.3108023422668582, 0.2405733925139325, 0.24072018776153126, 0.22239894613215472, 0.2500456425933527, 0.22877135115563152, 0.21857939052989628, 0.23847368323147689, 0.24269696793232942, 0.2490342413067187, 0.18768065670729717, 0.18608659624759916, 0.1747501022194723, 0.18170888178218325, 0.20951323660045462, 0.2060613001073741, 0.18347864636568567, 0.17864415906515618, 0.17825727526881452, 0.1949095049522993, 0.17889210384507626, 0.18466953538789, 0.16962486204565574, 0.1861891692054658, 0.1776730588969242, 0.17248899090495085, 0.17703890922549526, 0.17291690028952456, 0.5553519318879003, 0.5905183861708884, 0.18291995611644174, 0.5968543431973345, 0.5458567358230774, 0.43469389912088263, 0.4054551089004853, 0.25871070921708283, 0.2014068418411994, 0.6159455307012244, 0.20507310195374095, 0.48399323121881976, 0.18502231987959705, 0.3516370306880737, 0.48933833697398843, 0.5851633953607898, 0.20368151529638878, 0.4952853049207011, 0.1713003141651579, 0.18708955569034036, 0.1905309411064895, 0.17620967945055055, 0.16767052369923963, 0.17631530512285387, 0.20687630318647643, 0.17818649816691956, 0.17439234332357245, 0.062261047934355385, 0.07283173240181473, 0.07064192616289433, 0.06199088367725103, 0.07110280076552677, 0.06845718006995194, 0.06883580921927768, 0.08906117514290768, 0.0693094255094302]}, "mutation_prompt": null}
{"id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 50, "fitness": 0.322427094335997, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "e3ecb613-b6ff-42c2-8d8f-bd4cdf2096c1", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "efd6d973-2b72-499c-9902-df281bb12aa3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "6039f618-0da6-43de-8813-e0869ace5aa5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "d2073913-2607-412a-bf23-671b4de59d57", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "516c989a-37a8-4c9b-8566-2161d0208e0b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "18cefa74-4245-49e3-8df0-0c887eb62cef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "8804af28-b17f-45f0-a1c5-a88f5dc398d6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "e01bd254-756b-4e6c-be8f-304b0ab7bca6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "ec2f3fae-e35e-4594-b1f4-ef063e3aa8e0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        # Implement dynamic crossover rate adaptation\n        self.CR = 0.9 - 0.5 * (self.evaluations / self.budget)\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling and dynamic crossover rate adaptation to improve exploration and exploitation balance.", "configspace": "", "generation": 58, "fitness": 0.2585809627267098, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7427386448669134, 0.6550489968906481, 0.6906025058224318, 0.7782693208682034, 0.6970720550387709, 0.7088897037140967, 0.7728880411160226, 0.6678685043538704, 0.7120360898566218, 0.5563085499216287, 0.49490835212236206, 0.5142845977221705, 0.5371301418813553, 0.44763001115903467, 0.5092618022568982, 0.5809607732965278, 0.44368380998656554, 0.5345128638266402, 0.14901056668611945, 0.1282005314391541, 0.1184278651268843, 0.13886959203900884, 0.13615587385713734, 0.12322515527586586, 0.14699618490686772, 0.13320972259269492, 0.13294417080262988, 0.13318502588665793, 0.11456496449588793, 0.1207033914760115, 0.13348457039262318, 0.11547396609902116, 0.11656602746655631, 0.138747398210187, 0.12836793220026266, 0.11787639575756348, 0.9483322734882752, 0.9278198617171166, 0.8842681847024693, 0.9072170180425344, 0.9418701308247974, 0.9742560033963041, 0.9340279776736327, 0.9351651780115416, 0.9610350238098967, 0.36793683701595015, 0.28986634177148773, 0.2910324223709627, 0.333540717512122, 0.2788672807579594, 0.3073074544993739, 0.29592523155174777, 0.25253581309649664, 0.27440184739894335, 0.6248865575635696, 0.27637731942604427, 0.6276615248551649, 0.7492955290462238, 0.3098572444011257, 0.3727688479096175, 0.6421358918280955, 0.32156791300019205, 0.28848424284342056, 0.14590467814182462, 0.14337465149286877, 0.16175877687702833, 0.17678103212655005, 0.13714920840311384, 0.16332100776762526, 0.1683687365634451, 0.12469342596052757, 0.14638623620947055, 0.1912245408374008, 0.14050632734233892, 0.10580165657506968, 0.1612017216624918, 0.1473053376494945, 0.1540806052552698, 0.17390573805290044, 0.18161666082061134, 0.15772949305335404, 0.051487363529235, 9.999999999998899e-05, 0.025174335517989643, 0.07547930954070647, 0.015779097710662104, 0.009425030151452685, 0.08224755925505611, 0.0042269663391152346, 0.034840300551145065, 0.1702796856587767, 0.11936110291580293, 0.1701657472102832, 0.18045747457365413, 0.08134134902927703, 0.14539552264895106, 0.21559984981512548, 0.16978383630295124, 0.1854490041958734, 0.017517730162189382, 9.999999999998899e-05, 9.999999999998899e-05, 0.003949824512365918, 0.00020755902825986272, 9.999999999998899e-05, 0.003941501765386435, 0.0046644806906696035, 0.026915187669402596, 0.14036791814236493, 0.09058501283633391, 0.11648066196394125, 0.14926606981302104, 0.11452214988147313, 0.1365651893430775, 0.1351759136270384, 0.10700768764749924, 0.12708678956948738, 0.5081438856312528, 0.41098504162792615, 0.44995051612271486, 0.47242244433637093, 0.42831140402484214, 0.4611553440378129, 0.4981123329254751, 0.44025012125578733, 0.4648449342006682, 0.11382175132044958, 0.08815720621734124, 0.09782928751635678, 0.10127485876181619, 0.0898463333260664, 0.10749691223209445, 0.09936148232419395, 0.08918565103175857, 0.09546108661964914, 0.1352481037967671, 0.16890107025407508, 0.17528111466552232, 0.1323693167776504, 0.14727966061053865, 0.1656432986452735, 0.13415299263288016, 0.1369917101403948, 0.13470522952653718, 0.30907859648692515, 0.2721341722691567, 0.2817168771190821, 0.30052214494238527, 0.25514454184933655, 0.29387647295207653, 0.38240173918169085, 0.31641704865491616, 0.31296526453157936, 0.19786954594005346, 0.19359245022648286, 0.18659060687904594, 0.21098007597384227, 0.15440062618287353, 0.19353746397189242, 0.22894903200745242, 0.21280539127692555, 0.22097004212109095, 0.17956457399576853, 0.16949397251850584, 0.1992965236834331, 0.19101595698857077, 0.17472297675869208, 0.1799551596953114, 0.19072088078384375, 0.1895091066244331, 0.17046070966731752, 0.20902489413278058, 0.19783689405978433, 0.1819576930545993, 0.20685803386044954, 0.18661241858657118, 0.19466439256762946, 0.18441027137384258, 0.1895622186508249, 0.19414982579954143, 0.18490119162619723, 0.2628329811811422, 0.1774019185052963, 0.3098910054873423, 0.19802343518843535, 0.34016903314438696, 0.6170204596895701, 0.200047500820565, 0.19645032193050793, 0.16282581538505925, 0.2027515025285529, 0.318450714250486, 0.299577658942242, 0.1870993078768245, 0.1865583508564328, 0.5694064889222759, 0.1985273808732101, 0.2000180132349979, 0.18954789067225097, 0.18924328349692532, 0.18289491454582807, 0.20117145597111963, 0.17832852652479414, 0.18244120023106303, 0.18295662907358856, 0.2099688084749708, 0.19347820518547176, 0.07697919444829837, 0.07789239365804046, 0.07730447059024448, 0.0802493675548196, 0.06999805946566051, 0.08648610357743003, 0.07599923743107062, 0.06844606426663724, 0.07639556310974382]}, "mutation_prompt": null}
{"id": "9e1402e8-2263-489f-9e31-e8c46927e1d0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce dynamic scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.4, 1.6)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def local_search(self, individual, func):\n        step_size = 0.1\n        for _ in range(3):\n            candidate = individual + np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n            if func(candidate) < func(individual):\n                individual = candidate\n        return individual\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n                # Apply local search if within budget\n                if self.evaluations < self.budget:\n                    population[i] = self.local_search(population[i], func)\n                    fitness[i] = func(population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation with dynamic scaling and introduction of a local search component for improved convergence.", "configspace": "", "generation": 59, "fitness": 0.13220924471265716, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.11.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.27720750567305985, 0.2246159938616744, 0.2737052388814597, 0.28665549434318005, 0.26314258393109036, 0.24306919150701511, 0.2616087770037716, 0.2766320561353457, 0.27192276197955856, 0.0020795778950090105, 0.02943864303715249, 0.015812874890347106, 0.02204701328690284, 0.017801407566971683, 0.020387125114316063, 0.02216320678984307, 0.032436434133519265, 0.014033652345535441, 0.06679201179796035, 0.08237242820963275, 0.07699306541973527, 0.06673235789906651, 0.054771766952235734, 0.07336948918762776, 0.06340205286472067, 0.07283659522930486, 0.08573088846109589, 0.0750029179543561, 0.04329078168000655, 0.06373129229907049, 0.07511996996981485, 0.05749407223645553, 0.05003725495270661, 0.05700416458137336, 0.04570667877795953, 0.03637205070477745, 0.6701809380084875, 0.6409489500877416, 0.601426512407999, 0.5292542043123509, 0.6055654161965847, 0.35359649584784025, 0.4745522015588637, 0.35088970207612746, 0.6710398411143655, 0.1137825123319679, 0.06767943955827704, 0.07589342864777082, 0.09533989927567277, 0.08005538784649457, 0.0949899454704286, 0.07947683331039623, 0.09046152460366574, 0.10266585573897846, 0.1466794544743052, 0.17194265045848856, 0.11724622945110441, 0.16058341138541543, 0.14319230308307573, 0.1277009490508495, 0.13114052560105338, 0.18212385060443892, 0.17316653938063842, 0.02944816694942476, 0.06154540639584938, 0.07845985403968547, 0.049932557136574185, 0.06940154455125136, 0.0601657379918723, 0.08477214354381868, 0.08066198949090109, 0.06750675239263615, 0.07206306907320237, 0.08497096294623097, 0.07716877542946221, 0.07004493222725305, 0.048145915920755344, 0.0762397588309901, 0.04177450439410535, 0.06118682806372233, 0.07214991115125757, 0.00017399480433089032, 0.02123118511716926, 0.00542833454003977, 0.0014949557752937936, 0.010098719457245497, 0.002126917573474718, 0.002711067921794319, 0.00011114338843232208, 0.0002814618266576696, 0.0904160349918246, 0.08949807875336357, 0.10922828212267688, 0.1227548359104027, 0.07838331497783979, 0.11742798434848778, 0.12748182535781127, 0.09636310648824242, 0.09720465246164078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0448819980165337, 0.04308717311593646, 0.04278057939728441, 0.049260561008347525, 0.03967847102110278, 0.04899864939012599, 0.0392940593169997, 0.050326705107449965, 0.05119159617320179, 0.22130441596388106, 0.28578681750038526, 0.24958657984545485, 0.23955602073076343, 0.27368235911868555, 0.2928452327055112, 0.27060313314968576, 0.22414814213733303, 0.28757463546711126, 0.07075852654360548, 0.06155773951453014, 0.06725322970425207, 0.06207246345335682, 0.06664286818525811, 0.09787533528782077, 0.08029106121407947, 0.056280551523280486, 0.09133195481257461, 0.1404841328088995, 0.1565625311025689, 0.16283698837027283, 0.1655102056969836, 0.1442962925096385, 0.16176754603680843, 0.15693420917216405, 0.15177403861366656, 0.16935058203656794, 0.18622834082654782, 0.17106008773681258, 0.18313257161637908, 0.16204475997011303, 0.15466719794254458, 0.17429025099446405, 0.16486544732930541, 0.19531604647319978, 0.17397867958913538, 0.1058685453787781, 0.12343779285387957, 0.1338170807945127, 0.12332203758093041, 0.10115047813447742, 0.11252584997147641, 0.11225666001594259, 0.13475225380834777, 0.12829764094930451, 0.177390055680964, 0.16835653659643834, 0.15842396502875622, 0.16932118458514833, 0.1685494724458052, 0.16843270065875438, 0.1648803291967793, 0.16642010243287064, 0.1704408003017881, 0.1609927806294822, 0.1349180096713355, 0.15324776155342135, 0.14425260378483562, 0.14989831022920574, 0.16744285394708736, 0.13720080216886144, 0.16035745514330646, 0.14374184467107576, 0.16565550425324127, 0.1488612370949144, 0.23235372270529886, 0.13805447110566316, 0.16452605608881, 0.16375901851122232, 0.16381407989480834, 0.1464093898455462, 0.17486509260936434, 0.22825076037906888, 0.16001336660698418, 0.13733446821198814, 0.1490631404725311, 0.18590069312630864, 0.20839109745161277, 0.17149294087015954, 0.24663114163766786, 0.1646710956094536, 0.17732443867357306, 0.17785817751081434, 0.18673660683951265, 0.17032124089475342, 0.1645609121154521, 0.19092051327232384, 0.18839874768745535, 0.1733060123576784, 0.19367874107746852, 0.05616145205165124, 0.05530305809896452, 0.06702510352615754, 0.06257276703252723, 0.057926794906132284, 0.07151509963146108, 0.05693784761709053, 0.06621314351387786, 0.05489316242546227]}, "mutation_prompt": null}
{"id": "750f5435-de54-4fca-8797-84f7a974dcdf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.learning_rate *= 0.95  # Reduce learning rate dynamically\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling and dynamic learning rate to improve exploration capability and address stagnation.", "configspace": "", "generation": 60, "fitness": 0.2980796290102652, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.6984150203909324, 0.6399503440668555, 0.649052772419039, 0.7062738848878217, 0.7023625136251783, 0.7038987879519869, 0.6704055125849886, 0.6943660157719915, 0.6693049030942791, 0.5022822010946275, 0.4439472750672939, 0.42936580609365527, 0.44341054557405, 0.4697554586763866, 0.4396543208354853, 0.4629123928275908, 0.4635179390907195, 0.4838491629634575, 0.1197455707120969, 0.10771072262611703, 0.09497132545061027, 0.11266877899186767, 0.09521198277243426, 0.09994683805349303, 0.09593450303954432, 0.10551860351263154, 0.09221281879023169, 0.10033825394180662, 0.09871450828468309, 0.09971552222268731, 0.10298526300112609, 0.09974835146573113, 0.10394959802840054, 0.10085163813500853, 0.0945093021952873, 0.07697825581718976, 0.9074226572135593, 0.9396451712848681, 0.9598849650392831, 0.9379628818236138, 0.9623628072165794, 0.9037637570559123, 0.956807972948561, 0.9220428552807436, 0.9079758724634799, 0.3489374126146282, 0.3006741019761985, 0.3378201372214781, 0.30429728273137346, 0.3605681122990443, 0.3215909683217686, 0.3512669017665546, 0.3612196490781875, 0.32606566812521154, 0.5198726991335694, 0.5709937302155208, 0.5751364375226184, 0.621348744958843, 0.5970335044899668, 0.6166975266991366, 0.615951362319962, 0.6538151638244432, 0.6190519844492589, 0.24311964926266894, 0.22217705947888422, 0.22432881276901517, 0.2219603555438654, 0.27151770659258856, 0.22808159201862965, 0.24321676070865428, 0.2183386238032392, 0.2401475917305249, 0.262903329636307, 0.29302211998197103, 0.26080092185593895, 0.27868775765285514, 0.2209372176027793, 0.19584492319340896, 0.19829286130154944, 0.19764722674944069, 0.22766602400536107, 0.16291139251056752, 0.20375844108921615, 0.19246830040282703, 0.22097826502891627, 0.16319543592277386, 0.15284610171022417, 0.1789303072636632, 0.2110492831431523, 0.17941748853092054, 0.30439769879142486, 0.32677690897525524, 0.32824313679001527, 0.3044976133359555, 0.3235394051078876, 0.30251376222949766, 0.37515156467585253, 0.3802082320387874, 0.32733954188162473, 0.07985942023807169, 0.08162745517088821, 0.04799051385641795, 0.04965393746762259, 0.06796317477856229, 0.0687268858580159, 0.04424283389102712, 0.05514665905291072, 0.06272411415082857, 0.18803353069873496, 0.18384993740029298, 0.18587129234892408, 0.20065959530901878, 0.18714763324003114, 0.19025359696316002, 0.19428179935796064, 0.19612472396268055, 0.18339753056490504, 0.5350088507029958, 0.5560410383031541, 0.5266204931412308, 0.5276040147934711, 0.5258617623438645, 0.5356576152886536, 0.5494309631265193, 0.4941125826024193, 0.5248448115613742, 0.10528916971148683, 0.11007399531037387, 0.11245648509250461, 0.09011267527422973, 0.08397264043728814, 0.09794506204616249, 0.07957587977777913, 0.08085043625303989, 0.10562147453857162, 0.1425938895302059, 0.139386661065394, 0.18891760960520598, 0.20942712197954394, 0.15103424776161523, 0.18343621992009973, 0.18477547833976182, 0.16386609158474363, 0.14509267319009178, 0.29400695958154266, 0.29314080938507825, 0.2830371035465963, 0.3043373437774888, 0.26949485812564566, 0.30109083301684403, 0.3265531898439139, 0.3249742516558055, 0.3076508567565932, 0.23447103648607637, 0.2378473592587027, 0.21598299861539594, 0.22364389335870516, 0.2172610501836162, 0.23892568846012896, 0.2389440032274911, 0.23933503536829703, 0.26296112489764456, 0.17792436623114116, 0.20164430013623003, 0.19951596878780342, 0.18979056641985936, 0.1949494006978505, 0.18289694151029168, 0.19638246245405666, 0.18189557412270208, 0.19489203075005046, 0.17507633140414325, 0.17733506594565585, 0.18321600965190377, 0.21103782249763048, 0.18170716174591406, 0.18121517361293282, 0.1869929219607822, 0.18635323686960215, 0.1799196395550503, 0.635114284887, 0.16849875807576786, 0.5881039261050961, 0.5968030755126328, 0.5010275333646279, 0.1774295709216145, 0.18185653768194054, 0.17882756356810348, 0.6013673056097559, 0.5173297323673474, 0.1972831931239044, 0.19504307897221185, 0.5077109699386045, 0.47058561327018855, 0.5049967819675552, 0.20329722185399768, 0.19950927717843048, 0.20086889671632446, 0.18981694010944516, 0.18155155837944892, 0.18313443465700252, 0.179443578859522, 0.2010819605356301, 0.22029791195037063, 0.19003741613840464, 0.18678074068537964, 0.19359746880184825, 0.07148150479912585, 0.08076835701676666, 0.07742527972518132, 0.06992052263760129, 0.07295357442703898, 0.07470182426857463, 0.06751559976598442, 0.07594609965318921, 0.06796338975276028]}, "mutation_prompt": null}
{"id": "afa22146-8221-448d-82b9-89e36daf752b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "a4f2a449-518c-409b-b30e-ef58f861fdbc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.dynamic_adjustment_rate = 0.1  # Rate for dynamic population adjustment\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_adjustment(self):\n        if np.random.rand() < self.dynamic_adjustment_rate:\n            self.pop_size = int(self.pop_size * (1 + np.random.uniform(-0.05, 0.05)))\n            self.pop_size = max(4, min(self.pop_size, 20 * self.dim))  # Keep population size in check\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            self.dynamic_population_adjustment()  # Dynamic adjustment\n            for i in range(self.pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic population size adjustment for improved performance.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {}, "mutation_prompt": null}
{"id": "05ba57b5-ed4a-4365-94ad-e3deda1cc837", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce dynamic scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.7, 1.3)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        # Dynamic CR adaptation for robust convergence\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.7, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with dynamic scaling and crossover adaptation to improve robustness and convergence.", "configspace": "", "generation": 63, "fitness": 0.3087270698547364, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7293329144898992, 0.5813004279336467, 0.6597008793825954, 0.739324868782295, 0.625155473621239, 0.7171746662426123, 0.7468547792754282, 0.6082767094423391, 0.6634083930938508, 0.5090405744159521, 0.38534143637201534, 0.4910064754790303, 0.5677158539500451, 0.3940856905261698, 0.4850613193171813, 0.5134899136078932, 0.36844147825634477, 0.44603605965909554, 0.10163882452021156, 0.07983459537262405, 0.11473046605270998, 0.10441396081223064, 0.09789837407600188, 0.10138651787658715, 0.12215367767363838, 0.10565537411316894, 0.09836451703828042, 0.09420058534045894, 0.09988504759996963, 0.09553706576514454, 0.0886737162773441, 0.0844958297518531, 0.09357403354465388, 0.09298370085095142, 0.0882430725941058, 0.08461814730213846, 0.9876481041228602, 0.9326849466999697, 0.964262209607271, 0.9283505173108546, 0.9391240438423932, 0.9504509020055902, 0.9525390310367083, 0.9478197669828651, 0.9090857818954277, 0.35686935995875824, 0.3028583084277743, 0.3192568458523918, 0.3836521485142773, 0.2943000116575537, 0.28580138906280794, 0.39093096552992845, 0.3226095822404236, 0.32814655573388607, 0.8055250985588618, 0.5254496386091425, 0.5110978495686798, 0.8144156211936768, 0.5906133848881148, 0.6090646834368703, 0.777247699123847, 0.5526720749352472, 0.5860289400014155, 0.3907124047444269, 0.16811453058254067, 0.2027352397605663, 0.3530097708161384, 0.191443730423962, 0.2270915018455959, 0.38954918681357387, 0.18994973880837507, 0.2338459207086201, 0.3602353733204501, 0.24850705268239248, 0.18251270442333112, 0.35299219396388193, 0.2093104538875844, 0.13355903205584674, 0.3003881313336323, 0.167286451713884, 0.2088177373421316, 0.417062910285793, 0.20925334664161255, 0.15162595498682552, 0.4093340670413178, 0.20672661327778996, 0.13006197884271986, 0.37757539089763337, 0.1869450120118833, 0.15888742192598582, 0.507219451434846, 0.289609972232014, 0.28438452921021173, 0.5339549630247857, 0.34036275506608293, 0.23752510097860924, 0.5885117462983136, 0.3452417427689075, 0.32589235079097867, 0.17376163179977555, 0.03693776979557584, 0.043104973594747964, 0.2837104450794763, 0.06348590055047332, 0.043006021880795386, 0.22841793104563823, 0.03085069692492637, 0.04338834223056476, 0.281402973173173, 0.1736845684774282, 0.19461067692373857, 0.2989340882617181, 0.19999336114440136, 0.165269245545844, 0.30742158441375755, 0.1873644880596389, 0.17518629913133932, 0.639143038219725, 0.5159538796010994, 0.5412620875136449, 0.6392286616886854, 0.49318057282503847, 0.5395422749869502, 0.673465219784191, 0.5247845991920854, 0.48958979596231733, 0.09967937841089658, 0.08561920462575745, 0.08395737930457614, 0.11553776894968437, 0.08332381614055717, 0.09429721789673129, 0.09169586336073954, 0.08306161597288775, 0.08480272595497407, 0.16469164689529747, 0.14886476320682362, 0.15570345639650474, 0.14502581434112105, 0.161338975493304, 0.12910571217173505, 0.14507845012427656, 0.13722587802862962, 0.14002430838560287, 0.3294625963362132, 0.28178206053501476, 0.30543796850332416, 0.34937844363748893, 0.26372796490473915, 0.2682499043348432, 0.35328456710237655, 0.3026963519493405, 0.3318565422525621, 0.28543481726587416, 0.22920796026887436, 0.2280327810942372, 0.2831132658062211, 0.2247838017401117, 0.21614446441770774, 0.2812951630489997, 0.25656624283637763, 0.25756530999152527, 0.20325706534999965, 0.20619396573961957, 0.16925882903496292, 0.17451000754625434, 0.16026068372811464, 0.17565698531977036, 0.2055716678602847, 0.17868139694081087, 0.19103735126434718, 0.19887099215967552, 0.185018084940352, 0.1952143307375913, 0.18051072576125027, 0.1735404898043782, 0.17322998640171605, 0.18230671700524226, 0.17925473828958582, 0.17685204822745326, 0.707407787210756, 0.4769288857689554, 0.18244895772526382, 0.6963242337836373, 0.5675860656241243, 0.4629251217311683, 0.7314701624830349, 0.17662848762912453, 0.16863231450818694, 0.6712307390995587, 0.1647223321763991, 0.1969050072771158, 0.16328100480269736, 0.23375952969728553, 0.17908836363683533, 0.20817930553378405, 0.20432391459988175, 0.206386976518651, 0.1992815781229771, 0.1816963347148518, 0.1867935345309868, 0.18723435808403766, 0.17261694968508623, 0.16707973187303216, 0.18845843305940457, 0.1762702187358538, 0.19123813727005734, 0.07399150870338012, 0.07444075845678855, 0.06878815285499984, 0.07387031048449211, 0.07339817125435333, 0.08775794880215237, 0.08251174243063264, 0.06945387829865635, 0.08119743170022542]}, "mutation_prompt": null}
{"id": "801b6c75-7be5-4e49-b17b-90dde26192ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        # Introduce random scaling factor for enhanced exploration\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)  # Adjusted for more rigorous exploration\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()  # Adaptive parameters\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy with random scaling to improve exploration capability and address stagnation.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7170565187912776, 0.6262189295766465, 0.7152517584632774, 0.7895121923492142, 0.6420646385545115, 0.7090282571519079, 0.7628455911485477, 0.6368658348517338, 0.6877532886928559, 0.5990702320893477, 0.41164936727710066, 0.5064991498214233, 0.5741572057673293, 0.4501544131658616, 0.5179314930840058, 0.5495077524715876, 0.46336406135701247, 0.5172885420823162, 0.10757479045845342, 0.09855365075325295, 0.09270269934174025, 0.10091498725629322, 0.11029934597075752, 0.10653295503601967, 0.09574361128589282, 0.1186421968534993, 0.13337298454327773, 0.08690932985562905, 0.09333688781911154, 0.08649263220233139, 0.10677794872664104, 0.08457947756504713, 0.10125943088079858, 0.09396154207384622, 0.0878441182409444, 0.09004505476926739, 0.8772902918838346, 0.9421965888138375, 0.965856590833621, 0.8739539757717011, 0.9453381752591085, 0.9081170187271874, 0.9337615946135464, 0.9244151241645199, 0.9665085235451801, 0.36209419654266406, 0.327706650615899, 0.3180130695783705, 0.3606790886078215, 0.31861801568691395, 0.3480124839793569, 0.4046257844907505, 0.3305118022608873, 0.3161091342991442, 0.8223661155896999, 0.5430077819279693, 0.5601759631613197, 0.7817642385431989, 0.6375679242221489, 0.6489590123951626, 0.8202356554036733, 0.587105827482348, 0.6543966365798106, 0.3504679167139748, 0.18160602913874468, 0.24961793917560082, 0.30938709103981044, 0.22582710962474273, 0.20019908896905814, 0.47042890776545965, 0.24491517541613628, 0.23322606580045924, 0.3618372508856669, 0.11252153072762872, 0.02063543403598611, 0.3647923490340962, 0.26646017524985377, 0.18874683794740943, 0.4658479866038653, 0.23015717769180077, 0.20742231919957, 0.4242293156854938, 0.20528551546198837, 0.18075074268062086, 0.5019453912728415, 0.21545842457948872, 0.16423239385550514, 0.4601776677560312, 0.22690420600528316, 0.1653580070779861, 0.583010019286282, 0.4369642843563879, 0.24471006420843677, 0.5929124237994979, 0.3121925744825288, 0.27089586165641555, 0.647387264628317, 0.40363689273527315, 0.332587079124685, 0.2015083115815307, 0.05435216971549106, 0.0699109290497194, 0.28108039949584984, 0.10046713281359076, 0.082018496386428, 0.222792875373112, 0.0748776199454293, 0.09081229875690278, 0.34738736049272934, 0.21550320582341287, 0.1690317058003611, 0.3390303023231416, 0.2306068049265788, 0.21721304437919386, 0.32576182761279915, 0.19169553756786417, 0.18241064772829085, 0.7259022114419907, 0.5148319723935099, 0.5298241150432862, 0.7207749337760718, 0.49874642292862725, 0.5306476669982612, 0.7060162719794643, 0.5205707796260661, 0.5261543704426825, 0.09108870389560286, 0.08066756039259348, 0.08682395684884192, 0.09209859616914617, 0.1068040384371578, 0.08662264628487815, 0.1102932887016912, 0.09008557909125425, 0.08157111404137685, 0.22880987136306663, 0.14017344523331654, 0.1596786027614966, 0.13969931750734288, 0.2499856308147963, 0.22244789166766854, 0.18664014333600076, 0.3509283063972962, 0.13786579056601966, 0.35303399741838626, 0.2939854119920057, 0.2971794318707254, 0.369827451628727, 0.2970959612082247, 0.2958283432659604, 0.3832489015241811, 0.3157656356552324, 0.32608374992231537, 0.29499518660719715, 0.21444818031434976, 0.23635732916587604, 0.30062317790874615, 0.23632053479634418, 0.24976722047218447, 0.2977360483589351, 0.2850168840451919, 0.24859026314854005, 0.17865726282409888, 0.18533403844557095, 0.1767274102525369, 0.19811027535491466, 0.1827578045078685, 0.1717380804022418, 0.17997194317458065, 0.17400581559962902, 0.18821920572798456, 0.20961491367281193, 0.17105949375469887, 0.18698148527978142, 0.19904918605137578, 0.16876938739672442, 0.1763893994412058, 0.19332635843189228, 0.18048026677731255, 0.19229048854195474, 0.7372116884095976, 0.16508562008259686, 0.16408286636024771, 0.7664158987714813, 0.5997094822687101, 0.17424595076654348, 0.1815935431653225, 0.15045156422555428, 0.5330150446301274, 0.19547443257093255, 0.18451532820142336, 0.39529714637475555, 0.33969351068586207, 0.23697000333725304, 0.18054947167772228, 0.20343705288327574, 0.20611975103682612, 0.6820037386642436, 0.1753794874008514, 0.17869739405153773, 0.1975100185888936, 0.17873466924288095, 0.15572789670034204, 0.21513500389436435, 0.180791166788987, 0.2497672871162383, 0.19347820518547176, 0.0899176585266932, 0.07431000367959872, 0.06798308750663329, 0.07907734835352676, 0.07085167028308192, 0.07611944257869852, 0.08599423780169124, 0.0741162294845088, 0.07930440344527145]}, "mutation_prompt": null}
{"id": "d7212103-c737-4899-a8e9-8a6dd70a3073", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.pop_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.evaluations = 0\n        self.learning_rate = 0.05\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.6, 1.4)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.15, 0.15))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.pop_size\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Optimized adaptive parameters and mutation diversity to enhance convergence and robustness.", "configspace": "", "generation": 65, "fitness": 0.32174712499466374, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7200405031795689, 0.6192439695761405, 0.688322552078221, 0.7854934740533175, 0.6600195392026353, 0.728882928476813, 0.7505887904786369, 0.6355724074818861, 0.7061065910808373, 0.5314700143923062, 0.3914609188907656, 0.5128485640748436, 0.5251254604649442, 0.4521300097587133, 0.5178278883003339, 0.5214336142445339, 0.45672416261613324, 0.4977066601348167, 0.10920707224661386, 0.10512500948165127, 0.0977659559575923, 0.09230183605427189, 0.12342446896697679, 0.10062859790021594, 0.09443002109117682, 0.10083834554916427, 0.11683456992080898, 0.09763414878391263, 0.08812489435338411, 0.09946521772977068, 0.0971374897556827, 0.09737345094717442, 0.1040555622135606, 0.10115560531455503, 0.0896099705180099, 0.08721453700578075, 0.7976632452749356, 0.8988652966330136, 0.9660761854617677, 0.7579402346898233, 0.9533191575120396, 0.9517752798408554, 0.9435417381862896, 0.8914326852674195, 0.9450756110578613, 0.4024441058114384, 0.3057661026748205, 0.31379967506324247, 0.3218628348856003, 0.33352802941888926, 0.36751411063693173, 0.3503841866689278, 0.35448567812465737, 0.34384477240368594, 0.8241948047027948, 0.6148300945712493, 0.6172644341389901, 0.7950070296480578, 0.6258833036855778, 0.6328645528878538, 0.8165944746372328, 0.580852433624824, 0.6616889239560427, 0.3175476569867056, 0.20554533286708343, 0.2733434711068988, 0.3449253665820665, 0.19927807348288784, 0.22840082987240717, 0.3176016360896432, 0.20224410293042605, 0.28629455437558304, 0.37610125866553656, 0.25574525386432945, 0.29509754736790905, 0.337797328322892, 0.2007082577253425, 0.24934308228864588, 0.3366058749135076, 0.2501155821621073, 0.2543650811312509, 0.3299016466677084, 0.20295624130175194, 0.19923206572795782, 0.41541979862333356, 0.18761972452932174, 0.20404943723739288, 0.323321024550285, 0.19776432992922544, 0.19784399924320173, 0.5028913389242764, 0.3067946805531563, 0.3385332428926193, 0.5327768672993005, 0.2934790437858774, 0.2992883706427405, 0.49934345029342053, 0.3330019740938531, 0.3986907175080633, 0.1398756266297787, 0.06172285210921746, 0.06339133210665582, 0.1709876672327486, 0.07098910078013909, 0.14298213806443105, 0.12018175045122903, 0.06534469651349484, 0.11232919590805213, 0.2645083336762898, 0.18981790224287765, 0.20228569403506136, 0.269169270149366, 0.19769153688209617, 0.2020645257671292, 0.2633977708694111, 0.19543395178655232, 0.21444630842959922, 0.6323647251778881, 0.4714088927774517, 0.5780875247203392, 0.6189938684804782, 0.4954111584231571, 0.5739614878091659, 0.6291902252273153, 0.5101301665410223, 0.5662827737425632, 0.08466688106220677, 0.08392302253464967, 0.08737225629806256, 0.09621902167500573, 0.0808202212961987, 0.0937852225697754, 0.0856209754434214, 0.10086907987595428, 0.0931740989546801, 0.16022775009683154, 0.14547564588276252, 0.12814292028325147, 0.22686568557116193, 0.15263024531187075, 0.17444432060004345, 0.23878402156610667, 0.20366282539029623, 0.13947534064712108, 0.3317728199092137, 0.2884913920598525, 0.3264943912960674, 0.33495098470038287, 0.27963089898883886, 0.31430579071799003, 0.32480746346303546, 0.3302219608031607, 0.34286889352298944, 0.2640577436223954, 0.22132596708383956, 0.23366852989644704, 0.2838714071652483, 0.2309740895738409, 0.2462966216350908, 0.2743904213451147, 0.2560692345416946, 0.2377520194065439, 0.17316772480171494, 0.19145683752203257, 0.20298045649007823, 0.1761311809321654, 0.17309192797800166, 0.1803083304729466, 0.199798623890022, 0.16575180284156266, 0.1817043238596462, 0.19842774488772708, 0.169521188898059, 0.18967750938680927, 0.18078541089120537, 0.1756320448864117, 0.16875226544480593, 0.19225489058185108, 0.17541704674590652, 0.1720775258354944, 0.7360939321352429, 0.338843695969977, 0.687218766853108, 0.7882758505353443, 0.18106761037702757, 0.4648170962602769, 0.38028192161440333, 0.15800618050631565, 0.47246944336626606, 0.7441453154509905, 0.19451011896833947, 0.19398826758907783, 0.5624004904276994, 0.18651082630596816, 0.18503670099863223, 0.7077110246615889, 0.20365310135511805, 0.6501508750626613, 0.18345969909546211, 0.18048574922717875, 0.19736789240067665, 0.1740730223306104, 0.17877547379135106, 0.19203077255876322, 0.18182589188684184, 0.176123756713651, 0.19680417271847972, 0.07084265882586738, 0.07419375824798957, 0.06832584928879237, 0.08055504774682709, 0.06527891418112763, 0.06785904829576106, 0.07383886840196552, 0.06850524371410938, 0.07856245503350112]}, "mutation_prompt": null}
{"id": "6f8303f4-2775-455b-89d0-c46074801a70", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population size adjustment to enhance adaptation to different problem landscapes.", "configspace": "", "generation": 66, "fitness": 0.3704898219337722, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "966c36d6-cf80-48f3-a5fa-9a05c4ad8e5f", "metadata": {"aucs": [0.7586453248877598, 0.721875579338304, 0.7712247380975976, 0.7743131044627853, 0.7477018045841977, 0.801239343056434, 0.7760437173340866, 0.730434852171608, 0.7769355653366121, 0.6592259853601898, 0.5847602198331835, 0.6504233110577755, 0.651745849407702, 0.5667556822921185, 0.6685921283586108, 0.6697314539951283, 0.5947441431035652, 0.6581803742938936, 0.11751228446032569, 0.12441045548391738, 0.1638953121796478, 0.2916346527662339, 0.24540941541332595, 0.11964962178670324, 0.1948817588388001, 0.16210495033275807, 0.11956824557260004, 0.11234902774985744, 0.11272943605696761, 0.12807149029557952, 0.12296725591112012, 0.09611672374104929, 0.10125225192722809, 0.2235239263752724, 0.1434881534354483, 0.11278357269581374, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.8604688660739819, 0.9716187312077708, 0.9668937620329957, 0.5475122174255997, 0.4328339048498735, 0.5277492182622363, 0.5479294071241282, 0.45887348850322673, 0.4670852752519433, 0.5401074376358451, 0.47806543274478597, 0.5366570479178139, 0.6996422109289314, 0.6574360176885584, 0.6898133623186378, 0.7200541201632795, 0.7159615537635676, 0.7424424025103185, 0.6988121647096456, 0.6013491283686434, 0.6965386115772574, 0.47142803000538147, 0.3340481439206271, 0.254202713089582, 0.37866085092607804, 0.21578830860981468, 0.2135396003415324, 0.42961956935265944, 0.3338863678364663, 0.2059813767813623, 0.1812826990336498, 0.44999704155015274, 0.3211342449577361, 0.44357265664522527, 0.31133676714359926, 0.18790213033456737, 0.40641991065304306, 0.28414779375606813, 0.20601595230502245, 0.41867860393970524, 0.1515874707704139, 0.3858450978270498, 0.3981156095625542, 0.21451181723991686, 0.3939868360289456, 0.35058254197829963, 0.19187113503510167, 0.44824620010369254, 0.4380948256430748, 0.3618722309484016, 0.49388710150086634, 0.4471892412589066, 0.3904771649452198, 0.5802266776599961, 0.49066518669667936, 0.3916782839494687, 0.5161481309959194, 0.1323086318337302, 0.09486256573036644, 0.10230328147436141, 0.22246785446082418, 0.11796755302907769, 0.19883539044336362, 0.14102799129226784, 0.09472064314753992, 0.1564557196387708, 0.297434774827231, 0.2111633824469703, 0.33197835140797893, 0.31024406600460075, 0.23459869658420907, 0.35037842021758236, 0.31537544509032756, 0.2124031853806697, 0.22647830063274954, 0.6474121886350175, 0.5960989311547595, 0.7168485667869671, 0.6810351646352748, 0.5464785709925988, 0.7073952636477361, 0.68578372271785, 0.5385726157572358, 0.7041735305361345, 0.12504563393260237, 0.09540129997971047, 0.10007146474530815, 0.10977226718695332, 0.10853665938774903, 0.10082610805404624, 0.10211734651186921, 0.0930341481449497, 0.10335038626110149, 0.23586398557332322, 0.3775796949378456, 0.1462289446800178, 0.1849049714317983, 0.1673432435203971, 0.1825747600041071, 0.23721201050599516, 0.1518186149607511, 0.18057024219667495, 0.4397268443851694, 0.33037374433985633, 0.5435963440257108, 0.4261399121880425, 0.36551387382092226, 0.45602109981682815, 0.4784689734356783, 0.38288117696531765, 0.5591090484927089, 0.32243547998249, 0.2613140781220479, 0.3530189083480273, 0.3349382037602545, 0.24565645913407375, 0.3791341246550204, 0.36015628289552604, 0.28495215668651586, 0.37888035227153116, 0.17797678133011063, 0.1768872371449164, 0.18648528888559346, 0.19462632690323967, 0.19480953843704374, 0.22926719148897623, 0.19169342692625646, 0.19897518723456997, 0.1895226309640734, 0.20896524391907356, 0.19395007099139505, 0.2634254953427583, 0.45943693761945237, 0.18373187299623184, 0.40556573680303276, 0.43377837844856626, 0.25867258732377074, 0.4883907454090789, 0.175967296302598, 0.6937332957599545, 0.7298035178793616, 0.6733626535525252, 0.5623725416247027, 0.24464295545640025, 0.678632075483911, 0.1754339095097448, 0.15704720342956646, 0.5809762158999383, 0.19749505155641778, 0.15931414661274446, 0.43538556309076293, 0.1854373484451891, 0.19652844343746667, 0.20809007138833757, 0.20500128375243531, 0.20689684350531945, 0.17129408377841537, 0.19174255701007448, 0.20616003456962184, 0.17402777493307275, 0.2001322429040232, 0.20819086643470375, 0.19063539619426773, 0.1967410160831089, 0.19559298462919572, 0.07858491705700676, 0.07418932889083518, 0.0756247602110629, 0.0788699493018854, 0.08872867529100659, 0.08132379880380669, 0.0703869257022528, 0.07061462618324299, 0.0746592969949077]}, "mutation_prompt": null}
{"id": "947aa977-15a4-48b6-b240-b8c40e67e1ee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population size adjustment to enhance adaptation to different problem landscapes.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.7586453248877598, 0.721875579338304, 0.7712247380975976, 0.7743131044627853, 0.7477018045841977, 0.801239343056434, 0.7760437173340866, 0.730434852171608, 0.7769355653366121, 0.6592259853601898, 0.5847602198331835, 0.6504233110577755, 0.651745849407702, 0.5667556822921185, 0.6685921283586108, 0.6697314539951283, 0.5947441431035652, 0.6581803742938936, 0.11751228446032569, 0.12441045548391738, 0.1638953121796478, 0.2916346527662339, 0.24540941541332595, 0.11964962178670324, 0.1948817588388001, 0.16210495033275807, 0.11956824557260004, 0.11234902774985744, 0.11272943605696761, 0.12807149029557952, 0.12296725591112012, 0.09611672374104929, 0.10125225192722809, 0.2235239263752724, 0.1434881534354483, 0.11278357269581374, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.8604688660739819, 0.9716187312077708, 0.9668937620329957, 0.5475122174255997, 0.4328339048498735, 0.5277492182622363, 0.5479294071241282, 0.45887348850322673, 0.4670852752519433, 0.5401074376358451, 0.47806543274478597, 0.5366570479178139, 0.6996422109289314, 0.6574360176885584, 0.6898133623186378, 0.7200541201632795, 0.7159615537635676, 0.7424424025103185, 0.6988121647096456, 0.6013491283686434, 0.6965386115772574, 0.47142803000538147, 0.3340481439206271, 0.254202713089582, 0.37866085092607804, 0.21578830860981468, 0.2135396003415324, 0.42961956935265944, 0.3338863678364663, 0.2059813767813623, 0.1812826990336498, 0.44999704155015274, 0.3211342449577361, 0.44357265664522527, 0.31133676714359926, 0.18790213033456737, 0.40641991065304306, 0.28414779375606813, 0.20601595230502245, 0.41867860393970524, 0.1515874707704139, 0.3858450978270498, 0.3981156095625542, 0.21451181723991686, 0.3939868360289456, 0.35058254197829963, 0.19187113503510167, 0.44824620010369254, 0.4380948256430748, 0.3618722309484016, 0.49388710150086634, 0.4471892412589066, 0.3904771649452198, 0.5802266776599961, 0.49066518669667936, 0.3916782839494687, 0.5161481309959194, 0.1323086318337302, 0.09486256573036644, 0.10230328147436141, 0.22246785446082418, 0.11796755302907769, 0.19883539044336362, 0.14102799129226784, 0.09472064314753992, 0.1564557196387708, 0.297434774827231, 0.2111633824469703, 0.33197835140797893, 0.31024406600460075, 0.23459869658420907, 0.35037842021758236, 0.31537544509032756, 0.2124031853806697, 0.22647830063274954, 0.6474121886350175, 0.5960989311547595, 0.7168485667869671, 0.6810351646352748, 0.5464785709925988, 0.7073952636477361, 0.68578372271785, 0.5385726157572358, 0.7041735305361345, 0.12504563393260237, 0.09540129997971047, 0.10007146474530815, 0.10977226718695332, 0.10853665938774903, 0.10082610805404624, 0.10211734651186921, 0.0930341481449497, 0.10335038626110149, 0.23586398557332322, 0.3775796949378456, 0.1462289446800178, 0.1849049714317983, 0.1673432435203971, 0.1825747600041071, 0.23721201050599516, 0.1518186149607511, 0.18057024219667495, 0.4397268443851694, 0.33037374433985633, 0.5435963440257108, 0.4261399121880425, 0.36551387382092226, 0.45602109981682815, 0.4784689734356783, 0.38288117696531765, 0.5591090484927089, 0.32243547998249, 0.2613140781220479, 0.3530189083480273, 0.3349382037602545, 0.24565645913407375, 0.3791341246550204, 0.36015628289552604, 0.28495215668651586, 0.37888035227153116, 0.17797678133011063, 0.1768872371449164, 0.18648528888559346, 0.19462632690323967, 0.19480953843704374, 0.22926719148897623, 0.19169342692625646, 0.19897518723456997, 0.1895226309640734, 0.20896524391907356, 0.19395007099139505, 0.2634254953427583, 0.45943693761945237, 0.18373187299623184, 0.40556573680303276, 0.43377837844856626, 0.25867258732377074, 0.4883907454090789, 0.175967296302598, 0.6937332957599545, 0.7298035178793616, 0.6733626535525252, 0.5623725416247027, 0.24464295545640025, 0.678632075483911, 0.1754339095097448, 0.15704720342956646, 0.5809762158999383, 0.19749505155641778, 0.15931414661274446, 0.43538556309076293, 0.1854373484451891, 0.19652844343746667, 0.20809007138833757, 0.20500128375243531, 0.20689684350531945, 0.17129408377841537, 0.19174255701007448, 0.20616003456962184, 0.17402777493307275, 0.2001322429040232, 0.20819086643470375, 0.19063539619426773, 0.1967410160831089, 0.19559298462919572, 0.07858491705700676, 0.07418932889083518, 0.0756247602110629, 0.0788699493018854, 0.08872867529100659, 0.08132379880380669, 0.0703869257022528, 0.07061462618324299, 0.0746592969949077]}, "mutation_prompt": null}
{"id": "d00351e9-fa93-435c-badb-fa7eb2402d29", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population size adjustment to enhance adaptation to different problem landscapes.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.7586453248877598, 0.721875579338304, 0.7712247380975976, 0.7743131044627853, 0.7477018045841977, 0.801239343056434, 0.7760437173340866, 0.730434852171608, 0.7769355653366121, 0.6592259853601898, 0.5847602198331835, 0.6504233110577755, 0.651745849407702, 0.5667556822921185, 0.6685921283586108, 0.6697314539951283, 0.5947441431035652, 0.6581803742938936, 0.11751228446032569, 0.12441045548391738, 0.1638953121796478, 0.2916346527662339, 0.24540941541332595, 0.11964962178670324, 0.1948817588388001, 0.16210495033275807, 0.11956824557260004, 0.11234902774985744, 0.11272943605696761, 0.12807149029557952, 0.12296725591112012, 0.09611672374104929, 0.10125225192722809, 0.2235239263752724, 0.1434881534354483, 0.11278357269581374, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.8604688660739819, 0.9716187312077708, 0.9668937620329957, 0.5475122174255997, 0.4328339048498735, 0.5277492182622363, 0.5479294071241282, 0.45887348850322673, 0.4670852752519433, 0.5401074376358451, 0.47806543274478597, 0.5366570479178139, 0.6996422109289314, 0.6574360176885584, 0.6898133623186378, 0.7200541201632795, 0.7159615537635676, 0.7424424025103185, 0.6988121647096456, 0.6013491283686434, 0.6965386115772574, 0.47142803000538147, 0.3340481439206271, 0.254202713089582, 0.37866085092607804, 0.21578830860981468, 0.2135396003415324, 0.42961956935265944, 0.3338863678364663, 0.2059813767813623, 0.1812826990336498, 0.44999704155015274, 0.3211342449577361, 0.44357265664522527, 0.31133676714359926, 0.18790213033456737, 0.40641991065304306, 0.28414779375606813, 0.20601595230502245, 0.41867860393970524, 0.1515874707704139, 0.3858450978270498, 0.3981156095625542, 0.21451181723991686, 0.3939868360289456, 0.35058254197829963, 0.19187113503510167, 0.44824620010369254, 0.4380948256430748, 0.3618722309484016, 0.49388710150086634, 0.4471892412589066, 0.3904771649452198, 0.5802266776599961, 0.49066518669667936, 0.3916782839494687, 0.5161481309959194, 0.1323086318337302, 0.09486256573036644, 0.10230328147436141, 0.22246785446082418, 0.11796755302907769, 0.19883539044336362, 0.14102799129226784, 0.09472064314753992, 0.1564557196387708, 0.297434774827231, 0.2111633824469703, 0.33197835140797893, 0.31024406600460075, 0.23459869658420907, 0.35037842021758236, 0.31537544509032756, 0.2124031853806697, 0.22647830063274954, 0.6474121886350175, 0.5960989311547595, 0.7168485667869671, 0.6810351646352748, 0.5464785709925988, 0.7073952636477361, 0.68578372271785, 0.5385726157572358, 0.7041735305361345, 0.12504563393260237, 0.09540129997971047, 0.10007146474530815, 0.10977226718695332, 0.10853665938774903, 0.10082610805404624, 0.10211734651186921, 0.0930341481449497, 0.10335038626110149, 0.23586398557332322, 0.3775796949378456, 0.1462289446800178, 0.1849049714317983, 0.1673432435203971, 0.1825747600041071, 0.23721201050599516, 0.1518186149607511, 0.18057024219667495, 0.4397268443851694, 0.33037374433985633, 0.5435963440257108, 0.4261399121880425, 0.36551387382092226, 0.45602109981682815, 0.4784689734356783, 0.38288117696531765, 0.5591090484927089, 0.32243547998249, 0.2613140781220479, 0.3530189083480273, 0.3349382037602545, 0.24565645913407375, 0.3791341246550204, 0.36015628289552604, 0.28495215668651586, 0.37888035227153116, 0.17797678133011063, 0.1768872371449164, 0.18648528888559346, 0.19462632690323967, 0.19480953843704374, 0.22926719148897623, 0.19169342692625646, 0.19897518723456997, 0.1895226309640734, 0.20896524391907356, 0.19395007099139505, 0.2634254953427583, 0.45943693761945237, 0.18373187299623184, 0.40556573680303276, 0.43377837844856626, 0.25867258732377074, 0.4883907454090789, 0.175967296302598, 0.6937332957599545, 0.7298035178793616, 0.6733626535525252, 0.5623725416247027, 0.24464295545640025, 0.678632075483911, 0.1754339095097448, 0.15704720342956646, 0.5809762158999383, 0.19749505155641778, 0.15931414661274446, 0.43538556309076293, 0.1854373484451891, 0.19652844343746667, 0.20809007138833757, 0.20500128375243531, 0.20689684350531945, 0.17129408377841537, 0.19174255701007448, 0.20616003456962184, 0.17402777493307275, 0.2001322429040232, 0.20819086643470375, 0.19063539619426773, 0.1967410160831089, 0.19559298462919572, 0.07858491705700676, 0.07418932889083518, 0.0756247602110629, 0.0788699493018854, 0.08872867529100659, 0.08132379880380669, 0.0703869257022528, 0.07061462618324299, 0.0746592969949077]}, "mutation_prompt": null}
{"id": "62be0bec-8cbf-4bf3-a524-b4cb000c7c2a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.stagnation_threshold = 50  # Stagnation threshold for restart\n        self.best_fitness = np.inf\n        self.stagnation_count = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n            # Check for stagnation\n            current_best = np.min(fitness)\n            if current_best < self.best_fitness:\n                self.best_fitness = current_best\n                self.stagnation_count = 0\n            else:\n                self.stagnation_count += 1\n\n            # Restart if stagnation detected\n            if self.stagnation_count > self.stagnation_threshold:\n                population = self.initialize_population()\n                fitness = np.apply_along_axis(func, 1, population)\n                self.evaluations += self.initial_pop_size\n                self.stagnation_count = 0\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance global exploration by introducing a simple restart mechanism when local stagnation is detected.", "configspace": "", "generation": 69, "fitness": 0.36407237228142303, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.7586453248877598, 0.721875579338304, 0.7712247380975976, 0.7743131044627853, 0.7477018045841977, 0.801239343056434, 0.7760437173340866, 0.730434852171608, 0.7769355653366121, 0.6592259853601898, 0.5847602198331835, 0.6504233110577755, 0.651745849407702, 0.5667556822921185, 0.6685921283586108, 0.6697314539951283, 0.5947441431035652, 0.6581803742938936, 0.10806691753054898, 0.10306632941779315, 0.1638953121796478, 0.10536931802929972, 0.10573000846751934, 0.10656810189441934, 0.11640707129226557, 0.1103422819279225, 0.09882703680355043, 0.11234902774985744, 0.09473809199258698, 0.11340700825235339, 0.12296725591112012, 0.08732741912976649, 0.09594794213248914, 0.08674161332012265, 0.11017887561630413, 0.09175701623613497, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.8604688660739819, 0.9716187312077708, 0.9668937620329957, 0.5475122174255997, 0.4328339048498735, 0.5277492182622363, 0.5479294071241282, 0.45887348850322673, 0.4670852752519433, 0.5401074376358451, 0.47806543274478597, 0.5366570361028647, 0.6996422109289314, 0.6574360176885584, 0.6898133623186378, 0.7200541201632795, 0.7159615537635676, 0.7424424025103185, 0.6988121647096456, 0.6013491283686434, 0.6965386115772574, 0.47142803000538147, 0.3340481439206271, 0.254202713089582, 0.37866085092607804, 0.21578830860981468, 0.2135396003415324, 0.42961956935265944, 0.3338863678364663, 0.2059813767813623, 0.1812826990336498, 0.44999704155015274, 0.3211342449577361, 0.44357265664522527, 0.31133676714359926, 0.18790213033456737, 0.40641991065304306, 0.28414779375606813, 0.20601595230502245, 0.41867860393970524, 0.1515874707704139, 0.3858450978270498, 0.3981156095625542, 0.21451181723991686, 0.3939868360289456, 0.35058254197829963, 0.19187113503510167, 0.44824620010369254, 0.3915203367974276, 0.3618722309484016, 0.4938871014581885, 0.4471892412589066, 0.3904771649452198, 0.5802266776599961, 0.49066518669667936, 0.3916782839494687, 0.5161481309959194, 0.1323086318337302, 0.09486256573036644, 0.10230328147436141, 0.20175359229306744, 0.11796755302907769, 0.19883539044336362, 0.14102799129226784, 0.09472064314753992, 0.1564557196387708, 0.297434774827231, 0.2111633824469703, 0.33197835140797893, 0.31024406600460075, 0.23459869658420907, 0.35037842021758236, 0.31537544509032756, 0.2124031853806697, 0.22647830063274954, 0.6474121886350175, 0.5960989311547595, 0.7168485667869671, 0.6810351646352748, 0.5464785709925988, 0.7073952636477361, 0.68578372271785, 0.5385726157572358, 0.7041735305361345, 0.11024210220462605, 0.0877098044939727, 0.08544096992702632, 0.09516838184875887, 0.10853665938774903, 0.08811275879852165, 0.08797054054733233, 0.10080979629201081, 0.09512906807408616, 0.16877821277490335, 0.3775796949378456, 0.14929559374695367, 0.1849049714317983, 0.15465073106016602, 0.1825747600041071, 0.23721201050599516, 0.1443815117688304, 0.18057024219667495, 0.4397268443851694, 0.33037374433985633, 0.5435963440257108, 0.4261399121880425, 0.36549105362778445, 0.45602109981682815, 0.4784689734356783, 0.38288117696531765, 0.5591090484927089, 0.32243547998249, 0.21728032143331677, 0.3530189083480273, 0.3349382037602545, 0.24565645913407375, 0.3791341246550204, 0.36015628289552604, 0.27272112586807407, 0.37888035227153116, 0.1697284910349185, 0.19225067214031666, 0.19421667117919683, 0.19500429031706967, 0.19127669440720818, 0.18028940566359797, 0.1903245093720476, 0.19897518723456997, 0.18810155377944637, 0.18988836537483267, 0.17692529982159688, 0.20061430169750194, 0.18783299970194056, 0.1808375881553398, 0.46042763899948336, 0.43377837844856626, 0.17981724128693366, 0.4883907454090789, 0.1759697808774472, 0.6937332957599545, 0.5721982656923069, 0.6733626535525252, 0.5623725416247027, 0.5920796949016828, 0.678632075483911, 0.1754339095097448, 0.23682263666772574, 0.5809762158999383, 0.19749505155641778, 0.20921130289082124, 0.1967736096347511, 0.1854373484451891, 0.20500235656144683, 0.2264879506730646, 0.20500128375243531, 0.20908786401611168, 0.1869020171474305, 0.19174255701007448, 0.20616003456962184, 0.17402777493307275, 0.2001322429040232, 0.20576645965140838, 0.19048483996361942, 0.18457951917408977, 0.19559298462919572, 0.07775063910288116, 0.07558470225310698, 0.07942387725597932, 0.07868667328834467, 0.07205637783106233, 0.08132379880380669, 0.07210545588756578, 0.07061462618324299, 0.07134100253236497]}, "mutation_prompt": null}
{"id": "11403183-b2a0-4a05-bfa4-67b939a6ee0a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        fitness_diversity = np.std(population, axis=0).mean()  # Compute fitness diversity\n        adaptive_F = self.F * (1 + fitness_diversity)  # New adaptive scaling factor\n        mutant = np.clip(population[a] + adaptive_F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a novel adaptive scaling factor based on fitness diversity to enhance convergence speed.", "configspace": "", "generation": 70, "fitness": 0.1887057658127491, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.22.", "error": "", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.5775460195724846, 0.456135136673531, 0.6341764249615021, 0.6955052181228272, 0.6300056839564787, 0.7051103304823118, 0.6797504833471546, 0.5838387751023539, 0.6817548913190392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.348925019811669, 9.999999999998899e-05, 0.42223263760980334, 0.011042913380317487, 0.007818379910880635, 0.011373102495654375, 0.10561987659083916, 0.07440167073676263, 0.0972287547610895, 0.09460582985566712, 0.05224928533917139, 0.08995406153472252, 0.11894828105376232, 0.07912257705256942, 0.09251121888141256, 0.06621970413161016, 0.041917495775700475, 0.06943539563445233, 0.08981535417824504, 0.043332250043659926, 0.07626659470248309, 0.07494831959090065, 0.048833611192074744, 0.07146495883719017, 0.9565702377254263, 0.9864613010282425, 0.9907922784902765, 0.9738688721263684, 0.9786223659961326, 0.9775692089926324, 0.9711188686369353, 0.9897030431256474, 0.9852626245249556, 0.3570683604053484, 0.1965970229533075, 0.2727685972273334, 0.33177986817320204, 0.24052939337376134, 0.3430142609276121, 0.04672185631113501, 0.2582665078768116, 0.07737506142722816, 0.15577915480522475, 0.1552694467250112, 0.23395892722498746, 0.37554061452438514, 0.12684879187312692, 0.4784490993499041, 0.14006561268618767, 0.1371783360645561, 0.4880280368404477, 0.102349980050364, 9.999999999998899e-05, 0.06499174517894812, 0.08966193313035487, 0.03993774275031936, 0.10346025602464726, 0.1557324314117008, 0.0829350473875653, 0.14964379291016683, 0.010015513145050892, 0.009244164508573127, 0.00957632441060774, 0.07060562252436486, 0.05597697879157182, 0.09109907643566817, 0.0374305792149755, 0.0807996138640179, 0.10092471211831011, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025059598661308025, 0.040518436481905895, 0.02533067862978533, 0.05288234231108013, 9.999999999998899e-05, 0.07071312854285972, 9.999999999998899e-05, 0.0352187357105167, 0.17006642038337216, 0.012547189733519537, 0.025898514179955368, 9.999999999998899e-05, 0.028679357663118243, 0.01498124325718131, 0.12956465122842709, 0.07489090433155654, 0.021808032777677955, 0.09965493423436622, 0.1442838721313614, 0.06577477056301739, 0.030729848435472884, 9.999999999998899e-05, 0.0971790617195093, 0.22321709372537069, 0.21508383084318217, 0.09413758187668742, 0.2700518225928229, 0.4739068315191083, 0.31613988210683786, 0.4444058753152904, 0.4420210302355627, 0.42461375385795364, 0.5833968282262698, 0.5585856919582697, 0.3466498696035166, 0.5086987662637164, 0.08749880508739794, 0.06629177981598422, 0.07433660525745289, 0.06673509035541647, 0.0370096215064204, 0.07081628967931197, 0.04619241287458753, 0.033646911596189044, 0.060017424269351416, 0.11062972475023125, 0.09655421455121393, 0.142171027156472, 0.10954840662544152, 0.11400698091547856, 0.10798713552628325, 0.10090441471095402, 0.08767173797659156, 0.13888504777901123, 0.21506880572528864, 0.14867260634817536, 0.3327535315496216, 0.2346499169273778, 0.16096897401492283, 0.27139206600007926, 0.3294632584682101, 0.26413193891599285, 0.3403408726796957, 0.08800082532244302, 0.13222157379323562, 0.1599964904931136, 0.08893110026612117, 0.13635905302936935, 0.2754430851664963, 0.11679905023815429, 0.17713920756607027, 0.18411415171345902, 0.17661749545168348, 0.1426075933951968, 0.1646981547656584, 0.16043947508413858, 0.14209939317868137, 0.15040896338430043, 0.14405724936754682, 0.14150793823421404, 0.16235888539396348, 0.11850778299580855, 0.11166858345937614, 0.1257272434922585, 0.12628801744989993, 0.11438069636666237, 0.12475927932360587, 0.12217197165020754, 0.11132460207353145, 0.1191089925047154, 0.08925256275364268, 0.16179345266045386, 0.16123045339816422, 0.15744033628457677, 0.1750808059202571, 0.16806355905645143, 0.1615626924803677, 0.13083455121150545, 0.16860145951875272, 0.2269504687880286, 0.16501612890329398, 0.1489559853242598, 0.0838656207944285, 0.12309896617817828, 0.13426309091159272, 0.18384562380335423, 0.17761442668071215, 0.16762302770230286, 0.16360422284367537, 0.16529288209626025, 0.17086529293004005, 0.1590170171876183, 0.15001581258555619, 0.14983098163414765, 0.1842034341823262, 0.15802491581842204, 0.19043051882149176, 0.04734305209993306, 0.04533905598832333, 0.055773658793288994, 0.048263693074045655, 0.04200398062711652, 0.051952487656591995, 0.0445078112114079, 0.04465587438087093, 0.057970956017004194]}, "mutation_prompt": null}
{"id": "03de677a-2a6f-494d-bddd-0bc22e03c984", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.restart_threshold = 0.1  # Threshold for restart\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def diversity_check(self, population):\n        diversity = np.std(population, axis=0).mean()\n        return diversity < self.restart_threshold\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            if self.diversity_check(population):\n                population = self.initialize_population()  # Restart if diversity is low\n                fitness = np.apply_along_axis(func, 1, population)\n                self.evaluations += self.initial_pop_size\n\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate diversity maintenance by adding a restart mechanism to prevent premature convergence.", "configspace": "", "generation": 71, "fitness": 0.25050410056055195, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.3853359340740168, 0.36603660743016275, 0.40244853095993827, 0.4158767409861186, 0.39971962758109425, 0.41651715218138075, 0.38904257675998366, 0.3670267197527377, 0.38769545067080236, 0.255373709832419, 0.2266952248487003, 0.23213939932479177, 0.2364609277275379, 0.2292305462357911, 0.2368985949370206, 0.2600277646931676, 0.22656812611862964, 0.2263331779438773, 0.10833862454741428, 0.12135774614742845, 0.13276201408987476, 0.14384109014462043, 0.12930667255738704, 0.1167859807751449, 0.14703264224659574, 0.1290349240609181, 0.12368036656990933, 0.10921566665211613, 0.11047266365201414, 0.11871655314605378, 0.11385217458578278, 0.09611672374104929, 0.10081079139375992, 0.12970407019487284, 0.11649622992805797, 0.10721961560057058, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.7882226334032043, 0.9716187312077708, 0.9668937620329957, 0.2382971417248364, 0.24004182460488432, 0.21869611692483326, 0.23597905288317345, 0.22407466485176064, 0.2247132395295094, 0.24333093468682754, 0.21161011432478005, 0.22789432113672425, 0.6064502972324215, 0.30953795685425967, 0.32310717840133707, 0.6140827746375552, 0.35733310985114863, 0.35623644879231975, 0.3055768210390274, 0.34062742097370147, 0.6153512518485351, 0.2559671572882394, 0.14741398953485352, 0.15181975972904038, 0.1507842787687561, 0.11123276061674647, 0.18804011843726176, 0.16774273744470392, 0.1468421122281348, 0.1387559007987682, 0.1544750139031581, 0.2726619891038957, 0.23077664634785378, 0.14767788479943245, 0.14307927853085634, 0.16235053996058357, 0.1750314256557125, 0.12032434720293328, 0.16155941743139646, 0.20162358339793163, 0.1447461828178901, 0.16574963952538668, 0.23040879825060345, 0.1544287161453709, 0.2199344306075468, 0.20000272135930264, 0.13810548557559887, 0.20596863639714147, 0.27939804963201786, 0.2733650154357008, 0.2852160972822786, 0.2429490213808041, 0.28153396434785605, 0.2964942149834252, 0.28733373757798863, 0.2759244094796005, 0.3380322046360582, 0.06646813237947913, 0.08323134366597662, 0.08884433187612228, 0.15011583842969545, 0.10118430014572444, 0.08660151578645525, 0.08193127579846327, 0.07757596670578681, 0.07959861900428677, 0.13776862325925632, 0.14612411085975996, 0.14479228698883762, 0.1259498207826688, 0.15142403668877158, 0.13656754339343624, 0.17694237579335714, 0.14591686188443653, 0.15788832904998995, 0.38627876069693967, 0.3782897754208284, 0.3856883272054713, 0.38711684038831706, 0.36869253463724094, 0.39445059079717326, 0.39017767008840354, 0.37181772091305165, 0.39083114247402506, 0.11901455333112265, 0.09331508125406851, 0.09183947173479279, 0.1080173838223698, 0.10853665938774903, 0.0969697988904269, 0.10211734651186921, 0.0930341481449497, 0.10188096453501239, 0.20043498449441965, 0.22161458537607814, 0.15415933979262264, 0.16772804981868905, 0.15974646827516026, 0.17989966634680077, 0.22657795014546955, 0.14834608663992044, 0.17772290474070362, 0.2657508369735476, 0.25477472540110324, 0.2738013514661528, 0.27731567996752815, 0.27258564688117914, 0.280932460801508, 0.2783538154591232, 0.2689328257569875, 0.2790561112342843, 0.22439796489586683, 0.22045173611254598, 0.2578121130042579, 0.2490379457780194, 0.21487219286698966, 0.23805346809643202, 0.23704706129497066, 0.22828337177474955, 0.24164886769082117, 0.17797678133011063, 0.1768872371449164, 0.18648528888559346, 0.19462632690323967, 0.19480953843704374, 0.22926719148897623, 0.19169342692625646, 0.19897518723456997, 0.1895226309640734, 0.20290330491394293, 0.19395007099139505, 0.19481857014894677, 0.254672781078471, 0.18373187299623184, 0.22970700212113138, 0.2335488372010176, 0.2049385010402922, 0.26095585926872955, 0.1756544819705108, 0.5827949250914093, 0.4857383017139274, 0.5117054262639812, 0.39657462585790904, 0.24464295545640025, 0.4289313368963099, 0.3437609447124692, 0.19411298493434503, 0.3991538847687499, 0.2487924524041073, 0.19519710444140548, 0.24877791210126865, 0.18467869840789886, 0.26706879819931517, 0.4175388042386732, 0.20441950775535678, 0.3476771406563488, 0.1753953888768861, 0.19174255701007448, 0.20616003456962184, 0.1754373738959243, 0.2001322429040232, 0.20819086643470375, 0.19063539619426773, 0.1967410160831089, 0.19559298462919572, 0.07858491705700676, 0.07418932889083518, 0.0756247602110629, 0.0788699493018854, 0.08872867529100659, 0.08132379880380669, 0.0703869257022528, 0.07061462618324299, 0.0746592969949077]}, "mutation_prompt": null}
{"id": "80dee056-b485-4619-83ef-a19df485bbf1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic population size adjustment to enhance adaptation to different problem landscapes.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.7586453248877598, 0.721875579338304, 0.7712247380975976, 0.7743131044627853, 0.7477018045841977, 0.801239343056434, 0.7760437173340866, 0.730434852171608, 0.7769355653366121, 0.6592259853601898, 0.5847602198331835, 0.6504233110577755, 0.651745849407702, 0.5667556822921185, 0.6685921283586108, 0.6697314539951283, 0.5947441431035652, 0.6581803742938936, 0.11751228446032569, 0.12441045548391738, 0.1638953121796478, 0.2916346527662339, 0.24540941541332595, 0.11964962178670324, 0.1948817588388001, 0.16210495033275807, 0.11956824557260004, 0.11234902774985744, 0.11272943605696761, 0.12807149029557952, 0.12296725591112012, 0.09611672374104929, 0.10125225192722809, 0.2235239263752724, 0.1434881534354483, 0.11278357269581374, 0.9205809294906856, 0.9495481237861553, 0.9682639561400823, 0.9720068945992197, 0.974878367411117, 0.9259768962123945, 0.8604688660739819, 0.9716187312077708, 0.9668937620329957, 0.5475122174255997, 0.4328339048498735, 0.5277492182622363, 0.5479294071241282, 0.45887348850322673, 0.4670852752519433, 0.5401074376358451, 0.47806543274478597, 0.5366570479178139, 0.6996422109289314, 0.6574360176885584, 0.6898133623186378, 0.7200541201632795, 0.7159615537635676, 0.7424424025103185, 0.6988121647096456, 0.6013491283686434, 0.6965386115772574, 0.47142803000538147, 0.3340481439206271, 0.254202713089582, 0.37866085092607804, 0.21578830860981468, 0.2135396003415324, 0.42961956935265944, 0.3338863678364663, 0.2059813767813623, 0.1812826990336498, 0.44999704155015274, 0.3211342449577361, 0.44357265664522527, 0.31133676714359926, 0.18790213033456737, 0.40641991065304306, 0.28414779375606813, 0.20601595230502245, 0.41867860393970524, 0.1515874707704139, 0.3858450978270498, 0.3981156095625542, 0.21451181723991686, 0.3939868360289456, 0.35058254197829963, 0.19187113503510167, 0.44824620010369254, 0.4380948256430748, 0.3618722309484016, 0.49388710150086634, 0.4471892412589066, 0.3904771649452198, 0.5802266776599961, 0.49066518669667936, 0.3916782839494687, 0.5161481309959194, 0.1323086318337302, 0.09486256573036644, 0.10230328147436141, 0.22246785446082418, 0.11796755302907769, 0.19883539044336362, 0.14102799129226784, 0.09472064314753992, 0.1564557196387708, 0.297434774827231, 0.2111633824469703, 0.33197835140797893, 0.31024406600460075, 0.23459869658420907, 0.35037842021758236, 0.31537544509032756, 0.2124031853806697, 0.22647830063274954, 0.6474121886350175, 0.5960989311547595, 0.7168485667869671, 0.6810351646352748, 0.5464785709925988, 0.7073952636477361, 0.68578372271785, 0.5385726157572358, 0.7041735305361345, 0.12504563393260237, 0.09540129997971047, 0.10007146474530815, 0.10977226718695332, 0.10853665938774903, 0.10082610805404624, 0.10211734651186921, 0.0930341481449497, 0.10335038626110149, 0.23586398557332322, 0.3775796949378456, 0.1462289446800178, 0.1849049714317983, 0.1673432435203971, 0.1825747600041071, 0.23721201050599516, 0.1518186149607511, 0.18057024219667495, 0.4397268443851694, 0.33037374433985633, 0.5435963440257108, 0.4261399121880425, 0.36551387382092226, 0.45602109981682815, 0.4784689734356783, 0.38288117696531765, 0.5591090484927089, 0.32243547998249, 0.2613140781220479, 0.3530189083480273, 0.3349382037602545, 0.24565645913407375, 0.3791341246550204, 0.36015628289552604, 0.28495215668651586, 0.37888035227153116, 0.17797678133011063, 0.1768872371449164, 0.18648528888559346, 0.19462632690323967, 0.19480953843704374, 0.22926719148897623, 0.19169342692625646, 0.19897518723456997, 0.1895226309640734, 0.20896524391907356, 0.19395007099139505, 0.2634254953427583, 0.45943693761945237, 0.18373187299623184, 0.40556573680303276, 0.43377837844856626, 0.25867258732377074, 0.4883907454090789, 0.175967296302598, 0.6937332957599545, 0.7298035178793616, 0.6733626535525252, 0.5623725416247027, 0.24464295545640025, 0.678632075483911, 0.1754339095097448, 0.15704720342956646, 0.5809762158999383, 0.19749505155641778, 0.15931414661274446, 0.43538556309076293, 0.1854373484451891, 0.19652844343746667, 0.20809007138833757, 0.20500128375243531, 0.20689684350531945, 0.17129408377841537, 0.19174255701007448, 0.20616003456962184, 0.17402777493307275, 0.2001322429040232, 0.20819086643470375, 0.19063539619426773, 0.1967410160831089, 0.19559298462919572, 0.07858491705700676, 0.07418932889083518, 0.0756247602110629, 0.0788699493018854, 0.08872867529100659, 0.08132379880380669, 0.0703869257022528, 0.07061462618324299, 0.0746592969949077]}, "mutation_prompt": null}
{"id": "a176fab9-4861-471a-b6f5-a76e6c4e3ac4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.1  # Adaptive learning rate for parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.7, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive learning rate and dynamic crossover probability adjustment for enhanced convergence.", "configspace": "", "generation": 73, "fitness": 0.34829132032307547, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.7772096060742038, 0.7395703368960658, 0.7689053302748129, 0.8009653063808484, 0.7681971598479473, 0.7832984616357745, 0.7889688807893898, 0.7660274248339083, 0.7868054627949127, 0.64924242243863, 0.6163773258220187, 0.6645826493382214, 0.664640315323908, 0.6114496528789022, 0.6703283206613959, 0.6680324586682871, 0.6124724971007296, 0.6714709830701631, 0.3258483826898967, 0.26187528145602545, 0.1694331824332438, 0.35178469709323057, 0.2375931510828273, 0.20955971542061502, 0.2470206594767962, 0.28401391254308106, 0.22324345293844994, 0.24440367344541825, 0.23537300642766168, 0.1274489931864451, 0.13197518914880324, 0.1291121641832529, 0.11666460609614093, 0.12864118116465229, 0.10531345524288316, 0.11700268303421091, 0.9307454697450555, 0.9666291592323251, 0.9673018994789137, 0.9288904876111962, 0.9552160654942311, 0.9267907015970871, 0.8797927932807684, 0.9576328277227913, 0.9470766347944446, 0.5041920970578582, 0.47566157951936416, 0.5121882455047297, 0.5402991940105931, 0.45310026927758984, 0.5478446750165447, 0.48621741823093556, 0.4754251530052681, 0.5552094949148383, 0.7706254680647772, 0.6760172417683595, 0.7021263886249454, 0.6840323275610565, 0.7274270474288815, 0.733744193515091, 0.7064671204169686, 0.6633721094854366, 0.6914019702060172, 0.30104841653818626, 0.23614844652568112, 0.1659753338827531, 0.38862103431154493, 0.2939785169173701, 0.26288674833947145, 0.3312627986477149, 0.25469305379853224, 0.1989505038613556, 0.21115511229726358, 0.18275680717044906, 0.23724353346864424, 0.3300628988361526, 0.28175672618197134, 0.18840311970326007, 0.4459475709786892, 0.20756881005119943, 0.19584276284645752, 0.23892672793742964, 0.15561488432157689, 0.11533399442759018, 0.27932164646087143, 0.12270602091423954, 0.00695677224350133, 0.21468730041834583, 0.09757640019278702, 0.26044253087993463, 0.36188434627442645, 0.2548531053083758, 0.49588466213224325, 0.3957547565208923, 0.24859433080640614, 0.4331643629485369, 0.3703610018213682, 0.367905131596015, 0.41706474136701277, 0.05264022739239149, 0.042106840314867444, 0.09796636196211927, 0.12979714017080446, 0.06963391013647502, 0.1887679507398189, 0.1700763432136153, 0.09999104254563063, 0.15162685804823173, 0.24565471749227819, 0.2015462877699522, 0.3523948611815617, 0.25075292002020466, 0.2167546628660607, 0.37973352126892845, 0.23253763042582132, 0.18619401750148512, 0.3324919251002969, 0.6212275695513658, 0.5793613799638548, 0.7023935327725733, 0.5842066622632969, 0.5353187806501358, 0.6414881647991325, 0.6362567737214098, 0.5182437053091015, 0.6734193784094333, 0.1000650998044319, 0.09260744929427034, 0.09345696570857076, 0.09552923245224088, 0.08858289580279799, 0.09404358132262747, 0.0962243185625049, 0.09151050753620216, 0.08948043684072304, 0.14134518780775251, 0.13886138494244538, 0.14483042588327266, 0.13590922220303892, 0.14419700466445373, 0.2567777023391531, 0.14242331017588017, 0.14818345870459892, 0.14037841097882664, 0.39713684812967875, 0.39325999217820473, 0.5176137021297293, 0.41295219337049105, 0.35058725866046925, 0.4832659991308771, 0.43916076531122894, 0.3912747649457565, 0.5349107456929613, 0.25373134248052565, 0.2766026604838847, 0.37065328170823597, 0.2770558518641193, 0.22452888442829977, 0.3032700972559227, 0.31262233619128654, 0.27155552588741994, 0.3625279575530389, 0.18050760011414946, 0.20487555776672228, 0.18775550094856186, 0.19798021672624389, 0.1760694915211306, 0.1773855636652777, 0.18742753502335663, 0.18815063394500253, 0.1973765049844265, 0.42544638301982174, 0.18443615447226092, 0.36787109943515595, 0.3305262149126984, 0.24244985208074732, 0.2159314481436564, 0.4266865355928431, 0.2004499619142316, 0.49510071793271204, 0.159550264697638, 0.18765467055417562, 0.7283856203980003, 0.16154744661683162, 0.4541316519961558, 0.18412485203122342, 0.6735736310605216, 0.17317244770663276, 0.5755036328287766, 0.1636930544654015, 0.16525784504734076, 0.19880697315014817, 0.41262164627925535, 0.15366399753573678, 0.19286667346000796, 0.21007751796866325, 0.18800007655807927, 0.2069753546566978, 0.19224246147133472, 0.1914591142025137, 0.1851396446596938, 0.17484909707647112, 0.19594648095914258, 0.1820230000688875, 0.19689962582035891, 0.18856853609746915, 0.18899373870985736, 0.06721350447472485, 0.0663392431457398, 0.0819708764675956, 0.07418099420141466, 0.09074850605492557, 0.08787057800721976, 0.0760460089143391, 0.06979418687138006, 0.07329036996609506]}, "mutation_prompt": null}
{"id": "81c48107-3570-4beb-b28c-68b352cdf9e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(np.random.rand() * self.F, 0.4, 1.0)  # Self-adaptive random scaling\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        if func(candidate) < func(target):\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        self.CR += self.learning_rate * (np.random.uniform(-0.05, 0.05))\n        self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation with a self-adaptive random scaling factor to improve exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.3763651968519015, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "6f8303f4-2775-455b-89d0-c46074801a70", "metadata": {"aucs": [0.8584655992753545, 0.8651836166352338, 0.8735540887057542, 0.8648888267582642, 0.8556173178566099, 0.8626342663984963, 0.8496628854648213, 0.8584363760415418, 0.834263510636035, 0.7709045294601646, 0.7692443354776526, 0.7630041743979985, 0.7609423398384122, 0.7485689119250315, 0.7668230058841093, 0.7351251338273337, 0.7693659047391879, 0.031782431566316105, 0.13472559476507573, 0.38492219077054346, 0.43278592885282763, 0.5055553714592479, 0.17708015732721938, 0.21739069003364964, 0.29408302416226706, 0.14834956544135203, 0.24254418065465888, 0.39475309423774985, 0.11772668048424861, 0.1275334724337639, 0.1562215457652032, 0.16406123007898166, 0.10221275694231768, 0.13736926088090218, 0.11499029811870787, 0.13478848717661984, 0.9240791102448177, 0.9228215292689664, 0.8206991685123873, 0.9305857871112933, 0.9166320020896145, 0.8267427763116966, 0.9371230857672146, 0.8669869168018965, 0.8655637385987813, 0.297792059890282, 0.1515213960077726, 0.18155926522824506, 0.23246520833261908, 0.35636499867030413, 0.2209655736967424, 0.3760074396286923, 0.15019575557552256, 0.1049425683222085, 0.8187437608658081, 0.8413189434329045, 0.8664323890900142, 0.8342739638107002, 0.8457205441399576, 0.8397891116033848, 0.8132545482013626, 0.8333585765654348, 0.8602356955949869, 0.20242974541957848, 0.18915646341110504, 0.21338610375040423, 0.16661843929973597, 0.3111320752268175, 0.24302750725013045, 0.23108535444092027, 0.16431444004483742, 0.20222854374945176, 0.1662793355715657, 0.15670568347824831, 0.20062831362883893, 0.2835705268112819, 0.17890750663666988, 0.20022127504977438, 0.2274183241376272, 0.13834797754640826, 0.21706593021437814, 0.1613422157949762, 0.37258205226360674, 0.2724787427742682, 0.46647981608496425, 0.0960262627927837, 0.17499159784773077, 0.5094153685606012, 0.13007775372138952, 0.3909646674695795, 0.37622357809695406, 0.4851253754995588, 0.32359769375491587, 0.5039595507295966, 0.1642209772833345, 0.6003022850663353, 0.42271741847860145, 0.24339950831045898, 0.5301092496218067, 0.05333104968544644, 0.12352839423338269, 0.05031176771847057, 0.08951508371158745, 0.1289406934969093, 0.3359702108048005, 0.1563304674365219, 0.10644286995584007, 0.11546122612247856, 0.3712816012025921, 0.3691332778356601, 0.39186657980230943, 0.36723634632991686, 0.46681549804762323, 0.20799160292130514, 0.272001080041988, 0.33628345920321756, 0.4919413630937213, 0.7314411447251721, 0.8214456689997203, 0.7357157775407985, 0.7598102234397466, 0.8319757042785849, 0.5909234327099198, 0.7881403059895129, 0.5687851798168477, 0.7689589331878103, 0.13792304499822616, 0.1251917266204433, 0.12739048573434664, 0.12613932489962953, 0.12657900673330846, 0.10492067223360169, 0.12526070203757933, 0.12940729973238663, 0.11021146229312417, 0.20128513962878525, 0.19811922597711296, 0.21293748997397333, 0.17690846848411912, 0.28216687447222566, 0.24245951195055604, 0.19229334119825603, 0.18321567581839115, 0.16331774464376014, 0.5480107369906655, 0.48120269810749783, 0.547006065873309, 0.5738787870927768, 0.5123003345920105, 0.5318646966251324, 0.6497988158428079, 0.691858869202395, 0.43391475586894135, 0.42243188129675113, 0.4401478607511211, 0.5147363597203578, 0.457697317276622, 0.40261785346713463, 0.4747542923502236, 0.3782543346045135, 0.2754126930214418, 0.3580637735574008, 0.20467551321142763, 0.19129554512309055, 0.2235969277064901, 0.2115143093203974, 0.20830307913302037, 0.19304330576703144, 0.210284260899949, 0.2171092360503878, 0.2208156830518555, 0.608150608209296, 0.22902610783628974, 0.20711816726833698, 0.41956120552816434, 0.32286695794423326, 0.22981060634204165, 0.2305017701908002, 0.20978184555123436, 0.19382270043444327, 0.8070649914741064, 0.8604668659878443, 0.196419183025901, 0.8601034211509702, 0.19728759382020145, 0.1651853635541669, 0.42138977706060476, 0.17589470062670864, 0.20392567235867387, 0.8340136658837694, 0.16585302369995547, 0.16618242536726635, 0.20755752301575414, 0.20532036739796833, 0.16754496956937892, 0.2039549530562066, 0.1535921152517825, 0.21003167702653436, 0.18701466467471606, 0.17500288724611346, 0.19121417841539046, 0.19346467383772237, 0.18643677301300132, 0.17924843628682352, 0.20689124071349552, 0.17103528580235328, 0.18497661266625742, 0.10205196330744115, 0.08067959212007991, 0.07821833203675521, 0.08928659416312879, 0.09479125655672527, 0.08628234369031018, 0.09347320631478673, 0.0863902430713055, 0.1058254935387406]}, "mutation_prompt": null}
{"id": "42a954b0-4c37-4b96-bd2d-7907acae2f7d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(np.random.rand() * self.F, 0.4, 1.0)  # Self-adaptive random scaling\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability using success history for better adaptation to fitness landscape.", "configspace": "", "generation": 75, "fitness": 0.394377312664811, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "81c48107-3570-4beb-b28c-68b352cdf9e2", "metadata": {"aucs": [0.8508127965417192, 0.8505167390241581, 0.8421975738644328, 0.8822998622230175, 0.8430288603201465, 0.8551954088875605, 0.8566209866357631, 0.8710605122269238, 0.8710363889662759, 0.7504537550121197, 0.7678548721499172, 0.767381587100053, 0.7647970687167431, 0.7515678952521716, 0.7569991613675952, 0.7829810702468525, 0.764830733905986, 0.7666502980107803, 0.14989125940121617, 0.3926852716044765, 0.14834035359936204, 0.2163367529961654, 0.20927344267105663, 0.15701656260170316, 0.268074237912559, 0.15908457254381358, 0.5327336935397678, 0.12026655783775242, 0.15659562359545431, 0.15091615867799923, 0.16111406188860533, 0.11209694922566449, 0.20947176361740572, 0.13845527719662898, 0.13388561704279167, 0.14367629830085749, 0.8271575167713523, 0.8961552137178403, 0.943985299720901, 0.886014879543804, 0.8985625121821452, 0.9130828631272221, 0.8324233762746082, 0.8191632782885558, 0.8687639329920467, 0.3143316606316702, 0.37264799667279713, 0.37702922503377234, 0.18886227366729114, 0.32052690989436494, 0.2862008773771919, 0.4527086406601256, 0.5820246712064481, 0.536789851097661, 0.8768110771066736, 0.8444043778649353, 0.8223169458703011, 0.8843886360150482, 0.8354475365401524, 0.8611829604565828, 0.8446174303848734, 0.8573421944760817, 0.8587649724477102, 0.21304776997331454, 0.18644350306521562, 0.19290959862226398, 0.1690911131972389, 0.4112601531279434, 0.15662827326653073, 0.20280644088231436, 0.22670152026719081, 0.23197179048219563, 0.26232222131769234, 0.16951976480887865, 0.1834494247305818, 0.16383921565705983, 0.14324588906930535, 0.19531944847042837, 0.1358378322975481, 0.27176136778236926, 0.12968530858922678, 0.24855561521397018, 0.5243304223536589, 0.5143536875808983, 0.2459932469378565, 0.4944251630407883, 0.3771028326855499, 0.2597040642786812, 0.2888810953442874, 0.19373282197509445, 0.5142758486220567, 0.3808501714123761, 0.23427825311005024, 0.2917426790948737, 0.46848630638936106, 0.3821116751169652, 0.6128856871916941, 0.29883547392415977, 0.6161708048231207, 0.12116565067222551, 0.11209131127581728, 0.3390695088404504, 0.08177328008856366, 0.135188188678794, 0.2152821933191582, 0.15639485794052688, 0.1871222558395712, 0.30438649039107724, 0.19015782286849592, 0.3006940657713081, 0.5072340919315153, 0.2784640440481845, 0.5632507004018164, 0.26552969396411785, 0.40094033937431417, 0.3306796148947486, 0.36884729794598314, 0.7610662020190933, 0.7924090749934531, 0.6785531664513506, 0.6595232792963951, 0.6990820686638812, 0.603762757592736, 0.7213392510081624, 0.7021409886055103, 0.7067402324884318, 0.11958233950179875, 0.13392147654631148, 0.12426306032877199, 0.14415251673079021, 0.1584007535997447, 0.21508347150154916, 0.1404358322953183, 0.12590655969899212, 0.1212126104041874, 0.17904870994922095, 0.15962132608547985, 0.16401359714886998, 0.14645336264642594, 0.1779178845387589, 0.2113293262177498, 0.23345975638837302, 0.23551746746348856, 0.16091141125404662, 0.6404501098568995, 0.44817347540445507, 0.558525672420805, 0.5224642053531487, 0.5603091585363995, 0.5059921879781346, 0.6516403918413467, 0.5769446175410333, 0.5647283826180328, 0.41411446657646633, 0.4072829635891013, 0.6312678202683197, 0.41287915255619523, 0.44660703598342255, 0.41630082511662425, 0.41442745360868827, 0.606581616425412, 0.4083708819077324, 0.22060469113505277, 0.19535775905401098, 0.20752579711598995, 0.2034494456279391, 0.20604672247398403, 0.24669928722164292, 0.19898792030450463, 0.21226052056816802, 0.19430273370650186, 0.22583323220759344, 0.20824759814821947, 0.5141174124099772, 0.22286284116850597, 0.5712479236215544, 0.4838606510337776, 0.2621510366652541, 0.5312427281677752, 0.21619903365800308, 0.1696951924446628, 0.181314940848037, 0.1404618222054831, 0.16815841143907195, 0.17435666468276545, 0.7471359092142749, 0.18051045018225154, 0.4277016075421203, 0.8363272814595075, 0.24416090978017335, 0.8151634222919676, 0.5960150103760437, 0.21444842545533294, 0.6719970484819731, 0.16599328464921326, 0.42037615928491623, 0.2090735998595673, 0.1523906645927896, 0.1821879457119061, 0.1801827336376648, 0.19535056167541576, 0.18767917932050948, 0.1915079641895615, 0.1863005296023993, 0.20259776868695034, 0.19255669950031074, 0.1782734111058567, 0.08070801157207008, 0.0774342063282425, 0.09752175833844978, 0.0836324547685734, 0.09458655593979659, 0.0849372326971205, 0.08333922583593811, 0.09255353133667998, 0.08622769759495441]}, "mutation_prompt": null}
{"id": "462a1313-3f61-4442-9056-60ea2818e395", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(np.random.rand() * self.F, 0.4, 1.0)  # Self-adaptive random scaling\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability using success history for better adaptation to fitness landscape.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "42a954b0-4c37-4b96-bd2d-7907acae2f7d", "metadata": {"aucs": [0.8508127965417192, 0.8505167390241581, 0.8421975738644328, 0.8822998622230175, 0.8430288603201465, 0.8551954088875605, 0.8566209866357631, 0.8710605122269238, 0.8710363889662759, 0.7504537550121197, 0.7678548721499172, 0.767381587100053, 0.7647970687167431, 0.7515678952521716, 0.7569991613675952, 0.7829810702468525, 0.764830733905986, 0.7666502980107803, 0.14989125940121617, 0.3926852716044765, 0.14834035359936204, 0.2163367529961654, 0.20927344267105663, 0.15701656260170316, 0.268074237912559, 0.15908457254381358, 0.5327336935397678, 0.12026655783775242, 0.15659562359545431, 0.15091615867799923, 0.16111406188860533, 0.11209694922566449, 0.20947176361740572, 0.13845527719662898, 0.13388561704279167, 0.14367629830085749, 0.8271575167713523, 0.8961552137178403, 0.943985299720901, 0.886014879543804, 0.8985625121821452, 0.9130828631272221, 0.8324233762746082, 0.8191632782885558, 0.8687639329920467, 0.3143316606316702, 0.37264799667279713, 0.37702922503377234, 0.18886227366729114, 0.32052690989436494, 0.2862008773771919, 0.4527086406601256, 0.5820246712064481, 0.536789851097661, 0.8768110771066736, 0.8444043778649353, 0.8223169458703011, 0.8843886360150482, 0.8354475365401524, 0.8611829604565828, 0.8446174303848734, 0.8573421944760817, 0.8587649724477102, 0.21304776997331454, 0.18644350306521562, 0.19290959862226398, 0.1690911131972389, 0.4112601531279434, 0.15662827326653073, 0.20280644088231436, 0.22670152026719081, 0.23197179048219563, 0.26232222131769234, 0.16951976480887865, 0.1834494247305818, 0.16383921565705983, 0.14324588906930535, 0.19531944847042837, 0.1358378322975481, 0.27176136778236926, 0.12968530858922678, 0.24855561521397018, 0.5243304223536589, 0.5143536875808983, 0.2459932469378565, 0.4944251630407883, 0.3771028326855499, 0.2597040642786812, 0.2888810953442874, 0.19373282197509445, 0.5142758486220567, 0.3808501714123761, 0.23427825311005024, 0.2917426790948737, 0.46848630638936106, 0.3821116751169652, 0.6128856871916941, 0.29883547392415977, 0.6161708048231207, 0.12116565067222551, 0.11209131127581728, 0.3390695088404504, 0.08177328008856366, 0.135188188678794, 0.2152821933191582, 0.15639485794052688, 0.1871222558395712, 0.30438649039107724, 0.19015782286849592, 0.3006940657713081, 0.5072340919315153, 0.2784640440481845, 0.5632507004018164, 0.26552969396411785, 0.40094033937431417, 0.3306796148947486, 0.36884729794598314, 0.7610662020190933, 0.7924090749934531, 0.6785531664513506, 0.6595232792963951, 0.6990820686638812, 0.603762757592736, 0.7213392510081624, 0.7021409886055103, 0.7067402324884318, 0.11958233950179875, 0.13392147654631148, 0.12426306032877199, 0.14415251673079021, 0.1584007535997447, 0.21508347150154916, 0.1404358322953183, 0.12590655969899212, 0.1212126104041874, 0.17904870994922095, 0.15962132608547985, 0.16401359714886998, 0.14645336264642594, 0.1779178845387589, 0.2113293262177498, 0.23345975638837302, 0.23551746746348856, 0.16091141125404662, 0.6404501098568995, 0.44817347540445507, 0.558525672420805, 0.5224642053531487, 0.5603091585363995, 0.5059921879781346, 0.6516403918413467, 0.5769446175410333, 0.5647283826180328, 0.41411446657646633, 0.4072829635891013, 0.6312678202683197, 0.41287915255619523, 0.44660703598342255, 0.41630082511662425, 0.41442745360868827, 0.606581616425412, 0.4083708819077324, 0.22060469113505277, 0.19535775905401098, 0.20752579711598995, 0.2034494456279391, 0.20604672247398403, 0.24669928722164292, 0.19898792030450463, 0.21226052056816802, 0.19430273370650186, 0.22583323220759344, 0.20824759814821947, 0.5141174124099772, 0.22286284116850597, 0.5712479236215544, 0.4838606510337776, 0.2621510366652541, 0.5312427281677752, 0.21619903365800308, 0.1696951924446628, 0.181314940848037, 0.1404618222054831, 0.16815841143907195, 0.17435666468276545, 0.7471359092142749, 0.18051045018225154, 0.4277016075421203, 0.8363272814595075, 0.24416090978017335, 0.8151634222919676, 0.5960150103760437, 0.21444842545533294, 0.6719970484819731, 0.16599328464921326, 0.42037615928491623, 0.2090735998595673, 0.1523906645927896, 0.1821879457119061, 0.1801827336376648, 0.19535056167541576, 0.18767917932050948, 0.1915079641895615, 0.1863005296023993, 0.20259776868695034, 0.19255669950031074, 0.1782734111058567, 0.08070801157207008, 0.0774342063282425, 0.09752175833844978, 0.0836324547685734, 0.09458655593979659, 0.0849372326971205, 0.08333922583593811, 0.09255353133667998, 0.08622769759495441]}, "mutation_prompt": null}
{"id": "89dda820-926d-417a-a9e4-f57db153ac9c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(np.random.rand() * self.F, 0.4, 1.0)  # Self-adaptive random scaling\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability using success history for better adaptation to fitness landscape.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "42a954b0-4c37-4b96-bd2d-7907acae2f7d", "metadata": {"aucs": [0.8508127965417192, 0.8505167390241581, 0.8421975738644328, 0.8822998622230175, 0.8430288603201465, 0.8551954088875605, 0.8566209866357631, 0.8710605122269238, 0.8710363889662759, 0.7504537550121197, 0.7678548721499172, 0.767381587100053, 0.7647970687167431, 0.7515678952521716, 0.7569991613675952, 0.7829810702468525, 0.764830733905986, 0.7666502980107803, 0.14989125940121617, 0.3926852716044765, 0.14834035359936204, 0.2163367529961654, 0.20927344267105663, 0.15701656260170316, 0.268074237912559, 0.15908457254381358, 0.5327336935397678, 0.12026655783775242, 0.15659562359545431, 0.15091615867799923, 0.16111406188860533, 0.11209694922566449, 0.20947176361740572, 0.13845527719662898, 0.13388561704279167, 0.14367629830085749, 0.8271575167713523, 0.8961552137178403, 0.943985299720901, 0.886014879543804, 0.8985625121821452, 0.9130828631272221, 0.8324233762746082, 0.8191632782885558, 0.8687639329920467, 0.3143316606316702, 0.37264799667279713, 0.37702922503377234, 0.18886227366729114, 0.32052690989436494, 0.2862008773771919, 0.4527086406601256, 0.5820246712064481, 0.536789851097661, 0.8768110771066736, 0.8444043778649353, 0.8223169458703011, 0.8843886360150482, 0.8354475365401524, 0.8611829604565828, 0.8446174303848734, 0.8573421944760817, 0.8587649724477102, 0.21304776997331454, 0.18644350306521562, 0.19290959862226398, 0.1690911131972389, 0.4112601531279434, 0.15662827326653073, 0.20280644088231436, 0.22670152026719081, 0.23197179048219563, 0.26232222131769234, 0.16951976480887865, 0.1834494247305818, 0.16383921565705983, 0.14324588906930535, 0.19531944847042837, 0.1358378322975481, 0.27176136778236926, 0.12968530858922678, 0.24855561521397018, 0.5243304223536589, 0.5143536875808983, 0.2459932469378565, 0.4944251630407883, 0.3771028326855499, 0.2597040642786812, 0.2888810953442874, 0.19373282197509445, 0.5142758486220567, 0.3808501714123761, 0.23427825311005024, 0.2917426790948737, 0.46848630638936106, 0.3821116751169652, 0.6128856871916941, 0.29883547392415977, 0.6161708048231207, 0.12116565067222551, 0.11209131127581728, 0.3390695088404504, 0.08177328008856366, 0.135188188678794, 0.2152821933191582, 0.15639485794052688, 0.1871222558395712, 0.30438649039107724, 0.19015782286849592, 0.3006940657713081, 0.5072340919315153, 0.2784640440481845, 0.5632507004018164, 0.26552969396411785, 0.40094033937431417, 0.3306796148947486, 0.36884729794598314, 0.7610662020190933, 0.7924090749934531, 0.6785531664513506, 0.6595232792963951, 0.6990820686638812, 0.603762757592736, 0.7213392510081624, 0.7021409886055103, 0.7067402324884318, 0.11958233950179875, 0.13392147654631148, 0.12426306032877199, 0.14415251673079021, 0.1584007535997447, 0.21508347150154916, 0.1404358322953183, 0.12590655969899212, 0.1212126104041874, 0.17904870994922095, 0.15962132608547985, 0.16401359714886998, 0.14645336264642594, 0.1779178845387589, 0.2113293262177498, 0.23345975638837302, 0.23551746746348856, 0.16091141125404662, 0.6404501098568995, 0.44817347540445507, 0.558525672420805, 0.5224642053531487, 0.5603091585363995, 0.5059921879781346, 0.6516403918413467, 0.5769446175410333, 0.5647283826180328, 0.41411446657646633, 0.4072829635891013, 0.6312678202683197, 0.41287915255619523, 0.44660703598342255, 0.41630082511662425, 0.41442745360868827, 0.606581616425412, 0.4083708819077324, 0.22060469113505277, 0.19535775905401098, 0.20752579711598995, 0.2034494456279391, 0.20604672247398403, 0.24669928722164292, 0.19898792030450463, 0.21226052056816802, 0.19430273370650186, 0.22583323220759344, 0.20824759814821947, 0.5141174124099772, 0.22286284116850597, 0.5712479236215544, 0.4838606510337776, 0.2621510366652541, 0.5312427281677752, 0.21619903365800308, 0.1696951924446628, 0.181314940848037, 0.1404618222054831, 0.16815841143907195, 0.17435666468276545, 0.7471359092142749, 0.18051045018225154, 0.4277016075421203, 0.8363272814595075, 0.24416090978017335, 0.8151634222919676, 0.5960150103760437, 0.21444842545533294, 0.6719970484819731, 0.16599328464921326, 0.42037615928491623, 0.2090735998595673, 0.1523906645927896, 0.1821879457119061, 0.1801827336376648, 0.19535056167541576, 0.18767917932050948, 0.1915079641895615, 0.1863005296023993, 0.20259776868695034, 0.19255669950031074, 0.1782734111058567, 0.08070801157207008, 0.0774342063282425, 0.09752175833844978, 0.0836324547685734, 0.09458655593979659, 0.0849372326971205, 0.08333922583593811, 0.09255353133667998, 0.08622769759495441]}, "mutation_prompt": null}
{"id": "d17b96d3-6d3e-43c2-90cb-27ab13981444", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(np.random.rand() * self.F, 0.4, 1.0)  # Self-adaptive random scaling\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F += self.learning_rate * (np.random.uniform(-0.1, 0.1))\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability using success history for better adaptation to fitness landscape.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "42a954b0-4c37-4b96-bd2d-7907acae2f7d", "metadata": {"aucs": [0.8508127965417192, 0.8505167390241581, 0.8421975738644328, 0.8822998622230175, 0.8430288603201465, 0.8551954088875605, 0.8566209866357631, 0.8710605122269238, 0.8710363889662759, 0.7504537550121197, 0.7678548721499172, 0.767381587100053, 0.7647970687167431, 0.7515678952521716, 0.7569991613675952, 0.7829810702468525, 0.764830733905986, 0.7666502980107803, 0.14989125940121617, 0.3926852716044765, 0.14834035359936204, 0.2163367529961654, 0.20927344267105663, 0.15701656260170316, 0.268074237912559, 0.15908457254381358, 0.5327336935397678, 0.12026655783775242, 0.15659562359545431, 0.15091615867799923, 0.16111406188860533, 0.11209694922566449, 0.20947176361740572, 0.13845527719662898, 0.13388561704279167, 0.14367629830085749, 0.8271575167713523, 0.8961552137178403, 0.943985299720901, 0.886014879543804, 0.8985625121821452, 0.9130828631272221, 0.8324233762746082, 0.8191632782885558, 0.8687639329920467, 0.3143316606316702, 0.37264799667279713, 0.37702922503377234, 0.18886227366729114, 0.32052690989436494, 0.2862008773771919, 0.4527086406601256, 0.5820246712064481, 0.536789851097661, 0.8768110771066736, 0.8444043778649353, 0.8223169458703011, 0.8843886360150482, 0.8354475365401524, 0.8611829604565828, 0.8446174303848734, 0.8573421944760817, 0.8587649724477102, 0.21304776997331454, 0.18644350306521562, 0.19290959862226398, 0.1690911131972389, 0.4112601531279434, 0.15662827326653073, 0.20280644088231436, 0.22670152026719081, 0.23197179048219563, 0.26232222131769234, 0.16951976480887865, 0.1834494247305818, 0.16383921565705983, 0.14324588906930535, 0.19531944847042837, 0.1358378322975481, 0.27176136778236926, 0.12968530858922678, 0.24855561521397018, 0.5243304223536589, 0.5143536875808983, 0.2459932469378565, 0.4944251630407883, 0.3771028326855499, 0.2597040642786812, 0.2888810953442874, 0.19373282197509445, 0.5142758486220567, 0.3808501714123761, 0.23427825311005024, 0.2917426790948737, 0.46848630638936106, 0.3821116751169652, 0.6128856871916941, 0.29883547392415977, 0.6161708048231207, 0.12116565067222551, 0.11209131127581728, 0.3390695088404504, 0.08177328008856366, 0.135188188678794, 0.2152821933191582, 0.15639485794052688, 0.1871222558395712, 0.30438649039107724, 0.19015782286849592, 0.3006940657713081, 0.5072340919315153, 0.2784640440481845, 0.5632507004018164, 0.26552969396411785, 0.40094033937431417, 0.3306796148947486, 0.36884729794598314, 0.7610662020190933, 0.7924090749934531, 0.6785531664513506, 0.6595232792963951, 0.6990820686638812, 0.603762757592736, 0.7213392510081624, 0.7021409886055103, 0.7067402324884318, 0.11958233950179875, 0.13392147654631148, 0.12426306032877199, 0.14415251673079021, 0.1584007535997447, 0.21508347150154916, 0.1404358322953183, 0.12590655969899212, 0.1212126104041874, 0.17904870994922095, 0.15962132608547985, 0.16401359714886998, 0.14645336264642594, 0.1779178845387589, 0.2113293262177498, 0.23345975638837302, 0.23551746746348856, 0.16091141125404662, 0.6404501098568995, 0.44817347540445507, 0.558525672420805, 0.5224642053531487, 0.5603091585363995, 0.5059921879781346, 0.6516403918413467, 0.5769446175410333, 0.5647283826180328, 0.41411446657646633, 0.4072829635891013, 0.6312678202683197, 0.41287915255619523, 0.44660703598342255, 0.41630082511662425, 0.41442745360868827, 0.606581616425412, 0.4083708819077324, 0.22060469113505277, 0.19535775905401098, 0.20752579711598995, 0.2034494456279391, 0.20604672247398403, 0.24669928722164292, 0.19898792030450463, 0.21226052056816802, 0.19430273370650186, 0.22583323220759344, 0.20824759814821947, 0.5141174124099772, 0.22286284116850597, 0.5712479236215544, 0.4838606510337776, 0.2621510366652541, 0.5312427281677752, 0.21619903365800308, 0.1696951924446628, 0.181314940848037, 0.1404618222054831, 0.16815841143907195, 0.17435666468276545, 0.7471359092142749, 0.18051045018225154, 0.4277016075421203, 0.8363272814595075, 0.24416090978017335, 0.8151634222919676, 0.5960150103760437, 0.21444842545533294, 0.6719970484819731, 0.16599328464921326, 0.42037615928491623, 0.2090735998595673, 0.1523906645927896, 0.1821879457119061, 0.1801827336376648, 0.19535056167541576, 0.18767917932050948, 0.1915079641895615, 0.1863005296023993, 0.20259776868695034, 0.19255669950031074, 0.1782734111058567, 0.08070801157207008, 0.0774342063282425, 0.09752175833844978, 0.0836324547685734, 0.09458655593979659, 0.0849372326971205, 0.08333922583593811, 0.09255353133667998, 0.08622769759495441]}, "mutation_prompt": null}
{"id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 79, "fitness": 0.4242821645879398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "42a954b0-4c37-4b96-bd2d-7907acae2f7d", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "631ad07d-11bd-42aa-a9c8-44003f0534c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        stochastic_F = self.F * np.random.uniform(0.8, 1.2)  # Add stochastic component\n        self.F = np.clip(stochastic_F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n        if self.evaluations % (self.budget // 4) == 0:  # Periodic reset\n            self.CR = 0.9\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive scaling by adding a stochastic component to F and improve exploration with periodic CR resets.", "configspace": "", "generation": 80, "fitness": 0.40949004304999703, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8467587896203251, 0.8261712725143775, 0.8276459964372026, 0.853823011577617, 0.8326344192677531, 0.8345980495250805, 0.8384433703614168, 0.8466101437229244, 0.8326976880049366, 0.7242689912930151, 0.7217012627099038, 0.7141179413266117, 0.7463390392078713, 0.7283135923182159, 0.7131037767113277, 0.7220182851102, 0.7100123915367876, 0.7467762019321871, 0.14768564527704953, 0.138281252939226, 0.14659596801431485, 0.14206571510296417, 0.12829791225495568, 0.1225225099928533, 0.12252881261168891, 0.13821956114899836, 0.11857974244676572, 0.12896892230196644, 0.12433939045625286, 0.12110914663910843, 0.1306327433770743, 0.14262564488800422, 0.1370276301803015, 0.13546933961433227, 0.1386880906082426, 0.12483842782220023, 0.8218482617820395, 0.9159296690530937, 0.8867106096334832, 0.9399606549582833, 0.8958958036706222, 0.965476484554366, 0.8884530551492054, 0.8872693612995635, 0.9767621401311354, 0.5576477072420336, 0.6132778724333362, 0.5764846031201907, 0.6053247696743365, 0.6154475798740496, 0.38691739894453536, 0.49963443504817084, 0.5929753394356676, 0.58289450054264, 0.8138546154476083, 0.821594706320134, 0.7880280994954306, 0.8210253307330676, 0.8228193985196204, 0.7962572767840275, 0.778586581927458, 0.7435293789669162, 0.8130805437497436, 0.24159296242449568, 0.22599312907632552, 0.19670159029407308, 0.15561487181691824, 0.20320758300187247, 0.2579191735941695, 0.2352243869621321, 0.22362967740699902, 0.2778061972654079, 0.20438313622638504, 0.27678507143023157, 0.1971243586344119, 0.1860822441912081, 0.2421393223713526, 0.3016401493263239, 0.1973346160040914, 0.2146540052800655, 0.20768411953478472, 0.5779386498694133, 0.20964753836156969, 0.5395852697466832, 0.5429057756641016, 0.49347871701732515, 0.5316829367989413, 0.5367569843060574, 0.24313419623664523, 0.23997986147597417, 0.5675981335938629, 0.5083835038324549, 0.6757983466704172, 0.5787409993326915, 0.49771465732189846, 0.5551190209496224, 0.4552701936609369, 0.5919086465526808, 0.6966957551327257, 0.1209722017576822, 0.15864185823493593, 0.17397546489966864, 0.2558122363836711, 0.14872009613273007, 0.2678419851298137, 0.20460967160790866, 0.218983518408836, 0.13599450708809668, 0.3814658943590359, 0.4458804536224128, 0.391840977928685, 0.5056640304128406, 0.48427728843563034, 0.33530974083392073, 0.36198706534189984, 0.35797971911306636, 0.4775554636556578, 0.7934140212259355, 0.7543161719103102, 0.7672181763323684, 0.7843958897854062, 0.7673962922056853, 0.7603919491996889, 0.7862756497632097, 0.6985183434605534, 0.7704675072045117, 0.1284213130582904, 0.18568857851000875, 0.11101809308867139, 0.109866576741119, 0.1263185901031667, 0.11070046348740636, 0.1387358701410163, 0.10084798284784813, 0.13259166652898025, 0.18353536065461962, 0.16991343253117908, 0.14231730249666852, 0.25065896436984936, 0.24256915810769775, 0.1410899504745381, 0.31361096755582085, 0.13416951599066684, 0.20175143438286347, 0.5278282053715525, 0.4913118458011394, 0.5969491446574018, 0.5364331425477886, 0.5135361818607065, 0.621533233090606, 0.6302643808458973, 0.5661388146710123, 0.6197796453286961, 0.37533548348747714, 0.4197361289858599, 0.38349151837908, 0.4089137143033491, 0.4066985608437431, 0.3857972369941026, 0.43289746651318317, 0.5405672922415283, 0.4546710366820895, 0.22193825174484783, 0.18996584914864922, 0.2059646724080103, 0.20126754621171705, 0.2020640785018527, 0.1837265012377628, 0.2168628667999366, 0.20333403558322405, 0.2008507682905678, 0.4377236515779893, 0.5239802979232419, 0.275345435123427, 0.2705425961727739, 0.3708055727931252, 0.5456037267667735, 0.5445549622292583, 0.5390011045942683, 0.19405548215919588, 0.17704466768529037, 0.1838474633435846, 0.1512254132884273, 0.18161481699741178, 0.20268112769561142, 0.8003439831517298, 0.7586171286889285, 0.804228148954881, 0.1661041138698911, 0.16612328530863674, 0.15390813417869087, 0.7662598553228439, 0.7300061945464995, 0.1615525995856324, 0.16846561099575852, 0.42401075182315073, 0.20588409494742665, 0.2093890084546579, 0.1877397799721321, 0.19594208627503973, 0.18518012296465458, 0.17554139843626404, 0.17790188694215903, 0.18726308189167806, 0.18139671421288728, 0.18574781557104558, 0.17991409412789994, 0.08444911128012444, 0.08340576711581504, 0.0922036781578981, 0.08498533108940409, 0.07908850083446983, 0.08800562878387974, 0.08405194350395573, 0.08455300446391445, 0.07793848825061689]}, "mutation_prompt": null}
{"id": "8de08e4f-9e3d-4f56-8ba5-7f57d2eb857f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        candidate_fitness = func(candidate)\n        self.evaluations += 1\n        if candidate_fitness < func(target):  # Prioritize new candidates for diversity\n            self.success_count += 1\n            return candidate_fitness, candidate\n        return func(target), target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness, new_individual = self.select(trial, population[i], func)\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = new_individual\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance selection strategy by incorporating diversity control for more robust exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.21503957332410156, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.5920100566171267, 0.5896238049642992, 0.5960432621252632, 0.5485956470742974, 0.5713009278246448, 0.5881503307012039, 0.5960211044191783, 0.592083390836895, 0.5651615917319323, 0.33196473201159993, 0.3363717641687469, 0.30243832064717224, 0.2919159733393192, 0.2955143281703235, 0.29954337844074963, 0.35433800417497174, 0.3289934443232697, 0.3215206327587464, 0.0962589078094459, 0.08881095828989694, 0.09560426722191695, 0.08818921518229694, 0.07616017340830383, 0.10795653472237865, 0.10385847457656239, 0.08629821781047431, 0.08547688797188124, 0.09534057267380902, 0.08957407868320422, 0.07973509552710456, 0.08164486425626472, 0.0822941649378901, 0.08633544279109795, 0.08184755584586523, 0.0901810914500546, 0.0940944293809498, 0.9258404166211915, 0.7278685772443513, 0.8738737668225663, 0.8487490318032623, 0.9721165351726515, 0.8271701892176144, 0.8405859117311081, 0.8736862702520194, 0.7372659661740965, 0.21485019066717892, 0.23072679470351387, 0.1941894654492441, 0.21609714257674872, 0.21411489214863466, 0.24173930023224266, 0.24688459982064126, 0.19060774413486725, 0.16362287133886566, 0.38805080188930174, 0.4208055536855896, 0.30974741820302165, 0.39106546989048907, 0.4881875032698497, 0.41144475208792475, 0.48062065374042906, 0.37473836698641516, 0.34859061871641694, 0.1312861129762789, 0.12288802961217138, 0.1309776702796891, 0.13270058958261344, 0.1374236689480851, 0.1531880185903055, 0.12718661574502244, 0.1207426316678013, 0.14017295777758265, 0.10979283460536793, 0.12528829863135693, 0.13652088178363575, 0.1071288839643848, 0.14712047972328746, 0.12030533061010773, 0.12293270940007484, 0.13610378315242977, 0.0988098594004323, 0.018376701523492245, 0.03731446912844172, 0.013630344196059796, 0.03329341828108623, 0.027176612077764895, 0.016782607944823447, 0.027872466785028194, 0.022236111425239513, 0.009598017405690773, 0.12719244915599703, 0.12171600244402903, 0.12996546908982032, 0.12487442123252035, 0.08612625104855198, 0.10803094209993214, 0.1403418571844237, 0.12360268767031923, 0.13717519660772126, 9.999999999998899e-05, 0.013534640587749336, 9.999999999998899e-05, 0.009518936381859522, 0.015542121751089488, 0.012332626955401271, 0.026059327840341928, 0.04384881777050176, 0.016882659167314018, 0.10920102270164211, 0.08777568905293065, 0.12310280480914082, 0.11146441410891661, 0.12319718489563569, 0.11289828228248155, 0.11926935329888477, 0.1033829923885955, 0.10643526595053066, 0.4105736359293708, 0.4239104750513385, 0.4529845532366402, 0.4214068340834519, 0.4131371470778721, 0.4021677675266335, 0.41026208949697807, 0.433877534655299, 0.4162143544110891, 0.0772622751106492, 0.07298114601052441, 0.08589563930717559, 0.07454860410681108, 0.08114236291727517, 0.0848342642316271, 0.06809776557697, 0.0986565660808143, 0.07376929933060639, 0.12685605177183878, 0.13215165629841563, 0.11988902367423893, 0.10985671633900163, 0.14177860556302402, 0.1183623121038112, 0.11992764552220891, 0.11624113670142744, 0.21249762443715214, 0.2656905224965245, 0.24551412382122273, 0.2642775699507568, 0.2634890509569413, 0.26131785701668386, 0.2298960391835443, 0.2927391815164123, 0.30013093330293195, 0.26511559238299753, 0.20963927956448425, 0.19939402869909018, 0.20009868877986325, 0.187707222906366, 0.18423041708881527, 0.1956451879308242, 0.18432285697938944, 0.18560165358997782, 0.20747210795052073, 0.1706958601359987, 0.17700923846772243, 0.1645812675175108, 0.18307125906927635, 0.17605605414789316, 0.1809300833171319, 0.16477123198615662, 0.16876763274259488, 0.1922215325233403, 0.16644633410178433, 0.1735927009511099, 0.1755627451411954, 0.1708958751940186, 0.16756471879998336, 0.17475943466234, 0.17118442596570926, 0.16564862565553262, 0.17358563661955706, 0.15455211858054585, 0.1477662281381259, 0.21294018734722864, 0.32382504402376455, 0.17537417594461058, 0.19437277950575205, 0.3782604137309412, 0.14536691229308418, 0.1819095862956247, 0.2000606134673205, 0.18449061224284868, 0.18781192298271854, 0.2746509723934554, 0.18386381808299723, 0.1797538538938226, 0.13956287654727584, 0.20142860425614517, 0.1950836409681056, 0.19221988252695743, 0.17054864624575317, 0.19923326810066178, 0.19856845832715886, 0.1682083655554778, 0.17140561035504653, 0.1736591611974866, 0.17992358138920028, 0.1753198767271824, 0.0649990813736866, 0.06572345202574947, 0.06993815207299336, 0.07175620602339172, 0.061763412145104835, 0.061874283120283646, 0.06027985631410915, 0.06559193970301835, 0.0725362332958952]}, "mutation_prompt": null}
{"id": "e40ea462-9cde-480d-b93d-5a4246a41e2c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        progress_factor = (self.budget - self.evaluations) / self.budget\n        adaptive_F = np.clip(self.F * progress_factor, 0.5, 1.0)\n        mutant = np.clip(population[a] + adaptive_F * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        progress_factor = (self.budget - self.evaluations) / self.budget\n        adaptive_CR = np.clip(self.CR * progress_factor, 0.8, 1.0)\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic crossover probabilities and mutation scaling based on evaluation progress to enhance convergence.", "configspace": "", "generation": 82, "fitness": 0.36377552808391617, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.784892157912705, 0.7798456872959794, 0.7767505734520685, 0.7972685483427351, 0.7930220965423332, 0.795642543016678, 0.782574155630809, 0.781113142206653, 0.7771140268638803, 0.6551559339123265, 0.6663621735202356, 0.6653663218639829, 0.6793224832566931, 0.6710601918328349, 0.6609292220257057, 0.6657136286947767, 0.6663416867554011, 0.655238585632262, 0.19512936400055392, 0.37994311172351813, 0.3438795156969672, 0.13402050664127785, 0.14745766711680697, 0.35016080462886756, 0.13966274316197547, 0.4048101745158963, 0.33062653244935225, 0.15803330311478836, 0.13804094918463838, 0.13544626058610554, 0.12497492565466417, 0.1159583381157232, 0.2802825046490348, 0.18171607719888083, 0.11721093864759935, 0.14814338344738076, 0.9290521921537235, 0.9668958616230693, 0.9772511761147128, 0.9463893436933783, 0.9405730574603707, 0.9672343814335265, 0.9798550317471778, 0.9721102476878909, 0.9456476402211258, 0.4600342254051286, 0.5189280979287558, 0.48966056414758263, 0.4497703873024498, 0.5638110100458358, 0.48900814991880404, 0.5783327110952354, 0.5558924627236982, 0.43123545866742574, 0.690971939267323, 0.6839495495617118, 0.6771841625361545, 0.7228846213370008, 0.7177593776872979, 0.6869701726678645, 0.7012792092322636, 0.6929246706879055, 0.6655451275086284, 0.22404732927918047, 0.1901095871612306, 0.16996295017255325, 0.1740307922324268, 0.1625856690934523, 0.242939556161762, 0.2018954821176292, 0.2044576368965224, 0.22412629911357063, 0.1354827825067194, 0.2527946965056056, 0.050194722162617667, 0.2592987150075442, 0.14798410042779309, 0.17156812197019866, 0.13021413557577421, 0.17541743135194487, 0.19856542210809602, 0.24048667082986452, 0.20066506442573828, 0.2793285559225326, 0.22497313306176092, 0.31151143919983015, 0.15901983580095402, 0.21129192784052997, 0.20132554312530937, 0.30841320548027606, 0.27531424847704866, 0.44857549656619555, 0.37999536813857415, 0.4018846219488268, 0.28653861462272345, 0.4059017491081125, 0.3586160611626984, 0.4799686594030763, 0.2907238085043009, 0.15809598934167968, 0.07600796008592825, 0.11321593664657614, 0.18654115196865184, 0.14316624489996377, 0.18646198850811468, 0.11441258428072065, 0.13773036877917655, 0.08991228798257056, 0.2331466820989464, 0.27326570782020665, 0.2364752577232041, 0.28438098490376895, 0.3334222754204862, 0.31370121979502597, 0.25813475746311787, 0.2769583445942527, 0.22740602284953704, 0.6531861997954572, 0.6863579060750764, 0.6272825955784558, 0.6719181871906356, 0.5860442363266898, 0.5870832312168022, 0.6556913234699022, 0.68187030398224, 0.6614880329637478, 0.10565772971858556, 0.10291748123291089, 0.09159120707809743, 0.1030098706126249, 0.09295872828312712, 0.11413802703925535, 0.10585402031439028, 0.0988224601903932, 0.09408032321020876, 0.16377250497177231, 0.15056867281772846, 0.1586214421217459, 0.2299121419062572, 0.20400971540574087, 0.1478574342981821, 0.1634416193799172, 0.16148736068717573, 0.14942161649128316, 0.5246341515585847, 0.4231598912477619, 0.5287434124727719, 0.44557522097498936, 0.4730704164985394, 0.40389942879995266, 0.5479474319374275, 0.4741693852310518, 0.47965915583766205, 0.3441389807054852, 0.34035671195246386, 0.3932596012111077, 0.33646961533060815, 0.3221243131448831, 0.30086577732388764, 0.36047831406774344, 0.4083327530572307, 0.3425274278802718, 0.1901348697379449, 0.20643929534030347, 0.18948385583426774, 0.17753237842077052, 0.19529986064031657, 0.17724314726089196, 0.18133501500514337, 0.1917322068255516, 0.18806074289259622, 0.21000581915668637, 0.3873214433562606, 0.21670121389379116, 0.41553436505295627, 0.48452206824791877, 0.19079461670523656, 0.4000109337382801, 0.4436262443819943, 0.29978302780924304, 0.5187874875713883, 0.18024242052670436, 0.17294281136995104, 0.7270368244992165, 0.1795927775895767, 0.6673995495879281, 0.6039867448717473, 0.5474137996224436, 0.17459482243553448, 0.6156639366828678, 0.199201319496225, 0.6228365784323133, 0.6020199555416521, 0.18777323858389205, 0.41705329147051773, 0.191063472115516, 0.2071068313197011, 0.20898938569606262, 0.1981184689980131, 0.17989284483962642, 0.1810855078150072, 0.20743809972353788, 0.19211855938389755, 0.1781160760612447, 0.19169181599861895, 0.18332043974099266, 0.1965493043826506, 0.07395891421454837, 0.07763252683187927, 0.07869252357343615, 0.07318973965000042, 0.08036169842710428, 0.07826067365156286, 0.08118582281749809, 0.08000200171116323, 0.07317004722786646]}, "mutation_prompt": null}
{"id": "18b083f0-6bde-4b1f-bbf4-8e3953dc9390", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "8079cf5a-34e8-4010-9173-4fec41a1297c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "877ae130-b46d-4c48-95fe-1be4b5dce960", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.fitness_history = []  # Track fitness improvements\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        candidate_fitness = func(candidate)\n        target_fitness = func(target)\n        self.fitness_history.append(candidate_fitness - target_fitness)\n        if candidate_fitness < target_fitness:\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 10:  # Adjust CR based on historical fitness improvements\n            recent_improvements = np.mean(self.fitness_history[-10:])\n            self.CR += self.learning_rate * (recent_improvements - 0.5)\n            self.CR = np.clip(self.CR, 0.7, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a self-adaptive crossover rate that dynamically adjusts based on historical fitness improvements to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": 0.4242821645879398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "2a01d42a-07d1-4ab1-8649-c9704df706c7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.memory = []\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  \n        mutation_non_uniformity = np.random.uniform(0.5, 1.0)\n        mutant = np.clip(population[a] + mutation_non_uniformity * self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            self.memory.append((self.F, self.CR))  # Store successful parameters\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  \n            self.CR = np.clip(self.CR, 0.8, 1.0)\n        if self.memory and np.random.rand() < 0.2:  # Occasionally use parameters from memory\n            self.F, self.CR = self.memory[np.random.randint(len(self.memory))]\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  \n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive differential evolution with non-uniform mutation and memory-based parameter adaptation for improved robustness.", "configspace": "", "generation": 86, "fitness": 0.3671039804649369, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8711124529098228, 0.8533391706761851, 0.8780270678351016, 0.8713660400753549, 0.854042915300406, 0.8656571211182414, 0.8801906957422636, 0.856427784506673, 0.8518934267464153, 0.7645566585419025, 0.773338553632832, 0.7690298363900604, 0.791873913065571, 0.7698735422749959, 0.764913079653462, 0.7667532070827192, 0.7812098160465878, 0.7673248941654582, 0.2298910026003388, 0.20345892960607925, 0.31586617898485625, 0.5511677079976254, 0.15784833748226468, 0.5447658684735246, 0.14682526625041048, 0.15926990128473317, 0.2503405866182584, 0.13221952776068668, 0.1423361773848998, 0.14078864297734361, 0.13955244316249515, 0.13933366045880669, 0.13263552011938395, 0.13432470274889563, 0.1438910996982541, 0.15808583936858178, 0.7973752023243449, 0.8331916341290214, 0.8919678697557695, 0.8084954687241923, 0.8748878836660678, 0.9372876565133879, 0.866296742809053, 0.8054235323510192, 0.9914973429904868, 0.28904430604696374, 0.08528559909826361, 0.4131718257654706, 0.14397372452838808, 0.14981348369407643, 0.2751322489461844, 0.18247738326719143, 0.2764005888400749, 0.17080676619704227, 0.8538857508703362, 0.8632437898500702, 0.830395912676624, 0.8547337460922325, 0.8154773107500282, 0.8512516145058453, 0.8396790464525177, 0.8544764255185645, 0.8472640874589304, 0.20831253891188695, 0.17864795926302135, 0.13498335188526056, 0.15921081464660525, 0.1341444351877682, 0.5017115541637119, 0.19508480994267796, 0.1510878806027427, 0.1615581198170124, 0.20122297107377685, 0.16298676514568233, 0.130309600555637, 0.20596671981145864, 0.1999953735369845, 0.2618523855470124, 0.14078846934554234, 0.139256648771919, 0.1570770201965488, 0.2960812148490122, 0.2206309139412902, 0.1697926311214225, 0.25233020466892775, 0.0663438961614411, 0.12906577478394488, 0.16938650294859292, 0.05729479329358711, 0.06403951292312215, 0.18954788929515098, 0.21806196418798995, 0.310305704439929, 0.25327199543565815, 0.23734429758630549, 0.12973564099589074, 0.18467730634254154, 0.513496445426388, 0.5539835806677469, 0.12071295114012248, 0.4142709550125383, 0.16190070480923535, 0.1884725958438609, 0.0850459729346219, 0.23208222860330308, 0.1264633803109848, 0.20932280492263422, 0.16819566340694692, 0.23080965751110094, 0.2972090960687429, 0.3171868007595263, 0.2820471642712038, 0.19014092912363767, 0.30148814065272145, 0.34210615726089966, 0.2664499541657035, 0.35558718896146213, 0.6551227516323631, 0.5813128056590803, 0.6517860477094493, 0.6321446170378588, 0.7088377653366894, 0.7310041795578766, 0.5582616737611994, 0.8072786490609898, 0.5927309311194724, 0.13544367235426757, 0.12276334285759427, 0.1086400590493728, 0.115919092951136, 0.14088288807518679, 0.1266776287850091, 0.11978244848915187, 0.10680261510404121, 0.13045081297542016, 0.1683389426504316, 0.220562217244614, 0.2343667899514298, 0.21096118559207677, 0.25026245299124084, 0.2163858010180375, 0.1997825560976435, 0.2210564911570032, 0.13765646599216397, 0.528411639363136, 0.5967628833337493, 0.5072356093842794, 0.6142956410331731, 0.5186082758990097, 0.6944314047983159, 0.5873509958055216, 0.685064836520715, 0.5101998879527838, 0.4084943153635088, 0.3082618572000515, 0.5156750082880351, 0.41180293204248064, 0.35796270100942806, 0.39682435193769416, 0.48503225352965695, 0.38335940945325486, 0.45448086170019775, 0.196500407304528, 0.21743869761236667, 0.2086342518427462, 0.20358599583785275, 0.1973098838263312, 0.21545044183991535, 0.21194219536562897, 0.2318495596413519, 0.20962516464797165, 0.20509496477285583, 0.6444776090821118, 0.36993643666953413, 0.5373905871128312, 0.5762972773549528, 0.3286893488032002, 0.3717176779570506, 0.215018866695591, 0.40857866320961556, 0.8089585444576681, 0.19671709718245856, 0.3917226121063644, 0.8259173185643787, 0.1668881331252201, 0.8865609430937178, 0.1854964637438158, 0.16515166121579317, 0.2009417672254823, 0.36949105147638495, 0.16668076623707806, 0.2042202696091414, 0.1669036837603035, 0.2019054199037298, 0.16686656420857637, 0.30397666182289584, 0.12692632718962793, 0.20919316683431, 0.1868244834181284, 0.18159478986882394, 0.18602750142634872, 0.1902696797698571, 0.18202211708874405, 0.18544213249715946, 0.1888227614823088, 0.17360000911961382, 0.1889479911625661, 0.1015240550861145, 0.08891143170135474, 0.085546770155014, 0.08213643477519272, 0.08131818950736014, 0.09552674039531006, 0.07990379735429431, 0.09737629877796439, 0.08958982088397371]}, "mutation_prompt": null}
{"id": "e12b3bb4-df20-4ee4-9fcd-ea8d92b5392a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.strategy_switch_threshold = 0.3  # Threshold for dynamic strategy\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        \n        # Introduce additional mutation strategy based on success rate\n        if self.success_count / max(1, self.total_count) > self.strategy_switch_threshold:\n            mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        else:\n            mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[idx]), self.bounds[0], self.bounds[1])\n        \n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting mutation strategies based on success rate to better explore diverse landscapes.", "configspace": "", "generation": 87, "fitness": 0.4163936449861153, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8214654208792939, 0.8315089290835493, 0.8248597623293561, 0.8311208404555884, 0.8475099228408642, 0.8263958486432093, 0.8404219615391052, 0.836292059672342, 0.8238845432290226, 0.7103489083808074, 0.7329062026605544, 0.719356364847247, 0.7071899765247087, 0.7242401193016625, 0.7202563437760277, 0.7209793394910078, 0.7169861045214525, 0.708667478770534, 0.13237404618496673, 0.11848334253694359, 0.14220849126784163, 0.12353649502532604, 0.11855250709801479, 0.12273435707082081, 0.11302594517674314, 0.11853212348998787, 0.11206828585992612, 0.11936891704647168, 0.10910537382501151, 0.11992531445534782, 0.11229929906061076, 0.1108110105417589, 0.11309432361324756, 0.11910446981589429, 0.10510666431137217, 0.11699428212850016, 0.975450545596172, 0.9180828508283067, 0.9354686804462746, 0.9493591774855957, 0.9481893075269264, 0.9093691795150425, 0.9242654170744687, 0.9377440478352739, 0.9290844251565348, 0.43217163637051226, 0.5056492093345537, 0.4077048576877319, 0.525634883953159, 0.46784368010127875, 0.47699120201352874, 0.455024029656368, 0.41124682912471433, 0.5538795385634585, 0.8179862714541697, 0.7978440374224979, 0.7816015435922748, 0.8590219996899175, 0.8228909061113918, 0.8391974166063468, 0.8115006378538026, 0.8096485792718009, 0.7897109945457134, 0.18104207085067192, 0.30311382322753444, 0.19937802454905396, 0.26071054719763875, 0.147604806150327, 0.21280407928436962, 0.2287673537161794, 0.1992680600430773, 0.2368868507233235, 0.6187524491684631, 0.153916735651496, 0.3585297552107931, 0.24634858360409106, 0.2567771864017121, 0.2023811801789248, 0.2079023095615813, 0.20291523290536595, 0.22753337340852797, 0.593347785556696, 0.530114789940481, 0.5132759697534058, 0.5677226494210861, 0.5525618659722181, 0.4785644556016674, 0.5841106985158849, 0.616570069631041, 0.5910195868627519, 0.6624306611891646, 0.6781899021457736, 0.6391814332487229, 0.6643976340847193, 0.6339746370753498, 0.6527103452168217, 0.6542081841371776, 0.6895322215994326, 0.6929264891717701, 0.1409033608605781, 0.15825041137113527, 0.0812896951472285, 0.4258820460767342, 0.18845191292741803, 0.17183983459357388, 0.18903660641221576, 0.20029371933661122, 0.21632988681266085, 0.46617691727697885, 0.478122494864227, 0.3827960865504676, 0.45176322241553857, 0.43480303259679776, 0.5448600473345498, 0.48639910470284686, 0.429752023345092, 0.5080133546710334, 0.7896568780604565, 0.7848181113239698, 0.7639807999840305, 0.7808292618315451, 0.776295188505651, 0.7617411639760255, 0.7754126469057928, 0.7864670538036816, 0.7910805444029302, 0.11098078905195763, 0.12772515222056446, 0.09931124190860918, 0.11641969291852239, 0.09819663272158963, 0.10775001321644684, 0.11358732080413969, 0.10782739297817423, 0.10604691670605082, 0.1533333947505351, 0.1629113175642084, 0.15858191000266364, 0.18032350904841166, 0.1747539917016354, 0.19003279493821312, 0.2537664764574694, 0.16026757401381442, 0.16138246851968252, 0.5306017845074227, 0.4740058643188474, 0.5549761832445509, 0.4511324913444802, 0.575417847128803, 0.5844704839616996, 0.5611485526799358, 0.6135407236040369, 0.5900360926837898, 0.39932967304093814, 0.38978898352934244, 0.380221174425432, 0.45730128247323254, 0.4241078760438738, 0.41482554173079933, 0.4324538573407386, 0.4631600341432539, 0.43500233230217433, 0.19198285615903976, 0.20172493826897664, 0.2349421682295999, 0.1993133418452061, 0.18952762022603187, 0.20570455508909102, 0.2170134150009505, 0.19293025555980614, 0.20833281527767955, 0.257508179701485, 0.20235445751379588, 0.2777421900175743, 0.22354993244395738, 0.19032525314003934, 0.37600141489621, 0.2018743810147936, 0.211131397331197, 0.20648310240527312, 0.2048402818434263, 0.20510793133438743, 0.1494467821086577, 0.6930635452606226, 0.17996394045851416, 0.748552847281033, 0.7461332784734274, 0.7200511714075053, 0.7698408947836056, 0.6440408943846915, 0.6109148266710548, 0.20739719225539088, 0.20684706090290716, 0.6620909616946085, 0.39035678268158613, 0.16341809445784006, 0.20538472169221766, 0.20927828017494698, 0.1945653444344717, 0.18395618609432995, 0.18498220204851368, 0.1859260957763067, 0.19374998114241693, 0.1883963160279022, 0.18091068086550255, 0.18983729452413223, 0.1880128044739785, 0.09192835234961516, 0.07631185299086296, 0.08601989989037795, 0.07840413669689295, 0.0973886437639927, 0.08992890268561837, 0.07991319463697077, 0.08107663283015987, 0.08083319843568604]}, "mutation_prompt": null}
{"id": "79c86164-2e12-4892-b75d-f2b7757641a6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "569ed12c-b5ac-486b-9b78-c06dd0be42a7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "32730693-f05b-4bc4-a9d4-c7d1c4974ec6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "a0c83459-b0bd-45a2-a578-d6c182db7642", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.7, 1.3)  # Modified range for finer control\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def rank_based_selection(self, population, fitness):\n        rank = np.argsort(fitness)\n        probabilities = (rank + 1) / rank.sum()\n        idx = np.random.choice(len(population), p=probabilities)\n        return population[idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Integrate rank-based selection and finer dynamic scaling for improved convergence efficiency.", "configspace": "", "generation": 91, "fitness": 0.4198218252534519, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8488161818518742, 0.8326741794226552, 0.845491338447389, 0.844348100022687, 0.8250605017313963, 0.8455822914784192, 0.8442814294682093, 0.8347493007257459, 0.8446553455728463, 0.7494381760373112, 0.7443340531694881, 0.7287352423090006, 0.7397479166417481, 0.7468087027332265, 0.7239725951230898, 0.7595730054193295, 0.739075257849167, 0.7408724497347896, 0.13483230764172693, 0.5341962063928555, 0.4659313057618403, 0.1380152212553618, 0.14064631317103593, 0.11841169458823042, 0.12281777848491926, 0.12225408355370948, 0.39161616902798035, 0.11769621334022906, 0.1293997154932085, 0.13166259404919511, 0.25090709114139653, 0.1298146968048881, 0.14109393981248175, 0.1349844578884959, 0.1521099845711027, 0.12419961844957983, 0.9277298826886881, 0.9062758914333129, 0.9365758968609754, 0.915950401778491, 0.923747452741432, 0.930654254362214, 0.8757237228386681, 0.8519962626370727, 0.8755066386648849, 0.5111046375844523, 0.47476888063587697, 0.5753652033099608, 0.3665052868350507, 0.48964353417047335, 0.4921923667732704, 0.3488434259610267, 0.4054643916249242, 0.53269046379251, 0.8327367626857848, 0.8339469046495332, 0.8274909011817497, 0.8366389511177301, 0.8451577984055225, 0.827004288279527, 0.8381058123403904, 0.8156904743562693, 0.8272626410000096, 0.2326401285617411, 0.19489755642416295, 0.14270232576300457, 0.17216078170472537, 0.17871336866752685, 0.14819309043232953, 0.20663166352704343, 0.619424086985584, 0.23506787552520503, 0.19509191077271304, 0.19610006787419776, 0.1736326553076295, 0.24727142127863044, 0.26714169158732204, 0.21867570992468832, 0.15983265767477428, 0.25753206110679816, 0.14301330835199222, 0.38230956974120744, 0.21624457784453888, 0.17342769910538514, 0.5798088104568726, 0.6097047170501545, 0.47433130839996085, 0.2597149268437011, 0.5852150269574785, 0.38866341132048743, 0.6118394799344244, 0.6768206715824707, 0.6994078265951857, 0.6647409939764655, 0.7016903439687988, 0.7048630780486519, 0.717975574827255, 0.6329526265940668, 0.702198676973014, 0.2525277163034617, 0.13576414520797386, 0.1847352135528335, 0.22758987791135454, 0.24827217616150177, 0.16302107133498012, 0.15335251260233929, 0.17853799790338376, 0.15168076586156476, 0.37677768578763504, 0.4418329334933553, 0.44964674808205307, 0.5037781335125486, 0.3100363817917239, 0.5195529650592781, 0.36195071885260155, 0.3731852215842726, 0.379532867623083, 0.7919795154192261, 0.7869168730761723, 0.7592005643564094, 0.8109653135028885, 0.7912373854333643, 0.7416720776348893, 0.7427704959979757, 0.8011381009090106, 0.7788466670819143, 0.10178247221367076, 0.11444273786861447, 0.13960122895761418, 0.135221305071775, 0.12619422037730654, 0.17474292177928585, 0.10705739552259896, 0.11483280458475242, 0.11786518491384412, 0.21545087665495433, 0.349156106390493, 0.15072405511174924, 0.1852489303612601, 0.26156742799253285, 0.19995209981875284, 0.16774956249403405, 0.1711430206444975, 0.2291129828325722, 0.5006109380159554, 0.5279564857350829, 0.5346239384674745, 0.4932582879642715, 0.6358711600434599, 0.5185171965054862, 0.6661762172543257, 0.6662133125211218, 0.6439287027827547, 0.4242956677974492, 0.452606472812237, 0.4237363376659057, 0.4553224696116499, 0.45989412692912934, 0.3871648819348371, 0.5159013379098725, 0.5052343170333828, 0.4495459685618667, 0.20646303615277417, 0.2066094184688122, 0.24008679264175814, 0.18352851112397506, 0.20979713347346052, 0.2082962781088875, 0.21196792881258064, 0.20718828430114122, 0.18772075986546122, 0.3435970087727217, 0.4979798212462335, 0.5706858598771489, 0.5583163787427419, 0.3246052472735925, 0.5495795304062481, 0.20520103369180087, 0.3037246764150897, 0.4179795514786826, 0.7569909203816388, 0.2005917364896047, 0.16333225665923568, 0.7745321596421897, 0.1940682915613957, 0.1940454222068564, 0.18282549112543534, 0.7011240942295967, 0.7744615656893379, 0.8158886868779884, 0.2043043431405569, 0.46080774686234804, 0.20853512859229673, 0.19599553404302372, 0.19786331651541234, 0.15139644411432696, 0.2064922060736022, 0.21064690659227503, 0.17696947856819278, 0.19512319680524903, 0.186617417130719, 0.18082215199846718, 0.19210562605794645, 0.17823966773242605, 0.18921055711196577, 0.17968941560743568, 0.17698199276861282, 0.08567271049096381, 0.08877404039706926, 0.07881506628987611, 0.08220394045455648, 0.07955361177415166, 0.08526549127015892, 0.0737763195469322, 0.08651948263056597, 0.08452903771911946]}, "mutation_prompt": null}
{"id": "2faeb077-379e-47e1-87b4-2d676a060877", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  \n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self, fitness):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  \n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)\n            self.CR = np.clip(self.CR, 0.5 + np.std(fitness) / 10, 1.0)  # Dynamic CR based on fitness variance\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters(fitness)  # Pass fitness to adaptation\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover probability based on fitness variance to enhance exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.4242821645879398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "602b8037-36ad-418d-b015-bc0cfcc2df76", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "667e239d-065c-402c-a01d-59e3936bd7d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def local_search(self, individual, func):\n        step_size = 0.1  # Small step size for local exploration\n        candidate = individual + np.random.uniform(-step_size, step_size, self.dim)\n        candidate = np.clip(candidate, self.bounds[0], self.bounds[1])\n        if self.evaluations < self.budget:\n            self.evaluations += 1\n            if func(candidate) < func(individual):\n                return candidate\n        return individual\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n                # Apply local search on improved solutions\n                population[i] = self.local_search(population[i], func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by integrating a local search step to refine promising solutions.", "configspace": "", "generation": 94, "fitness": 0.2782066977971208, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.6094860138508237, 0.6204967305945926, 0.620640441976825, 0.6167552964223519, 0.6252689642163247, 0.6404076405278383, 0.600629780207504, 0.6314875215846759, 0.632147608130627, 0.3668170321624016, 0.3926301909463783, 0.36521293775807695, 0.34690105667541926, 0.3919010750800205, 0.38147115074678184, 0.3839394472901194, 0.3656981364708407, 0.38156170500060493, 0.11500951426672201, 0.11862062806265661, 0.1220892561012652, 0.11874139784399917, 0.12574617928260212, 0.1331590822597023, 0.11415508544527475, 0.10879665843358777, 0.12036151663603067, 0.10523064663140014, 0.10114849694483075, 0.10669710033568514, 0.11528815193800257, 0.10327685952614196, 0.09583484491617178, 0.10313526053849598, 0.08802834390966163, 0.09448904522095836, 0.8395984480477301, 0.8322972448244923, 0.7525810198919048, 0.8451592621599493, 0.7974775345729923, 0.8693519934966669, 0.8353487130766913, 0.8245320955603543, 0.7927977818953585, 0.2712579754739636, 0.2704426032982018, 0.29424756649243267, 0.25709323216397983, 0.2423138299142431, 0.3043534551634246, 0.26614427532946416, 0.24588750143801297, 0.3078458537510935, 0.6427807357293622, 0.6376742366496411, 0.593215910000892, 0.6307849539642456, 0.6211999713985865, 0.5551379886416303, 0.5558097310548247, 0.6260245225192285, 0.5097662383991679, 0.17764081134519671, 0.13592151665510954, 0.1468283485997357, 0.16376014849694187, 0.1483999696104451, 0.15627792169177213, 0.16152514357391556, 0.11734657476880417, 0.1705667501760335, 0.1594024239736216, 0.133602862697367, 0.18122456472947723, 0.14778612620781473, 0.15312182606778224, 0.17294033703663647, 0.16044171827325704, 0.12516780050198395, 0.13341347484754928, 0.16734199016656381, 0.13125997865968397, 0.10893927789936586, 0.1510793062411867, 0.12124736190347052, 0.2185081277209946, 0.2327458864322267, 0.05550124472369933, 0.11670994954794622, 0.3072237966949991, 0.31533705555471214, 0.2518845840567677, 0.29983337461797543, 0.2825634354496177, 0.2321110740308061, 0.30109847579238336, 0.3244819247134678, 0.30926202095177746, 0.07128543060221104, 0.05021901716237831, 0.08740260415026568, 0.060863384699336165, 0.06428431905603083, 0.09931889434383101, 0.11545016449713297, 0.028177219278141097, 0.0731627451329585, 0.16646172129835235, 0.1652563177369788, 0.17563429915030337, 0.19207639496656226, 0.189288996212714, 0.18947249385461595, 0.1690821979221564, 0.20527820820113307, 0.16726116820816583, 0.5120700293290167, 0.5215649522936788, 0.5377497655653225, 0.539739431631771, 0.5415149206419574, 0.49244857197346315, 0.5298783734906691, 0.4952215601495592, 0.5088372390921654, 0.12279750910744736, 0.11249779109216851, 0.11651709380471997, 0.11056408683974117, 0.11483127300719731, 0.0981383332642588, 0.11334658504067496, 0.10718591878874484, 0.11323187726550499, 0.16998944771070312, 0.15714553275254783, 0.21150098693361674, 0.24990322332441406, 0.16928343430914228, 0.171621945284828, 0.1691601211143794, 0.1825646004383369, 0.1636828306134832, 0.2982906183207852, 0.30966180141800936, 0.3068335530360021, 0.3032155862591829, 0.2651872153774928, 0.27081129004028226, 0.31861288719997805, 0.345196597036899, 0.3080829361375378, 0.2583593909025672, 0.2508052316093331, 0.2127338970840802, 0.2460767128537421, 0.22317349256973262, 0.18846109738908012, 0.24253712788457937, 0.26677417300619266, 0.23752885098305287, 0.18304968583534742, 0.19088682829784243, 0.1916962584970513, 0.20622852845911288, 0.19364643391130298, 0.17601076334709542, 0.2002148725222227, 0.18841465501191546, 0.1897194939818052, 0.1876630218996438, 0.18560133074861251, 0.19758879511439398, 0.19323576653840868, 0.21368237788096345, 0.1778586744801992, 0.206836353774158, 0.18368285841419973, 0.19238018456533978, 0.17142788373074946, 0.597890848729574, 0.6051507289431897, 0.5435431001062201, 0.5198351020455264, 0.462934516079446, 0.1819463044537648, 0.6033854038994804, 0.47451995575584993, 0.6160551953358442, 0.2037428710187218, 0.31159164699737507, 0.15649449343309918, 0.29038608898687535, 0.24438845490340488, 0.6060990773673729, 0.19698957935640404, 0.20506689047356663, 0.18337571270915565, 0.18077333361463932, 0.18067222761585022, 0.19722819630315302, 0.19218586055822884, 0.16585856269472987, 0.17552897927566224, 0.18318418190321073, 0.1747287523055142, 0.07665548839461878, 0.07695251557083016, 0.08708165230234877, 0.07566430159716331, 0.08284557122456426, 0.07500868915564662, 0.06970298995885116, 0.07672687135807665, 0.07643968504344134]}, "mutation_prompt": null}
{"id": "63a6aca1-f0a6-4be0-99dc-a4eeb3fc1732", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.hypermutation_rate = 0.1  # Rate for hypermutation\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def hypermutate(self, candidate):\n        if np.random.rand() < self.hypermutation_rate:\n            noise = np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate + noise, self.bounds[0], self.bounds[1])\n        return candidate\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        candidate = self.hypermutate(candidate)\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce hypermutation with adaptive parameters based on success history to enhance exploration and convergence.", "configspace": "", "generation": 95, "fitness": 0.4242821645879398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "97fad80c-c8e2-405f-96d8-c86ea3dd5d1e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.stagnation_counter = 0  # Track stagnation\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.adjust_crossover_rate()  # Adjust CR based on stagnation\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def adjust_crossover_rate(self):\n        if self.stagnation_counter > 5:  # If stagnation detected\n            self.CR = max(0.7, self.CR - 0.1)  # Decrease CR to encourage exploration\n        else:\n            self.CR = min(0.9, self.CR + 0.01)  # Slightly increase CR otherwise\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        candidate_fitness = func(candidate)\n        target_fitness = func(target)\n        self.evaluations += 2\n        if candidate_fitness < target_fitness:\n            self.success_count += 1\n            self.stagnation_counter = 0  # Reset stagnation counter on improvement\n            return candidate, candidate_fitness\n        else:\n            self.stagnation_counter += 1  # Increment stagnation counter\n            return target, target_fitness\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    population[i], fitness[i] = self.select(trial, population[i], func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by introducing a dynamic crossover rate that adapts based on population diversity and stagnation detection.", "configspace": "", "generation": 96, "fitness": 0.2803524800309476, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.7295920253923522, 0.7218218421448512, 0.7235087936357034, 0.711783886424374, 0.7209164496522371, 0.7101970152537747, 0.7127554089296817, 0.6876381959632646, 0.7003952733368191, 0.5589287185376633, 0.5593638796159441, 0.5463550296641723, 0.542196179285879, 0.5266613050888986, 0.5367182348911408, 0.5526459075260086, 0.5106791632806555, 0.5711757689151054, 0.1518055885406373, 0.16016352012371204, 0.14687515231752035, 0.107451696195351, 0.1404517381029653, 0.25342436200538376, 0.13461067527147752, 0.12023875145792828, 0.232178516133408, 0.10753600461043011, 0.10468393299598522, 0.11789930088846645, 0.10839995400286484, 0.11818812284096836, 0.10866278677876995, 0.09873772130146552, 0.11128717491341322, 0.11743340787537948, 0.9586406540875141, 0.7350715558838243, 0.8516308089199048, 0.9772695891188228, 0.9137982481173409, 0.9087928865623364, 0.9430684626578568, 0.9278319123967838, 0.9010913360425782, 0.2995406554193345, 0.3156737716781368, 0.26956802450711614, 0.357335574478286, 0.3112777612527997, 0.34764488216289335, 0.21369214709862805, 0.25851082303220574, 0.28203946636436583, 0.5738936312103282, 0.5918922746677812, 0.4766845256604467, 0.6167821349507367, 0.5624325206986549, 0.5796387287394951, 0.6442933592838591, 0.6049645460427968, 0.5588393641318896, 0.16059962170129316, 0.18087814911202327, 0.19741899595351675, 0.17629406111829615, 0.12871708939617788, 0.15034666209583503, 0.1793046864906186, 0.14123598029147666, 0.14218322311237774, 0.12822632207376705, 0.13181456905610545, 0.17234892167951532, 0.16087694734643898, 0.12614182697044107, 0.1652212264800763, 0.15365255366527852, 0.1265096194984764, 0.16097032775053444, 0.06472158008058049, 9.999999999998899e-05, 0.06685334285861977, 0.03700420558992046, 0.12417110231556672, 0.02787725547666886, 0.03765683847376389, 0.0681532237686302, 0.07959182111682817, 0.23715991239254586, 0.1758625195173017, 0.1957864498869406, 0.14809864592500266, 0.21742857023908602, 0.07063016043097647, 0.20560354579365425, 0.2044770547188859, 0.2442424325852628, 0.0681202972714614, 0.06322064453706866, 0.06745526722290929, 0.04975984097747477, 0.07180195852012006, 0.05505247467555896, 0.07448471107828558, 0.06963593782294553, 0.06866805953950517, 0.1929495375699225, 0.18041392938913958, 0.17161808439423643, 0.18999839568491583, 0.23609123719114433, 0.19644384604167975, 0.1778406756221299, 0.18064793338551355, 0.20152495993196085, 0.524348046729401, 0.5055873264466477, 0.4957223164064377, 0.5011248678941821, 0.571368171535513, 0.517677321662007, 0.5644500980846748, 0.5584025002717055, 0.5239623000710141, 0.09073297568551841, 0.08247703664559358, 0.10165502846592411, 0.09858435409928368, 0.08687344709040612, 0.09053125351239799, 0.08582627438779511, 0.10139201889385352, 0.07655370226193592, 0.148685749849627, 0.13247234021231402, 0.13998623063714366, 0.13193228770208043, 0.12617256848330638, 0.1693326836045833, 0.1488666226074289, 0.14165353385555757, 0.13817503798741304, 0.3007276764350689, 0.34207100202650476, 0.36840128979199094, 0.375850371574865, 0.3315026961618236, 0.352660847012087, 0.4063697016344159, 0.4282344573542327, 0.3930960765004923, 0.24511293219250152, 0.2556947702196428, 0.24127032067228227, 0.2431811717043627, 0.24970250725660303, 0.22870327275548208, 0.2959494041324916, 0.2773933873797092, 0.24698398355267437, 0.20225267690707183, 0.18402677593344752, 0.18312890797785097, 0.2040536454467322, 0.1791203856392003, 0.18009557788053476, 0.19702979990479585, 0.18420923497217034, 0.21617554748295675, 0.23713830144615544, 0.23429749186934923, 0.2005706625991429, 0.34546847045953, 0.275482937303963, 0.18933117431897273, 0.25841005354875235, 0.20295309632009617, 0.18141196917783475, 0.1484683982249695, 0.186387331947364, 0.15938592397264928, 0.4812450422720488, 0.16697958806774293, 0.5569257116140592, 0.4493980897163792, 0.5472845976571233, 0.569908646925523, 0.12346986190072695, 0.3147104199084816, 0.1498079152743177, 0.18933981857097837, 0.19117913894251692, 0.17943397970134212, 0.14327861471659564, 0.14716516302665072, 0.19831130351501758, 0.174580293340306, 0.18680554696489682, 0.17118004700588096, 0.1727795507581108, 0.19552135606685883, 0.1836078224875206, 0.19476881104936938, 0.16638354036311198, 0.1686972839668549, 0.07582062113644428, 0.07342592571514528, 0.06700146955279684, 0.07601658073201834, 0.08363381078497534, 0.06819771328028879, 0.07548481578211608, 0.08001374451176468, 0.09778016972237946]}, "mutation_prompt": null}
{"id": "774b05bb-8158-4b24-bdd8-a24c88105d08", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n            self.learning_rate = 0.02 + 0.03 * success_rate  # Adjust learning rate based on success\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive learning rate based on success ratio to improve parameter tuning dynamically.", "configspace": "", "generation": 97, "fitness": 0.4242821645879398, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
{"id": "f7f29f05-1ee0-44d4-9da9-c1a29108142a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n        self.best_solution = None  # Track best solution\n        self.best_fitness = float('inf')  # Track best fitness\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        candidate_fitness = func(candidate)\n        if candidate_fitness < func(target):\n            self.success_count += 1\n            return candidate, candidate_fitness\n        return target, func(target)\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n            self.learning_rate = np.clip(self.learning_rate * (1 + 0.1 * (success_rate - 0.5)), 0.01, 0.1)  # Self-adaptive learning rate\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial, trial_fitness = self.select(trial, population[i], func)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n                    if trial_fitness < self.best_fitness:  # Update best solution\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Introduce self-adaptive learning rate and use elitism to balance exploration and exploitation.", "configspace": "", "generation": 98, "fitness": 0.20798762884150795, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.5899079246785409, 0.5764199840579541, 0.5769465139469574, 0.5539573573637988, 0.5887456401775348, 0.5827211275974546, 0.6058419775539443, 0.5863852130595641, 0.5857412342914337, 0.28742985606325633, 0.32253903916582616, 0.2832596564457205, 0.29015752625729274, 0.30730527286933285, 0.3020562003107955, 0.2950615443556961, 0.28374645041185154, 0.31702524449460234, 0.0948942923043049, 0.0986481874435422, 0.09294650892237621, 0.102958520194111, 0.09399589569650502, 0.09987852443465195, 0.09231548518886068, 0.09377878354274038, 0.08904843646738758, 0.08199351060326876, 0.08407404186735057, 0.0824741259032733, 0.08310355329725794, 0.07807414356567988, 0.09117436765166076, 0.08854424939835903, 0.08708967253586652, 0.08280080935443035, 0.9125988449755077, 0.8248169656727344, 0.8715852483368199, 0.7903089579948397, 0.9721977156037471, 0.7249047677815283, 0.8649538981475049, 0.8836935891722544, 0.8849998011431729, 0.1922532841450283, 0.19773586777066876, 0.21366537032478194, 0.21452304525190002, 0.22814745990805174, 0.21039822866865565, 0.21702796357891252, 0.17912816259923725, 0.23749780360837303, 0.24573334456832585, 0.29207556874472484, 0.2920741914638404, 0.33304986687700977, 0.4134615895929472, 0.2836339545225559, 0.37532680420502684, 0.38396556782197444, 0.27352584297728055, 0.11557060184173751, 0.11729543558280675, 0.1424291479990265, 0.13779584325644423, 0.1600872181680868, 0.12767571323387905, 0.14512177997005615, 0.1461318515667701, 0.12953630133438987, 0.041345749427673995, 0.11836610530608782, 0.0724665511536261, 0.114876108814144, 0.14825933033193983, 0.11303908487032677, 0.10704392354337655, 0.12676852311976727, 0.11329010782862192, 0.028985271274718616, 0.04831810225217015, 0.02771899997454441, 0.038322773132611454, 0.028188545582447988, 0.00406924832502531, 0.02253670245851591, 0.036566662602720124, 0.028359009172535643, 0.14088437281260446, 0.11764997061985483, 0.12246627937011267, 0.08208825321909785, 0.09549905661520441, 0.08016726629414239, 0.12526503574795445, 0.16275895966440623, 0.14266232968094517, 0.010364041569398297, 0.014276287243529251, 0.023448476014488517, 0.026216035581327568, 0.007874815514462341, 0.006594629416643127, 0.018409689922643135, 0.02713914768644099, 0.010573484854378923, 0.09599918677168096, 0.11969975619401907, 0.10597141808284904, 0.09466919263397688, 0.10636778297331206, 0.11904992034023731, 0.10452409083593361, 0.09956775902269344, 0.08781166470285096, 0.401518390358086, 0.3994143281188548, 0.4181752989856553, 0.4367696152290621, 0.4044192036011517, 0.40834026047593963, 0.4281367556450816, 0.3897048595450757, 0.42072691591749667, 0.07192472860882315, 0.08231673781437254, 0.07121883410932783, 0.07555121162212164, 0.07672394380578063, 0.07932939160921382, 0.08211021090402448, 0.07957231033575496, 0.08097087427963157, 0.15691941923102348, 0.12823358393382334, 0.12718597022315825, 0.13417026679393074, 0.1384314954038357, 0.11639553819871074, 0.11885455724774985, 0.12205175031128945, 0.12011518859822246, 0.23922328767962941, 0.2748358133036505, 0.24728184651052354, 0.24707414437724073, 0.23340015733354869, 0.27167514796803394, 0.25559386532638007, 0.29219426158442274, 0.2794655940479077, 0.20207796278294865, 0.1729191686956596, 0.1617950332096334, 0.1793180883014549, 0.184005489134346, 0.179412515963425, 0.20776403709846847, 0.19042741486393933, 0.17770473202627113, 0.1887772929278725, 0.1731389246052586, 0.18757901210686934, 0.1794640457081338, 0.16788275226485205, 0.16357615644384949, 0.1644784777375664, 0.16260140418696412, 0.2228794334178288, 0.19276933544621733, 0.17007824034322472, 0.1747571022048412, 0.16701111847590233, 0.17701289862519165, 0.16641912620754884, 0.177046538207274, 0.1678832909427478, 0.1681102675850369, 0.27821393752814094, 0.15609311946172477, 0.1570978280613914, 0.37865088056426577, 0.1739585638114689, 0.21398054559957014, 0.16095699691172083, 0.14495070017606193, 0.16172104839201762, 0.1772119003104573, 0.19520820786446247, 0.1619743305050806, 0.1510069335894696, 0.12451393489538565, 0.16201338640837948, 0.17895102805934637, 0.20068513232193264, 0.18907490364812718, 0.17064791808758617, 0.16184245353251714, 0.16932687619227105, 0.16554575641761204, 0.16734196591911132, 0.1764528729068745, 0.19039196936961655, 0.17190832115667143, 0.17967214295539613, 0.0694377383681607, 0.06307715542361425, 0.0716420222313906, 0.07031091346800744, 0.07105038636146388, 0.07123997462515086, 0.07469702769549513, 0.05546572420943463, 0.06760944174465366]}, "mutation_prompt": null}
{"id": "decf55d2-ce40-4bc2-bd60-927721281b1d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_pop_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.evaluations = 0\n        self.learning_rate = 0.05  # Learning rate for adaptive parameters\n        self.success_count = 0  # Track successful mutations\n        self.total_count = 0  # Track total mutations\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, self.dim))\n\n    def mutate(self, idx, population):\n        candidates = list(range(len(population)))  # Adjust based on dynamic pop size\n        candidates.remove(idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        rand_scale = np.random.uniform(0.5, 1.5)\n        self.F = np.clip(self.F + self.learning_rate * (self.success_count / max(1, self.total_count) - 0.5), 0.4, 1.0)  # Adjust F based on success\n        mutant = np.clip(population[a] + self.F * rand_scale * (population[b] - population[c]), self.bounds[0], self.bounds[1])\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        return np.where(crossover_mask, mutant, target)\n\n    def select(self, candidate, target, func):\n        self.total_count += 1\n        if func(candidate) < func(target):\n            self.success_count += 1\n            return candidate\n        return target\n\n    def adapt_parameters(self):\n        self.F = np.clip(self.F, 0.5, 1.0)\n        if self.total_count > 0:  # Avoid division by zero\n            success_rate = self.success_count / self.total_count\n            self.CR += self.learning_rate * (success_rate - 0.5)  # Adjust CR based on success\n            self.CR = np.clip(self.CR, 0.8, 1.0)\n\n    def dynamic_population_size(self):\n        return max(4, int(self.initial_pop_size * (1 - self.evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.initial_pop_size\n\n        while self.evaluations < self.budget:\n            current_pop_size = self.dynamic_population_size()\n            population = population[:current_pop_size]  # Reduce population size dynamically\n            fitness = fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                self.adapt_parameters()\n                mutant = self.mutate(i, population)\n                trial = self.crossover(population[i], mutant)\n                if self.evaluations < self.budget:\n                    trial_fitness = func(trial)\n                    self.evaluations += 1\n                    if trial_fitness < fitness[i]:\n                        fitness[i] = trial_fitness\n                        population[i] = trial\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor based on success history to improve convergence in diverse landscapes.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b97c8284-e4b6-4a42-8a26-4efd1e629ffa", "metadata": {"aucs": [0.8422824101411855, 0.8379852787989397, 0.8440771453458209, 0.8492563866503644, 0.8272878042487769, 0.8420885923637291, 0.8409736612729704, 0.8378378531142113, 0.8417814337960803, 0.7626436315173144, 0.7309552674049542, 0.7425139371657541, 0.7142756097859698, 0.7259458060566942, 0.7414824582628692, 0.7297345838497642, 0.7593476097165743, 0.7295838087747994, 0.1476221975325931, 0.18896517269164304, 0.13886889322109397, 0.12947955606443207, 0.26114941465231023, 0.1319829221729808, 0.19722151255287412, 0.2058961036071324, 0.16685285805726413, 0.12900838437934092, 0.14790970485520827, 0.10521760527647461, 0.12634982560661667, 0.1186415430989819, 0.14976520312727348, 0.13419669034231252, 0.15125397794030582, 0.24027979919367326, 0.870747254470918, 0.8539030762123145, 0.85318181604242, 0.8612732825046193, 0.9099278974251651, 0.9612060793023297, 0.898836526778328, 0.8533078188469384, 0.8855639502626113, 0.4673381205807612, 0.6609633989723387, 0.515678388038707, 0.5378046178965123, 0.5272692967823935, 0.5808394001880137, 0.42463239441076406, 0.3573990500071158, 0.5770232678189764, 0.8241700938386374, 0.8214114589072515, 0.8203883614718969, 0.8502494665231947, 0.8443110915324485, 0.8622413457730678, 0.8327270709574991, 0.8470194527179613, 0.8484134726702139, 0.21909344513867168, 0.2173872196216854, 0.14184013190962064, 0.18702606327206273, 0.173059949827589, 0.19999544239335887, 0.1741188023720226, 0.6266990636491161, 0.26622057203403815, 0.20943996523873576, 0.1892295953642642, 0.15191853756244222, 0.20993231350197006, 0.18470303489411533, 0.25511066099542423, 0.2120452218917861, 0.1485910984277754, 0.2030082492435319, 0.30385554508217305, 0.35197974452968683, 0.5735408785248699, 0.4799908875016443, 0.5902681978003317, 0.5746083986191017, 0.3790267551580683, 0.4657903305850215, 0.562688068286794, 0.5829550743168264, 0.6724975856502355, 0.5824296871229502, 0.5446311823093237, 0.6881121044201824, 0.6185537350381831, 0.7050712183924277, 0.7100949689786094, 0.6193079404859173, 0.09296836908288875, 0.08808002501353618, 0.29682793915177386, 0.20492179067210936, 0.20571925779220035, 0.22163892835843058, 0.16565308949743662, 0.18349898827752342, 0.19536669096387882, 0.3470068155233691, 0.34219352733036346, 0.47074387510606386, 0.2997868294900501, 0.4686168096115144, 0.40416655798903045, 0.37700841019149, 0.3253346596277409, 0.3646124902543135, 0.7779364327674699, 0.7924845561359466, 0.6560616460277229, 0.668198486247077, 0.7235610644967028, 0.7160334788586176, 0.7839006984922089, 0.6125090113591254, 0.7704593931399853, 0.12828025029031265, 0.13234164908521107, 0.12582490704259164, 0.13178501223095973, 0.11419189168495303, 0.10588901938370876, 0.12328380129269412, 0.12251220009214137, 0.10640020945431039, 0.16967986572693428, 0.16771205516306598, 0.19165150875565884, 0.1528303429449388, 0.2103377736978116, 0.21400715583827, 0.16472793861360535, 0.1951173401467482, 0.22291434495960571, 0.6330590825691601, 0.6476238479391274, 0.47954345361075834, 0.5568766456555743, 0.6258999439985482, 0.529321886539752, 0.6602040307373659, 0.569454193564302, 0.6338331317239008, 0.39165747192099154, 0.4466715119312926, 0.43576131487180336, 0.4618548450603819, 0.4520620780640102, 0.33442595171138656, 0.4751602505149958, 0.45854930224018997, 0.41562900405106706, 0.20598310347041326, 0.19493382593752517, 0.19436880064360829, 0.19558281559907553, 0.19878270371616003, 0.1929701998401664, 0.20594659036050778, 0.1971114287845559, 0.20247429887529267, 0.22995318683041943, 0.22126831825776427, 0.6090265200198888, 0.20711706838014898, 0.22066226981710102, 0.5331398325147445, 0.5711771240486729, 0.4142594228634855, 0.5892245489521, 0.8336814303988209, 0.8631377134159156, 0.8095202360181804, 0.18488151866862168, 0.1890022861743348, 0.7826338808195772, 0.7802711431316954, 0.812517194176163, 0.7878065827379062, 0.3349138617962776, 0.16648916878518616, 0.2032164509176514, 0.7497710857041473, 0.20081198618455787, 0.19306696158723324, 0.8152506881986862, 0.20376695101512587, 0.2088591593040643, 0.18309252632054074, 0.17339842129912864, 0.18667791519395216, 0.18214844416098508, 0.19166440999993706, 0.18459548009418636, 0.18681997414396068, 0.18097440452716873, 0.1943645835472616, 0.08208082462099642, 0.08032935704375033, 0.08085920299199079, 0.08384146198233244, 0.0941943501159962, 0.08019021899643797, 0.07784274157874826, 0.0760717405413801, 0.08649233761052377]}, "mutation_prompt": null}
