{"id": "7aac0d41-2e43-4986-adcf-6981a847437b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        # Initial Harmony Memory Evaluation\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Hybrid Harmony Search and Differential Evolution with Adaptive Parameter Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 0, "fitness": 0.246095757020787, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7490627783757097, 0.5509776204906978, 0.5794577505462772, 0.5588015895960385, 0.5722289138423344, 0.5246241094424888, 0.5850216720984676, 0.5789381242168419, 0.5032944881482874, 0.34282660159475176, 0.33916233489682923, 0.2297174552395812, 0.06382138554672945, 0.18123936070381408, 0.22037708451991822, 0.23643368675404242, 0.08719689050802804, 0.09893306516488753, 0.2597578496367402, 0.34043110668301413, 0.30055818763411357, 0.39849975280905914, 0.29277441323708464, 0.24479033564505748, 0.3217367556925307, 0.44202841578739827, 0.2222307678839177, 0.18660435690423927, 0.17774302238695217, 0.24949670508659916, 0.17847990630416555, 0.21123350539661723, 0.2427636578028658, 0.17188013808456615, 0.22426458713040343, 0.24927657426371075, 0.9741946557975136, 0.9619795196486945, 0.9761027984312453, 0.9811200816010173, 0.9748230941550954, 0.9621768762313634, 0.9761144316509079, 0.948242189762885, 0.9813555909335442, 0.2455688394495471, 0.22618545915536747, 0.22126659816248484, 0.25824158853257684, 0.3346359950378046, 0.2873586437993543, 0.25047146320448377, 0.25333089044397283, 0.24949338794306242, 0.2855306986971864, 0.16217465849842194, 0.2893368945576482, 0.2160413615340091, 0.19406628442387563, 0.3677526959021836, 0.2503348246751873, 0.22082536979462053, 0.24751980648488325, 0.225555400935607, 0.1440812516788259, 0.2851375983391551, 0.15319613344963656, 0.19089005065663944, 0.22520853779098993, 0.1833481112848122, 0.1468185494973384, 0.3165249523704189, 0.13381692675440338, 0.12890644546789498, 0.1307479908539868, 0.14624741331833957, 0.21646206481246544, 0.18866188601602796, 0.18688760507861235, 0.13186471203205985, 0.13497011912853019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050713436582423554, 0.052838579501239824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032514855295138645, 0.06626168879388838, 0.07337900423539756, 0.10869200581552885, 0.07620096438107304, 0.04330143325616753, 0.02960574559284146, 0.20715600765887088, 0.1463210338411649, 0.0598959314402866, 0.1791523779803692, 0.026422317366489367, 0.05162618681343123, 0.21320810387160827, 0.006329942286115164, 0.0408454151790234, 0.04768774561720457, 0.06932714317263089, 0.01507002003422453, 0.058949983299148356, 0.13830263908534857, 0.07355579775524834, 0.07866215097686358, 0.09925791706703113, 0.08782540684016671, 0.23220527093928767, 0.07711001832425624, 0.0892812685065223, 0.38112936784755824, 0.3791246876473908, 0.40582204054465554, 0.3857773044628413, 0.45380745339832507, 0.3511130441259658, 0.3960233048673045, 0.49032953769067844, 0.374288145035102, 0.14388027405849602, 0.12942947363167734, 0.13117305975818305, 0.13458097266487257, 0.09275087090640222, 0.142590017839045, 0.09514732343041321, 0.14201265623296477, 0.1363037323866032, 0.1881054781017396, 0.22175352045867114, 0.2352379259845233, 0.19162083935687246, 0.18566123408520985, 0.28341720972056184, 0.150869752013706, 0.26114403922756324, 0.23964896982778983, 0.2892661331500287, 0.31216448881451864, 0.19224685903954963, 0.30230488016580603, 0.24543648198411028, 0.270713683773416, 0.3144342651902199, 0.3505383136553717, 0.3841429265283772, 0.2373407718656827, 0.22606120658117168, 0.24011965592470697, 0.28081323640768496, 0.19557053084212872, 0.32111781386583915, 0.20653956858087374, 0.2020912293048841, 0.16061233326350344, 0.23601122133864405, 0.2128948680819156, 0.24133011645079272, 0.21893976446419494, 0.195051958548366, 0.2257433475778614, 0.23058643446213545, 0.22233842979224405, 0.19897722951041097, 0.1986928568475429, 0.22146370302666352, 0.1944665364951611, 0.2549625527152044, 0.3904860842168262, 0.22495175908641984, 0.21951850647982307, 0.20000968174975275, 0.18439427616719473, 0.17256152940605063, 0.17879858073254928, 0.189720376203943, 0.20098978448355198, 0.20034919215257418, 0.20200584717928038, 0.1654275002249258, 0.5023365265750434, 0.16034442097578105, 0.41133685297708766, 0.24614457595854644, 0.1907679238539277, 0.395833810398431, 0.20948280541306208, 0.21061597852296188, 0.2705714997234482, 0.10521404759458763, 0.23335096190384008, 0.21539150424011855, 0.2032796455983874, 0.20982688023304774, 0.23950927285918222, 0.21996602943327426, 0.20021716366414632, 0.18297956569002694, 0.20105851833449495, 0.20475458816045577, 0.09657762008916726, 0.0773894744002871, 0.08422488874330125, 0.07929629720410303, 0.09868497510933216, 0.07582357926447125, 0.07349550681470807, 0.08115061702140502, 0.07323553748209666]}, "mutation_prompt": null}
{"id": "99d95ab4-a9f5-4525-8526-9988fde843c0", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        # Initial Harmony Memory Evaluation\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Hybrid Harmony Search and Differential Evolution with Adaptive Parameter Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aac0d41-2e43-4986-adcf-6981a847437b", "metadata": {"aucs": [0.7490627783757097, 0.5509776204906978, 0.5794577505462772, 0.5588015895960385, 0.5722289138423344, 0.5246241094424888, 0.5850216720984676, 0.5789381242168419, 0.5032944881482874, 0.34282660159475176, 0.33916233489682923, 0.2297174552395812, 0.06382138554672945, 0.18123936070381408, 0.22037708451991822, 0.23643368675404242, 0.08719689050802804, 0.09893306516488753, 0.2597578496367402, 0.34043110668301413, 0.30055818763411357, 0.39849975280905914, 0.29277441323708464, 0.24479033564505748, 0.3217367556925307, 0.44202841578739827, 0.2222307678839177, 0.18660435690423927, 0.17774302238695217, 0.24949670508659916, 0.17847990630416555, 0.21123350539661723, 0.2427636578028658, 0.17188013808456615, 0.22426458713040343, 0.24927657426371075, 0.9741946557975136, 0.9619795196486945, 0.9761027984312453, 0.9811200816010173, 0.9748230941550954, 0.9621768762313634, 0.9761144316509079, 0.948242189762885, 0.9813555909335442, 0.2455688394495471, 0.22618545915536747, 0.22126659816248484, 0.25824158853257684, 0.3346359950378046, 0.2873586437993543, 0.25047146320448377, 0.25333089044397283, 0.24949338794306242, 0.2855306986971864, 0.16217465849842194, 0.2893368945576482, 0.2160413615340091, 0.19406628442387563, 0.3677526959021836, 0.2503348246751873, 0.22082536979462053, 0.24751980648488325, 0.225555400935607, 0.1440812516788259, 0.2851375983391551, 0.15319613344963656, 0.19089005065663944, 0.22520853779098993, 0.1833481112848122, 0.1468185494973384, 0.3165249523704189, 0.13381692675440338, 0.12890644546789498, 0.1307479908539868, 0.14624741331833957, 0.21646206481246544, 0.18866188601602796, 0.18688760507861235, 0.13186471203205985, 0.13497011912853019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050713436582423554, 0.052838579501239824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032514855295138645, 0.06626168879388838, 0.07337900423539756, 0.10869200581552885, 0.07620096438107304, 0.04330143325616753, 0.02960574559284146, 0.20715600765887088, 0.1463210338411649, 0.0598959314402866, 0.1791523779803692, 0.026422317366489367, 0.05162618681343123, 0.21320810387160827, 0.006329942286115164, 0.0408454151790234, 0.04768774561720457, 0.06932714317263089, 0.01507002003422453, 0.058949983299148356, 0.13830263908534857, 0.07355579775524834, 0.07866215097686358, 0.09925791706703113, 0.08782540684016671, 0.23220527093928767, 0.07711001832425624, 0.0892812685065223, 0.38112936784755824, 0.3791246876473908, 0.40582204054465554, 0.3857773044628413, 0.45380745339832507, 0.3511130441259658, 0.3960233048673045, 0.49032953769067844, 0.374288145035102, 0.14388027405849602, 0.12942947363167734, 0.13117305975818305, 0.13458097266487257, 0.09275087090640222, 0.142590017839045, 0.09514732343041321, 0.14201265623296477, 0.1363037323866032, 0.1881054781017396, 0.22175352045867114, 0.2352379259845233, 0.19162083935687246, 0.18566123408520985, 0.28341720972056184, 0.150869752013706, 0.26114403922756324, 0.23964896982778983, 0.2892661331500287, 0.31216448881451864, 0.19224685903954963, 0.30230488016580603, 0.24543648198411028, 0.270713683773416, 0.3144342651902199, 0.3505383136553717, 0.3841429265283772, 0.2373407718656827, 0.22606120658117168, 0.24011965592470697, 0.28081323640768496, 0.19557053084212872, 0.32111781386583915, 0.20653956858087374, 0.2020912293048841, 0.16061233326350344, 0.23601122133864405, 0.2128948680819156, 0.24133011645079272, 0.21893976446419494, 0.195051958548366, 0.2257433475778614, 0.23058643446213545, 0.22233842979224405, 0.19897722951041097, 0.1986928568475429, 0.22146370302666352, 0.1944665364951611, 0.2549625527152044, 0.3904860842168262, 0.22495175908641984, 0.21951850647982307, 0.20000968174975275, 0.18439427616719473, 0.17256152940605063, 0.17879858073254928, 0.189720376203943, 0.20098978448355198, 0.20034919215257418, 0.20200584717928038, 0.1654275002249258, 0.5023365265750434, 0.16034442097578105, 0.41133685297708766, 0.24614457595854644, 0.1907679238539277, 0.395833810398431, 0.20948280541306208, 0.21061597852296188, 0.2705714997234482, 0.10521404759458763, 0.23335096190384008, 0.21539150424011855, 0.2032796455983874, 0.20982688023304774, 0.23950927285918222, 0.21996602943327426, 0.20021716366414632, 0.18297956569002694, 0.20105851833449495, 0.20475458816045577, 0.09657762008916726, 0.0773894744002871, 0.08422488874330125, 0.07929629720410303, 0.09868497510933216, 0.07582357926447125, 0.07349550681470807, 0.08115061702140502, 0.07323553748209666]}, "mutation_prompt": null}
{"id": "0c517911-f6f1-4f76-a2b7-2c7f58cc2e03", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        # Initial Harmony Memory Evaluation\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Hybrid Harmony Search and Differential Evolution with Adaptive Parameter Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aac0d41-2e43-4986-adcf-6981a847437b", "metadata": {"aucs": [0.7490627783757097, 0.5509776204906978, 0.5794577505462772, 0.5588015895960385, 0.5722289138423344, 0.5246241094424888, 0.5850216720984676, 0.5789381242168419, 0.5032944881482874, 0.34282660159475176, 0.33916233489682923, 0.2297174552395812, 0.06382138554672945, 0.18123936070381408, 0.22037708451991822, 0.23643368675404242, 0.08719689050802804, 0.09893306516488753, 0.2597578496367402, 0.34043110668301413, 0.30055818763411357, 0.39849975280905914, 0.29277441323708464, 0.24479033564505748, 0.3217367556925307, 0.44202841578739827, 0.2222307678839177, 0.18660435690423927, 0.17774302238695217, 0.24949670508659916, 0.17847990630416555, 0.21123350539661723, 0.2427636578028658, 0.17188013808456615, 0.22426458713040343, 0.24927657426371075, 0.9741946557975136, 0.9619795196486945, 0.9761027984312453, 0.9811200816010173, 0.9748230941550954, 0.9621768762313634, 0.9761144316509079, 0.948242189762885, 0.9813555909335442, 0.2455688394495471, 0.22618545915536747, 0.22126659816248484, 0.25824158853257684, 0.3346359950378046, 0.2873586437993543, 0.25047146320448377, 0.25333089044397283, 0.24949338794306242, 0.2855306986971864, 0.16217465849842194, 0.2893368945576482, 0.2160413615340091, 0.19406628442387563, 0.3677526959021836, 0.2503348246751873, 0.22082536979462053, 0.24751980648488325, 0.225555400935607, 0.1440812516788259, 0.2851375983391551, 0.15319613344963656, 0.19089005065663944, 0.22520853779098993, 0.1833481112848122, 0.1468185494973384, 0.3165249523704189, 0.13381692675440338, 0.12890644546789498, 0.1307479908539868, 0.14624741331833957, 0.21646206481246544, 0.18866188601602796, 0.18688760507861235, 0.13186471203205985, 0.13497011912853019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050713436582423554, 0.052838579501239824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032514855295138645, 0.06626168879388838, 0.07337900423539756, 0.10869200581552885, 0.07620096438107304, 0.04330143325616753, 0.02960574559284146, 0.20715600765887088, 0.1463210338411649, 0.0598959314402866, 0.1791523779803692, 0.026422317366489367, 0.05162618681343123, 0.21320810387160827, 0.006329942286115164, 0.0408454151790234, 0.04768774561720457, 0.06932714317263089, 0.01507002003422453, 0.058949983299148356, 0.13830263908534857, 0.07355579775524834, 0.07866215097686358, 0.09925791706703113, 0.08782540684016671, 0.23220527093928767, 0.07711001832425624, 0.0892812685065223, 0.38112936784755824, 0.3791246876473908, 0.40582204054465554, 0.3857773044628413, 0.45380745339832507, 0.3511130441259658, 0.3960233048673045, 0.49032953769067844, 0.374288145035102, 0.14388027405849602, 0.12942947363167734, 0.13117305975818305, 0.13458097266487257, 0.09275087090640222, 0.142590017839045, 0.09514732343041321, 0.14201265623296477, 0.1363037323866032, 0.1881054781017396, 0.22175352045867114, 0.2352379259845233, 0.19162083935687246, 0.18566123408520985, 0.28341720972056184, 0.150869752013706, 0.26114403922756324, 0.23964896982778983, 0.2892661331500287, 0.31216448881451864, 0.19224685903954963, 0.30230488016580603, 0.24543648198411028, 0.270713683773416, 0.3144342651902199, 0.3505383136553717, 0.3841429265283772, 0.2373407718656827, 0.22606120658117168, 0.24011965592470697, 0.28081323640768496, 0.19557053084212872, 0.32111781386583915, 0.20653956858087374, 0.2020912293048841, 0.16061233326350344, 0.23601122133864405, 0.2128948680819156, 0.24133011645079272, 0.21893976446419494, 0.195051958548366, 0.2257433475778614, 0.23058643446213545, 0.22233842979224405, 0.19897722951041097, 0.1986928568475429, 0.22146370302666352, 0.1944665364951611, 0.2549625527152044, 0.3904860842168262, 0.22495175908641984, 0.21951850647982307, 0.20000968174975275, 0.18439427616719473, 0.17256152940605063, 0.17879858073254928, 0.189720376203943, 0.20098978448355198, 0.20034919215257418, 0.20200584717928038, 0.1654275002249258, 0.5023365265750434, 0.16034442097578105, 0.41133685297708766, 0.24614457595854644, 0.1907679238539277, 0.395833810398431, 0.20948280541306208, 0.21061597852296188, 0.2705714997234482, 0.10521404759458763, 0.23335096190384008, 0.21539150424011855, 0.2032796455983874, 0.20982688023304774, 0.23950927285918222, 0.21996602943327426, 0.20021716366414632, 0.18297956569002694, 0.20105851833449495, 0.20475458816045577, 0.09657762008916726, 0.0773894744002871, 0.08422488874330125, 0.07929629720410303, 0.09868497510933216, 0.07582357926447125, 0.07349550681470807, 0.08115061702140502, 0.07323553748209666]}, "mutation_prompt": null}
{"id": "e4f96abc-e32d-4e5b-9f97-e6125af6411e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-1, 1)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        # Initial Harmony Memory Evaluation\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Hybrid Harmony Search and Differential Evolution with Adaptive Parameter Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7aac0d41-2e43-4986-adcf-6981a847437b", "metadata": {"aucs": [0.7490627783757097, 0.5509776204906978, 0.5794577505462772, 0.5588015895960385, 0.5722289138423344, 0.5246241094424888, 0.5850216720984676, 0.5789381242168419, 0.5032944881482874, 0.34282660159475176, 0.33916233489682923, 0.2297174552395812, 0.06382138554672945, 0.18123936070381408, 0.22037708451991822, 0.23643368675404242, 0.08719689050802804, 0.09893306516488753, 0.2597578496367402, 0.34043110668301413, 0.30055818763411357, 0.39849975280905914, 0.29277441323708464, 0.24479033564505748, 0.3217367556925307, 0.44202841578739827, 0.2222307678839177, 0.18660435690423927, 0.17774302238695217, 0.24949670508659916, 0.17847990630416555, 0.21123350539661723, 0.2427636578028658, 0.17188013808456615, 0.22426458713040343, 0.24927657426371075, 0.9741946557975136, 0.9619795196486945, 0.9761027984312453, 0.9811200816010173, 0.9748230941550954, 0.9621768762313634, 0.9761144316509079, 0.948242189762885, 0.9813555909335442, 0.2455688394495471, 0.22618545915536747, 0.22126659816248484, 0.25824158853257684, 0.3346359950378046, 0.2873586437993543, 0.25047146320448377, 0.25333089044397283, 0.24949338794306242, 0.2855306986971864, 0.16217465849842194, 0.2893368945576482, 0.2160413615340091, 0.19406628442387563, 0.3677526959021836, 0.2503348246751873, 0.22082536979462053, 0.24751980648488325, 0.225555400935607, 0.1440812516788259, 0.2851375983391551, 0.15319613344963656, 0.19089005065663944, 0.22520853779098993, 0.1833481112848122, 0.1468185494973384, 0.3165249523704189, 0.13381692675440338, 0.12890644546789498, 0.1307479908539868, 0.14624741331833957, 0.21646206481246544, 0.18866188601602796, 0.18688760507861235, 0.13186471203205985, 0.13497011912853019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050713436582423554, 0.052838579501239824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032514855295138645, 0.06626168879388838, 0.07337900423539756, 0.10869200581552885, 0.07620096438107304, 0.04330143325616753, 0.02960574559284146, 0.20715600765887088, 0.1463210338411649, 0.0598959314402866, 0.1791523779803692, 0.026422317366489367, 0.05162618681343123, 0.21320810387160827, 0.006329942286115164, 0.0408454151790234, 0.04768774561720457, 0.06932714317263089, 0.01507002003422453, 0.058949983299148356, 0.13830263908534857, 0.07355579775524834, 0.07866215097686358, 0.09925791706703113, 0.08782540684016671, 0.23220527093928767, 0.07711001832425624, 0.0892812685065223, 0.38112936784755824, 0.3791246876473908, 0.40582204054465554, 0.3857773044628413, 0.45380745339832507, 0.3511130441259658, 0.3960233048673045, 0.49032953769067844, 0.374288145035102, 0.14388027405849602, 0.12942947363167734, 0.13117305975818305, 0.13458097266487257, 0.09275087090640222, 0.142590017839045, 0.09514732343041321, 0.14201265623296477, 0.1363037323866032, 0.1881054781017396, 0.22175352045867114, 0.2352379259845233, 0.19162083935687246, 0.18566123408520985, 0.28341720972056184, 0.150869752013706, 0.26114403922756324, 0.23964896982778983, 0.2892661331500287, 0.31216448881451864, 0.19224685903954963, 0.30230488016580603, 0.24543648198411028, 0.270713683773416, 0.3144342651902199, 0.3505383136553717, 0.3841429265283772, 0.2373407718656827, 0.22606120658117168, 0.24011965592470697, 0.28081323640768496, 0.19557053084212872, 0.32111781386583915, 0.20653956858087374, 0.2020912293048841, 0.16061233326350344, 0.23601122133864405, 0.2128948680819156, 0.24133011645079272, 0.21893976446419494, 0.195051958548366, 0.2257433475778614, 0.23058643446213545, 0.22233842979224405, 0.19897722951041097, 0.1986928568475429, 0.22146370302666352, 0.1944665364951611, 0.2549625527152044, 0.3904860842168262, 0.22495175908641984, 0.21951850647982307, 0.20000968174975275, 0.18439427616719473, 0.17256152940605063, 0.17879858073254928, 0.189720376203943, 0.20098978448355198, 0.20034919215257418, 0.20200584717928038, 0.1654275002249258, 0.5023365265750434, 0.16034442097578105, 0.41133685297708766, 0.24614457595854644, 0.1907679238539277, 0.395833810398431, 0.20948280541306208, 0.21061597852296188, 0.2705714997234482, 0.10521404759458763, 0.23335096190384008, 0.21539150424011855, 0.2032796455983874, 0.20982688023304774, 0.23950927285918222, 0.21996602943327426, 0.20021716366414632, 0.18297956569002694, 0.20105851833449495, 0.20475458816045577, 0.09657762008916726, 0.0773894744002871, 0.08422488874330125, 0.07929629720410303, 0.09868497510933216, 0.07582357926447125, 0.07349550681470807, 0.08115061702140502, 0.07323553748209666]}, "mutation_prompt": null}
{"id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced Hybrid Search Algorithm with Dynamic Parameter Adjustments for Improved Convergence.", "configspace": "", "generation": 4, "fitness": 0.2569293723365963, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "7aac0d41-2e43-4986-adcf-6981a847437b", "metadata": {"aucs": [0.6585213984531604, 0.6249963296983847, 0.8440525973833641, 0.6349177153924226, 0.7136278052263112, 0.5858113079532068, 0.6792025022884406, 0.6655668613445171, 0.5975658349014221, 0.14216273273860502, 0.17850067243042755, 0.15371092793538976, 0.21469979707046216, 0.361934021665549, 0.24175790915467843, 0.3515981811521969, 0.3208938349391347, 0.14376703679369363, 0.18308934834524548, 0.1800280715536159, 0.4018893886458196, 0.32408441341676986, 0.32872689285360834, 0.3187215364560322, 0.27144578268146446, 0.3884866237657253, 0.16992389672934916, 0.18225232025642624, 0.16277203289352604, 0.26136208237718206, 0.3045589295124689, 0.18396042468820883, 0.15370970036247655, 0.29606336081430207, 0.1702413680679361, 0.27068394171804544, 0.9548681438863654, 0.9646316892551403, 0.9481177796578306, 0.9698533295393509, 0.9709344371637253, 0.9597418793241368, 0.9523287627111281, 0.9579570561482854, 0.9664387416826445, 0.35153976602470893, 0.3105574880656423, 0.28288406609734384, 0.28497554670118097, 0.26958835856717556, 0.33995165672231187, 0.298054967496576, 0.27572523875048305, 0.29330324217978687, 0.2319428718526978, 0.1547429826597665, 0.212366991407426, 0.2226886123256827, 0.19542945647127685, 0.3573384900791715, 0.34134697613258536, 0.1772360096646084, 0.24076777270846883, 0.1529391612079869, 0.15704143960094463, 0.16881475381675826, 0.15578444059445973, 0.17581325501393497, 0.258616403882576, 0.1727149609042835, 0.17019182069103445, 0.1416770297804837, 0.13426642234718678, 0.13408909093856858, 0.2933443090461417, 0.3109424971380844, 0.1387088980571276, 0.16022151929219675, 0.1940231025912248, 9.999999999998899e-05, 0.1844194057854306, 9.999999999998899e-05, 0.0182542443760223, 9.999999999998899e-05, 9.999999999998899e-05, 0.030652600237980887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13094626882584415, 0.06756231438704385, 0.07332673747813279, 0.08466982414294688, 0.13426503007711998, 0.05210664301482104, 0.14131782894918632, 0.13321236461812713, 0.08704473804315827, 0.07651051140531162, 0.13514637606031865, 0.07008672417694961, 0.03742989510759176, 0.042460873997152704, 0.008093617704006295, 0.10815817578950604, 0.10136706415402463, 0.01899120441943014, 0.06719483825421046, 0.14866870568850832, 0.1334250790973559, 0.045028733216225025, 0.06889838530159809, 0.03669272727621209, 0.14753514438551796, 0.09235377904559006, 0.08450011418774739, 0.3649572061496077, 0.44781949955977307, 0.4189460166854406, 0.4067318698775034, 0.44015436206795466, 0.4845249776213334, 0.4079664734506593, 0.41762738463416416, 0.3623543191138171, 0.07096954071888772, 0.07054050643022403, 0.08676361899382723, 0.1575060552166, 0.14391990505123808, 0.12933492259429857, 0.12823770608502405, 0.15886578771608129, 0.09610174309460195, 0.35979399564938597, 0.23256776155709502, 0.30745724967097854, 0.17756290130727792, 0.17590165565137306, 0.198049911168257, 0.23347490434964135, 0.1607922746568764, 0.1656457264799408, 0.28296339889916655, 0.32544575245258045, 0.3474776087238809, 0.32145166507072476, 0.2218884769651165, 0.29804471635766405, 0.2692944863766972, 0.23552966486606264, 0.40948615095281926, 0.1856366027765589, 0.24193666596630092, 0.23781421798527702, 0.2930168861486251, 0.24038961852226626, 0.31661368486274966, 0.2871705130109937, 0.15092990765102565, 0.3235598796929223, 0.26265050177411886, 0.2344392734074522, 0.16639090337566964, 0.19822232941489903, 0.23318929889838447, 0.2454262490295449, 0.23917769875663897, 0.2363875892775511, 0.20095604589529836, 0.4228666573226777, 0.22907093037098547, 0.2544543036573388, 0.20648126146994294, 0.196666444131401, 0.22699595733239175, 0.19820371006249438, 0.19961302082400834, 0.19989818275699545, 0.17276595004420092, 0.5512008124727306, 0.18928472792696094, 0.7023506608496701, 0.7219355728792488, 0.201248840894501, 0.15935246939880876, 0.16571935623288336, 0.16032343692967965, 0.46117412628627685, 0.21296423005841958, 0.3466923466112434, 0.30696482807375225, 0.20935848723694161, 0.21345126527244418, 0.09486569048449056, 0.10509923886266714, 0.2816330986775081, 0.19286872252274578, 0.19150961921926601, 0.22527588842651758, 0.19857286048202683, 0.19518374073878564, 0.20421066188406645, 0.2206428641401993, 0.18923185233760154, 0.19523381409219243, 0.10624653264240291, 0.09176793429407826, 0.09588272014007249, 0.09930688276863531, 0.0988911294076733, 0.09727848300238073, 0.07702889142132152, 0.09641330078384347, 0.08959590757635016]}, "mutation_prompt": null}
{"id": "421472d1-eb62-43db-9368-ad071f7002ec", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced Hybrid Search Algorithm with Dynamic Parameter Adjustments for Improved Convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "metadata": {"aucs": [0.6585213984531604, 0.6249963296983847, 0.8440525973833641, 0.6349177153924226, 0.7136278052263112, 0.5858113079532068, 0.6792025022884406, 0.6655668613445171, 0.5975658349014221, 0.14216273273860502, 0.17850067243042755, 0.15371092793538976, 0.21469979707046216, 0.361934021665549, 0.24175790915467843, 0.3515981811521969, 0.3208938349391347, 0.14376703679369363, 0.18308934834524548, 0.1800280715536159, 0.4018893886458196, 0.32408441341676986, 0.32872689285360834, 0.3187215364560322, 0.27144578268146446, 0.3884866237657253, 0.16992389672934916, 0.18225232025642624, 0.16277203289352604, 0.26136208237718206, 0.3045589295124689, 0.18396042468820883, 0.15370970036247655, 0.29606336081430207, 0.1702413680679361, 0.27068394171804544, 0.9548681438863654, 0.9646316892551403, 0.9481177796578306, 0.9698533295393509, 0.9709344371637253, 0.9597418793241368, 0.9523287627111281, 0.9579570561482854, 0.9664387416826445, 0.35153976602470893, 0.3105574880656423, 0.28288406609734384, 0.28497554670118097, 0.26958835856717556, 0.33995165672231187, 0.298054967496576, 0.27572523875048305, 0.29330324217978687, 0.2319428718526978, 0.1547429826597665, 0.212366991407426, 0.2226886123256827, 0.19542945647127685, 0.3573384900791715, 0.34134697613258536, 0.1772360096646084, 0.24076777270846883, 0.1529391612079869, 0.15704143960094463, 0.16881475381675826, 0.15578444059445973, 0.17581325501393497, 0.258616403882576, 0.1727149609042835, 0.17019182069103445, 0.1416770297804837, 0.13426642234718678, 0.13408909093856858, 0.2933443090461417, 0.3109424971380844, 0.1387088980571276, 0.16022151929219675, 0.1940231025912248, 9.999999999998899e-05, 0.1844194057854306, 9.999999999998899e-05, 0.0182542443760223, 9.999999999998899e-05, 9.999999999998899e-05, 0.030652600237980887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13094626882584415, 0.06756231438704385, 0.07332673747813279, 0.08466982414294688, 0.13426503007711998, 0.05210664301482104, 0.14131782894918632, 0.13321236461812713, 0.08704473804315827, 0.07651051140531162, 0.13514637606031865, 0.07008672417694961, 0.03742989510759176, 0.042460873997152704, 0.008093617704006295, 0.10815817578950604, 0.10136706415402463, 0.01899120441943014, 0.06719483825421046, 0.14866870568850832, 0.1334250790973559, 0.045028733216225025, 0.06889838530159809, 0.03669272727621209, 0.14753514438551796, 0.09235377904559006, 0.08450011418774739, 0.3649572061496077, 0.44781949955977307, 0.4189460166854406, 0.4067318698775034, 0.44015436206795466, 0.4845249776213334, 0.4079664734506593, 0.41762738463416416, 0.3623543191138171, 0.07096954071888772, 0.07054050643022403, 0.08676361899382723, 0.1575060552166, 0.14391990505123808, 0.12933492259429857, 0.12823770608502405, 0.15886578771608129, 0.09610174309460195, 0.35979399564938597, 0.23256776155709502, 0.30745724967097854, 0.17756290130727792, 0.17590165565137306, 0.198049911168257, 0.23347490434964135, 0.1607922746568764, 0.1656457264799408, 0.28296339889916655, 0.32544575245258045, 0.3474776087238809, 0.32145166507072476, 0.2218884769651165, 0.29804471635766405, 0.2692944863766972, 0.23552966486606264, 0.40948615095281926, 0.1856366027765589, 0.24193666596630092, 0.23781421798527702, 0.2930168861486251, 0.24038961852226626, 0.31661368486274966, 0.2871705130109937, 0.15092990765102565, 0.3235598796929223, 0.26265050177411886, 0.2344392734074522, 0.16639090337566964, 0.19822232941489903, 0.23318929889838447, 0.2454262490295449, 0.23917769875663897, 0.2363875892775511, 0.20095604589529836, 0.4228666573226777, 0.22907093037098547, 0.2544543036573388, 0.20648126146994294, 0.196666444131401, 0.22699595733239175, 0.19820371006249438, 0.19961302082400834, 0.19989818275699545, 0.17276595004420092, 0.5512008124727306, 0.18928472792696094, 0.7023506608496701, 0.7219355728792488, 0.201248840894501, 0.15935246939880876, 0.16571935623288336, 0.16032343692967965, 0.46117412628627685, 0.21296423005841958, 0.3466923466112434, 0.30696482807375225, 0.20935848723694161, 0.21345126527244418, 0.09486569048449056, 0.10509923886266714, 0.2816330986775081, 0.19286872252274578, 0.19150961921926601, 0.22527588842651758, 0.19857286048202683, 0.19518374073878564, 0.20421066188406645, 0.2206428641401993, 0.18923185233760154, 0.19523381409219243, 0.10624653264240291, 0.09176793429407826, 0.09588272014007249, 0.09930688276863531, 0.0988911294076733, 0.09727848300238073, 0.07702889142132152, 0.09641330078384347, 0.08959590757635016]}, "mutation_prompt": null}
{"id": "26b1a7bc-c7db-4185-999f-217f54bee355", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced Hybrid Search Algorithm with Dynamic Parameter Adjustments for Improved Convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "metadata": {"aucs": [0.6585213984531604, 0.6249963296983847, 0.8440525973833641, 0.6349177153924226, 0.7136278052263112, 0.5858113079532068, 0.6792025022884406, 0.6655668613445171, 0.5975658349014221, 0.14216273273860502, 0.17850067243042755, 0.15371092793538976, 0.21469979707046216, 0.361934021665549, 0.24175790915467843, 0.3515981811521969, 0.3208938349391347, 0.14376703679369363, 0.18308934834524548, 0.1800280715536159, 0.4018893886458196, 0.32408441341676986, 0.32872689285360834, 0.3187215364560322, 0.27144578268146446, 0.3884866237657253, 0.16992389672934916, 0.18225232025642624, 0.16277203289352604, 0.26136208237718206, 0.3045589295124689, 0.18396042468820883, 0.15370970036247655, 0.29606336081430207, 0.1702413680679361, 0.27068394171804544, 0.9548681438863654, 0.9646316892551403, 0.9481177796578306, 0.9698533295393509, 0.9709344371637253, 0.9597418793241368, 0.9523287627111281, 0.9579570561482854, 0.9664387416826445, 0.35153976602470893, 0.3105574880656423, 0.28288406609734384, 0.28497554670118097, 0.26958835856717556, 0.33995165672231187, 0.298054967496576, 0.27572523875048305, 0.29330324217978687, 0.2319428718526978, 0.1547429826597665, 0.212366991407426, 0.2226886123256827, 0.19542945647127685, 0.3573384900791715, 0.34134697613258536, 0.1772360096646084, 0.24076777270846883, 0.1529391612079869, 0.15704143960094463, 0.16881475381675826, 0.15578444059445973, 0.17581325501393497, 0.258616403882576, 0.1727149609042835, 0.17019182069103445, 0.1416770297804837, 0.13426642234718678, 0.13408909093856858, 0.2933443090461417, 0.3109424971380844, 0.1387088980571276, 0.16022151929219675, 0.1940231025912248, 9.999999999998899e-05, 0.1844194057854306, 9.999999999998899e-05, 0.0182542443760223, 9.999999999998899e-05, 9.999999999998899e-05, 0.030652600237980887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13094626882584415, 0.06756231438704385, 0.07332673747813279, 0.08466982414294688, 0.13426503007711998, 0.05210664301482104, 0.14131782894918632, 0.13321236461812713, 0.08704473804315827, 0.07651051140531162, 0.13514637606031865, 0.07008672417694961, 0.03742989510759176, 0.042460873997152704, 0.008093617704006295, 0.10815817578950604, 0.10136706415402463, 0.01899120441943014, 0.06719483825421046, 0.14866870568850832, 0.1334250790973559, 0.045028733216225025, 0.06889838530159809, 0.03669272727621209, 0.14753514438551796, 0.09235377904559006, 0.08450011418774739, 0.3649572061496077, 0.44781949955977307, 0.4189460166854406, 0.4067318698775034, 0.44015436206795466, 0.4845249776213334, 0.4079664734506593, 0.41762738463416416, 0.3623543191138171, 0.07096954071888772, 0.07054050643022403, 0.08676361899382723, 0.1575060552166, 0.14391990505123808, 0.12933492259429857, 0.12823770608502405, 0.15886578771608129, 0.09610174309460195, 0.35979399564938597, 0.23256776155709502, 0.30745724967097854, 0.17756290130727792, 0.17590165565137306, 0.198049911168257, 0.23347490434964135, 0.1607922746568764, 0.1656457264799408, 0.28296339889916655, 0.32544575245258045, 0.3474776087238809, 0.32145166507072476, 0.2218884769651165, 0.29804471635766405, 0.2692944863766972, 0.23552966486606264, 0.40948615095281926, 0.1856366027765589, 0.24193666596630092, 0.23781421798527702, 0.2930168861486251, 0.24038961852226626, 0.31661368486274966, 0.2871705130109937, 0.15092990765102565, 0.3235598796929223, 0.26265050177411886, 0.2344392734074522, 0.16639090337566964, 0.19822232941489903, 0.23318929889838447, 0.2454262490295449, 0.23917769875663897, 0.2363875892775511, 0.20095604589529836, 0.4228666573226777, 0.22907093037098547, 0.2544543036573388, 0.20648126146994294, 0.196666444131401, 0.22699595733239175, 0.19820371006249438, 0.19961302082400834, 0.19989818275699545, 0.17276595004420092, 0.5512008124727306, 0.18928472792696094, 0.7023506608496701, 0.7219355728792488, 0.201248840894501, 0.15935246939880876, 0.16571935623288336, 0.16032343692967965, 0.46117412628627685, 0.21296423005841958, 0.3466923466112434, 0.30696482807375225, 0.20935848723694161, 0.21345126527244418, 0.09486569048449056, 0.10509923886266714, 0.2816330986775081, 0.19286872252274578, 0.19150961921926601, 0.22527588842651758, 0.19857286048202683, 0.19518374073878564, 0.20421066188406645, 0.2206428641401993, 0.18923185233760154, 0.19523381409219243, 0.10624653264240291, 0.09176793429407826, 0.09588272014007249, 0.09930688276863531, 0.0988911294076733, 0.09727848300238073, 0.07702889142132152, 0.09641330078384347, 0.08959590757635016]}, "mutation_prompt": null}
{"id": "543a31ae-edfe-45f5-9159-7558ab8b6b10", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced Hybrid Search Algorithm with Dynamic Parameter Adjustments for Improved Convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "metadata": {"aucs": [0.6585213984531604, 0.6249963296983847, 0.8440525973833641, 0.6349177153924226, 0.7136278052263112, 0.5858113079532068, 0.6792025022884406, 0.6655668613445171, 0.5975658349014221, 0.14216273273860502, 0.17850067243042755, 0.15371092793538976, 0.21469979707046216, 0.361934021665549, 0.24175790915467843, 0.3515981811521969, 0.3208938349391347, 0.14376703679369363, 0.18308934834524548, 0.1800280715536159, 0.4018893886458196, 0.32408441341676986, 0.32872689285360834, 0.3187215364560322, 0.27144578268146446, 0.3884866237657253, 0.16992389672934916, 0.18225232025642624, 0.16277203289352604, 0.26136208237718206, 0.3045589295124689, 0.18396042468820883, 0.15370970036247655, 0.29606336081430207, 0.1702413680679361, 0.27068394171804544, 0.9548681438863654, 0.9646316892551403, 0.9481177796578306, 0.9698533295393509, 0.9709344371637253, 0.9597418793241368, 0.9523287627111281, 0.9579570561482854, 0.9664387416826445, 0.35153976602470893, 0.3105574880656423, 0.28288406609734384, 0.28497554670118097, 0.26958835856717556, 0.33995165672231187, 0.298054967496576, 0.27572523875048305, 0.29330324217978687, 0.2319428718526978, 0.1547429826597665, 0.212366991407426, 0.2226886123256827, 0.19542945647127685, 0.3573384900791715, 0.34134697613258536, 0.1772360096646084, 0.24076777270846883, 0.1529391612079869, 0.15704143960094463, 0.16881475381675826, 0.15578444059445973, 0.17581325501393497, 0.258616403882576, 0.1727149609042835, 0.17019182069103445, 0.1416770297804837, 0.13426642234718678, 0.13408909093856858, 0.2933443090461417, 0.3109424971380844, 0.1387088980571276, 0.16022151929219675, 0.1940231025912248, 9.999999999998899e-05, 0.1844194057854306, 9.999999999998899e-05, 0.0182542443760223, 9.999999999998899e-05, 9.999999999998899e-05, 0.030652600237980887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13094626882584415, 0.06756231438704385, 0.07332673747813279, 0.08466982414294688, 0.13426503007711998, 0.05210664301482104, 0.14131782894918632, 0.13321236461812713, 0.08704473804315827, 0.07651051140531162, 0.13514637606031865, 0.07008672417694961, 0.03742989510759176, 0.042460873997152704, 0.008093617704006295, 0.10815817578950604, 0.10136706415402463, 0.01899120441943014, 0.06719483825421046, 0.14866870568850832, 0.1334250790973559, 0.045028733216225025, 0.06889838530159809, 0.03669272727621209, 0.14753514438551796, 0.09235377904559006, 0.08450011418774739, 0.3649572061496077, 0.44781949955977307, 0.4189460166854406, 0.4067318698775034, 0.44015436206795466, 0.4845249776213334, 0.4079664734506593, 0.41762738463416416, 0.3623543191138171, 0.07096954071888772, 0.07054050643022403, 0.08676361899382723, 0.1575060552166, 0.14391990505123808, 0.12933492259429857, 0.12823770608502405, 0.15886578771608129, 0.09610174309460195, 0.35979399564938597, 0.23256776155709502, 0.30745724967097854, 0.17756290130727792, 0.17590165565137306, 0.198049911168257, 0.23347490434964135, 0.1607922746568764, 0.1656457264799408, 0.28296339889916655, 0.32544575245258045, 0.3474776087238809, 0.32145166507072476, 0.2218884769651165, 0.29804471635766405, 0.2692944863766972, 0.23552966486606264, 0.40948615095281926, 0.1856366027765589, 0.24193666596630092, 0.23781421798527702, 0.2930168861486251, 0.24038961852226626, 0.31661368486274966, 0.2871705130109937, 0.15092990765102565, 0.3235598796929223, 0.26265050177411886, 0.2344392734074522, 0.16639090337566964, 0.19822232941489903, 0.23318929889838447, 0.2454262490295449, 0.23917769875663897, 0.2363875892775511, 0.20095604589529836, 0.4228666573226777, 0.22907093037098547, 0.2544543036573388, 0.20648126146994294, 0.196666444131401, 0.22699595733239175, 0.19820371006249438, 0.19961302082400834, 0.19989818275699545, 0.17276595004420092, 0.5512008124727306, 0.18928472792696094, 0.7023506608496701, 0.7219355728792488, 0.201248840894501, 0.15935246939880876, 0.16571935623288336, 0.16032343692967965, 0.46117412628627685, 0.21296423005841958, 0.3466923466112434, 0.30696482807375225, 0.20935848723694161, 0.21345126527244418, 0.09486569048449056, 0.10509923886266714, 0.2816330986775081, 0.19286872252274578, 0.19150961921926601, 0.22527588842651758, 0.19857286048202683, 0.19518374073878564, 0.20421066188406645, 0.2206428641401993, 0.18923185233760154, 0.19523381409219243, 0.10624653264240291, 0.09176793429407826, 0.09588272014007249, 0.09930688276863531, 0.0988911294076733, 0.09727848300238073, 0.07702889142132152, 0.09641330078384347, 0.08959590757635016]}, "mutation_prompt": null}
{"id": "261fefc6-6c31-40d4-814e-3c560d9007de", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced Hybrid Search Algorithm with Dynamic Parameter Adjustments for Improved Convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "metadata": {"aucs": [0.6585213984531604, 0.6249963296983847, 0.8440525973833641, 0.6349177153924226, 0.7136278052263112, 0.5858113079532068, 0.6792025022884406, 0.6655668613445171, 0.5975658349014221, 0.14216273273860502, 0.17850067243042755, 0.15371092793538976, 0.21469979707046216, 0.361934021665549, 0.24175790915467843, 0.3515981811521969, 0.3208938349391347, 0.14376703679369363, 0.18308934834524548, 0.1800280715536159, 0.4018893886458196, 0.32408441341676986, 0.32872689285360834, 0.3187215364560322, 0.27144578268146446, 0.3884866237657253, 0.16992389672934916, 0.18225232025642624, 0.16277203289352604, 0.26136208237718206, 0.3045589295124689, 0.18396042468820883, 0.15370970036247655, 0.29606336081430207, 0.1702413680679361, 0.27068394171804544, 0.9548681438863654, 0.9646316892551403, 0.9481177796578306, 0.9698533295393509, 0.9709344371637253, 0.9597418793241368, 0.9523287627111281, 0.9579570561482854, 0.9664387416826445, 0.35153976602470893, 0.3105574880656423, 0.28288406609734384, 0.28497554670118097, 0.26958835856717556, 0.33995165672231187, 0.298054967496576, 0.27572523875048305, 0.29330324217978687, 0.2319428718526978, 0.1547429826597665, 0.212366991407426, 0.2226886123256827, 0.19542945647127685, 0.3573384900791715, 0.34134697613258536, 0.1772360096646084, 0.24076777270846883, 0.1529391612079869, 0.15704143960094463, 0.16881475381675826, 0.15578444059445973, 0.17581325501393497, 0.258616403882576, 0.1727149609042835, 0.17019182069103445, 0.1416770297804837, 0.13426642234718678, 0.13408909093856858, 0.2933443090461417, 0.3109424971380844, 0.1387088980571276, 0.16022151929219675, 0.1940231025912248, 9.999999999998899e-05, 0.1844194057854306, 9.999999999998899e-05, 0.0182542443760223, 9.999999999998899e-05, 9.999999999998899e-05, 0.030652600237980887, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13094626882584415, 0.06756231438704385, 0.07332673747813279, 0.08466982414294688, 0.13426503007711998, 0.05210664301482104, 0.14131782894918632, 0.13321236461812713, 0.08704473804315827, 0.07651051140531162, 0.13514637606031865, 0.07008672417694961, 0.03742989510759176, 0.042460873997152704, 0.008093617704006295, 0.10815817578950604, 0.10136706415402463, 0.01899120441943014, 0.06719483825421046, 0.14866870568850832, 0.1334250790973559, 0.045028733216225025, 0.06889838530159809, 0.03669272727621209, 0.14753514438551796, 0.09235377904559006, 0.08450011418774739, 0.3649572061496077, 0.44781949955977307, 0.4189460166854406, 0.4067318698775034, 0.44015436206795466, 0.4845249776213334, 0.4079664734506593, 0.41762738463416416, 0.3623543191138171, 0.07096954071888772, 0.07054050643022403, 0.08676361899382723, 0.1575060552166, 0.14391990505123808, 0.12933492259429857, 0.12823770608502405, 0.15886578771608129, 0.09610174309460195, 0.35979399564938597, 0.23256776155709502, 0.30745724967097854, 0.17756290130727792, 0.17590165565137306, 0.198049911168257, 0.23347490434964135, 0.1607922746568764, 0.1656457264799408, 0.28296339889916655, 0.32544575245258045, 0.3474776087238809, 0.32145166507072476, 0.2218884769651165, 0.29804471635766405, 0.2692944863766972, 0.23552966486606264, 0.40948615095281926, 0.1856366027765589, 0.24193666596630092, 0.23781421798527702, 0.2930168861486251, 0.24038961852226626, 0.31661368486274966, 0.2871705130109937, 0.15092990765102565, 0.3235598796929223, 0.26265050177411886, 0.2344392734074522, 0.16639090337566964, 0.19822232941489903, 0.23318929889838447, 0.2454262490295449, 0.23917769875663897, 0.2363875892775511, 0.20095604589529836, 0.4228666573226777, 0.22907093037098547, 0.2544543036573388, 0.20648126146994294, 0.196666444131401, 0.22699595733239175, 0.19820371006249438, 0.19961302082400834, 0.19989818275699545, 0.17276595004420092, 0.5512008124727306, 0.18928472792696094, 0.7023506608496701, 0.7219355728792488, 0.201248840894501, 0.15935246939880876, 0.16571935623288336, 0.16032343692967965, 0.46117412628627685, 0.21296423005841958, 0.3466923466112434, 0.30696482807375225, 0.20935848723694161, 0.21345126527244418, 0.09486569048449056, 0.10509923886266714, 0.2816330986775081, 0.19286872252274578, 0.19150961921926601, 0.22527588842651758, 0.19857286048202683, 0.19518374073878564, 0.20421066188406645, 0.2206428641401993, 0.18923185233760154, 0.19523381409219243, 0.10624653264240291, 0.09176793429407826, 0.09588272014007249, 0.09930688276863531, 0.0988911294076733, 0.09727848300238073, 0.07702889142132152, 0.09641330078384347, 0.08959590757635016]}, "mutation_prompt": null}
{"id": "4774582e-710a-4831-a89c-f471a84947b0", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 9, "fitness": 0.26021608872464635, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "c6892c05-e1c7-4ed5-a892-1829ebc36ccc", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "bbfae354-8ca3-4cb5-878e-d708f355ead9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "a05011fd-0e90-4e5d-a74d-4325c91ce233", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "da7fea20-d278-4e42-b84f-21a06a768928", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "397fa502-c864-424e-bc70-e9997769870c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "00a80d4c-9825-42f9-9641-d5f93626dd90", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "233e6c5d-e9da-4f0c-b90b-c1fbd12c2f93", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "f72a5401-1220-4529-9a8c-3e91fd34f459", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n        self.adaptive_factors = np.random.uniform(0.4, 0.6, self.hms)  # Adaptive scaling factors\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        factor = self.adaptive_factors[candidates[0]]  # Use adaptive factor\n        mutant = np.clip(a + factor * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive scaling factors in Harmony Memory to enhance diversity and convergence.", "configspace": "", "generation": 16, "fitness": 0.24771405797569354, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6886143755953779, 0.7691010019708213, 0.6315077381294801, 0.6213839114053505, 0.6316437982617114, 0.6780543648025241, 0.7358551834784581, 0.8218971932376342, 0.6913210708310953, 0.25834722307667024, 0.16682134288257966, 0.27339791144964387, 0.3634341152347367, 0.15706165818858808, 0.2015194686904861, 0.16641528854723986, 0.26331198952471246, 0.16309863160914773, 0.40295497993946183, 0.14175000887770017, 0.2760580746633283, 0.20845148088790977, 0.16108940202011013, 0.18458306931324564, 0.15999610540151843, 0.16779307528721732, 0.17517663584829002, 0.17566970849194807, 0.1745550571599782, 0.17292294275085873, 0.5016371615591246, 0.1970358536863951, 0.17220770467844393, 0.17738967792156624, 0.17860017806279505, 0.12946819532048737, 0.9659797123617502, 0.9577916238137235, 0.9523544198451243, 0.967844311164528, 0.9703645823548945, 0.9550413894351533, 0.9681783035671452, 0.9671950191162161, 0.9674496883977562, 0.30673923666012715, 0.3230322773176485, 0.2767947352615481, 0.3118061515717936, 0.20063371888042525, 0.3882792210405749, 0.30006683043672977, 0.2934577957935385, 0.2844231108589501, 0.1776874023742968, 0.09631910340958438, 0.1723297279475282, 0.9115725394210131, 0.18548961713158918, 0.20954206990429458, 0.21616111723492037, 0.1355203772376029, 0.3654268038171068, 0.2100638630621514, 0.25196020281872356, 0.14720656098724672, 0.257036640118263, 0.19932565287946902, 0.24872331851467533, 0.2192423911661977, 0.14766703543368365, 0.18067483834456521, 0.15396526339374372, 0.10475262315073086, 0.10111311570331849, 0.13372142106138674, 0.1300716423804581, 0.1392514976834176, 0.18874114205666714, 0.1414578944767544, 0.19274684053949953, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024892059264027933, 0.09692855809053003, 9.999999999998899e-05, 0.06824799786863567, 0.12496973868672978, 0.0975659016015592, 0.06309425378268696, 0.028312384318685102, 0.040745996115157834, 0.0864058791728397, 0.09396943971681826, 0.10778973858042595, 0.09956784638773208, 0.07386952726968554, 0.09911201156409466, 0.04158616364501888, 0.06174278738134198, 0.06185626739090899, 0.049595426436764845, 0.08269305400576998, 0.03163337591914428, 0.09121733167897561, 0.07251033024339248, 0.10578387100123054, 0.03386094755293689, 0.11636202659963968, 0.13170864520857373, 0.0872512391307273, 0.127893277325009, 0.08363145100693925, 0.40824278242493794, 0.4480424949299143, 0.46723009597946463, 0.39373985649453414, 0.39537241439486914, 0.3733053849334268, 0.5440422331459196, 0.4536050077319207, 0.40525828636675554, 0.09519795842839374, 0.10309354631507817, 0.07306207096779749, 0.13071545604141044, 0.13467432541567537, 0.08545221366005684, 0.09690133717011884, 0.10455762945194325, 0.1003533368203069, 0.2013741551368209, 0.1621525182546455, 0.275456639021082, 0.16456378922766834, 0.13313852310080543, 0.20284072978355938, 0.32391142144114216, 0.18939208213447234, 0.18878834642950393, 0.23034571035049878, 0.2992728969807982, 0.22282333649466168, 0.28776314986235485, 0.2881850394860409, 0.22798407920456176, 0.3319122527514363, 0.35809941146834734, 0.29209642212853304, 0.09509942442150354, 0.23019050567208144, 0.19779055771677123, 0.21136884639674702, 0.3001056141052292, 0.25150148082695756, 0.1669149207382974, 0.2629327265825433, 0.18421859927922968, 0.22294480372077985, 0.2386791430453301, 0.21888454559584525, 0.22787957245743273, 0.19399048662409968, 0.18678362769224055, 0.22422960439665174, 0.18480721283829693, 0.24740802403092998, 0.217027889190743, 0.22075352448260632, 0.21931023865477994, 0.25772303348870684, 0.37802114786788854, 0.22565328338301993, 0.2559233834297351, 0.2698333525104687, 0.19791933268309814, 0.18875340261816131, 0.5443610967235015, 0.18899085352359368, 0.6959159521879124, 0.20193184216938964, 0.14885052879191984, 0.16820525448055723, 0.1884737130917431, 0.17203738432668436, 0.37013226541139543, 0.16913000709033532, 0.1268630422071234, 0.1262714504158745, 0.30938771073657556, 0.2084917012438009, 0.21299225925012888, 0.21316367218485166, 0.09486942073190474, 0.18354926552076767, 0.21900317948967474, 0.18145565412789966, 0.18324736393868013, 0.18034712778759643, 0.1838837433057844, 0.20294839824892974, 0.19914636457335166, 0.17032885242950013, 0.09502215656010249, 0.09250064912523992, 0.08451925789288928, 0.11881688456995054, 0.10433097231463562, 0.11556264980267983, 0.09378025989116101, 0.09517127693070182, 0.0921331574342037]}, "mutation_prompt": null}
{"id": "5caf68c2-7627-4c23-8e46-232703012e3b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "3afbf440-0a74-4340-9c55-6aa680a98049", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "8385b22e-b148-42b1-be37-c3a91dc183b9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "929914ec-f8ab-4180-8e41-1a53a0f40686", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "4d0a5042-ee37-4fad-90c2-f51599228c0f", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Dynamic adjustment of crossover rate based on harmony memory fitness diversity\n        fitness_range = np.max(self.hm_fitness) - np.min(self.hm_fitness)\n        self.cr = 0.9 - 0.5 * (fitness_range / (np.abs(np.min(self.hm_fitness)) + 1e-9))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced exploration balance in Hybrid Harmony Differential Evolution by adjusting crossover rate dynamically based on fitness diversity.", "configspace": "", "generation": 21, "fitness": 0.2414157035363972, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.5834826027437627, 0.6155645421236191, 0.5997136192609599, 0.562258225234876, 0.6633924454723232, 0.6440081742772039, 0.6480516140464325, 0.5821140935809943, 0.7716829203052739, 0.24584195878656934, 0.21262820638867674, 0.3275876856537575, 0.22121436028198305, 0.27011261995119606, 0.14971891682929395, 0.06820549655789454, 0.42619097351453517, 0.18070863896544398, 0.19371261770585202, 0.2440260431813981, 0.271524392097821, 0.19918267530742395, 0.1628174694319129, 0.1762862046036786, 0.17683117931957282, 0.2880647986627479, 0.44659672170416487, 0.34697574361233097, 0.1645755419860716, 0.27828662513731406, 0.19116111225909682, 0.1659546308242068, 0.16846110669156755, 0.28751753911331746, 0.17403506040651262, 0.1744584465829928, 0.9497668237518321, 0.9542917253175062, 0.9799307747341616, 0.9689490245325809, 0.9564949619185589, 0.9499229094042085, 0.9615573712086385, 0.9525382653164322, 0.9676549683360336, 0.3232931417647432, 0.2911891006682067, 0.28163552568447137, 0.3727316460444553, 0.2948565810646635, 0.28579458147364223, 0.2921444142869132, 0.2991543236084455, 0.2969175721405285, 0.20684528041795924, 0.09575333342753112, 0.2311492868883348, 0.19029158730487805, 0.27359495744762186, 0.2165220447014613, 0.2295071785689583, 0.1157378380397247, 0.2279025929058619, 0.16047277945993266, 0.1476719505259554, 0.16187144379761553, 0.2657683281398233, 0.20546192193175739, 0.13779979483929727, 0.14885789889413314, 0.14778103609991744, 0.16737495025872573, 0.186235388676515, 0.12730949943471892, 0.2748867088962851, 0.14375542455147172, 0.16301610850254877, 0.18092154511880942, 0.19011257545605387, 9.999999999998899e-05, 0.13170440597786404, 9.999999999998899e-05, 0.006384310931142112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09461177779244301, 0.030009042168833044, 0.0841499153432349, 0.1095318479023013, 0.09248620566805188, 0.022502237787191515, 0.06593882216444868, 0.06501259529776926, 0.0650158236656766, 0.031006154141094866, 0.008665725881689235, 0.07686826499557176, 0.024628080476842285, 0.08769475645987046, 0.002447125421846441, 0.04613911823081729, 0.02860633011342506, 0.030421469184369943, 0.0546003570885516, 0.09090273425561668, 0.06832300636691402, 0.06951124401451525, 0.14927701392254678, 0.11429403976287067, 0.09890554458421086, 0.07353957084748564, 0.08563402845290657, 0.4128005117651177, 0.39716787955885136, 0.3741427501736708, 0.3879321163602334, 0.4093755125005567, 0.38388557012642566, 0.5433764261538484, 0.4127428900927451, 0.42084371519503294, 0.1104281380483284, 0.11059651390530345, 0.052185499677807834, 0.12689116063693617, 0.09651675561090467, 0.08464804937864245, 0.06487359980666008, 0.08836293053223432, 0.0822986824518539, 0.3527432174234727, 0.13426338691457074, 0.17990373284771233, 0.31493469284143627, 0.27014085555745393, 0.2509546698185372, 0.23416366894389662, 0.15218323661233657, 0.20910021909928334, 0.23047717664453127, 0.20882139538997457, 0.23076754472751637, 0.21357450047247406, 0.18861549113036402, 0.28495890133857615, 0.31799888987772595, 0.3507684163921625, 0.40948615095281926, 0.10514887749800872, 0.16290306781564445, 0.11557784202491328, 0.38582950885450673, 0.1804319815980583, 0.3308342001965131, 0.23285494949751007, 0.16223826776792816, 0.1191500365137772, 0.20325215300339172, 0.2072959296935324, 0.25152550574527255, 0.22774616162781114, 0.23860587408099465, 0.25782766277178104, 0.2285310696179368, 0.2042180744178108, 0.21383037126623416, 0.22396849656712225, 0.20281467574753131, 0.2478430659422336, 0.19378876627133523, 0.2516774110464637, 0.2084505386458081, 0.20203882533251383, 0.2553014952625695, 0.20919951073183385, 0.17286665378178678, 0.2056763508897559, 0.16891558440377208, 0.6841326006896449, 0.20153610302287406, 0.11722546944850021, 0.16807954786147639, 0.16469719371399627, 0.15988495283469817, 0.38790385201487243, 0.21296423005841958, 0.49000811623949825, 0.28054707878155594, 0.4884350734231335, 0.2077647383851331, 0.25675248298726605, 0.30395271954630676, 0.2118745526344472, 0.23442514944849902, 0.19313260389849674, 0.19058236819770535, 0.18331956028169438, 0.19398086516173396, 0.18215953933372042, 0.21495780719772706, 0.18397050037326346, 0.18551419148528492, 0.09455271310697266, 0.08316618700901546, 0.08918290837721632, 0.0883505222342108, 0.09586298466171994, 0.0911471543400929, 0.09825164256044339, 0.08780696597799875, 0.08832011395504147]}, "mutation_prompt": null}
{"id": "6afd0d05-ccd7-4740-9447-36f80b05edfa", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "410f4c1a-a25f-4e0a-9317-c4a7e93d9cf7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Introduced slight variation in factor for enhanced exploration\n        self.f = 0.5 + 0.3 * np.random.rand()\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Improved Dynamic Adaptation Strategy for Enhanced Convergence in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6684918329596693, 0.6612171796630635, 0.6316547100492175, 0.6615275819197125, 0.6726316715525684, 0.6697238285843117, 0.7184133108333773, 0.6395299256504235, 0.6594552143104166, 0.29640099754774296, 0.2547240281817639, 0.2629830603481583, 0.33396842949632033, 0.13268468715626203, 0.3215724509366883, 0.39489915761196803, 0.16037179269930624, 0.26751562802256634, 0.157436863029509, 0.18574183699948044, 0.31698616769205923, 0.164073950917348, 0.1448463971431615, 0.1622276036456315, 0.1800391020841413, 0.17337123977601443, 0.1506338511972073, 0.15208819120725658, 0.1774275541103123, 0.17815552626805897, 0.17349524673484484, 0.2425219806117398, 0.14619140714777368, 0.1797451924666117, 0.15014104409445483, 0.16443781261471102, 0.9716617873215397, 0.9830102958840019, 0.9812211239801188, 0.9714449930746054, 0.9779965740300788, 0.9695257330155904, 0.9583006491955229, 0.9761038027111486, 0.9819369080760434, 0.3520977203502129, 0.3014073752543426, 0.2880328595911119, 0.2642296016086527, 0.3589027944183336, 0.29479585815283393, 0.3132662689875422, 0.281154078347604, 0.27164556676296703, 0.3967012469702812, 0.17551653313606186, 0.14597612924939896, 0.3375525174363425, 0.26801539213805325, 0.18010390295617196, 0.19884284523147044, 0.23831705695827166, 0.32631619134793943, 0.11145090667120161, 0.155596008434561, 0.15641154485313835, 0.1570021397232353, 0.18401526513399713, 0.12817849041034757, 0.32782489373513, 0.1547646691834338, 0.2193694919707032, 0.16516442645724605, 0.24552861944477478, 0.13363059041254, 0.1351309391908906, 0.1266490555783517, 0.13994084551687225, 0.1338214498329322, 0.14374109656480027, 0.1360951128824256, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282080104921476, 0.061251889780794766, 9.999999999998899e-05, 0.018071855491756272, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274256147371526, 0.10553693137583231, 0.09916134644338459, 0.14693600989448152, 0.13553683168127972, 0.03855968144997568, 0.0977588763684869, 0.1819939623335297, 0.07432304305968407, 0.10168154438908328, 0.0834442453576375, 0.1013392549019494, 0.07938017525500618, 0.05003854308574429, 0.29987293893439915, 0.009305764872556743, 0.0796359822911592, 0.06395915920117734, 0.03485892376159405, 0.15170151760503614, 0.05536889016312996, 0.0771353359177327, 0.1534408352332397, 0.03915105152848153, 0.1867203834809722, 0.10144242183298013, 0.18545640932026008, 0.158093076073211, 0.5161067664297903, 0.5487826865606309, 0.5041849215513854, 0.44540926959599625, 0.48451927718909193, 0.40297382818975347, 0.42181615369261394, 0.44339497005226336, 0.40873233764684, 0.05291457220638618, 0.14376231503350623, 0.15679638922696504, 0.11233489432546118, 0.09641485621518564, 0.12948829666713246, 0.10456307380623531, 0.14604166029153254, 0.10747727581136302, 0.19776678323923136, 0.2361855121923251, 0.24833593139747023, 0.17190336953887053, 0.22578969198473786, 0.3363363115498942, 0.24397064701035387, 0.1949422856044124, 0.23629687830605606, 0.24545327969836395, 0.3799500732494169, 0.40331006282183, 0.40411225585681354, 0.2675840969675062, 0.3579580787316504, 0.36486662295724615, 0.2927836246989659, 0.3401031778646526, 0.44247443774777895, 0.2748730725755859, 0.27738448641566493, 0.30096122267333125, 0.35996384799473036, 0.36087653994565416, 0.14815368396646844, 0.3188610655974893, 0.21768537411661226, 0.23936100720617626, 0.19705193754907246, 0.23716248553990038, 0.21628042067767939, 0.23711156422331636, 0.2030113152165538, 0.20981070887142073, 0.23504770212495418, 0.2397231520110683, 0.22712036721666973, 0.2328702282720274, 0.22715712623747963, 0.20313124413297134, 0.22816365872860322, 0.25686831517369757, 0.21617398292154433, 0.20961478168101855, 0.19502391926813012, 0.15943643730686985, 0.48542342321341525, 0.1881050004282694, 0.7343554089192752, 0.201349188656734, 0.16868137693453378, 0.17473017954519987, 0.5260993383690321, 0.19916881937990172, 0.42745599852849514, 0.2123856233085446, 0.42827781066352455, 0.11260549521176688, 0.29647230269361247, 0.20889419971300816, 0.11293019204714616, 0.15762752977248506, 0.2689544779266523, 0.19513467806321705, 0.1843865991436262, 0.20700063239301192, 0.1933711453334398, 0.2073459060938676, 0.18583669320293705, 0.17974952947653378, 0.19395566175878998, 0.2102289563574098, 0.07990113941632404, 0.08218506602709896, 0.08751406720629729, 0.09811523205153427, 0.10957006939147274, 0.12850996246888657, 0.07487261426612168, 0.08323155993326814, 0.09459492201961328]}, "mutation_prompt": null}
{"id": "39990905-9f6d-4e9e-a683-5348542ebc1a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Adaptive mutation scaling based on fitness diversity\n        fitness_range = np.max(self.hm_fitness) - np.min(self.hm_fitness)\n        self.f = 0.5 + (0.3 * np.random.rand() * fitness_range / (fitness_range + 1e-10))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced exploration through adaptive mutation scaling in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 24, "fitness": 0.2602787105359835, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "4774582e-710a-4831-a89c-f471a84947b0", "metadata": {"aucs": [0.6188183258423372, 0.661597069143422, 0.666630079427754, 0.6634179168318733, 0.6759069021987351, 0.6697702276950991, 0.7292791395470477, 0.6558352400654968, 0.6604544746930324, 0.2964108488371676, 0.25489092627980714, 0.2630142671850446, 0.333963364309932, 0.13454783170738305, 0.32158895592935954, 0.3999242147993898, 0.16036974858495867, 0.2677165290512594, 0.15743745733519587, 0.18589600198546952, 0.296396729255635, 0.16437631805985908, 0.14477196366651757, 0.16222710739888357, 0.18003941115248967, 0.17103239479199384, 0.15063617919269912, 0.15230187201777057, 0.17574664755424274, 0.17815528678624792, 0.1736413036014849, 0.2418905486225864, 0.14619203567846795, 0.17971512030335257, 0.15010523473366943, 0.1644369088080686, 0.9716617873210999, 0.9830102958839467, 0.9812211239801106, 0.9714449930745771, 0.9779965740299776, 0.9695257330141568, 0.9583006491954621, 0.9761038027111942, 0.9819369080760042, 0.34815009206166303, 0.3025710007349478, 0.2883016698393318, 0.26250897506572723, 0.35899521971930437, 0.2953510371685869, 0.31105116341464156, 0.27973324167522473, 0.2716455854326981, 0.3967012469702812, 0.16275968908341243, 0.14597612924939896, 0.3375525174363425, 0.2670359916689242, 0.18010419280077172, 0.20560681859344143, 0.23831705695827166, 0.3200321899931582, 0.11145080450401657, 0.155421057548761, 0.15649814349413904, 0.15707257249470163, 0.18401975132518034, 0.12860974420647453, 0.3278254667336187, 0.15476804843745595, 0.21936939764070518, 0.16518462176094673, 0.24552965228845702, 0.1336307429652055, 0.13511341979469893, 0.12651143765508166, 0.1399063767950398, 0.13381926140746148, 0.14372438130780574, 0.13608810163967067, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282079921282605, 0.06125220496526074, 9.999999999998899e-05, 0.018071857713674033, 9.999999999998899e-05, 9.999999999998899e-05, 0.0627425602427466, 0.10553696119139344, 0.0991585768810559, 0.14742896458966714, 0.13554194615496895, 0.0370379122918455, 0.09754540851861326, 0.18198954251850485, 0.07380862133478716, 0.10155212063611085, 0.08344587407449289, 0.10133925374310315, 0.0794097450613086, 0.050310852665828465, 0.299887605670344, 0.0028694179246444573, 0.07963598214974466, 0.06395916826696102, 0.03504537281512621, 0.15169659114781608, 0.05537413350442688, 0.07713531336369761, 0.15344285837110694, 0.03924426653057711, 0.18672039464294943, 0.1014424227379288, 0.18307430271242497, 0.15809325429911036, 0.5160899222259121, 0.5489256276997962, 0.5041883802942932, 0.4455658839912149, 0.48450978103178066, 0.4060959846278871, 0.42270511490853035, 0.44350693612477543, 0.4082098925881653, 0.05291459206008731, 0.1437095414007621, 0.15677400921858065, 0.11252851791660634, 0.09647163512116219, 0.12947980410755722, 0.10456352937815483, 0.146017432871985, 0.10747717312686522, 0.19776678195565478, 0.23362720585487606, 0.2483340449687953, 0.17189604098330802, 0.22578972389685403, 0.33634196610471856, 0.24397064677547764, 0.19494217284615345, 0.23629690734664432, 0.2454551993557348, 0.3799509183251064, 0.40331034603704863, 0.4041111746839572, 0.26758424649846724, 0.35795882661102496, 0.36482713224419794, 0.29278492334430395, 0.34010465971854753, 0.44247336800275505, 0.27487336584996025, 0.27738677213727825, 0.3009610422250365, 0.3599633783652141, 0.3608714624178406, 0.1481962781194559, 0.31885932556516583, 0.21768531689393, 0.2393610066058499, 0.19705193742298321, 0.23716300727967887, 0.21627254986625266, 0.2375799310772687, 0.20301131552220708, 0.20981070759829779, 0.23504770220011695, 0.23972315198886185, 0.22712076889120403, 0.23286873628215143, 0.22716121263707434, 0.2036937745800611, 0.22816125616012828, 0.25687718746336563, 0.21588133935279719, 0.2096154619090681, 0.19445435675619516, 0.15943578919291157, 0.4896809837470104, 0.1881051842050112, 0.7570153205828993, 0.20135051985666974, 0.16868125348560747, 0.1747309657669286, 0.5383403604316717, 0.1991798237474972, 0.4278119480288063, 0.2123892915323935, 0.4264733161640777, 0.11260617287157837, 0.2979790564987638, 0.20889424394164835, 0.11293017865810362, 0.1576275409278587, 0.26789913618583416, 0.19513467443433374, 0.18438659933070878, 0.20700063244973155, 0.19337114555035118, 0.20734590624377236, 0.18583621016893892, 0.1797495292197151, 0.19395566175256695, 0.21228851084418043, 0.08022752230624242, 0.08218489262255879, 0.0875137160170314, 0.09811523064884986, 0.10956558867527655, 0.12850995769045181, 0.07487245558796607, 0.0831173086463608, 0.09459492218408272]}, "mutation_prompt": null}
{"id": "0a6ab6fc-35af-4cda-acb8-2d87483ff8c8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Adaptive mutation scaling based on fitness diversity\n        fitness_range = np.max(self.hm_fitness) - np.min(self.hm_fitness)\n        self.f = 0.5 + (0.3 * np.random.rand() * fitness_range / (fitness_range + 1e-10))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced exploration through adaptive mutation scaling in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "39990905-9f6d-4e9e-a683-5348542ebc1a", "metadata": {"aucs": [0.6188183258423372, 0.661597069143422, 0.666630079427754, 0.6634179168318733, 0.6759069021987351, 0.6697702276950991, 0.7292791395470477, 0.6558352400654968, 0.6604544746930324, 0.2964108488371676, 0.25489092627980714, 0.2630142671850446, 0.333963364309932, 0.13454783170738305, 0.32158895592935954, 0.3999242147993898, 0.16036974858495867, 0.2677165290512594, 0.15743745733519587, 0.18589600198546952, 0.296396729255635, 0.16437631805985908, 0.14477196366651757, 0.16222710739888357, 0.18003941115248967, 0.17103239479199384, 0.15063617919269912, 0.15230187201777057, 0.17574664755424274, 0.17815528678624792, 0.1736413036014849, 0.2418905486225864, 0.14619203567846795, 0.17971512030335257, 0.15010523473366943, 0.1644369088080686, 0.9716617873210999, 0.9830102958839467, 0.9812211239801106, 0.9714449930745771, 0.9779965740299776, 0.9695257330141568, 0.9583006491954621, 0.9761038027111942, 0.9819369080760042, 0.34815009206166303, 0.3025710007349478, 0.2883016698393318, 0.26250897506572723, 0.35899521971930437, 0.2953510371685869, 0.31105116341464156, 0.27973324167522473, 0.2716455854326981, 0.3967012469702812, 0.16275968908341243, 0.14597612924939896, 0.3375525174363425, 0.2670359916689242, 0.18010419280077172, 0.20560681859344143, 0.23831705695827166, 0.3200321899931582, 0.11145080450401657, 0.155421057548761, 0.15649814349413904, 0.15707257249470163, 0.18401975132518034, 0.12860974420647453, 0.3278254667336187, 0.15476804843745595, 0.21936939764070518, 0.16518462176094673, 0.24552965228845702, 0.1336307429652055, 0.13511341979469893, 0.12651143765508166, 0.1399063767950398, 0.13381926140746148, 0.14372438130780574, 0.13608810163967067, 9.999999999998899e-05, 9.999999999998899e-05, 0.10282079921282605, 0.06125220496526074, 9.999999999998899e-05, 0.018071857713674033, 9.999999999998899e-05, 9.999999999998899e-05, 0.0627425602427466, 0.10553696119139344, 0.0991585768810559, 0.14742896458966714, 0.13554194615496895, 0.0370379122918455, 0.09754540851861326, 0.18198954251850485, 0.07380862133478716, 0.10155212063611085, 0.08344587407449289, 0.10133925374310315, 0.0794097450613086, 0.050310852665828465, 0.299887605670344, 0.0028694179246444573, 0.07963598214974466, 0.06395916826696102, 0.03504537281512621, 0.15169659114781608, 0.05537413350442688, 0.07713531336369761, 0.15344285837110694, 0.03924426653057711, 0.18672039464294943, 0.1014424227379288, 0.18307430271242497, 0.15809325429911036, 0.5160899222259121, 0.5489256276997962, 0.5041883802942932, 0.4455658839912149, 0.48450978103178066, 0.4060959846278871, 0.42270511490853035, 0.44350693612477543, 0.4082098925881653, 0.05291459206008731, 0.1437095414007621, 0.15677400921858065, 0.11252851791660634, 0.09647163512116219, 0.12947980410755722, 0.10456352937815483, 0.146017432871985, 0.10747717312686522, 0.19776678195565478, 0.23362720585487606, 0.2483340449687953, 0.17189604098330802, 0.22578972389685403, 0.33634196610471856, 0.24397064677547764, 0.19494217284615345, 0.23629690734664432, 0.2454551993557348, 0.3799509183251064, 0.40331034603704863, 0.4041111746839572, 0.26758424649846724, 0.35795882661102496, 0.36482713224419794, 0.29278492334430395, 0.34010465971854753, 0.44247336800275505, 0.27487336584996025, 0.27738677213727825, 0.3009610422250365, 0.3599633783652141, 0.3608714624178406, 0.1481962781194559, 0.31885932556516583, 0.21768531689393, 0.2393610066058499, 0.19705193742298321, 0.23716300727967887, 0.21627254986625266, 0.2375799310772687, 0.20301131552220708, 0.20981070759829779, 0.23504770220011695, 0.23972315198886185, 0.22712076889120403, 0.23286873628215143, 0.22716121263707434, 0.2036937745800611, 0.22816125616012828, 0.25687718746336563, 0.21588133935279719, 0.2096154619090681, 0.19445435675619516, 0.15943578919291157, 0.4896809837470104, 0.1881051842050112, 0.7570153205828993, 0.20135051985666974, 0.16868125348560747, 0.1747309657669286, 0.5383403604316717, 0.1991798237474972, 0.4278119480288063, 0.2123892915323935, 0.4264733161640777, 0.11260617287157837, 0.2979790564987638, 0.20889424394164835, 0.11293017865810362, 0.1576275409278587, 0.26789913618583416, 0.19513467443433374, 0.18438659933070878, 0.20700063244973155, 0.19337114555035118, 0.20734590624377236, 0.18583621016893892, 0.1797495292197151, 0.19395566175256695, 0.21228851084418043, 0.08022752230624242, 0.08218489262255879, 0.0875137160170314, 0.09811523064884986, 0.10956558867527655, 0.12850995769045181, 0.07487245558796607, 0.0831173086463608, 0.09459492218408272]}, "mutation_prompt": null}
{"id": "9e2c3de0-4e47-43ab-bd0d-aa8d20f324aa", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhancing exploration by incorporating dynamic parameter adjustment in Hybrid Harmony Differential Evolution.", "configspace": "", "generation": 26, "fitness": 0.26084451670881503, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "39990905-9f6d-4e9e-a683-5348542ebc1a", "metadata": {"aucs": [0.7196089575370611, 0.6254067442052389, 0.6711056257826671, 0.5260256531206605, 0.654339292880953, 0.604202476076252, 0.6635231999460977, 0.6254245800129101, 0.6037230124682542, 0.07488460102426509, 0.19032237182341827, 0.13024687358937714, 0.1387159329094233, 0.10863063892860159, 0.33276208815799757, 0.3435562519552261, 0.37328896387919075, 0.20007050332285325, 0.3795771992554602, 0.14438894541051195, 0.14615067645331237, 0.19537125785261755, 0.19107074541423963, 0.17906336594241912, 0.1838022322458882, 0.1806991531361375, 0.17446607780796553, 0.18179953823378792, 0.26004625001341597, 0.17559413163862758, 0.17094337137045446, 0.21437979975521404, 0.14488799348830994, 0.2995688814539468, 0.17337492734657367, 0.1334122722996357, 0.9581030990536532, 0.9585300036619695, 0.9774512842965524, 0.9624862463640254, 0.9697451202727853, 0.9791421164267171, 0.949254081410569, 0.9704218803023351, 0.9790515011635833, 0.2971700134141504, 0.2753599945610157, 0.28080662339886964, 0.3429243584273368, 0.3410127342990219, 0.3121661881850114, 0.30755775859620804, 0.3076675441918494, 0.2534442139969312, 0.23174636970268747, 0.08547149649805652, 0.2638752693750369, 0.28177706909015, 0.2218582676649935, 0.39183740008353884, 0.2655801255670621, 0.1686654818181491, 0.22141104901269582, 0.2642082270456213, 0.18273401825984326, 0.1612631511899899, 0.20678843767889088, 0.1530439944531412, 0.23982257021987385, 0.17455597104359644, 0.1891520242619501, 0.1363321531011299, 0.14981867881115885, 0.16806555546907276, 0.1329786294187093, 0.13585012112612005, 0.2441429767670492, 0.14138095919503835, 0.13125255157092375, 0.08038521672633236, 0.13960474729282846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052501070756634904, 0.016081443784568772, 9.999999999998899e-05, 9.999999999998899e-05, 0.05705126957114148, 0.06355995557948413, 0.16687495247377004, 0.17212397674931634, 0.03565903708939844, 0.09465078813834693, 0.17031392019019298, 0.11676307377639239, 0.1370779579809832, 0.06782326473279277, 0.02153464648534742, 0.21961807820994494, 0.09090598045330078, 0.1839302326548513, 0.11268455522267518, 0.07509159819965805, 0.08143916299049048, 0.13662734221220074, 0.15928443674925274, 0.04658639674529408, 0.0990405417181226, 0.03367007766660024, 0.22775018096621136, 0.13251613286263653, 0.12945664466777362, 0.12948904956239715, 0.1326542912928198, 0.45259213111804086, 0.5919580516894799, 0.37220296528119456, 0.4781243227207248, 0.5830748783809163, 0.517303245965095, 0.4296233943285337, 0.4247582663025299, 0.44061730888637585, 0.10442346950013892, 0.10198627470750676, 0.12271093969414759, 0.11866096028962925, 0.10279157534268812, 0.3202879843948241, 0.14246391332503006, 0.14413905786308623, 0.147490217149588, 0.3539691708796553, 0.40343399885693665, 0.35927829800421673, 0.18063250178393264, 0.2506664241052199, 0.23049689201150036, 0.2133784585797337, 0.20499746863257873, 0.2111962484611396, 0.3685051796773742, 0.25847955002875, 0.3124871020836488, 0.47235592899624457, 0.3106867683099567, 0.30297792467687146, 0.24164743795045573, 0.31859494923688414, 0.2913872383933631, 0.2975183787921636, 0.2717404449924492, 0.3733644779274502, 0.404403238217932, 0.17990458868432346, 0.25029762861996296, 0.20217288551570511, 0.13682040583015442, 0.27414491612762626, 0.1942573627272396, 0.20724236238297256, 0.20420106973312124, 0.22103944514080842, 0.21541903756409386, 0.21814531612678556, 0.21700792964064763, 0.20404988091790865, 0.19804059287541975, 0.21423259479296552, 0.37931613802039177, 0.2014745600344362, 0.2522689201665772, 0.23036395176774926, 0.2489754087256486, 0.21236669863998703, 0.2554495316602643, 0.22429217268770107, 0.17772813154105493, 0.2066058369544943, 0.7387787983576974, 0.17343576488949908, 0.20165512703704824, 0.2010690307416768, 0.9100734490352731, 0.15868023863315261, 0.16904467932745304, 0.5042702922305807, 0.2110530295226397, 0.4225182134967631, 0.4150515003335651, 0.1682696892350919, 0.21244457824025542, 0.11288641291335388, 0.15776885055586387, 0.33903965725463037, 0.19193237038513444, 0.19058142305257453, 0.18794289437346978, 0.1807430994218192, 0.18658113984199198, 0.2017778331174509, 0.21394455728038442, 0.170861739336591, 0.19701005791784687, 0.09615852673147707, 0.07317123203088727, 0.09475528884181261, 0.10410662247128055, 0.10600573451077377, 0.10965768718716773, 0.1394611323667737, 0.09549287187551558, 0.08917576145273798]}, "mutation_prompt": null}
{"id": "962e085f-f7ad-4404-82e3-835ee32bcba7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a decay mechanism in the Pitch Adjustment Rate (PAR) to gradually reduce randomness.", "configspace": "", "generation": 27, "fitness": 0.2630913950958812, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "9e2c3de0-4e47-43ab-bd0d-aa8d20f324aa", "metadata": {"aucs": [0.7670235345883205, 0.7368364222226688, 0.5943480553575251, 0.6816703874652288, 0.6864373881149218, 0.649544784610987, 0.5395090534153472, 0.5961813989353262, 0.6586659175591238, 0.24834480726207853, 0.4922012517476897, 0.21135307792308045, 0.3176552125464568, 0.4170153309083434, 0.30030949982924304, 0.1293635108286426, 0.3071929968806567, 0.23291357187773987, 0.2833959953813261, 0.1955742596713098, 0.19489778343098219, 0.22327534957922124, 0.19199923198736546, 0.35265429174296437, 0.21030534531439515, 0.3322826802825095, 0.1908040251830625, 0.1535203171950481, 0.29771205403550494, 0.16279915014494928, 0.21954006917838798, 0.18931002050437484, 0.17081919282100844, 0.18889750409148953, 0.18244042630377866, 0.18364789677722027, 0.975014160101352, 0.9634263049701661, 0.9714320109728429, 0.9745354661340592, 0.9646309529632177, 0.9792249039018774, 0.9637415020523383, 0.9710158606375257, 0.9788223069869155, 0.3184742094284493, 0.28080850094874255, 0.339778298078534, 0.37321010754313255, 0.2681604441538593, 0.2566414973656892, 0.3537878086723243, 0.261400004565464, 0.2761208349712966, 0.23189475825132588, 0.09148962031125485, 0.36360364251685073, 0.21646070437145148, 0.282515814759255, 0.3885643795367255, 0.16474139106293628, 0.15216741019054247, 0.15242920993929965, 0.4035180033131486, 0.2229583017297072, 0.17042418673869308, 0.19611836135438254, 0.15443904492292893, 0.3226153984661454, 0.15483996769444897, 0.1680061582041128, 0.14281178986083665, 0.16352737886609992, 0.18774577075173682, 0.13179133153687272, 0.13092597543644802, 0.28764892447435686, 0.16970470309398333, 0.1729281104035041, 0.072588019911495, 0.14783620317236223, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007319470454775212, 9.999999999998899e-05, 0.02595610615031896, 0.07986369605508792, 9.999999999998899e-05, 0.006883821103389365, 0.042657616500586304, 0.06895078021055179, 0.12517240557370857, 0.11423512422091575, 0.03083276912886046, 0.07393186859975498, 0.17743409259198362, 0.12339321258501279, 0.08437788122290135, 0.09762950997086917, 0.11704457292796344, 0.07370316740373672, 9.999999999998899e-05, 0.09480300255085983, 0.012605846564543888, 0.14737810537192164, 0.157675786374866, 0.32269309587157335, 0.08228663721655882, 0.04733840367759423, 0.10184300806516478, 0.03633068526987482, 0.19333228123542756, 0.11269515849922063, 0.08910798994329494, 0.14674940559939498, 0.135063587221405, 0.5208753841830204, 0.3846306707047985, 0.43616006077186953, 0.5567604446256591, 0.4808109195401826, 0.6010268881424039, 0.3725768254747188, 0.4271529258361969, 0.48805599311419856, 0.10875903775361384, 0.10032636690846408, 0.14856900415960972, 0.13236416904146098, 0.10610008274769955, 0.11042875163257682, 0.12687132934266243, 0.1316459467852028, 0.13994649896443456, 0.1423370364164579, 0.4784860328075987, 0.3087663773162769, 0.35524484209205565, 0.3501946924288487, 0.28732421236060124, 0.25815173518260326, 0.20157739173336564, 0.20515962737754012, 0.4487241488167236, 0.332340570692612, 0.31147609664056963, 0.40470693703027627, 0.3406344819414606, 0.27703414634957113, 0.25066304857759547, 0.3698686917209909, 0.41770345031027867, 0.2940707124620041, 0.2760421804799963, 0.2693036045327585, 0.23324208017152337, 0.180905194156195, 0.22930322943523895, 0.2378439346883211, 0.1396515129456204, 0.09110063383181422, 0.20698828378060152, 0.21430484624539714, 0.22628914105798348, 0.20129506476542303, 0.2504597952035277, 0.20523530419487868, 0.21418530418135118, 0.2204058414945098, 0.19110569746262762, 0.23156839523872264, 0.18743291946847307, 0.1876668584882356, 0.2087465784121605, 0.21214814746906963, 0.2187696790897935, 0.22941494212798574, 0.21165615923682413, 0.22483158844614837, 0.15895670136118822, 0.20902833619556782, 0.655554336117065, 0.1736044329169627, 0.2016763384390099, 0.20135002493923693, 0.615205864509194, 0.15865059845081908, 0.1690908362173783, 0.3460478673077194, 0.2118417153311647, 0.3749737109685275, 0.5145896530972685, 0.16831511737627536, 0.21226643816983193, 0.11282188456567133, 0.1577722542193436, 0.3020528598163611, 0.21395546984932456, 0.18708078089370694, 0.1703645960536896, 0.19675113651221476, 0.18617065460760374, 0.21023884843922835, 0.18033274199274585, 0.18565788166206232, 0.1825195035899475, 0.08523563569812664, 0.08166667091771684, 0.08499465620519353, 0.10112170271786491, 0.11733569682166212, 0.14030745073067408, 0.14743491154016197, 0.09602922967875549, 0.0810592584398957]}, "mutation_prompt": null}
{"id": "e0b1a711-b187-423c-abe5-d7063e217966", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.2631814711945471, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "962e085f-f7ad-4404-82e3-835ee32bcba7", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "116c22c9-2224-4b22-b9bb-69bc602f7e26", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "90e73795-d5c7-4b5a-a566-37ac455bce7f", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress and correlation\n        progress = (self.eval_count / self.budget)\n        correlation_factor = np.corrcoef(a, b)[0, 1] # Correlation-based adjustment\n        self.f = 0.5 + (0.1 * np.random.rand() * (1 - progress)) * (1 + correlation_factor)\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a correlation-based adjustment for DE scaling factor to improve precision in later stages.", "configspace": "", "generation": 30, "fitness": 0.2603724377539394, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.614798231610732, 0.6430018706067251, 0.6559598198829386, 0.7739127223614903, 0.6849213544321062, 0.5921192282956999, 0.5969343987264369, 0.6072627391754766, 0.6178781998496752, 0.1106129731708061, 0.5131211717262669, 0.2534272361569817, 0.26418000270674546, 0.31140659585054, 0.17045358401386712, 0.3037944835564145, 0.19857173262100813, 0.3584107137992387, 0.24764757795475545, 0.28008719677383276, 0.3835066359353817, 0.3993543808424438, 0.2627585777828124, 0.29394822559545486, 0.1706420071747562, 0.37055792387181463, 0.3292053148423667, 0.14866298103075037, 0.2686095678751903, 0.17137692779307145, 0.15057964297662363, 0.17227284583337055, 0.1711881025303441, 0.1745926838895513, 0.17969994077253837, 0.22121182152889085, 0.9780400440242448, 0.9523820673693579, 0.9763062978260293, 0.9635223929338025, 0.9673340610591735, 0.9714740750663663, 0.9617434243622458, 0.9702079027935888, 0.9783109027708414, 0.27626632840130005, 0.3485692154432021, 0.2849441432634908, 0.2724510422169305, 0.3102487000715145, 0.26806437032833774, 0.3185236787588701, 0.30096406448873647, 0.2764039322346876, 0.2448390006779736, 0.13671900685270444, 0.17128262165067953, 0.28388042421092163, 0.16268859317737805, 0.34357567205874506, 0.22470942394538262, 0.23879862267046204, 0.16976936799870668, 0.1759097299844018, 0.14880420645777725, 0.15321783718532478, 0.4297833862261583, 0.19544562972797208, 0.1523864118119227, 0.2428996527622227, 0.2780315438355484, 0.14537407311524353, 0.15914369803907868, 0.11949872760479197, 0.3740995782421842, 0.13537728958602524, 0.14652704730962085, 0.14750436741847262, 0.17721552128206708, 0.055494188993618465, 0.20479730546293817, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01604565488490184, 9.999999999998899e-05, 9.999999999998899e-05, 0.23583586234743692, 0.045004508373331364, 0.06186679767211878, 0.0941250897974627, 0.037991376947621, 0.033538135841561956, 0.060557118257365095, 0.08490030297246631, 0.0707840194483923, 0.10844253918211655, 0.04997975526858811, 0.005483635550109445, 0.2733802054526687, 0.034586850974956396, 0.178960818482663, 0.10680821132431406, 0.028792211401761802, 0.03095346218418127, 0.1760588070404412, 0.08791507748829042, 0.1604942849475176, 0.13348971553034172, 0.07262931980654264, 0.06416084162883484, 0.2049024099891813, 0.15136813852357867, 0.2834747643942378, 0.1807267810764157, 0.380155152605108, 0.3904477204784893, 0.41619370144748813, 0.41323437265651, 0.35258123199566804, 0.5124898508651792, 0.5161382383933879, 0.38455270069561054, 0.40150459280430206, 0.11842701185079096, 0.1305370641888921, 0.10823370743449123, 0.10986974039806285, 0.07841994352861181, 0.13308016955810786, 0.08709652546125857, 0.15989862941256883, 0.1280082623296892, 0.17410009499450407, 0.14279193664335144, 0.203496466308156, 0.17050343507694832, 0.35665379293807375, 0.21263157053207538, 0.2654622735532375, 0.16552567099800164, 0.15803653969402398, 0.38580009919122593, 0.3469066044386101, 0.19350196707538103, 0.45178683310535994, 0.49284549895943186, 0.30316250317275106, 0.3038972234789702, 0.2067989714804438, 0.3487924282358279, 0.14765394620923566, 0.28377149745781327, 0.17364340309983528, 0.38152214194509915, 0.4274646746613865, 0.28148454580532156, 0.17965708343429865, 0.12804470292781134, 0.23564013089477842, 0.20801575861137522, 0.21901684585076409, 0.27300988374470525, 0.20711316604673713, 0.18874347627250632, 0.27438367887653625, 0.2395362344515083, 0.22152544792730267, 0.2159414776118589, 0.24385504331071262, 0.1735678590509555, 0.25039508967637947, 0.19896686351311788, 0.2420243237310693, 0.20853406617119685, 0.22358487569262964, 0.23662569167798098, 0.19732352302695455, 0.18864608810259675, 0.518907719395007, 0.5965534058022126, 0.17340186803613777, 0.7189692021511298, 0.20118926806601367, 0.1665756205352945, 0.1478711763440067, 0.19538128566258695, 0.7212345626939403, 0.1423255909850175, 0.33305127727985906, 0.11205744055938172, 0.16972191001979975, 0.21013948373970792, 0.11358169210022684, 0.15728930307815103, 0.31480261894136685, 0.1919306078035352, 0.17829229972913896, 0.23064165195862973, 0.18426618258157246, 0.19365498161314787, 0.17866746525484778, 0.1913564096364363, 0.17162343320081708, 0.2053207756271891, 0.09447462829224829, 0.11418175238413164, 0.08884619165107155, 0.09400095284509702, 0.09589339364358929, 0.092363455869517, 0.0872802095393943, 0.07677342503382001, 0.09041558499629887]}, "mutation_prompt": null}
{"id": "255e2a8d-b6fd-4e90-96c9-0067c3d376c9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "1958ad37-5332-4ae7-a60a-a6bf4e88c378", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "e9255f27-e7d3-4793-a1b8-d6130d27246d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "a73c18b7-a54e-4002-aa79-3636eec55177", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        ranked_indices = np.argsort(self.hm_fitness)\n        candidates = np.random.choice(ranked_indices[:int(self.hms/2)], 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce selective mutation based on fitness ranking to enhance convergence speed.", "configspace": "", "generation": 34, "fitness": 0.24340748621564107, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.5895845999555718, 0.6225710415654394, 0.564760493563302, 0.6077506404598714, 0.663813622076844, 0.5478129231511275, 0.6334603739506832, 0.6012459250080266, 0.5879368546074366, 0.1688925069642644, 0.31697116693359095, 0.29455218650650283, 0.2666883569918126, 0.3118104471969756, 0.3516048230578884, 0.2880938330707943, 0.2529084304083954, 0.2210631675331044, 0.324769817443579, 0.38839381517374494, 0.24100533878974595, 0.26135203365796256, 0.27928622419723137, 0.30457805987388253, 0.2525049720243867, 0.25632041134640515, 0.22029998772182302, 0.17749107519234675, 0.1804777811620426, 0.15581095535047207, 0.27994449816035083, 0.14359504252987332, 0.1632556100726713, 0.17780633410742608, 0.1675269389611247, 0.19343846409254595, 0.9726553159008843, 0.9675096060902556, 0.9806548159617166, 0.9430249027187289, 0.9761971260906648, 0.9670987825002996, 0.9533888108683392, 0.9772038096502043, 0.9751750513037439, 0.3213206273109397, 0.2514431173000975, 0.28107789327350097, 0.3403518878779255, 0.26040605287725227, 0.28870158419615577, 0.32088046472600795, 0.2611534873480621, 0.25260582121702735, 0.20790654768358818, 0.113044153423561, 0.21834418355879148, 0.366155457856171, 0.2564435383343898, 0.38558173048629973, 0.2257737146555474, 0.23653700934637267, 0.2364310230763631, 0.18781984020889453, 0.14469466228123984, 0.14761733522050657, 0.11217794908837464, 0.19588273271909862, 0.21303547530230693, 0.15262915043315006, 0.17227385387511962, 0.2863557944275391, 0.1743763640469902, 0.13637603457945346, 0.13167835687552654, 0.04011811507166563, 0.18347382936743228, 0.13530500457045924, 0.17124964466863202, 9.999999999998899e-05, 0.10924905500766724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06946888554960629, 0.2438341889487371, 0.07711696933482104, 0.05390635498998286, 0.0644878114008568, 0.05203493530120051, 0.04523004310223533, 0.09845530555826387, 0.09690516544991645, 0.09399615110576254, 0.009871206503232699, 0.09649875236899874, 0.0107405172300159, 0.06805130631739198, 0.011127454013106441, 0.0035157577201898604, 0.014192716043272768, 0.04484458184193152, 0.00011013641125789952, 0.1446959479976756, 0.18851432117686584, 0.07105913808799591, 0.1445071324054834, 0.160307496364977, 0.0923660687451009, 0.1488242723885702, 0.11331997866689691, 0.08177611123825868, 0.4202256368867945, 0.45405643757915504, 0.4123840514021061, 0.3651177349658207, 0.433074832898798, 0.4407923169381994, 0.45280506381679675, 0.4085477937248535, 0.4251719976294611, 0.062171092074615464, 0.07083437890198108, 0.1176737873231043, 0.07634619494538275, 0.08069353579806615, 0.0886137514798615, 0.1203360091997463, 0.09327524490208894, 0.07328838491451495, 0.25923845436367043, 0.2622984212452346, 0.24420848060869083, 0.23569388168649896, 0.18222180003323085, 0.19427170960656848, 0.19464641310706432, 0.15569982239147884, 0.17137941667253742, 0.2308072177576166, 0.26594893198873404, 0.18390247182827546, 0.3289524683650349, 0.2770077617910863, 0.2854490187871457, 0.2862636938807943, 0.15931320742866883, 0.28053986961144106, 0.1567171530760787, 0.19606141992616022, 0.1177132042900575, 0.18882300810502406, 0.14730556199818656, 0.22890495870674954, 0.2557754637699816, 0.20594741403970585, 0.0944831806466514, 0.18608356660541325, 0.2020075055660433, 0.24549002782744356, 0.23394028043911053, 0.20754180853596094, 0.19694535483390518, 0.21121631209445757, 0.18628018649913425, 0.20274159855884533, 0.25047369721647605, 0.2127463378546084, 0.4026732326526148, 0.18742858923514083, 0.22438077835923198, 0.20955591968552922, 0.21856967349576562, 0.2391134322820463, 0.2182018179156039, 0.18970486550472365, 0.16018033965258438, 0.5798070288470727, 0.1706764418100336, 0.2016160560927851, 0.7331407954901172, 0.16775792819758428, 0.16120920265830396, 0.16730299230800993, 0.33766085808485746, 0.16958666084259422, 0.4140778693708669, 0.17013454583267162, 0.06441482038534707, 0.2814166254560141, 0.30287655381721146, 0.2744590339233639, 0.45915867430372104, 0.19316591305395414, 0.1836000607166749, 0.18989223661344456, 0.1800921322476342, 0.19551414372242815, 0.19342042363434053, 0.21704227640129092, 0.1842772048346395, 0.18567548439963044, 0.09489975092216796, 0.09068991870455578, 0.08182050595172297, 0.09315322811244875, 0.08472445942960838, 0.1107282611109871, 0.09210725209489734, 0.09760935983069152, 0.09063317496965118]}, "mutation_prompt": null}
{"id": "5697ef9d-777a-437b-84da-0089c72e47c4", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        # Adaptive mutation with simulated annealing inspired adjustment\n        temp_factor = max(0.1, 1 - progress)\n        mutant = np.clip(a + self.f * (b - c) * temp_factor, self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate adaptive mutation rate inspired by simulated annealing to enhance convergence in high-dimensional spaces.", "configspace": "", "generation": 35, "fitness": 0.2604636176330758, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.6450222744288154, 0.611076142666213, 0.6405864307216483, 0.5764767444284298, 0.6541452439120145, 0.7264350668187473, 0.5668011597722141, 0.7915243608727585, 0.6211522514861506, 0.2017635450887718, 0.2727995376644431, 0.12219317799742058, 0.211564009248151, 0.36163344979541645, 0.3423500586850954, 0.3497669066608716, 0.3360853661808002, 0.3155159204169886, 0.17357073925058053, 0.20158030931387716, 0.3248603148665541, 0.29884297355447786, 0.20927888830452002, 0.17715709474509045, 0.29760142334303563, 0.3042399066440502, 0.17528624332831444, 0.18644077461036646, 0.18404442620159311, 0.17483372601351643, 0.3136317164671032, 0.15863309835683814, 0.27973177242953406, 0.1909979128988013, 0.23692982998184564, 0.1576797476761762, 0.9585760918007211, 0.9534234276084984, 0.9738057754460578, 0.9755682386658389, 0.9568684722485519, 0.9904182827515987, 0.9795754659657335, 0.966545397146526, 0.9689079513574683, 0.3606829596739185, 0.2683983075331654, 0.2694805692158263, 0.3140497522088973, 0.368657001840181, 0.24568229764338856, 0.3137924735005093, 0.2851430468820597, 0.3218446869512982, 0.21328606392917315, 0.3726502510741514, 0.21669046629349442, 0.3933589397694901, 0.31158884864871317, 0.21646686629404543, 0.8611090403209268, 0.23837432365828293, 0.17565282714755848, 0.14735237911220356, 0.1524247726509802, 0.32075071171166336, 0.17144696421944206, 0.17088002899434118, 0.3583607506699371, 0.1412581741229495, 0.1503172730693768, 0.1571129043775965, 0.16846669419219362, 0.14208840147722368, 0.1416136630144893, 0.13470640081648255, 0.13275763033221843, 0.2330253680730766, 0.1909989761144829, 0.11975183488325325, 0.13300015017861422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029005376348477885, 0.014185110660935418, 9.999999999998899e-05, 0.08687182230208035, 9.999999999998899e-05, 9.999999999998899e-05, 0.05315884191553322, 0.09221238523885877, 0.06952139887336195, 0.0859827045693432, 0.08197706907399083, 0.05496408661145402, 0.13021636549728632, 0.13298297692460115, 0.09118195296058496, 0.12458074652788198, 0.09708566006219899, 0.045053209081128975, 0.11618905896307552, 0.0654245268298721, 0.00938086957798101, 0.15996316902188168, 0.08995588436075885, 0.043804416431722504, 0.09712161564336952, 0.09680404355628491, 0.09271065031554226, 0.1630292050355875, 0.159031968791566, 0.13670804592518926, 0.08854351023389895, 0.21584931079393943, 0.1306517818012891, 0.4769870545074897, 0.3669299141665655, 0.4518016297912304, 0.43797240328916265, 0.41349860471959354, 0.4304414553519138, 0.4153307445799882, 0.4066589338753379, 0.42978888703852847, 0.14536800992024546, 0.17497125164746907, 0.07173231487001452, 0.1156910277273333, 0.07442217853668076, 0.1695241632560086, 0.11489954931477064, 0.15499324833148842, 0.09401800130031823, 0.26646837972183846, 0.2249185226738477, 0.23691587289016625, 0.19372121415001553, 0.19969998561035918, 0.2584848596054796, 0.33540958811971877, 0.1655517811809375, 0.21252663688418438, 0.2827165744170078, 0.26296701412837764, 0.3806912361832633, 0.25110869081258, 0.32563660473918876, 0.3450394944705829, 0.37131234102633714, 0.31596637906612823, 0.22703368548513614, 0.18573318607453604, 0.3067590310296274, 0.16097337561049663, 0.18016345712015192, 0.2225659609860664, 0.26029642802010766, 0.1840638432226246, 0.252868331997124, 0.13236598643173725, 0.2114786634887923, 0.18864237213082347, 0.17918142608362653, 0.19540514905876638, 0.2270097241984158, 0.21943671251441788, 0.20710115725881273, 0.24088691336744783, 0.19128802909896192, 0.20970361327637932, 0.4394633384943315, 0.2170770973075048, 0.21171759297387271, 0.2105923310240294, 0.24363613496244385, 0.4459324006961821, 0.22748684654682605, 0.2008812893051264, 0.17360693246885694, 0.18738576844604837, 0.16740077583274393, 0.7647377790604767, 0.18937232378612356, 0.6266092135793165, 0.1483831754427949, 0.3212672358487729, 0.16855227850793053, 0.5840647307973328, 0.12432820751753948, 0.16859342251954224, 0.25182963752097776, 0.10537601627880233, 0.21159935538543573, 0.09469923817316428, 0.2896147303743317, 0.26358228015537644, 0.22886574491665357, 0.19769402342521047, 0.17495535698307796, 0.18576694344769606, 0.18511411829779623, 0.192667285934501, 0.21854951388735921, 0.20788851408458764, 0.19275718746131942, 0.08719306800741056, 0.08061748449449202, 0.07886268716888511, 0.09642018342240333, 0.08583383058598393, 0.12044868325656222, 0.08129336199197401, 0.08938842401295866, 0.07702205765391412]}, "mutation_prompt": null}
{"id": "71a08df7-9e40-4d29-b71d-95bff9e0a8d8", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "97e88692-6939-4cfe-9c61-4af4a9a3292a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - self.eval_count / self.budget) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        # Dynamic parameter adjustment based on progress\n        progress = (self.eval_count / self.budget)\n        self.f = 0.5 + (0.2 * np.random.rand() * (1 - progress))\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Augment randomness decay in Pitch Adjustment with adaptive CR reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7048887237758727, 0.59135116819589, 0.6639441520550655, 0.7124590855475943, 0.666140362172642, 0.5886765818768335, 0.5860418110385828, 0.7085677893849247, 0.6083739955301392, 0.3939404922212947, 0.34328580665704844, 0.20695384199716782, 0.23769744388780112, 0.30489273455136356, 0.31874272295640715, 0.33537354923899165, 0.3772296472660903, 0.1828343510464483, 0.2800426547199595, 0.3234043022328922, 0.1947224778596821, 0.18233138641530922, 0.1917070604025536, 0.398971735012024, 0.21051241187662995, 0.30023949091781255, 0.36625698943565255, 0.15927605065305162, 0.18362572270906352, 0.17161656102004874, 0.21747295469364925, 0.1886249103377221, 0.16901191335665755, 0.19191086864720353, 0.17929606767262707, 0.1893932642304157, 0.960398111265995, 0.9633857417032551, 0.9759736987399131, 0.9603553611681617, 0.9741272672660477, 0.9777866649057547, 0.9472573932412747, 0.9639636318636545, 0.9819999328922455, 0.33260926105553434, 0.3071341937773693, 0.33408431910402947, 0.3173675154708764, 0.30132325578026353, 0.22844467163490212, 0.31793118709035684, 0.2511125047695083, 0.2762793750815695, 0.23081622701883842, 0.08946758822210554, 0.22524417137351394, 0.21616519974981496, 0.21558093458203553, 0.3410943669642763, 0.1382399036375116, 0.37150294271098383, 0.22601374744092084, 0.3442596482079133, 0.20801647825340697, 0.15674253680909245, 0.18400264734544258, 0.16596638368243077, 0.29092682892200117, 0.15216126241689543, 0.1847365351753124, 0.14881846320235415, 0.16153425424650503, 0.19645962769688463, 0.13222559690908964, 0.147130336504654, 0.3070007603891357, 0.13394751106222447, 0.1777718649721861, 0.07345367620975707, 0.13366901822206967, 9.999999999998899e-05, 0.0028837298679893486, 0.10831295167288113, 9.999999999998899e-05, 9.999999999998899e-05, 0.008051510630425973, 0.1276564888897257, 9.999999999998899e-05, 0.13761348580595545, 0.08609006539148267, 0.07152892982729986, 0.1289281465417107, 0.18575361748573305, 0.030172828978502153, 0.0852984401957323, 0.17167704616387658, 0.15083057039964953, 0.05822257028343225, 0.13486665763013372, 0.17256734752277314, 0.10187664438514743, 9.999999999998899e-05, 0.13686177749707618, 0.07744444698702524, 0.09686436567458023, 0.08436954447086176, 0.06422892879038278, 0.13204695248862242, 0.0600768598870578, 0.058153078720423634, 0.05091523490110428, 0.024675552059985062, 0.147221197480915, 0.11557612063512912, 0.16531700391228255, 0.16615182089324354, 0.4132620639286694, 0.3891265205240878, 0.4394204242753378, 0.3905916241347952, 0.47054239542895515, 0.39814936203652995, 0.4330351783753106, 0.4228948143424547, 0.4966702524220806, 0.09247447516707252, 0.09796454197753335, 0.09594275291383603, 0.14631991014460455, 0.10710961849767353, 0.16427962863880785, 0.15985691888322395, 0.12965693776630194, 0.10737065218426411, 0.2389022078480102, 0.3653642061120612, 0.2516906736202773, 0.20467407743137955, 0.2699950467352483, 0.33176324524709677, 0.2935603706506995, 0.2019271646355485, 0.43357581748646246, 0.2867582396814927, 0.3629899165396434, 0.2815760258138492, 0.34198185014399707, 0.3929596655954748, 0.2558130160474238, 0.24734495136187518, 0.35732855412412823, 0.23247685888964265, 0.2771954033919657, 0.36305168077769945, 0.2181849912965358, 0.3515893016653169, 0.22736713515950158, 0.2811575476835205, 0.28675641254368156, 0.19688959470530876, 0.0803044667408156, 0.19781352669700225, 0.23902187081102932, 0.20155312026958516, 0.22570534239119322, 0.22460119670794798, 0.21415650137926123, 0.21545864457897324, 0.2246833203878118, 0.20785486726718128, 0.23061267553119502, 0.25211350695206225, 0.21350660378245967, 0.21045080425974916, 0.2121386728619763, 0.2117397293229013, 0.18878611247051658, 0.2545813246498967, 0.1874508993396783, 0.18786017072540895, 0.21139041336708908, 0.7189223922540977, 0.173618158738577, 0.201644230543348, 0.2013174422020042, 0.59251749041995, 0.15866975030922126, 0.16906038295786818, 0.4919416193907339, 0.21166681159171075, 0.4399299529102556, 0.4454589627968404, 0.16835202845230013, 0.2096636957883422, 0.11293929352083998, 0.15777186737091975, 0.2630516642371328, 0.21390818532550115, 0.20076501716702477, 0.1703645960536896, 0.1986105216455687, 0.1862892684359897, 0.18361418356810144, 0.2429279147305693, 0.24502019167167832, 0.2131048700849718, 0.082477992895993, 0.08526551093197654, 0.09068195641160803, 0.08046271299500407, 0.13123867502897024, 0.13622677583611076, 0.0897422154780817, 0.08118389048943697, 0.10243416206232248]}, "mutation_prompt": null}
{"id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 38, "fitness": 0.31593472018707647, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "e0b1a711-b187-423c-abe5-d7063e217966", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "65fcbe91-8bc8-4356-ab74-11719ec2e4aa", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "26f426c2-6069-44e4-b37c-d4c6956ecc6b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "76008fe1-c569-4255-b194-810f5c3845dd", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr_min = 0.5  # Min Crossover rate\n        self.cr_max = 1.0  # Max Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        self.cr = self.cr_min + (self.cr_max - self.cr_min) * progress  # Dynamic CR\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic crossover rate in the Differential Evolution step.", "configspace": "", "generation": 41, "fitness": 0.23885704859546347, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.6391863563954818, 0.6022603496902607, 0.6820938662486671, 0.6172419221134973, 0.6636929546604369, 0.6836145733196832, 0.6034118698009907, 0.6373525161184901, 0.6342401545474852, 0.11078697351212974, 0.3151470547032914, 0.22278006600176536, 0.39378363824649876, 0.37157990383391204, 0.2345297881546754, 0.5214845251281901, 0.4012988357512932, 0.17614827009413514, 0.1842145290257322, 0.19010711132298785, 0.2887073765833382, 0.17173227470173424, 0.16650748259583492, 0.18191486042590044, 0.24320835552900166, 0.21369944917553652, 0.19241200434933203, 0.29446982113306786, 0.15492415820945138, 0.26436142821685105, 0.30578440274249274, 0.1603619317731747, 0.16422816552986808, 0.23473018945062585, 0.1458383161383512, 0.15304469522697817, 0.980598908101571, 0.9914395927893732, 0.9611779155538164, 0.9786248344237924, 0.9857430821272907, 0.9811585495725377, 0.9693005299304273, 0.9790831730033696, 0.9654165700885824, 0.27295746233573503, 0.3066279434123874, 0.2896086654116904, 0.3157389116733691, 0.3056525526111066, 0.31405860684511566, 0.2859128777457165, 0.3196190262313142, 0.2776667617176434, 0.21622865682994674, 0.35062302629705555, 0.22934703127574363, 0.19590498912564713, 0.19174377564975154, 0.19342730307622613, 0.2466293563867329, 0.1303067646475209, 0.2353725227923955, 0.12423824706446485, 0.23981286359749654, 0.15166412210145497, 0.1529150561987157, 0.232166671894811, 0.27811015474470147, 0.15051274081114607, 0.2522522092205016, 0.14880659576015987, 0.14999130593895937, 9.999999999998899e-05, 0.1860831724269456, 0.11705468184598844, 0.15252382168511736, 0.13841113180752096, 0.15680876499573337, 9.999999999998899e-05, 0.17065482016831013, 0.02827024097758679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007498681518620098, 0.05417269854150364, 0.023487754106321868, 0.10119095836327174, 0.07450245031755909, 0.001972507850587002, 0.02389830495600287, 0.17176218893078554, 0.08078434931216871, 0.07416096697347185, 0.017999295107248736, 0.10048659638844692, 0.006044630045940136, 0.07484922081504286, 0.053054470963400435, 0.03746470512622058, 0.07569167499228446, 0.07697297454460916, 0.08367819312345381, 0.14048894157211855, 0.0867408416781833, 0.09137212622687507, 0.06168794591900317, 0.04509482187387115, 0.10636883603641911, 0.08612392508379618, 0.09430152204172959, 0.08350843761549731, 0.4722577385243878, 0.4412756311826169, 0.446000218461982, 0.36754275523751223, 0.4628616508931743, 0.4654420966805185, 0.40750434301175265, 0.394307094902806, 0.5901566683906962, 0.12729680955309008, 0.11258151551717055, 0.11696750263090494, 0.08685417826153008, 0.11121854350031568, 0.10848010559312604, 0.13474164537760858, 0.11952836338134509, 0.07642109825638732, 0.3888615008291687, 0.2903679512060817, 0.2194295091189863, 0.16334796803057694, 0.1643857311233884, 0.17772366224366865, 0.12882893665179906, 0.16697110667055548, 0.14641981067594423, 0.2850799549453268, 0.20140644642431826, 0.18082044714283818, 0.17986589951202825, 0.3518346986365808, 0.22677120298349396, 0.30858461954916694, 0.21386422292007945, 0.13061762394871257, 0.27090503370424734, 0.16809308583921134, 0.1988759344320289, 0.2466692225488566, 0.2687954498335601, 0.29034767218964086, 0.19145031916210187, 0.18974358380501277, 0.08607637167349513, 0.18814280401519545, 0.16950620671125616, 0.19840539913578903, 0.19857849375357084, 0.1980589012272801, 0.22103603431989383, 0.21636079843466272, 0.1788591985566652, 0.19176976840816062, 0.21390532043081478, 0.22752882953951037, 0.21224316139969912, 0.21834774720612893, 0.20587567271536944, 0.2574680107359444, 0.24946677321697297, 0.19576938384625542, 0.2274964870564109, 0.15992175248686258, 0.1882179410897279, 0.17230118456059806, 0.6551026053142566, 0.20162505430822353, 0.2021674864126276, 0.5363398364526522, 0.1260929827220183, 0.1581747208915344, 0.09118672711236453, 0.16922202873846492, 0.12750990641852422, 0.11283538276003124, 0.20944742328439725, 0.21288466505041992, 0.32235345985555186, 0.08269665208402166, 0.38362096945926494, 0.20041755610693568, 0.19501613754086045, 0.17705745178034105, 0.16999869260396483, 0.17983147868056226, 0.19362534265345244, 0.17305375966872105, 0.17445211527373194, 0.17085258037710027, 0.07186302123527566, 0.07484708597726863, 0.06639102283665654, 0.08953754269195646, 0.09921044587380878, 0.08870581228094776, 0.07729500866510841, 0.09588717243545375, 0.07959839369800081]}, "mutation_prompt": null}
{"id": "150d4da0-4645-4b38-8f6b-c677449c68e2", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n        # Retain top halves in the harmony memory\n        top_indices = np.argsort(self.hm_fitness)[:self.hms // 2]\n        self.harmony_memory[top_indices] = self.harmony_memory[top_indices]\n        self.hm_fitness[top_indices] = self.hm_fitness[top_indices]\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce elitist selection by retaining top solutions in harmony memory to enhance convergence.", "configspace": "", "generation": 42, "fitness": 0.31593472018707647, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "7f4f6ef3-df2b-4af2-b7cd-cd5f9f12ae02", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "9d816d74-4769-4326-b46a-8c7c25bbf641", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "77b6972e-495b-450c-abbc-3d8685dcc923", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "cf59b1fb-63c0-4989-82fa-4f7a690ce8a9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < self.par * (1 - self.eval_count / self.budget):  # Decay mechanism\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        # Adjust f based on evaluation progress\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate a variable scaling factor in Differential Evolution for better adaptability to function landscapes.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.7943782673984608, 0.7364398202245119, 0.7825309004522677, 0.7429341960434652, 0.8007374353980644, 0.7930809826377447, 0.9458936624156857, 0.8666011557623641, 0.7355923397870207, 0.5630142538261971, 0.5367933326211523, 0.6959534523807733, 0.48341786232047723, 0.38377737417517443, 0.6859504332932109, 0.19731682709061704, 0.4204741441924854, 0.5975192223732069, 0.3145153401576911, 0.16378036391111328, 0.34284594574328064, 0.17971703243361514, 0.3147425556602046, 0.18004364108854876, 0.25134038529854374, 0.3557402729289021, 0.4104009101119914, 0.18602782365907422, 0.16272205527518435, 0.276127439322278, 0.18459976096577357, 0.27201913336171735, 0.15741962747282434, 0.24538239348428736, 0.2151893382811515, 0.30610192886573573, 0.9879191908447723, 0.9672635155376009, 0.9755204142522881, 0.9677669843367224, 0.9846221773130076, 0.9753378393588537, 0.9817746859316046, 0.9861960233544799, 0.9834437043385116, 0.3011912462544305, 0.28765435049485955, 0.23621085969988254, 0.48567490379855094, 0.37161986639070255, 0.4306362237169784, 0.297975586900345, 0.3117493475095445, 0.29384181199497583, 0.9267439916226512, 0.9218416721876055, 0.16743875911661266, 0.19294066286626432, 0.27898409088394216, 0.19156434647431697, 0.35592614035755543, 0.23295201791942222, 0.23812196835593158, 0.23041726250697148, 0.17826981434923694, 0.3072912822089592, 0.2255329779711731, 0.15139219346397004, 0.179488300890844, 0.18352590623535137, 0.24785829479455923, 0.15505420795047153, 0.10350305846831431, 0.12294763214821236, 0.18204150478992143, 0.1696386384802303, 0.1581553854287322, 0.14116070968046457, 0.1758963336149202, 0.1359914972562366, 0.13414192892198773, 0.2571857095514626, 9.999999999998899e-05, 0.22798857731861466, 0.05586921170031056, 0.04710384805665435, 0.0438753658611869, 0.1473683505513843, 9.999999999998899e-05, 0.13846325320960462, 0.28215627800590704, 0.05295120789812213, 0.28302908922330217, 0.13245759052379058, 0.12000339780024971, 0.04832528518256207, 0.16017779189535342, 0.06557344684102295, 0.19665495342517536, 0.12599529448879587, 0.08463419020075913, 0.11423309603596699, 0.23703705766310068, 0.08309766844683841, 0.15375704074032404, 0.030095809834155607, 0.12852485416140313, 0.11700342788295204, 0.07695781984458938, 0.26139015890103146, 0.30413894122751395, 0.09361685843275314, 0.2254262886558842, 0.22415821966312754, 0.31815772687809896, 0.24267818489359738, 0.3143190292041662, 0.6116455796737255, 0.5959183971609399, 0.6063826613404701, 0.5129384952426155, 0.4933527851811357, 0.6607874248231355, 0.6861370660161694, 0.6409632880422631, 0.5367470289031678, 0.1421710091963707, 0.11058664882028646, 0.1322049930331568, 0.18847996089757757, 0.08099197858392038, 0.15524314325508148, 0.1254515445312432, 0.13175118784129047, 0.11912854293743547, 0.5240308907103775, 0.22478753584471833, 0.178798659026566, 0.4527688737080452, 0.23898781533759217, 0.14747911914913125, 0.20249274476892243, 0.17039232690286332, 0.20764918735740423, 0.5629447591151906, 0.4263780549299627, 0.21702975427291726, 0.4070025383588508, 0.30360612801826237, 0.3393306640096665, 0.27795398472491173, 0.35953521131427413, 0.5362386625863257, 0.3488918671631841, 0.379367606605008, 0.22331503072328474, 0.41426427921337694, 0.24815700278888786, 0.3877024135241244, 0.29179880900852617, 0.38347159342380743, 0.4348060442343975, 0.21140006123460353, 0.18835309988413518, 0.19567833438205795, 0.21625513141759523, 0.1952116898292503, 0.2070792770069647, 0.18206121944064824, 0.19946317890941478, 0.17948151083014963, 0.49447699318532135, 0.22759774801718358, 0.23744468535637753, 0.22353776291457306, 0.20070203945287435, 0.20828755909608343, 0.21335665785295088, 0.2142633375402172, 0.2188077510265154, 0.20017506558915898, 0.16596936147194485, 0.18788566501501813, 0.9224971933410434, 0.19971341548625754, 0.13571052540692274, 0.565863826858157, 0.15817704074227568, 0.1620323250586394, 0.5027782290804372, 0.21226255359290735, 0.7224528975586335, 0.11342513502363016, 0.1605413188482585, 0.21403942700813816, 0.8922303614370689, 0.21355012221720293, 0.34901079768823284, 0.20378555245555663, 0.18499742979234501, 0.2353923845637168, 0.18774879524859234, 0.19469774922370586, 0.17655315800665738, 0.18890729213191426, 0.19548435621304294, 0.19436217452767124, 0.0850231563602647, 0.08292466186055858, 0.07940601908393763, 0.09302137239293728, 0.08771097015546636, 0.08625129188796932, 0.108078534128074, 0.08251402290758758, 0.07225810277957934]}, "mutation_prompt": null}
{"id": "c44d5516-b566-40ac-beb9-9ca883278bce", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation balance by introducing a dynamic pitch adjustment rate based on evaluation progress.", "configspace": "", "generation": 47, "fitness": 0.3211549790071906, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "5481b08a-ed88-4d85-a25b-978761ccf7fa", "metadata": {"aucs": [0.680075401914241, 0.9307301908093218, 0.7026851244224803, 0.8534634810657327, 0.6442911335434922, 0.9282930645674864, 0.7717971875379148, 0.6921330990175135, 0.9170146364278703, 0.44908283433039986, 0.2988153246579931, 0.5680437062672212, 0.4915768027632317, 0.37495136691524455, 0.6683137859565343, 0.4828407839846436, 0.2650261798377245, 0.541720510026928, 0.15679259246704602, 0.1845916585768267, 0.23423564862599955, 0.159286275570092, 0.1804071095364428, 0.16139781410688225, 0.299901686864151, 0.1908286721345177, 0.2971014112310624, 0.2880785893066252, 0.16864327430774917, 0.21995829651127485, 0.15483767306622853, 0.22795277627405963, 0.16387328135439327, 0.28170404261305315, 0.16847562004706984, 0.2580058898186687, 0.985331653783536, 0.9625007787883886, 0.9806534900463321, 0.9685502574039112, 0.962055088781677, 0.9825896233327029, 0.9850964805559522, 0.9795843792372891, 0.9651561735880435, 0.3300484846516325, 0.3252559746758814, 0.45964021992998705, 0.3634973443393935, 0.355728242978942, 0.4557801840064243, 0.47949094621345223, 0.4321769684262181, 0.3242161692187079, 0.36053456369802184, 0.0936960214966659, 0.32655020719114514, 0.9198624807994318, 0.27906854559073424, 0.3874603923875899, 0.7788585885149094, 0.23754034267601143, 0.922460530881739, 0.169948741361029, 0.20088746579366923, 0.16668956970881466, 0.21467240020807787, 0.22210861200160936, 0.21981587218648246, 0.16726053683073805, 0.15307308808771247, 0.18482491125781986, 0.17276564968243313, 0.18576983786010215, 0.19128214858309067, 0.19915833862401955, 0.16348243431462361, 0.17063308949824463, 0.19289592963231839, 0.19196943462584493, 0.17293797503450548, 0.14500714469550313, 0.06635562129251538, 0.08165904471727481, 0.009850779282832844, 0.09151476485088528, 0.05068401743553819, 9.999999999998899e-05, 9.999999999998899e-05, 0.08235798242783787, 0.11272904736339828, 0.24363408014870225, 0.15507848692376014, 0.06645339616294788, 0.19570374537002655, 0.09362572681648307, 0.36762865778654463, 0.1639289064493321, 0.11422388696668262, 0.22399170684437053, 0.22131577565089133, 0.12737055119477847, 0.0966300920365396, 0.14603922190583274, 0.08233875628494769, 0.1250037259835517, 0.20841856322260055, 0.09804996437550273, 0.23678140406814674, 0.15401109091884213, 0.1802288093492661, 0.4740919915052043, 0.31438360702209456, 0.15392464804327355, 0.3777880259111348, 0.1954359596660009, 0.2879432687227732, 0.5336174621245567, 0.5581266014890074, 0.5990660335576978, 0.4646076453463701, 0.6111324893948293, 0.5713266614427222, 0.7369134344288206, 0.6202615553872397, 0.6671443053874115, 0.1480571188251275, 0.12868356526143832, 0.1149646254601977, 0.15678083754955674, 0.11674069956305433, 0.15983745681824635, 0.11514320704858017, 0.14437488874975024, 0.1335107475604691, 0.1763427393334619, 0.18075889723332783, 0.2683472135856645, 0.21298499939684723, 0.4085669829849511, 0.2106563219650458, 0.1766075227095586, 0.3454530099305333, 0.16725410248742423, 0.3807666035480606, 0.3962496091813117, 0.4469223577475845, 0.4675295336765015, 0.3742148495663048, 0.4070318695108498, 0.3491799943763426, 0.20642380789277825, 0.3396691044733934, 0.2614265124575623, 0.3261653869937967, 0.1805282961897381, 0.2707390320485821, 0.274158878382045, 0.29618551496935996, 0.29472181797719244, 0.2242414161187125, 0.19623318465143746, 0.23448784082860807, 0.20139223420244368, 0.22902656405903277, 0.253506075944006, 0.20088218297984528, 0.20544761695490266, 0.24406196704055616, 0.24533553800639707, 0.22977807846855125, 0.2307893145914599, 0.39719634803751436, 0.6589905118438335, 0.4057913275233016, 0.25547719490241283, 0.22697920443317365, 0.22446636981881918, 0.21203682423959713, 0.20932950672768869, 0.16857060784383682, 0.1885324019531397, 0.16615363932565108, 0.9540929100094266, 0.18908672544849947, 0.8096080025509522, 0.16730126089402197, 0.212322098686347, 0.1669919546086328, 0.7819432817565415, 0.16939544474650503, 0.4779928256904119, 0.1699054199684098, 0.4335273724762023, 0.41863416452295643, 0.11266863268385041, 0.21367222423679832, 0.9200835094071688, 0.19393180227131346, 0.1977820098460037, 0.19875464710416169, 0.18188224551169807, 0.22276338900967052, 0.19081621346941025, 0.21063392467471165, 0.17174506771782672, 0.20282493381348177, 0.06778102805760422, 0.08664882311975175, 0.09267583062548368, 0.11735949293313774, 0.10697439094191596, 0.09509118325174626, 0.09303293340128915, 0.0982894562613994, 0.09051247500762694]}, "mutation_prompt": null}
{"id": "d8b8bdbc-85db-4c97-ab07-acaf6eabccad", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        fitness_diversity = (np.max(self.hm_fitness) - np.min(self.hm_fitness)) / np.max(self.hm_fitness)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress) * fitness_diversity\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate adaptive scaling factor based on both progress and fitness diversity to enhance convergence accuracy.", "configspace": "", "generation": 48, "fitness": 0.25048303636760516, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "c44d5516-b566-40ac-beb9-9ca883278bce", "metadata": {"aucs": [0.606581019483541, 0.6175815146906454, 0.6173210796523725, 0.6080431170950948, 0.5929425651895124, 0.5740197639855951, 0.6356338905420167, 0.5879854250044765, 0.6471663990954988, 0.17447692176578022, 0.1302786893638197, 0.18486913045622155, 0.23924198436710753, 0.19412611644068212, 0.14382622708913972, 0.24063367334865593, 0.23938058995962797, 0.2607222123510069, 0.18720131079070956, 0.1426772113390412, 0.4105693950099141, 0.18166697243931484, 0.18274266739991474, 0.1846571945412563, 0.29067045245499723, 0.2930680049923782, 0.17371604099092852, 0.16526068414800377, 0.17150947682580575, 0.2769586779083333, 0.14663950192733533, 0.16822173571985366, 0.1492626444168378, 0.2566245005602602, 0.24978741315759778, 0.17501193592871567, 0.9813348803629516, 0.9579678286576779, 0.972033965197564, 0.9794829976467264, 0.9579791347365493, 0.9780722190377659, 0.9379771706511209, 0.9804267124154032, 0.9581656204354916, 0.29601437970206734, 0.29260436523089917, 0.3380991238735418, 0.2969679311939911, 0.3056340340866962, 0.3389356613870438, 0.2923364137441452, 0.31549709636919976, 0.3031287838847384, 0.22929335948949348, 0.2304862541495103, 0.1397339308638086, 0.36268961869535543, 0.21736037928789242, 0.21591163365194588, 0.18030513109911972, 0.23872224953808852, 0.355876247984549, 0.15020035140533905, 0.1779134382096519, 0.2568365653245682, 0.14983119067910833, 0.15715739099245785, 0.22699089792312366, 0.15146328731425873, 0.15040398839229496, 0.2404801618511747, 0.2519304646257208, 0.11538887272970755, 0.13988461442676203, 0.13136159157728855, 0.32314004548642883, 0.13010151629104127, 0.1635215377915854, 0.17716024032449718, 0.13133437127836478, 0.05589952337807713, 9.999999999998899e-05, 9.999999999998899e-05, 0.07056663904321725, 0.08878121395764516, 9.999999999998899e-05, 0.0007890669064648526, 0.029405986161199493, 9.999999999998899e-05, 0.14779092499389845, 0.08781992615466439, 0.17608975591195863, 0.0879837529157087, 0.1094841109990492, 0.035693604308607574, 0.16001155114270438, 0.10936938163435861, 0.09295948412829746, 0.16523560510459012, 0.007836092126181526, 0.13998694822145374, 0.06797179753823568, 0.10850635071214143, 0.05450248519409451, 0.05725095938840474, 0.15898662303995026, 0.2730563781370744, 0.04735980581155996, 0.09871202971950932, 0.11157829068067526, 0.17161157203859745, 0.16683212333904684, 0.037615061107889924, 0.12393825823278148, 0.1508703933200981, 0.09002381005943694, 0.39996943871223034, 0.459824465317349, 0.4224236279213637, 0.45145768412899356, 0.4333242234242134, 0.46543509149433315, 0.40802490030614613, 0.4882459760123158, 0.39083353099827933, 0.07892345531224232, 0.06888622267276556, 0.13748581989305364, 0.13096318351553726, 0.11671544972978687, 0.13781191313255858, 0.09122287107631621, 0.11678134187764244, 0.07933151543464523, 0.1833635818651057, 0.17624881910704338, 0.1866509135978085, 0.30098682307765634, 0.16748769886986992, 0.15055676422047526, 0.21059120830534783, 0.1885569460388158, 0.2244855781748024, 0.3457103979669164, 0.3054790152428226, 0.343646109359922, 0.30008705769960664, 0.2551405191359809, 0.2694214604455193, 0.2614152119441343, 0.36687258631783093, 0.33749061962640026, 0.11229962672965343, 0.2232537773011094, 0.2153786364296174, 0.24266582603668618, 0.23942820025216272, 0.24452034342173556, 0.1826944710249102, 0.17454476707303834, 0.2308717700405959, 0.2377376607308952, 0.2062521383429694, 0.2301231096789339, 0.2415198603139702, 0.2186720592875505, 0.24037067117205968, 0.21469108880714316, 0.20192671354386138, 0.2381387607791977, 0.21500513692565637, 0.20251700101322012, 0.2302376902301566, 0.22608158565470982, 0.2198656794687618, 0.22309599907129718, 0.2385421597967755, 0.2046313423026227, 0.18956965371891987, 0.15940485076842814, 0.6096023123827401, 0.15918960135787186, 0.7420468380241495, 0.2016943651415859, 0.11701553118610608, 0.5496530121416578, 0.16010687706889548, 0.16778714610547285, 0.4216294281270707, 0.17028866642972185, 0.13909802672900207, 0.1696597799790961, 0.21307573812695513, 0.21193840867185865, 0.41925847144007544, 0.1051474440084319, 0.15592138616169282, 0.1781051724920406, 0.19762492659242847, 0.1921988604678707, 0.22041426704276335, 0.1944747836514672, 0.21415676366061787, 0.18447983635678966, 0.1906662977334016, 0.23615099134345052, 0.10765489385504612, 0.08267567856522073, 0.08200129313383386, 0.08265347111095611, 0.11658602108947691, 0.1101577454703554, 0.08847991269580213, 0.09421436807822448, 0.09850164127183691]}, "mutation_prompt": null}
{"id": "f0869171-7473-4989-9cd6-f814a1438e64", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        diversity = np.mean(np.std(self.harmony_memory, axis=0))  # Calculate population diversity\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - diversity / (self.ub - self.lb))  # Adaptive scaling\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on population diversity to improve convergence speed and robustness.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'progress' is not defined\").", "error": "NameError(\"name 'progress' is not defined\")", "parent_id": "c44d5516-b566-40ac-beb9-9ca883278bce", "metadata": {}, "mutation_prompt": null}
{"id": "618c4920-95e4-4f97-8397-152fc70771e7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        diversity = np.mean(np.std(self.harmony_memory, axis=0))  # Calculate solution diversity\n        self.f = self.f_min + (self.f_max - self.f_min) * (diversity / self.ub)  # Adaptive scaling factor\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - (self.eval_count / self.budget)) and j != j_rand:  # Adaptive CR reduction\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Integrate an adaptive scaling factor update mechanism to enhance convergence by adjusting mutation strength based on solution diversity.", "configspace": "", "generation": 50, "fitness": 0.24379023631950744, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "c44d5516-b566-40ac-beb9-9ca883278bce", "metadata": {"aucs": [0.5560840761873584, 0.6301017354255127, 0.5718157708801846, 0.5961534929579662, 0.6018566546266224, 0.7003321110681952, 0.5980997931232147, 0.5899991981989005, 0.5939001028349757, 0.12287162440499455, 0.13438998448469686, 0.3036948923209293, 0.2084484163034378, 0.16968653108631482, 0.09708117273455152, 0.3033408914688339, 0.11023322266289104, 0.18615095984684116, 0.15846141349647447, 0.1531661239910792, 0.21735423540081278, 0.1558630186018669, 0.3199767746967439, 0.25112761701201924, 0.26835570163224753, 0.19176987998198203, 0.17309741108813648, 0.15717887578298362, 0.2090250274047174, 0.21171108754370938, 0.17623460237492905, 0.16808568992327888, 0.16951301818344322, 0.23044749253898966, 0.16801600857218624, 0.15207168129506776, 0.9854191577878737, 0.9585260170599438, 0.9699016166701725, 0.9620586053823565, 0.9578112282888354, 0.9682501233161713, 0.9750149535942962, 0.9443229750773952, 0.9666461682368042, 0.3146232721072646, 0.33489539501979837, 0.28869373595517633, 0.3232453059749605, 0.39753644744758554, 0.3235818000821463, 0.27956243849439466, 0.29930236860539916, 0.3038370167314194, 0.21756153587511895, 0.2612696638771749, 0.14100893166999173, 0.2842931825126451, 0.19196255959626474, 0.19882250573905536, 0.18015655020045218, 0.23542638367378865, 0.1803655367925434, 0.23406769253611903, 0.15511953015686308, 0.17423748858399335, 0.1901580735311038, 0.15058073364096436, 0.16412971664385057, 0.18702788883193333, 0.18575781848025197, 0.1491765840119379, 0.15508881767136595, 0.2620513300755182, 0.1537873764588843, 0.13398853522591547, 0.20460016801525704, 0.15715730482000378, 0.20101906542504622, 0.14122985974565183, 0.13192907498992723, 0.020608706708987623, 9.999999999998899e-05, 0.027629058163365916, 9.999999999998899e-05, 0.08382866561523694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05849749920476843, 0.07854518982522463, 0.11281289885806178, 0.09548935328035935, 0.10995879146446985, 0.1633343651150384, 0.09696165973022453, 0.09046323958543812, 0.10367352184636713, 0.05808397756632544, 0.10837753643917936, 0.0027619211900695717, 0.08407302236549508, 0.08180630603408223, 0.06004681970894121, 0.028748767414876197, 0.04617433187087516, 0.03596000113061959, 0.07238137056128058, 0.04235501462935842, 0.09209719112904713, 0.06983837508672563, 0.12677947615131357, 0.14109890857667085, 0.034473702145403906, 0.16107304162337022, 0.13431645716076468, 0.08084305912031997, 0.36411414438886824, 0.42142732709129005, 0.45510562991750436, 0.4338451097380326, 0.42983346008712187, 0.41103036480969246, 0.40117075745836805, 0.42533022902243345, 0.37219004224930574, 0.09128243803793934, 0.12605342643476647, 0.06860507514202996, 0.11066153083361208, 0.1738330771285691, 0.06947036981307808, 0.09949329015005948, 0.14804957195943536, 0.12692202630306437, 0.21199043293428588, 0.15813730565807094, 0.15328022716149559, 0.37683624041515695, 0.23355040804363236, 0.16835873337309093, 0.26876229437275534, 0.19189373387313569, 0.1844579502183853, 0.32734151639628606, 0.23151862182089988, 0.2163983783396377, 0.2884451353678127, 0.3060947899138253, 0.33916855770403376, 0.3247675358795292, 0.23004666718059197, 0.20707946481846362, 0.15392495150035646, 0.23697265565851544, 0.20627557523036755, 0.21349523847066043, 0.22949008572066454, 0.27685519686108295, 0.21835024090481314, 0.22866411607660897, 0.1943013835959253, 0.22200595369401388, 0.21812244983163387, 0.21736863083221314, 0.24850922349925308, 0.2081360552902526, 0.2670622773983019, 0.26197523561416625, 0.20886623669530213, 0.22996267665551162, 0.2525947482063199, 0.21723431363303558, 0.2022018347354918, 0.30611540728987896, 0.23054712829042967, 0.2272619447229406, 0.2292131427873324, 0.2064951288693334, 0.21684916602019788, 0.1595948390585925, 0.6040571190449135, 0.18913560395665974, 0.6018534213546705, 0.20148554904360838, 0.17903404362071051, 0.14903374049018348, 0.21390674226750617, 0.15959664851365873, 0.36364740222259984, 0.21235387168534503, 0.8457310185954006, 0.29840469720947727, 0.21125539808699545, 0.21032543032461593, 0.21336092438820764, 0.2821469418752329, 0.09488574593681931, 0.16965573422682323, 0.18053788238625512, 0.18440245549335355, 0.1986851810379141, 0.17475756239530948, 0.20794735902942352, 0.17835905222434956, 0.19489318888475715, 0.19292433045453972, 0.094231196759609, 0.08294731709715142, 0.0723602567606747, 0.11382877390608737, 0.10969552157511386, 0.09055422768681942, 0.08671182617852957, 0.08349766867449926, 0.09300445639336974]}, "mutation_prompt": null}
{"id": "75cf241e-825d-493b-a341-c22c847bb323", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 51, "fitness": 0.3253462262907614, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "c44d5516-b566-40ac-beb9-9ca883278bce", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "688018a2-45d2-484f-9d23-0f20e7cc12d4", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "1c32e1db-46bb-458c-9433-72d21c93482c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "d62be374-4b6c-4116-9e20-d4cb524bf34c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        hmcr_dynamic = self.hmcr * (1 - progress * 0.3)  # Dynamic HMCR adjustment\n        for i in range(self.dim):\n            if np.random.rand() < hmcr_dynamic:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Refine the exploration component by introducing dynamic adjustment to the harmony memory considering rate, enhancing adaptability.", "configspace": "", "generation": 54, "fitness": 0.315611290117922, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.718138817202463, 0.7468081071525623, 0.7660591889421092, 0.7231971845098202, 0.9160292581360518, 0.6327660332578223, 0.8474593536127708, 0.5781432600612277, 0.6326280948738146, 0.7440707139149649, 0.6778883162382239, 0.2477577880715085, 0.40071754503562074, 0.4865683672142017, 0.7787343435107481, 0.5633780469152905, 0.5844645325485314, 0.7782406511962958, 0.23565273132995013, 0.292020048632496, 0.20246463418974203, 0.1556923911501421, 0.16864838989830844, 0.1910909847549953, 0.19949253620919272, 0.22697062923532696, 0.16006965293858044, 0.15283931833918674, 0.1792492705771832, 0.14946299117770523, 0.1504309390499622, 0.1857415708750243, 0.15761451648983982, 0.13585018634155055, 0.16660059486929335, 0.17164219018460602, 0.9809902327442003, 0.974320411325472, 0.9825604995584479, 0.9864344488787646, 0.9793906762666811, 0.9790735603483415, 0.969782602569714, 0.9797998831709162, 0.9766556077788843, 0.4050210530552799, 0.3288384796839332, 0.41674849779265943, 0.35191073918105853, 0.2840019075686566, 0.3558774752627579, 0.43179338559073677, 0.28354086927618405, 0.3813143286748907, 0.22974459320894447, 0.1571901367096491, 0.2279408190890223, 0.27976462181973016, 0.3400510492178087, 0.38432138528779947, 0.8609038834368729, 0.2378562055759197, 0.9117536272157791, 0.2287348551738192, 0.14792566896500225, 0.1641064285327879, 0.21643683580918005, 0.34052745907060167, 0.17446317706265801, 0.15955461370978885, 0.1573970899921856, 0.19626277630497513, 0.14992169767840247, 0.33740119530004764, 0.18907429659266295, 0.19757334536140037, 0.13643199765386949, 0.14175609251701915, 0.157227804099205, 0.1744266031520545, 0.14239869118829285, 0.004195296920628588, 9.999999999998899e-05, 0.02645162142721258, 0.13018134374847123, 0.05273544116870743, 0.04866449463521205, 0.04709297268920454, 0.04322349047797269, 0.03982708327867113, 0.14404420869546797, 0.21527661485470406, 0.18307394921203202, 0.22486382558997786, 0.1556311504837664, 0.033973551969112115, 0.16209712449647817, 0.15495479160459746, 0.0910486515098834, 0.3108069850969962, 0.08703832063151529, 0.06580155899521811, 0.1938404262170197, 0.08325571159398515, 0.09543991252614037, 0.1662416560377038, 0.17750355231714587, 0.11280760472893148, 0.2903591250020714, 0.23353069825269757, 0.3834471920503504, 0.274570798441776, 0.40162983171302713, 0.1900335817798654, 0.3022158785871536, 0.1719097778563622, 0.22394334007587857, 0.6466999580513004, 0.7113024663916034, 0.6134852126091631, 0.49222087438006623, 0.5572946608493987, 0.4873589274520632, 0.6078583126564663, 0.5383858729593534, 0.7555800407492519, 0.12221436947986564, 0.10355417307014525, 0.10244706678632143, 0.11996263937351703, 0.12597979046371133, 0.1426802019026603, 0.11053743326721777, 0.13440345378722995, 0.10962337771314667, 0.21443183748222427, 0.21816576894457462, 0.14058156284167977, 0.5258214217227627, 0.20800895091077554, 0.28040559257236264, 0.178665813376221, 0.20833528835091641, 0.19168823279210379, 0.32330123860828486, 0.44516700538789256, 0.35138078077258494, 0.43836497869433, 0.6112369580656027, 0.4297867594152872, 0.6764342951323636, 0.30886335786485475, 0.35531428557979194, 0.26448261375850046, 0.25872045634810603, 0.21719203662099962, 0.2837907819051608, 0.34099738623237974, 0.40322253170893907, 0.2667426105188707, 0.17327595482197244, 0.20033498968405827, 0.23923059029470473, 0.17988064336023712, 0.17810092263803234, 0.19909257348234033, 0.229691523476793, 0.20410878266730248, 0.2079979045142034, 0.2165936530590734, 0.205082515950062, 0.22597373112029928, 0.37997149917956485, 0.2525524503766279, 0.23068113753873254, 0.24741877800614498, 0.2284389162459598, 0.5145519682721035, 0.21867752666307594, 0.2537451034303494, 0.18862292643562728, 0.18854230255107796, 0.16612045025129374, 0.935888702607025, 0.6747030251451311, 0.9467455540851719, 0.20156936367395795, 0.21100472541800563, 0.16731046558185025, 0.4977000606959642, 0.16939593439286238, 0.5520447665463376, 0.16971599112775948, 0.40555398235066775, 0.3227483431837641, 0.21700290836555636, 0.21360608154227134, 0.20005205741957865, 0.1665135150949456, 0.17208502186532149, 0.19731907551791028, 0.21486983154028927, 0.18424175481203542, 0.19452122266801986, 0.22901844830512108, 0.18248399194259246, 0.20208496645413865, 0.09281451921878237, 0.08280117025644174, 0.07734534188227593, 0.12669382540757101, 0.11855089311076794, 0.1015320328268261, 0.09000333342625033, 0.09931054271706885, 0.08783264296309334]}, "mutation_prompt": null}
{"id": "7652fb16-c0f7-4759-9487-e7ad8668a46b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "ae581772-af5a-473a-a6f5-666939a6cc97", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "3127f8b4-8d52-49f9-851d-fa64238bbd26", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "7044124f-82f6-41b8-ba2c-92dfc992146f", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "926d97d0-b2ee-4233-b58a-88f353f82b19", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "b5fe88cd-adbe-48d5-b5c0-fbadad2e8726", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            # Dynamically adjust harmony memory size\n            self.hms = max(5, int(10 * (1 - self.eval_count / self.budget)))\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic adaptation of exploration-exploitation balance by varying harmony memory size based on progress.", "configspace": "", "generation": 60, "fitness": 0.28602996238634226, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7537806525811799, 0.7248074980139729, 0.7268609264647127, 0.6770817526083839, 0.5894186004372644, 0.5716555404855066, 0.9016903825079797, 0.8551774091140558, 0.7281472129370912, 0.29991638350533023, 0.27399863375577016, 0.6157980005106121, 0.3048309079971224, 0.45452130802285684, 0.4776506014675215, 0.3457283209870694, 0.4544027874264178, 0.5177762242506676, 0.22366369003894915, 0.14318702044869946, 0.17164805245258485, 0.22285706170240405, 0.2613857311841913, 0.16016098200631057, 0.17997050709672535, 0.1480552970464203, 0.2244724685540228, 0.16166006799558985, 0.15106744431015517, 0.1570828455445149, 0.20576359493971463, 0.16030097166623114, 0.14602950776731938, 0.16849046342309482, 0.16913991677064355, 0.256037108492003, 0.9700231276629032, 0.9708778828419234, 0.9762654168183316, 0.9812024867203808, 0.9473057257903039, 0.962360479047841, 0.9556700450220138, 0.9902472995820086, 0.9776510666409229, 0.3041182008335467, 0.2669475188090069, 0.36183955768933707, 0.36478898840795304, 0.3163110578605828, 0.3030553540334827, 0.35565582750119473, 0.31598164696934383, 0.3573346471890758, 0.22509747870697738, 0.166885471944908, 0.2289934721688195, 0.2773398136079951, 0.2118840483151908, 0.2847140673341432, 0.9117690748329093, 0.2390109860320766, 0.23276416873273764, 0.143997803731732, 0.4304550551915196, 0.15019068668922408, 0.16353951592120497, 0.17441887959365854, 0.23298542629473662, 0.14423320189420175, 0.486536030829564, 0.19586488933908042, 0.13730458368345932, 9.999999999998899e-05, 0.24160437080452069, 0.3116521485184568, 0.16069253297294273, 0.1756581200400742, 0.2191519808089567, 0.14128329424902386, 0.1737153433571379, 0.11464421512602097, 0.05158974369797231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044880001364814404, 0.00275827439712939, 0.07015979350343426, 0.14318521995450917, 0.05540457457155701, 0.09540886049384356, 0.09145358131266423, 0.14507982435424094, 0.09704152895651874, 0.10701185223236576, 0.10089485535065523, 0.1826062718196435, 0.16482645807880292, 0.23592261286196314, 0.03839119332105079, 0.07448200990778697, 0.02082067029034973, 0.26581186336721174, 0.12133598709107285, 0.11734220909274573, 0.3064762046815668, 0.12279515750343784, 0.1044951728607455, 0.11754394842293059, 0.12983172074097005, 0.13332052162759533, 0.11455356426049379, 0.26058783306077915, 0.21705823806808344, 0.26756096137099306, 0.43849985577267736, 0.451274289729255, 0.6597926267932677, 0.45996222729555036, 0.5227269025502469, 0.6262918322015201, 0.5301980663855177, 0.471537864542674, 0.6042457657420796, 0.13367995598123306, 0.14187604424563638, 0.09713850358164655, 0.1576660741304, 0.10898316217960835, 0.1488028465385416, 0.14378895528937685, 0.1238050118237205, 0.11309665303125416, 0.4742666591752762, 0.26220683125156896, 0.22355725031325768, 0.2256678375522878, 0.21189549054122547, 0.1953868882543166, 0.21770181685408574, 0.21362250353389167, 0.2057148707425991, 0.34180252911817166, 0.3413422460084091, 0.37414188249277536, 0.41770721410740186, 0.26076373666952346, 0.3238174744102972, 0.39402481907912, 0.3519957791038332, 0.37662696518477534, 0.2826464599051943, 0.2001053978364189, 0.2130496215321952, 0.33808897364378154, 0.22733332154297015, 0.315088235523442, 0.14034057194958005, 0.22887163201306893, 0.1406954135535431, 0.19740624025232367, 0.20408953925933104, 0.21295628800205213, 0.2897249964205363, 0.19286607100033848, 0.21416019687867094, 0.2188728921628874, 0.22137484663972407, 0.2084315721717206, 0.2560193527961535, 0.23821423258406027, 0.25611998730945396, 0.22183326294185213, 0.2267554729991872, 0.20417225668386396, 0.18371418295646236, 0.22708040841418986, 0.2230775639370688, 0.1593546952363768, 0.18689912901290895, 0.1654963559985455, 0.46461369685213616, 0.9077226100000929, 0.21145984591584188, 0.18931746043175324, 0.1688962632352239, 0.16677854628362054, 0.28644968420491224, 0.1374713897798021, 0.6350169873953903, 0.355822474473952, 0.21108283378646497, 0.21330402337227783, 0.765254394905112, 0.21506831771617985, 0.5969295170335787, 0.18319646505834775, 0.1730741385784118, 0.19375413791581286, 0.17236029347128312, 0.21816448873964778, 0.18785205333372723, 0.19180373363709602, 0.2011823116683108, 0.20430005333711887, 0.09591405672361364, 0.07933227285722155, 0.08999138710758636, 0.08053737170945352, 0.07934540120039713, 0.08867159363643207, 0.08581013687929084, 0.08272295449997857, 0.06945280307249724]}, "mutation_prompt": null}
{"id": "9fdf6406-9209-4263-b67a-7fdfc4bc499c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "fa3b9be1-eeb7-4a90-be9e-ef6c8064c05e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n        self.best_fitness = np.inf  # Track the best fitness\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        # Dynamically adjust crossover rate based on improvement\n        cr_adjustment = 0.1 if self.best_fitness < self.hm_fitness.min() else -0.1\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr + cr_adjustment) * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n            self.best_fitness = min(self.best_fitness, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by dynamically adjusting the crossover rate based on fitness improvement over iterations.", "configspace": "", "generation": 62, "fitness": 0.3178311784667347, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7779899685792085, 0.6361112330240635, 0.905530066677974, 0.7881185371394164, 0.8151067324084232, 0.6941393127440123, 0.7098938064619162, 0.9257725081031246, 0.6840415211471012, 0.659036426526695, 0.6261374764267176, 0.5619472751389305, 0.5222205840897161, 0.31774982981367206, 0.8802961375866288, 0.32636597397411826, 0.8775357277063525, 0.22205932327916567, 0.49084736464273904, 0.15745677691971072, 0.16380581472984235, 0.2888814563287351, 0.1787370576936348, 0.18599086130778375, 0.18763317085037945, 0.4283035672042962, 0.16805823088573257, 0.18692099490719516, 0.14885141956278536, 0.1717402976116349, 0.18190801177440863, 0.17277217828185787, 0.20378911874114913, 0.1697353281036783, 0.34288120372400777, 0.16484533137984259, 0.9827023875085448, 0.9749442918197266, 0.9769332190860955, 0.9808322786663577, 0.9845333995579177, 0.9662552470766926, 0.9820083168455888, 0.9853817852279404, 0.9885518212766008, 0.43212362127360104, 0.4380296764913254, 0.33957552140819425, 0.4174983103036065, 0.43201432857283995, 0.4769418689499184, 0.39369580467826315, 0.39762970553995314, 0.38087475453890574, 0.302703200109385, 0.22195895751369232, 0.32605470007526494, 0.38667621416261977, 0.21586481525198498, 0.3629992894362142, 0.17899438896141873, 0.23618143331952568, 0.9257601336556205, 0.24247630209414683, 0.1536930410711821, 0.18977048424207543, 0.142344686186467, 0.1340721835957216, 0.16099421898081456, 0.3190183596000856, 0.18694132334574698, 0.17086705311079475, 0.1537483204479706, 0.1553854735427509, 0.21808242909036513, 0.13147155752023643, 0.16868128325847187, 0.13712090933134602, 0.19643502508331945, 0.12167205158640115, 0.1348523923657463, 0.2767207838898893, 0.09171654365948034, 0.027320168899142683, 0.08080832244417702, 9.999999999998899e-05, 0.12345012469124672, 0.2115970236546878, 9.999999999998899e-05, 0.0939117748627456, 0.11837507555302362, 0.14003206283617842, 0.21038015805049415, 0.08609492616021874, 0.22600158971308304, 0.12520130983252675, 0.20123890233741581, 0.22736871459514818, 0.26606929048444883, 0.2479054106582409, 0.08391575362286807, 0.1371969289688335, 0.08395353864019561, 0.2267427833996356, 0.3125961631803835, 0.09747137571733133, 0.16355729408644315, 0.1401319935300802, 0.305964450421078, 0.26200208582514684, 0.10497717702605736, 0.19592613929386005, 0.05033492985269317, 0.15789178946947524, 0.24653525999643366, 0.27020651036882126, 0.23426830969629486, 0.4973119351142593, 0.6576333823165472, 0.4769317856569274, 0.45428008203238857, 0.5799069969145645, 0.5423798683592571, 0.5890069170905001, 0.5735362176628742, 0.6785356757254677, 0.15851901248071465, 0.11901439948787462, 0.12962097079478185, 0.10984944015538278, 0.1409370540765822, 0.1432774352732913, 0.1428588491635321, 0.13894009868888402, 0.14695913905922786, 0.22024422514164887, 0.20879386953491308, 0.31192895722879466, 0.26914377640623544, 0.18959370699158729, 0.23897699593824173, 0.38359833578121216, 0.25876689942625, 0.43734809924165297, 0.24973357706485333, 0.23443709852371064, 0.30298138818379294, 0.397450061994707, 0.2562229985506117, 0.32146350656256895, 0.3843796463902772, 0.3694594415982867, 0.46896000728535214, 0.2262179877631858, 0.29987278540620366, 0.26712021767816974, 0.26233075259314265, 0.24283638500910354, 0.27378931340945545, 0.23735172697551177, 0.2608338092131808, 0.2925451661526369, 0.21978240106000613, 0.21679850128806, 0.22729514671591866, 0.20017669422137419, 0.21774878647142237, 0.28403875148230684, 0.22120176272138292, 0.21153677153229966, 0.22971262719021568, 0.20797816129920488, 0.22662069559054687, 0.45081070034269544, 0.22747095492517533, 0.20943363063364573, 0.2533299756453664, 0.19072636459734937, 0.20903019794805178, 0.4485259620783325, 0.18867273505310556, 0.1887115241925058, 0.9297334974280779, 0.9505965458276284, 0.20064679917645745, 0.18660436111272116, 0.1681934739337836, 0.15917844783158652, 0.17687335430603723, 0.9388913420267668, 0.16958812091937603, 0.6396376710328496, 0.38726593933428, 0.21346859972427235, 0.8204697770731296, 0.11308912144727257, 0.21398768196765328, 0.15562774752871078, 0.1877181091096206, 0.17727996549847502, 0.19812348070890895, 0.20647885800779564, 0.19326884649213083, 0.1830552920448788, 0.24474071895485727, 0.17665753301351794, 0.20344948556828013, 0.0875612458501055, 0.1277205512737375, 0.08511635259614958, 0.11930207179237617, 0.13898994348941052, 0.08149476929941557, 0.09399058685376172, 0.09913196202822816, 0.09149809781925977]}, "mutation_prompt": null}
{"id": "6b51d249-f785-4b09-aab4-86479b975b17", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "062a94e6-2c51-4276-bd29-b01813076bd9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par = self.par_min + (self.par_max - self.par_min) * (1 - progress * 0.5)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() > self.cr * (1 - progress * 0.5) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by integrating a self-adaptive strategy for both harmony memory and DE parameters.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.7962875423275353, 0.7419835565128758, 0.866902425088143, 0.7248720881212484, 0.6805343289928047, 0.6556129837727735, 0.9157666371414201, 0.9364305581621143, 0.8359928477201201, 0.6362081042663954, 0.3507839926994223, 0.6309040485949773, 0.8522035160255559, 0.45800470574272256, 0.4151034809344555, 0.8162714302900149, 0.5942713143948137, 0.48524893493330723, 0.187347022050545, 0.18517890894649702, 0.3671888510084276, 0.3636448731192673, 0.14519813326552755, 0.17906743611859, 0.18711837814297083, 0.2643753381073688, 0.14615417922233098, 0.18515048788707633, 0.1635184396387407, 0.1543936371843887, 0.19241893863400628, 0.23195886908826024, 0.18840416113433078, 0.13848801594836369, 0.1742533160314963, 0.16380421333849804, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.36806333240207667, 0.3818063319364755, 0.4597533475094163, 0.32623823858219725, 0.38123279257054776, 0.4133253791688899, 0.3975135526881982, 0.42020176412112165, 0.4392161587266169, 0.3278689328422041, 0.10765877027090953, 0.2265703109649928, 0.9130990964485916, 0.3601353074222524, 0.3296397737368614, 0.2580526793482598, 0.9290553547877848, 0.366078368998934, 0.2428386933550628, 0.2003774678630258, 0.1568919278290628, 0.17453933015035605, 0.1355824815352511, 0.15924344678721136, 0.151290321151754, 0.15696527598575472, 0.1439621314630085, 0.1689937837767992, 0.4192479873433901, 0.17278232193557774, 0.16667590891671447, 0.18604200956685912, 0.13649823842202768, 0.17326486261338248, 0.20012233760833387, 0.13807956186297088, 0.04592875377703043, 9.999999999998899e-05, 0.09282335467315284, 0.10711588966322927, 0.12875170877752384, 0.09424196427074238, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344196974939092, 0.126126154591778, 0.1399754270700767, 0.31713954245986886, 0.0854854423361665, 0.1942184381249612, 0.051946660341111284, 0.11888868507119099, 0.13108815519565797, 0.13312504337931264, 0.12472496870333727, 0.04545739495008405, 0.08551900310161387, 0.10696677854317516, 0.4926906406713065, 0.11257471826286836, 0.08318206198931077, 0.3502818260051269, 0.11188838074689322, 0.21829886200817505, 0.3857579295495549, 0.23091507547473922, 0.3829520772107804, 0.3249823129969426, 0.2474092851633699, 0.33704882794481916, 0.2264333163290828, 0.20460174357534378, 0.5236005840692977, 0.6653616071677746, 0.5848330506640931, 0.63898525195622, 0.5334114905025764, 0.6740184120244692, 0.47208919964670226, 0.5191450312945239, 0.5143212141177238, 0.1468866248246219, 0.12151830066348013, 0.12180585242209141, 0.10130199053272826, 0.09492153159748651, 0.12582896765519558, 0.12170050391537623, 0.11097312731467446, 0.18000902508680205, 0.19614007163609715, 0.19408923831800673, 0.2770034547032627, 0.2208443677947911, 0.15779647433552113, 0.26649023264124483, 0.18645464711082782, 0.26165851153946573, 0.25980369576880025, 0.41489321511504085, 0.4509456246197995, 0.47771506940788544, 0.3905483379469462, 0.4235344956369168, 0.5060233711236017, 0.3616814249544884, 0.39514621387502735, 0.31828996691408473, 0.283786885570672, 0.28779448100115124, 0.19830024287576975, 0.3335693590960441, 0.44027200809759515, 0.3327360050008319, 0.25410649039207234, 0.2770983345537281, 0.3929495217824247, 0.22273088330552615, 0.20688655470358264, 0.1887232009825971, 0.24495066794284515, 0.22920402123566497, 0.22087216091863648, 0.22024347102810393, 0.20565911409003568, 0.2255176795984346, 0.2090550380275742, 0.5113131190981381, 0.2336962433770664, 0.4970369055320165, 0.25541796182061216, 0.4187465289140033, 0.20949935647425655, 0.2280848454998422, 0.6273208382024211, 0.16856936207407813, 0.18855171847044772, 0.16613545713548172, 0.9262852114659343, 0.18911915249043265, 0.9439960064075382, 0.1593311680756393, 0.21173052327634645, 0.1672835981483608, 0.9174764067396705, 0.16939516358598683, 0.6716684807569859, 0.16990185242794653, 0.3817943806599723, 0.38067996868659804, 0.105174146936314, 0.21367798707265218, 0.15670591067219142, 0.18458202738129226, 0.18422354323819035, 0.1829163257648594, 0.19082774077255282, 0.2066203002426762, 0.17409158912665312, 0.2184985180152489, 0.18516544842965055, 0.19992255171492124, 0.07689432079552883, 0.090741397336352, 0.08017083860897711, 0.11450422054928133, 0.09999734394051174, 0.09976941998541766, 0.08814270350046449, 0.10978513292453862, 0.09430242287732615]}, "mutation_prompt": null}
{"id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 65, "fitness": 0.32839045225610114, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "75cf241e-825d-493b-a341-c22c847bb323", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "34b467a0-265b-4599-8658-5a9b43802108", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        self.hms = int(self.hms * (1 + 0.1 * np.log(1 + self.eval_count/self.budget)))  # Adaptive HMS\n        self.harmony_memory = np.resize(self.harmony_memory, (self.hms, self.dim))\n        self.hm_fitness = np.resize(self.hm_fitness, self.hms)\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive harmony memory size to improve convergence by dynamically adjusting the search space.", "configspace": "", "generation": 66, "fitness": 0.32839045225610114, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "72b226d3-fcfe-4cd2-a3a8-e66649ea2e57", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "5bf5fd2d-6444-4d9d-b213-5faac9c8e4b1", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        \n        # Introducing fitness diversity-based scaling\n        fitness_diversity = np.std(self.hm_fitness) / np.mean(self.hm_fitness)\n        adaptive_f = self.f * (1 + 0.5 * fitness_diversity)\n        \n        mutant = np.clip(a + adaptive_f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive mutation scaling factor based on fitness diversity to improve exploration in the early stages.", "configspace": "", "generation": 68, "fitness": 0.32358388203107064, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.6782776016197373, 0.7693100143460174, 0.8690027614102764, 0.9208464523778634, 0.8668841376833679, 0.745841403814662, 0.8318250739154539, 0.734387614825173, 0.9346522551441667, 0.7624230151380517, 0.6687933192459946, 0.4566744417231935, 0.5059153107912466, 0.36092241740257713, 0.5795384186402195, 0.3290857517419069, 0.10609776692046269, 0.44495402047181964, 0.6250203635748279, 0.16455375628652857, 0.1945094551199973, 0.21908836351194527, 0.1885056111456247, 0.18222330728857983, 0.6081727887145618, 0.5633209808544337, 0.42193848114502974, 0.172248436642378, 0.16386141956488687, 0.24124600759542347, 0.15520604328379972, 0.3494942469391591, 0.1537136900155207, 0.15655391783081052, 0.17362954871160985, 0.1554264194329833, 0.9850718472871289, 0.9746656583918563, 0.9919647334783038, 0.9856363951780175, 0.9861101917395555, 0.9750351282638563, 0.9677728605505471, 0.96834867860509, 0.9668124429089082, 0.45101795162777314, 0.30972039597449375, 0.345326886777519, 0.33849364905088086, 0.3099811822432893, 0.3594183781272423, 0.32003292031754604, 0.5409383157453436, 0.3357598670948553, 0.39708545829120967, 0.22085160678296223, 0.9322809410891788, 0.19573824015243935, 0.2766157671130961, 0.36481576250359604, 0.2275961893782058, 0.23698514821431127, 0.15929390852504277, 0.13432128070922011, 0.15834021472213555, 0.1743257008872704, 0.21132852173999206, 0.15384737209393884, 0.15912876105647333, 0.1547876563342101, 0.16890450776354116, 0.1668489935343136, 0.2985407734029819, 0.15462174520728278, 0.2041490308687821, 0.1376493334168969, 0.40689448380094495, 0.17080513398001873, 0.1819649065555935, 9.999999999998899e-05, 0.2161074256348232, 0.08357202822046705, 0.03710202292742126, 9.999999999998899e-05, 0.002001740427367782, 0.05468892815569637, 0.05829716586730593, 0.027036671442882243, 0.007414637377162414, 0.011329233495204427, 0.08670610531658163, 0.26048420754248236, 0.21549453179575728, 0.09083874726426189, 0.09215262891504916, 0.08388117306102338, 0.33067143801062415, 0.3745562064695006, 0.1338092972325321, 0.08765216717693924, 0.07001903765615825, 0.1048959875173916, 0.07855843491386316, 0.23485807609953313, 0.14170644983396563, 0.14062631896878353, 0.3134529848164871, 0.22151203139491993, 0.2509642502927826, 0.09431529535138128, 0.28675907854540905, 0.3570485024888457, 0.18591740484121289, 0.33755647474779016, 0.2087898680854975, 0.307938947680625, 0.42630207230734285, 0.5419225176003633, 0.5056142651700931, 0.5527060902804126, 0.5255237573119269, 0.622426968403311, 0.560569693345545, 0.6683496797931214, 0.6659797450003146, 0.4957403727210048, 0.12730159295826637, 0.10517913035580873, 0.1377327509735704, 0.12605302691582743, 0.08478005174081904, 0.18414666680084235, 0.11568036346029198, 0.10715835714277, 0.12516651040200977, 0.2795548698588167, 0.2880079844203224, 0.2530890041941116, 0.2125446668258396, 0.26721496050335736, 0.2892008165932005, 0.22692003769303515, 0.21819734276613267, 0.23837199074665982, 0.4395605905968316, 0.3904343640513396, 0.2761442295399955, 0.37603376715458425, 0.5384143417876511, 0.35766478583774197, 0.5448372341838437, 0.5082598589881571, 0.3701244310345876, 0.22050213345178027, 0.26925993002234316, 0.2930085896400264, 0.3829207141212312, 0.20583275391176425, 0.2425305161417155, 0.46012505542384796, 0.3903607867071295, 0.34553174433446465, 0.21063153212399888, 0.20799241442191074, 0.2255419422707663, 0.22986210756965797, 0.20995341445268045, 0.24069971840892612, 0.21853633745747558, 0.201348257711504, 0.23933921873687347, 0.20453229394800487, 0.8821963691468062, 0.22674895143964147, 0.2537835195799395, 0.7178226487450902, 0.25396866826374787, 0.20089263874155316, 0.22617466051143797, 0.2533031201378225, 0.17245132241562455, 0.13655184705628487, 0.17223925789589034, 0.2010612955348332, 0.18902766529761372, 0.9371467469736746, 0.21000601364644977, 0.16400376972786257, 0.16665369928062534, 0.9138826960543726, 0.21234786342061707, 0.6096609835050619, 0.16966921390078882, 0.2105298916214854, 0.9385926818898628, 0.21303335830709458, 0.5368475981621139, 0.11325176295196437, 0.19580978966924045, 0.22848279154354645, 0.18310575753014458, 0.21166681298568102, 0.20398434689982992, 0.1954790462148489, 0.217720374035008, 0.19130753091727215, 0.18232225558021564, 0.09294457431109382, 0.08098280159891569, 0.08950859609678952, 0.08362088569029313, 0.1285518642307676, 0.1145109915656356, 0.09278509022715609, 0.07982558798650952, 0.08535379118022379]}, "mutation_prompt": null}
{"id": "c37bf227-3269-446e-825f-b69520881a17", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "b38811db-a506-49ed-9cbd-c2a6d21b0411", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "4c4d0150-e187-49d3-9451-fcd018005df6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "a0312010-1aa6-4122-8b8e-f6e698b6c8cb", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "98f5b5c5-0c70-4e5d-b4c1-b50d10a6269c", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c) + np.random.uniform(-0.1, 0.1, self.dim) * (1 - progress), self.lb, self.ub)  # Dynamic mutation\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce dynamic mutation in DE based on evaluation progress to balance exploration and exploitation effectively.", "configspace": "", "generation": 73, "fitness": 0.3045990844984726, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.6567203284297989, 0.6372102973127585, 0.6415193569477209, 0.6435203788022748, 0.6467564113514228, 0.6490642270301126, 0.6558869461366625, 0.6378452325815193, 0.6575272139476003, 0.3159440483394127, 0.2746231098445998, 0.320744775252396, 0.2851947803049698, 0.32492384012111575, 0.2712010497436892, 0.27058508237231815, 0.3184982305646433, 0.305476955936823, 0.15896175090747233, 0.17097903529791858, 0.18752562037202647, 0.17515702101848762, 0.18243916624967504, 0.2008956497190224, 0.3554060941589612, 0.16458855194419808, 0.1796962527199103, 0.16488625804245183, 0.14661082711216333, 0.146908961622625, 0.1408718739972441, 0.15705826463214834, 0.13055923628232635, 0.18286576420110834, 0.30960200640768476, 0.11975061123827035, 0.9820978505623741, 0.9730285802757067, 0.9734466773929682, 0.9781033677946948, 0.9734716814501043, 0.9902085428431573, 0.9730192053943245, 0.9648892493803899, 0.9815545404385739, 0.4374620387577387, 0.4196047899330456, 0.4759855767373674, 0.43330820123425506, 0.42449167701225266, 0.4396755061851648, 0.4402855100238534, 0.4189664343190471, 0.4192207049850073, 0.7424410643502645, 0.8303200324012456, 0.832791193773542, 0.8510048313387318, 0.9132663699968742, 0.2134714584694325, 0.7635725707009627, 0.25462246167870795, 0.2653643191696323, 0.2477334898810828, 0.21891867978490687, 0.2427414052704614, 0.314867140497364, 0.26697355789393373, 0.2780285813012857, 0.258733030118946, 0.235728022143323, 0.2839858604805463, 0.21716407101665924, 0.13020974973245758, 0.24431739232164706, 0.32895504354653227, 0.2684891608252983, 0.22987337494322635, 0.2259032422667645, 0.17627794916651418, 0.2223237755701154, 0.17426761016862002, 0.107986969884037, 0.060713382206662336, 0.01908962684840354, 0.018418956007999254, 0.0773710412495644, 0.09592637093555989, 0.08291481097314302, 0.12396090317992625, 0.058521094366018045, 0.16731294522534312, 0.11998504715507519, 0.13758708981688073, 0.15724840277939023, 0.08746945571125031, 0.23323438603769697, 0.16660099900369219, 0.16224755952307335, 0.04800347551888806, 0.014927228635404188, 0.02885191349525207, 0.03831525724455842, 0.04786856953150287, 0.0538430822165028, 0.04896409487460218, 0.0529625980516133, 0.0612528409857892, 0.16595624546114685, 0.17122001422705357, 0.16449179242859313, 0.19299771213564887, 0.18707470950783278, 0.15503680597079705, 0.170629507602169, 0.16531021573703197, 0.1595302921568329, 0.49467646922137487, 0.49386823857298234, 0.5220310857679313, 0.5168066959291882, 0.48650620543891765, 0.5317843081770424, 0.5098273282812109, 0.5358112666477358, 0.5257641709620262, 0.11984436250007913, 0.0798226824227728, 0.14408224170305062, 0.15185359467009873, 0.13854871773850186, 0.13573987625481154, 0.13334463602839164, 0.10008805484878325, 0.14808787372285437, 0.2603846279026467, 0.2356697739519673, 0.3824656144713747, 0.37505616719112445, 0.3014952697458667, 0.31400480663003527, 0.26516600553279746, 0.35887867381863303, 0.18286538595472535, 0.3657835946390756, 0.3432007071464349, 0.38068021314884304, 0.37449149213249633, 0.3721965156569308, 0.27272457707257414, 0.3761918775332781, 0.3769347609949335, 0.37009356902059065, 0.3044205580254117, 0.22906656894312216, 0.27316691574606444, 0.30465192751607406, 0.2960868220458084, 0.2949702544145556, 0.31015190722427466, 0.31069882662031834, 0.31354892146105606, 0.21041935839868198, 0.23342391859214162, 0.2403534923745686, 0.20484227901091845, 0.1990443491374212, 0.22380329978904412, 0.2561994615447949, 0.20105510532239634, 0.21073898906075594, 0.2256925732346895, 0.2525578278024382, 0.2248267110560379, 0.25251617720671915, 0.20206890983192194, 0.46349145280896276, 0.46097181321365155, 0.20818075114845225, 0.25479484805811137, 0.15960677734587203, 0.2125449170809719, 0.2133147549062625, 0.8421555074123638, 0.18896942819152995, 0.9126874887400352, 0.16868053593925758, 0.1263634487653268, 0.1425463947673148, 0.780509728152872, 0.2134880123063112, 0.12856470569530576, 0.16937813513336297, 0.8507716846502157, 0.2136231549161416, 0.11352188354836146, 0.21254592967983943, 0.15720667532949606, 0.18372922418069426, 0.1949155513992601, 0.20301142418984108, 0.21648385798266556, 0.19966823965242064, 0.19897500293814596, 0.18089597864899865, 0.22615338973026988, 0.1928297374205974, 0.09843660800702947, 0.09576150068146838, 0.08493359302215775, 0.08956407143779821, 0.09140302621459084, 0.09643426962995805, 0.0922184725661811, 0.08803579181103327, 0.09196170741809384]}, "mutation_prompt": null}
{"id": "676aa4c9-d1bc-4247-bc18-2750b9d99be2", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "6649a9d0-d832-4450-89df-63fa96a3ab20", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr_min = 0.7  # Min Crossover rate\n        self.cr_max = 0.95 # Max Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > self.cr_min + (self.cr_max - self.cr_min) * ((1 - progress) ** cr_decay) and j != j_rand:  # Dynamic CR\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced adaptive parameter control by incorporating a dynamic scaling factor for both PAR and CR rates.", "configspace": "", "generation": 75, "fitness": 0.3111340983934112, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.7778014548476881, 0.6641872817742978, 0.8410154022267751, 0.9287471470806873, 0.7716326064047233, 0.7222246179463852, 0.6792834515370085, 0.8680201852094505, 0.7127306802808153, 0.407926363897571, 0.3821080523590503, 0.3524615350163651, 0.5287155920252085, 0.3596228082842685, 0.6725813369301109, 0.6348032536707261, 0.2258920617381185, 0.6679600665477046, 0.16402920079934935, 0.3094175695223069, 0.22330877867687537, 0.460495910842607, 0.30202646530650623, 0.1829430649730872, 0.14790360041932782, 0.2788328852473675, 0.15976178095605842, 0.16111627549762741, 0.18376790817928224, 0.16828906699036283, 0.2027902015174864, 0.15123762169890598, 0.20707164931820055, 0.13026802555494865, 0.1658695084477838, 0.12507416031005558, 0.9856049710969567, 0.9794905459480883, 0.971194935582144, 0.9608084579507712, 0.9828260319594769, 0.9781965894228234, 0.9625692388596717, 0.978740365878733, 0.9774833255665253, 0.337015897790488, 0.28547545151695575, 0.4644566363073347, 0.34423910685600245, 0.319783154509124, 0.40483859153234303, 0.3610622763569139, 0.3935204790010116, 0.36639341884334076, 0.3073579979943907, 0.21816939907965294, 0.38649461772622395, 0.9303485531923419, 0.19436491544277257, 0.36635622668509127, 0.8599019917381572, 0.2518635836781259, 0.40076383304653973, 0.3207670296320092, 0.21751554561372155, 0.15387834590065685, 0.24454973774295719, 0.13651655295923448, 0.18120129529494144, 0.16345746936903105, 0.15174808255875993, 0.15829525215406082, 0.15736137370035996, 0.21523090696288893, 0.19014652435965773, 0.1343156317735742, 0.1534370210877869, 0.15055246556278612, 0.1847372982297214, 0.13664003640535116, 0.19446227987861198, 0.10939278619440196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060780665590033256, 0.2319887280551549, 0.003765676948549679, 0.00738536642146137, 0.1808957247819316, 0.08977285952764391, 0.10943078038788157, 0.11746788119934137, 0.13229969090065297, 0.3543678736184973, 0.18203762034326187, 0.28744428276325085, 0.2156364684276535, 0.05094818689083547, 0.078307234792796, 0.26876512009673303, 0.15318838422921743, 0.09412912205879853, 0.23299232318769192, 0.058065370259466675, 0.22085359720856812, 0.13959571964195383, 0.17813881337119564, 0.1983046027350368, 0.14834079862686544, 0.3449238212099628, 0.21071649718756136, 0.2040071737533249, 0.12220407091896957, 0.31603993675895403, 0.1370153523710156, 0.09743163545126121, 0.6403902641737576, 0.5746501108630273, 0.5015200361006882, 0.474765170639982, 0.5120380844916657, 0.5420980684625236, 0.5976402520887072, 0.5460976820114403, 0.47112773690884446, 0.13206861761438582, 0.10529645858671333, 0.1405239631845021, 0.11604277609560432, 0.18512748617661035, 0.12655482788168504, 0.09532925934560066, 0.09093229300255423, 0.14843181405997585, 0.1671681508602635, 0.29589786449633704, 0.4224263791638453, 0.23850438961766185, 0.17247488685565637, 0.28396164366958654, 0.171473291513344, 0.17473404670689174, 0.23272904733074107, 0.3196833753807097, 0.2857587517387382, 0.29215049172834984, 0.3612591442585317, 0.3407574644060256, 0.44468562601603967, 0.3515037221634515, 0.3228734864121403, 0.33309908637101204, 0.15722126673873105, 0.23670090247106212, 0.28880001777925013, 0.21579273233798302, 0.35562293262625455, 0.327753283455419, 0.23344956386375848, 0.31352874473915704, 0.3091752290845622, 0.20185423093262567, 0.2130033782659705, 0.23069756175300138, 0.19753454947189597, 0.19145836516505843, 0.2063395349456767, 0.2652911012799345, 0.2653048912794166, 0.21648000732136619, 0.22213847384848018, 0.20181856679173993, 0.2568816524029591, 0.2148666634448061, 0.2247725728322182, 0.20088267296922857, 0.25038463949621137, 0.2469127518528228, 0.22737577205966886, 0.1890827294698726, 0.9384761029589006, 0.9431374307579921, 0.9586534743105387, 0.9280509949717131, 0.20069845917714724, 0.16802598385172096, 0.16943555546608968, 0.16729715906498244, 0.575011477182193, 0.21256069369139519, 0.5219093420908961, 0.16846125610354157, 0.21193694269661667, 0.2107678522517532, 0.10505078975011906, 0.2129428314255788, 0.6005511241795347, 0.1819301718909887, 0.20295573037043924, 0.1818471556010326, 0.1892887817535559, 0.201736520721722, 0.1845042247095865, 0.18280635578465798, 0.2053881499218112, 0.1967038233496715, 0.09353477400363441, 0.135868210429413, 0.08271609397716528, 0.09795638247820038, 0.11140990807182971, 0.0721736968942388, 0.06835462117360802, 0.09138074381784722, 0.08555671834686096]}, "mutation_prompt": null}
{"id": "04e5593f-2384-4a66-9ea6-3bcb13f96b10", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "e422ca36-8a0c-477a-afb6-f4d44cf92aca", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        dynamic_par = (self.par_min + self.par_max) / (1 + 2 * np.exp(-5 * progress))  # Logistic-like decay\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  \n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < dynamic_par:  # Feedback-enhanced dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand: \n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance adaptive parameters by incorporating feedback mechanisms from fitness progression to improve convergence.", "configspace": "", "generation": 77, "fitness": 0.2957315433014973, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.7700974662206005, 0.6165887451289598, 0.6613966227168723, 0.933375484750183, 0.7492819467400897, 0.8803248893993763, 0.6572667058060171, 0.8141693112635943, 0.6199062895993783, 0.28186400643139187, 0.17061575236867088, 0.8605220015358421, 0.5739111889369943, 0.43412158610398854, 0.162167228061473, 0.24642450690666573, 0.17897806508466696, 0.2321518169799225, 0.15010585341312832, 0.1601910749267328, 0.18164086529764423, 0.18773668722197312, 0.16430273532038975, 0.3242277369841644, 0.15433452255678426, 0.18578177945639562, 0.2050833901507919, 0.16092021315864857, 0.1832213707873519, 0.1654759600565603, 0.18333025684693927, 0.15848964537518173, 0.2006732992412854, 0.1646359723191423, 0.15358311225566668, 0.14508615732473829, 0.9795534906298129, 0.9830904585734357, 0.9847488626573551, 0.9628429393912201, 0.9815466552471122, 0.9709631978047764, 0.978030806074423, 0.9844765908636787, 0.968162280939339, 0.26221458788594476, 0.32486361184469015, 0.38175293930161147, 0.4262886638566248, 0.2934082307663265, 0.41937674279775083, 0.31014763194340167, 0.33351714964126866, 0.3257091810764555, 0.39212236773879994, 0.8997398946160525, 0.326298434205214, 0.21798059851909946, 0.2064034046759322, 0.926788621538033, 0.9135508246334473, 0.23306466480232613, 0.22833667507003197, 0.18090692053607405, 0.16344793028171534, 0.15399203254982563, 0.23021962592608625, 0.13050189218060426, 0.8559569077914413, 0.1985494604782828, 0.147645755051507, 0.17731532337849398, 0.12749149282140626, 0.18123454601522349, 0.1779962555001835, 0.13007222400096685, 0.162657426199729, 0.22252024945288262, 0.22301858673590702, 0.18961573002446963, 0.30087697178901096, 0.08536204677276016, 0.066951731147049, 0.10702623664049737, 0.012258755085310269, 0.040324606836597554, 0.05822179674004824, 0.0055601193306307195, 0.1522527985196349, 9.999999999998899e-05, 0.2477492601034571, 0.24656567636225135, 0.13003147275430949, 0.09458887104769531, 0.2675656872700699, 0.11999983000696046, 0.1455011283728319, 0.2237662377489854, 0.12777611974160574, 0.05057297391228022, 0.2321381026750008, 0.12571663209212314, 0.1020812228972987, 0.11772197162478515, 0.1928486065789322, 0.20468437564271202, 0.12770251810469235, 0.13680524639583058, 0.23329473142849444, 0.23511284454165948, 0.0711299778918314, 0.1642032749204131, 0.04843622777377243, 0.09919237629537747, 0.1762621586595462, 0.16522943976643623, 0.13602459010031054, 0.43976503410242007, 0.6417791529640718, 0.5029999679129332, 0.40438458202336525, 0.7446325053578192, 0.5512353715946186, 0.4795886725329861, 0.9037987296935454, 0.6792406658318397, 0.09971476234591015, 0.1015839557543704, 0.11517093697138625, 0.1126249603979792, 0.17787922826719005, 0.10790420637437059, 0.16153588715268175, 0.1370868642721047, 0.1429058559776074, 0.1952006490523085, 0.19333347065975381, 0.18502223861534972, 0.20648662912742544, 0.2283995012435116, 0.21008404044671602, 0.16029834081693084, 0.17139245782344004, 0.21091300508781963, 0.3166175072519507, 0.2603525430186159, 0.3058509343211401, 0.3050676015549124, 0.29083161266041246, 0.2680319304005867, 0.37818363909312114, 0.6165874337474772, 0.36696752467611615, 0.23161995983582295, 0.16204235754288476, 0.2626206396435613, 0.35310606312977666, 0.21246373376768757, 0.27866325992964114, 0.2353294393500902, 0.19173222489441633, 0.3905259412529807, 0.205699541270989, 0.20069094968480883, 0.1825123571059768, 0.18674919904769605, 0.1855567000482261, 0.21014470022102205, 0.20720771967062834, 0.1981500741600386, 0.19371200709766734, 0.2241442849215639, 0.25462325232258176, 0.2566930877003961, 0.24633464897587742, 0.2011095112739203, 0.20854997074335246, 0.2298296965892448, 0.20680672731464622, 0.23399684031300572, 0.1597637985803695, 0.18826364671717066, 0.9477197139638747, 0.9542580832208883, 0.1999094512799927, 0.16771749386333867, 0.18864156851202674, 0.17640285359943098, 0.1888948778124091, 0.7377024167039596, 0.16807248314356749, 0.2115819626702613, 0.21330407273895569, 0.4037377791455343, 0.21382695293715237, 0.5089717453403788, 0.10490717432920704, 0.10496713990229345, 0.1710757382008885, 0.1690331805053774, 0.1819646311958638, 0.2047271619986083, 0.20814806276463693, 0.19422486588663368, 0.18378472023969594, 0.18258166413436872, 0.20447483537456168, 0.09073277064753127, 0.08615273619116559, 0.06953500449170458, 0.09555904417647476, 0.09534691501959913, 0.09330214328266717, 0.10643296297226457, 0.10012784807596598, 0.08635583625293508]}, "mutation_prompt": null}
{"id": "1d6c42b3-c6e8-4df0-ae51-1ceec36d9bae", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "9c81b2a0-07f7-4a3e-b182-8ec3b7b4791b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 3, replace=False)\n        a, b, c = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance exploration-exploitation by introducing a decay factor for the PAR and CR rates to focus on exploitation towards the end.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "139a1882-9215-4642-9165-aad9c1f61d84", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 80, "fitness": 0.34122496003699304, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "cd283769-1ae6-411e-87ac-bab49d50f5e5", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "57e43e29-71dd-4217-a8ad-eac186320da6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "e6eefb0d-b164-4f2f-8e8a-a46c9c3f376a", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "efaedcc4-e50b-408a-892d-8b1e14b7cc90", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        progress = (self.eval_count / self.budget)\n        self.hms = max(4, int(10 * (1 - progress)))  # Adaptive population size\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive population size mechanism to optimize exploration and exploitation balance in differential evolution.", "configspace": "", "generation": 83, "fitness": 0.28727745216351536, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.9181833360132836, 0.8178739962079008, 0.6010620979004258, 0.6585391556807427, 0.8104863025714268, 0.7897466336067792, 0.6096002440028521, 0.8218255287237279, 0.6251427711289377, 0.4954815239019008, 0.42838032810438476, 0.2716248859460496, 0.5283721615000321, 0.3025688045649475, 0.476785421636546, 0.45812618812159833, 0.286830328866854, 0.2670385160373323, 0.1535425327321367, 0.14659285916740794, 0.18942736219705436, 0.15404872458901686, 0.18361226052630908, 0.1979905400653148, 0.19767852662273822, 0.1507505494745479, 0.1914566969137993, 0.15621534406055448, 0.12308326578455164, 0.1563745209499321, 0.14076660508135974, 0.17614431185149604, 0.19770772438208473, 0.49974466252311844, 0.18550731910488794, 0.15427124162407635, 0.9744734186637951, 0.9789900788404529, 0.9731940933086177, 0.9540461218821367, 0.9803234200031912, 0.9772781322797558, 0.9790941652907881, 0.974965284162603, 0.969769013159448, 0.31650730542726113, 0.3193697004043936, 0.3247124806049465, 0.3614064433033537, 0.3110787298835096, 0.3769324743120753, 0.30897468868069755, 0.33861059176160524, 0.32359227254171286, 0.22877079779264176, 0.22829658805677322, 0.33393706319211747, 0.2157575490000314, 0.6342871692371914, 0.2836548168740346, 0.3360033405451468, 0.23280892383927, 0.23595989446653864, 0.3435287256345715, 0.17206637822081194, 0.1482473884679648, 0.18967554522158558, 0.15055314575689904, 0.17212998454902806, 0.16285333911682842, 0.1841796425746356, 0.20004243565854418, 0.1857925654789857, 0.1884780907166005, 0.17987573198859885, 0.18437179956919159, 0.13470199522121495, 0.2301732359631421, 0.14128775883624234, 0.15313034702964945, 0.13324139519928413, 0.05754742953229852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06093404181922124, 0.09555174708490632, 9.999999999998899e-05, 0.04735398749700637, 0.08458226868552376, 0.04044761209492376, 0.17297744962396122, 0.17947698316177907, 0.1861951614584163, 0.10462877668845882, 0.14270072266059997, 0.18790860058521297, 0.0934014418170307, 0.07234542797237387, 0.3656666362366565, 0.03858510623814326, 0.10110115424118082, 0.13245140020749713, 0.18835055051099403, 0.0952509763237609, 0.32971969236785803, 0.2217002278389283, 0.07878686358588094, 0.159692244817495, 0.1643144185476929, 0.335555254250256, 0.02589299396252953, 0.11069726722659201, 0.11970138497970162, 0.23475867652214188, 0.0844811692512738, 0.5984636635874179, 0.6026315649364123, 0.6207331965928027, 0.6399674171682218, 0.525652392800803, 0.47185982109968905, 0.5183405282147938, 0.5540087739815924, 0.6083608590257346, 0.12700469183183394, 0.13958980901967077, 0.1285002932642284, 0.10953988986777496, 0.12191346331012265, 0.13273017033873513, 0.07124671642699554, 0.10057732539052378, 0.13253483680125722, 0.1630624527194765, 0.1685033876419305, 0.33532192098896674, 0.3871443830206813, 0.22831185787290775, 0.2912384233561768, 0.154852051260139, 0.2709746710482015, 0.2928379255917596, 0.36785659649464375, 0.4136279377196289, 0.27433296754016534, 0.37115401224664224, 0.24937769723899983, 0.34159260510949263, 0.3749936445703177, 0.4056139375937733, 0.433552646446969, 0.267927588431345, 0.22223969655996978, 0.29030372500876067, 0.38169111494016505, 0.33964928551277385, 0.29892379871550867, 0.14115531392009184, 0.1663498127451707, 0.27007477242945155, 0.24994363349485715, 0.2273694238535925, 0.22453321315711006, 0.20084077773196118, 0.21904265953241708, 0.23033059663533473, 0.20177413569305724, 0.21773347605631554, 0.22989411530131243, 0.25494853163316433, 0.22892158483299008, 0.22602796756988797, 0.19984219786492674, 0.23882327327044794, 0.19921265150900158, 0.25459483872654765, 0.22354394191051075, 0.22662749912875957, 0.16758599635149407, 0.16594418513122255, 0.16884527479693767, 0.1682032753871675, 0.9618054653296949, 0.14908706306773234, 0.17736558055968, 0.9502117210192955, 0.16863579845627608, 0.9326108044625538, 0.12877842923070237, 0.3741863963631249, 0.12847080683950463, 0.12768601765186194, 0.21344344556085015, 0.46821818653034075, 0.21393495514122973, 0.0946761706553032, 0.21073801339552123, 0.19042577372907887, 0.20012529900555032, 0.18852707350869946, 0.19334946865431102, 0.1813694935396275, 0.19921864597989825, 0.18163385270437615, 0.1951163124090629, 0.09052728162830115, 0.09106515016261385, 0.09061016601738414, 0.09654706714654837, 0.10614410597008772, 0.0830949404373027, 0.11022021397809056, 0.08382509937853977, 0.07641297618016418]}, "mutation_prompt": null}
{"id": "66a79d4e-3ab3-405c-b182-515b216b0b6f", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "5cfd3582-9b54-4f5e-a06c-fc0746a914b6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "07338618-12c4-47cc-a198-a4797df1aed6", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "5612e189-3b19-4e9c-b6fe-ddc9170bcd0d", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * np.exp(-5 * progress)  # Exponential decay for better tuning\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce adaptive parameter tuning using an exponential decay strategy for better exploration-exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.3212341388035862, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.923748646246459, 0.7693637058677946, 0.7345885742456554, 0.9400021417252286, 0.927635724304398, 0.7592589616636534, 0.7120188225339317, 0.8510130173092403, 0.9320702453536506, 0.22819234772756458, 0.6319168978014575, 0.521066307845137, 0.47834621141882394, 0.6658475822354433, 0.3516958830297868, 0.8666758456092711, 0.6075162858420158, 0.23600524273272072, 0.4581243056782036, 0.17968055643547431, 0.191464578403585, 0.37154043904447676, 0.186098149514758, 0.5045684007788479, 0.34690300555896925, 0.4439670647478462, 0.181681312855974, 0.16894679239671317, 0.1537188139704485, 0.14023480383290865, 0.31436613430609506, 0.19011965929759467, 0.16337746531135422, 0.21891625038335516, 0.3507597685575412, 0.18129212895270774, 0.9931052299045957, 0.9861670587402901, 0.9892699355547291, 0.9776185201172969, 0.9851490784423521, 0.9745637670275606, 0.9756993250996985, 0.9836451306291587, 0.9853546002586124, 0.37921940594351233, 0.4589188412919055, 0.3727361118954631, 0.5012366486262798, 0.5102540175155359, 0.40223567261151283, 0.35959942521735433, 0.408605517531749, 0.5567563006910665, 0.396682194438575, 0.1715191770403982, 0.3618736365140228, 0.37380459141794076, 0.8688990773041316, 0.8877870206491751, 0.23046845407016125, 0.4001758729313353, 0.23802965250549446, 0.1605329220153262, 0.2784582547464506, 0.19221965884085657, 0.1459162504622349, 0.14981703809340274, 0.17312289691536875, 0.17941031554258202, 0.21269854188569148, 0.1592234064066772, 0.20615565733084396, 0.178308569579671, 0.2539265797940323, 0.18942089524379746, 0.3374865432035554, 0.18345324043533595, 0.1977148816531955, 0.18309432359214173, 0.1856594054682167, 0.1544646769176845, 0.12488137890693762, 0.0765055144458584, 0.17641189472669339, 9.999999999998899e-05, 0.029137596236941343, 0.031059083957535982, 9.999999999998899e-05, 0.016749444061850194, 0.0697231498331723, 0.29429097718070596, 0.12873514189408086, 0.13576477204478365, 0.044207319421315505, 0.06780564422725532, 0.24554017292530583, 0.12070682548500478, 0.12324543400301113, 0.16420194828100354, 0.0757583482319587, 0.212268315753098, 0.09911795837709558, 0.14764790298659625, 0.1481343115521604, 0.17404536437291918, 0.14916629439484896, 0.08150554960311707, 0.14189162426374258, 0.20143258309756773, 0.25375416016777586, 0.35548829900548884, 0.18281896666177466, 0.23295443593673704, 0.19635624287097497, 0.33843746871905145, 0.09889868689259529, 0.5686726535073046, 0.5323333069568965, 0.6048101265288647, 0.5238171743280134, 0.7195531001200619, 0.5954387563731119, 0.5598780665960709, 0.5961642246276361, 0.4777090575264258, 0.1814310527780757, 0.15842288032410923, 0.1446194538545298, 0.11103562134372968, 0.09768422362627549, 0.11915389484555527, 0.08877298023513269, 0.10753733460240888, 0.10760949713980372, 0.7406910285232724, 0.34788020877596004, 0.26983250815405113, 0.18026288407064806, 0.19594853707448845, 0.21515151573670166, 0.19859219613988377, 0.27471224309748765, 0.49207146862492135, 0.3970216629140314, 0.48262617405012465, 0.4058287539328085, 0.3423949468852244, 0.25375591436856937, 0.36204670733597777, 0.4649052485668854, 0.4714454456378886, 0.5599291344258762, 0.27704540208916273, 0.3283062308962471, 0.2989373456670459, 0.35864612125728346, 0.47683780282537336, 0.2527338590537058, 0.4307885105280461, 0.21474355182976712, 0.2460144585659002, 0.19512171846673532, 0.19384347715978278, 0.19271959651655934, 0.25551647702236535, 0.21199247677199995, 0.24744058886591846, 0.20860187100911654, 0.2188818780280014, 0.20697279280725933, 0.2573727337087903, 0.20457765981478337, 0.1991449331283619, 0.20797051260504618, 0.22859682761506817, 0.42968514719532536, 0.22977333791455168, 0.21268665051635582, 0.247865166762543, 0.2001100752397742, 0.16608413910301, 0.17293626376905302, 0.7903890129044804, 0.20103596639406163, 0.16892762582307042, 0.1683612110737377, 0.15332093830031301, 0.1622849975219991, 0.5003905102403177, 0.7069246663345827, 0.16987060094632978, 0.1689568957712383, 0.21004561003057953, 0.21231787341999808, 0.0942721311599577, 0.21432205574753493, 0.11350569462888416, 0.1906461709157038, 0.1821986595247107, 0.20078532429069817, 0.17026612179270484, 0.18507495563961096, 0.18321374401106727, 0.19431829441210235, 0.18009889395567147, 0.21953965363717787, 0.09545775123660682, 0.09784322877838458, 0.08577721354977652, 0.11940611888500441, 0.11204405095133663, 0.07442239668967288, 0.06327353462001517, 0.08338928269616375, 0.12018199919436245]}, "mutation_prompt": null}
{"id": "fe7381c9-93c7-440d-8c04-129ffade4249", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr_min = 0.7  # Minimum Crossover rate\n        self.cr_max = 0.9  # Maximum Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        self.cr = self.cr_min + (self.cr_max - self.cr_min) * progress  # Dynamic CR\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhance diversity and convergence speed by introducing dynamic scaling in mutation rate and crossover probability.", "configspace": "", "generation": 88, "fitness": 0.30263154914736534, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.7705248227134779, 0.9096820709233888, 0.9217895293790234, 0.794584713831157, 0.9312180208233902, 0.7006263344841721, 0.7707631528544017, 0.7246302142893948, 0.770955644213786, 0.25391456314475325, 0.305259409393863, 0.830783316858083, 0.7365072325538113, 0.15119020509324343, 0.11295151938748982, 0.7023866641848164, 0.36095953434447325, 0.6104508147507128, 0.19234876344526441, 0.3572265780202537, 0.156472508574795, 0.2143299494585882, 0.18828786942605324, 0.15969075018855472, 0.19011380280880652, 0.17144508946918324, 0.405219640850203, 0.16038889253720368, 0.1393599531466443, 0.3774178574185747, 0.17139814286159016, 0.2403091377400094, 0.17615406387828425, 0.19039004583760966, 0.15563878456663716, 0.1580078775946504, 0.9855676983979533, 0.9783867062288761, 0.9747475484454102, 0.983411919384256, 0.9827355300876556, 0.9868529257954791, 0.9754897603522606, 0.9791308820477903, 0.9737698329786872, 0.46937818637439055, 0.3936617236533332, 0.4901815213779761, 0.2887613924325252, 0.31185046014899853, 0.39012861493285433, 0.3799541002510707, 0.3437259225469629, 0.32652344709228365, 0.14182018027720622, 0.20222972990702037, 0.22965075562119686, 0.2822948187996063, 0.9206083771155715, 0.21705594053421595, 0.18667629986177814, 0.22197540285748052, 0.37613412084737907, 0.14963090804749157, 0.3283677531919196, 0.19517049166529998, 0.15932615700770458, 0.1336541171838127, 0.17581534865507842, 0.4197628765185184, 0.17623185648706674, 0.17905885747917982, 0.18514936059329556, 0.11488476394726599, 0.20350181674318157, 0.14469008205712308, 0.14797128157609185, 0.25342783419368686, 0.2315270985774317, 0.19516413908786656, 0.18991492358902662, 0.1269940135800416, 0.2113244056263286, 0.08601278558228664, 0.08113112963039804, 0.048095767631455955, 0.07611590068046281, 9.999999999998899e-05, 0.13548243188079234, 0.11501692661150387, 0.24559784699247678, 0.05218837807909171, 0.1159527427773055, 0.08320574569409056, 0.13673497408571167, 0.12231619164780894, 0.1284308854992804, 0.21285517441058777, 0.12714790155320865, 0.08790814314837736, 0.06190685099934312, 0.06491810327579772, 0.10477861792556509, 0.08608528997156173, 0.15667909186175843, 0.10370544045354468, 0.12298189164601958, 0.09489914125618126, 0.2700394135602229, 0.045706904441661034, 0.14733074059176088, 0.06428769558858616, 0.22170561112319243, 0.1307471916584847, 0.2651971047017059, 0.18280219443419432, 0.13937226307333295, 0.5779292903211686, 0.6195071243543637, 0.4650180361910855, 0.5670126595817659, 0.5764702962710152, 0.5759866030223699, 0.6082072111479646, 0.523234450146924, 0.47023672042903686, 0.1153297052829505, 0.101141332105525, 0.14591403470837305, 0.14733830054616226, 0.10900302544019591, 0.13807286287101472, 0.13904338967178087, 0.13305637841495865, 0.10995232517812059, 0.19897445686745419, 0.33143942279077, 0.15554775927254827, 0.16718731130646725, 0.361624250977008, 0.2431555408703816, 0.22765799580290758, 0.29769811723559936, 0.20123556764806094, 0.2626624403021305, 0.4740508834482591, 0.3992721829471043, 0.3827690519304944, 0.4102292643768637, 0.4252638106572444, 0.372050752329258, 0.24146775866962777, 0.32544511020587275, 0.2893938869697862, 0.24637216280697016, 0.28259534113145324, 0.43926254373145623, 0.1503240875778029, 0.3428619017568032, 0.34296857993178165, 0.19219790916319412, 0.2602408697021934, 0.21808492653012423, 0.18564291019025136, 0.17616972940933884, 0.23102006391098984, 0.2025789646146472, 0.2985156537627691, 0.20775196889893888, 0.21780962308538643, 0.2100100706348751, 0.2558477291426592, 0.2043567388290105, 0.20902556014428642, 0.3847375913986255, 0.22589673492960893, 0.2140080328803139, 0.2533742954342022, 0.2271176625885809, 0.24757716188147483, 0.18710994237549872, 0.9419691218959855, 0.1891299302263073, 0.8001161191139778, 0.1997551936063714, 0.9395891314678757, 0.16793161217671349, 0.1733827670723984, 0.16320985715689562, 0.6365709363789721, 0.15616326041535866, 0.16914533765010897, 0.16904681966706048, 0.20977165889418703, 0.3327442388062547, 0.44908204497271476, 0.21419176074101465, 0.112959590047078, 0.19620360842955575, 0.19370620897905777, 0.1795570204057576, 0.1846435775498959, 0.17037460971001128, 0.21304273094842363, 0.19154934616219232, 0.2415054838119809, 0.19220401260094755, 0.0842486739055599, 0.08640233971071443, 0.09055809731047282, 0.11558649766021334, 0.12154644249749746, 0.09033766231097795, 0.0900431750385775, 0.09780501233948413, 0.10621684176274082]}, "mutation_prompt": null}
{"id": "2cabfb02-5a8e-43c3-a195-b41f81e7f63b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "7794ec08-a571-454a-925b-48dcd3f549f4", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "d4309829-0217-4790-80db-2af391fe5f5e", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "45dd4ae7-d82a-40ce-9494-f41834014b6b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.35  # Min scaling factor for DE\n        self.f_max = 0.95  # Max scaling factor for DE\n        self.cr = 0.85  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Enhanced adaptive scaling and crossover rates in differential evolution for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.32761944494054546, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.9298311958412872, 0.9131986817448897, 0.6730695988169696, 0.9183942711934039, 0.91558919076868, 0.918201846511582, 0.9200948760015859, 0.9233122158223894, 0.6886189513459136, 0.8484151462826434, 0.6911793266045025, 0.8620139619089291, 0.3120432554176945, 0.8747251245606233, 0.8521082812572158, 0.7267867342691516, 0.42359122896773505, 0.14919831875483558, 0.1658632944891577, 0.16816287134705166, 0.18257357711046862, 0.5372513385128608, 0.169529448627722, 0.4834703248873965, 0.16326270579274627, 0.16566653665188114, 0.18712803736463268, 0.16155909386205836, 0.17986080757968648, 0.13906359800260237, 0.17021778451967207, 0.17299838253586386, 0.16027351890278096, 0.3996222757812661, 0.19953457531940222, 0.18803687368800315, 0.96843119600246, 0.9882738380855955, 0.9848269302548571, 0.982465234446031, 0.9784848965808609, 0.9756060184951655, 0.9653039101041792, 0.9766391738131116, 0.9718791472390252, 0.5351695240168091, 0.3654788730967178, 0.45767590512142553, 0.3876343633275605, 0.4109858606478295, 0.388819664633432, 0.3805820777242688, 0.3763110563181169, 0.3330223126048607, 0.5097125005166174, 0.11156167243701931, 0.9207420419499174, 0.37945744845835694, 0.3807727472044449, 0.26271930409044886, 0.2366982897121015, 0.39939227592465654, 0.9106393189485364, 0.14895938478521442, 0.15167178832046613, 0.1944227873777994, 0.21900066526734863, 0.11871819077373125, 0.2631487305321921, 0.4141761709957057, 0.23394646838748268, 0.19930503748169248, 0.19373682400795944, 0.12415757501021707, 0.16904770569638017, 0.15574164949673108, 0.12688507743301725, 0.6538839682726885, 0.21399612711541527, 0.17540685042474835, 0.1442801747654967, 0.0654005664398084, 0.0895923933637941, 0.19937525843087844, 0.04309038579733737, 0.0007469528021983862, 0.03826475352336001, 0.06531065934192903, 0.1736443995718746, 0.02023947205790866, 0.19180692242388786, 0.06927639827991461, 0.3598563801123068, 0.15442234838178104, 0.03943144612312466, 0.07765681011914871, 0.1330015148643322, 0.21173022340626735, 0.07544486979998888, 0.08188204654728992, 0.3131128399302594, 0.14646119973376137, 0.1025931952550787, 0.08586254296002405, 0.24451886321885263, 0.15439669604923334, 0.17823293540296758, 0.08686894391517685, 0.25766635373708136, 0.3394106130988359, 0.07493487829813095, 0.1739426629535934, 0.30882151871014973, 0.22914279093061274, 0.13897801797056986, 0.10315187828368921, 0.28945308356484, 0.7509984606856484, 0.551530338257759, 0.8275940584696356, 0.541412228457512, 0.5069555650568993, 0.6090545854209537, 0.5357228921833086, 0.5576862385671232, 0.6276162979152847, 0.1147263258062089, 0.1529051838641775, 0.09829193000484338, 0.1250221010484056, 0.11454947003728666, 0.10520784744392764, 0.14185653207193683, 0.1373272349476785, 0.13779375187610854, 0.30330172294468716, 0.21118574414059466, 0.25371733209554637, 0.1974933361852248, 0.2913177804639693, 0.1876204692873631, 0.21750861816457123, 0.21727129268975076, 0.2288733656751447, 0.5788232344805593, 0.5283480279144703, 0.48074066413011773, 0.3620420910517631, 0.30029526079807656, 0.33430388538833156, 0.44285467378531185, 0.364674581338577, 0.49017580813093486, 0.26321806129150205, 0.33011261367810396, 0.33126094347313984, 0.31190199628249526, 0.4516037041290347, 0.26254918188256915, 0.39968094073610416, 0.28682547517938795, 0.20922497796203687, 0.17840619361745302, 0.2043305879095788, 0.1830187760364469, 0.2169682880305006, 0.2261054660333608, 0.22796094860422977, 0.25436879679137325, 0.2109804663965117, 0.20151620735636988, 0.2510059601290219, 0.21376387950239728, 0.21792408457245305, 0.227572374193308, 0.2290066832259674, 0.5039612145958959, 0.2561641072259657, 0.20991835292867933, 0.24797876558100873, 0.14260792810457967, 0.16237311095914098, 0.17301546823875646, 0.9506807870999652, 0.867595383905269, 0.2010393415618822, 0.16808229452208212, 0.1653581445445157, 0.14692401679444922, 0.8581521870613498, 0.3567902302214514, 0.16857679240220935, 0.1697458507510995, 0.08237710753134486, 0.16851050662334421, 0.11271173663074407, 0.2137339771449901, 0.11288172083174319, 0.17786016147027528, 0.20549006883044152, 0.20162814838444587, 0.17900835393605008, 0.18701660146435328, 0.20336628367918197, 0.18184124394921974, 0.1783702055734846, 0.19497789989820147, 0.07989527591355383, 0.07428541485882034, 0.10118214836694495, 0.08084636576459159, 0.08334977812333078, 0.09670140362030166, 0.11634385470531283, 0.08945177019252681, 0.08695974102931037]}, "mutation_prompt": null}
{"id": "2bc72ff6-3bbd-4fcf-8aa3-9549e55415b7", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c + np.random.uniform(-0.1, 0.1, self.dim)), self.lb, self.ub)  # Adaptive mutation\n        else:\n            mutant = np.clip(b + self.f * (c - d + np.random.uniform(-0.1, 0.1, self.dim)), self.lb, self.ub)  # Adaptive mutation\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce an adaptive mutation strategy in differential evolution to enhance exploration capabilities.", "configspace": "", "generation": 93, "fitness": 0.2944050329944506, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.6188758201957858, 0.6014490487903628, 0.6117257232844648, 0.6229051647222938, 0.5985482787366263, 0.6005261575007196, 0.6203546349921212, 0.6323811750623831, 0.6452991409104567, 0.199512983022336, 0.2397152577240158, 0.2755504558800037, 0.26731427154016907, 0.2682261584054296, 0.28025100645816003, 0.2685196450431243, 0.308883160437746, 0.30726924393304156, 0.20970900276035165, 0.31038981059544457, 0.18602968953970267, 0.178183018421457, 0.25408749697727995, 0.158917851199884, 0.3245763136749553, 0.15475656735770082, 0.15252124096379516, 0.15782737942150615, 0.1594463370844511, 0.14887639457017043, 0.18113269051785197, 0.184149061246765, 0.15479449813713686, 0.27450838549917567, 0.1697520591077164, 0.17918881718753876, 0.971733926753503, 0.9813222911740787, 0.9864209101955026, 0.9645872406710838, 0.9817018865434894, 0.9815040355468951, 0.9709514447748487, 0.9772537007996666, 0.9788009127053763, 0.427408025992414, 0.418672691977806, 0.4110911831559114, 0.42714570399350793, 0.4206690562062647, 0.40134144208511746, 0.4008228063676651, 0.3848866817325376, 0.3990857852327162, 0.7868028982691793, 0.8851546345236917, 0.8429663388656785, 0.3822560064122915, 0.27581187702528975, 0.7746903954633799, 0.7962876362420366, 0.1762438152702569, 0.8017848947020555, 0.18433328851055997, 0.19725162468799196, 0.20770827179358042, 0.21841044088942396, 0.13902516068595616, 0.23662351372577195, 0.20995867722037898, 0.2657591934478757, 0.2145566647822328, 0.20378060588042912, 0.22803386217512722, 0.21405822855517376, 0.21112791442226408, 0.21791688487217642, 0.20169462498508806, 0.1558278998900765, 0.14860968333447167, 0.2140578102711327, 0.06692145807937688, 0.07593975269702147, 0.0823760956139089, 0.06065686405417525, 0.044598368003572086, 0.05469439048533553, 0.0478857082225399, 9.999999999998899e-05, 0.051173290003181826, 0.11187319647320004, 0.116247571310097, 0.12328120324466108, 0.09200943552498209, 0.1270044331324376, 0.10446382312106905, 0.10464372087991292, 0.1108980566800537, 0.12916620422211544, 0.020375886486883932, 0.021682680443807834, 0.011688392905808365, 0.013228314164597021, 0.04888443571793322, 0.05208154117154262, 0.03668919774534951, 0.04052044964627599, 0.048797387068652665, 0.16227581412611813, 0.15674106415808875, 0.1515732168160886, 0.16961084699557072, 0.15028107297658722, 0.17677816034249139, 0.15554903535166598, 0.1276088779490807, 0.1553339011484861, 0.48368968674746016, 0.4780388684725033, 0.5152637007842701, 0.511685452763428, 0.5062171688942088, 0.49115591422842086, 0.4926070339305102, 0.48843075650421475, 0.4911492136688521, 0.1564638209604836, 0.17711977614028618, 0.17291660551831445, 0.12313108193210232, 0.14288675863579425, 0.13812537219439613, 0.13318529579617644, 0.11885768276858366, 0.087985360966784, 0.3329339964246091, 0.1520383014056249, 0.42945127094108504, 0.29874875010191293, 0.18528100598248398, 0.27914473753608604, 0.20045260906171203, 0.24769778997825265, 0.19171356476533985, 0.37584304451671746, 0.3530701960460557, 0.35512666561308026, 0.3700023739512378, 0.35756216846269595, 0.35741542103744495, 0.3881128068846541, 0.3920544271388261, 0.3817111759342209, 0.29103850865400316, 0.2829795450718209, 0.267882939651216, 0.30867110968166267, 0.2760979556343346, 0.2582254774447207, 0.29509381289728553, 0.32113900122698213, 0.29834759405256983, 0.20860826430485324, 0.21577457965559288, 0.20526508553295408, 0.19416124732107132, 0.20093050177830762, 0.21772365323952425, 0.2095523969557873, 0.2088665486813851, 0.21090719915849832, 0.2489559562383572, 0.19255530305252466, 0.3780453265209205, 0.24299169140140975, 0.21051223201326974, 0.25379149575266513, 0.21577627298974056, 0.2092486678518397, 0.25147256985553756, 0.15965220525535606, 0.915250347433338, 0.1592904857371823, 0.18791252041120288, 0.9018509571937041, 0.8942107581021576, 0.14275087576557055, 0.1655878923177181, 0.15480198671983503, 0.7955278232187576, 0.21103805111049356, 0.21266081423070105, 0.12815076149112303, 0.8238326428793117, 0.09457508710062668, 0.11341162978393238, 0.21129671910977088, 0.15674189772295355, 0.1822939875844387, 0.18855280429904153, 0.1761148431287647, 0.17955046657294593, 0.20375941759263416, 0.2007943626300026, 0.2002265441184331, 0.21290683058633908, 0.172655095712426, 0.09182424062125993, 0.09763473967316172, 0.09165124000912495, 0.1241806871722636, 0.08954017592477537, 0.0794925663654169, 0.08810613460835393, 0.08923688567060539, 0.0766174949632017]}, "mutation_prompt": null}
{"id": "4838137b-f973-4393-b593-f9b017e867a9", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "c2897887-8b1b-4fe5-b670-5b41ecd12669", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        sample_size = min(4, self.hms - 1)  # Dynamic sample size for competition\n        candidates = np.random.choice(self.hms, sample_size, replace=False)\n        selected = self.harmony_memory[candidates]\n        a, b, c = selected[:3]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Incorporate a dynamic competition mechanism in differential evolution to enhance exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.32839045225610114, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.8128369075943254, 0.9253362903272215, 0.9249283134469857, 0.9274172713933917, 0.7796484023195442, 0.6795935339550019, 0.9167440065531902, 0.9360233748481359, 0.8569877765088946, 0.568911133147457, 0.7163289973529483, 0.2853606140612982, 0.8496779604110476, 0.683599747114314, 0.4192912327165198, 0.6602013535713542, 0.45550467847973897, 0.4216350717520351, 0.1872536898332401, 0.21012175214591478, 0.29974711935970055, 0.3365297569034318, 0.1453555858646698, 0.18045214074269356, 0.18746393573740106, 0.2031792900301318, 0.13393987667353335, 0.18452985135676714, 0.1635549836879795, 0.1634154905734182, 0.20068834866295726, 0.2982662230312052, 0.18999328586157826, 0.1418210544578038, 0.16350646124730261, 0.16373259617686398, 0.985331653783536, 0.9675925075482997, 0.9825604995584479, 0.9769707343691454, 0.9740216048020485, 0.9790735603483415, 0.9617968611995019, 0.9795724583207788, 0.9716548925800633, 0.3892892847442788, 0.36634016932576663, 0.4299075290054952, 0.37162471326739344, 0.3963008947967247, 0.42681947471677295, 0.3751762579834048, 0.36177290243110416, 0.41321309512276283, 0.3278689328422041, 0.11951308473218136, 0.2265703109649928, 0.9130990964485916, 0.3601275340414323, 0.32963701779591836, 0.23845194177133378, 0.9290553547877848, 0.366078368998934, 0.3396622307261342, 0.18532283764566437, 0.15679214057715252, 0.17913946064409103, 0.13561096087536206, 0.1568629337404207, 0.14904284553391955, 0.14866541849113635, 0.14495791618150689, 0.2956607927163185, 0.40937131740953014, 0.17223861760854542, 0.16777675749597487, 0.1787953607971533, 0.13704053627577995, 0.17346016185523827, 0.20311564162247386, 0.13830883541581807, 0.0009231313056552448, 9.999999999998899e-05, 0.09783005998762306, 0.10974887464937944, 0.1906487031126488, 0.09766390817699588, 9.999999999998899e-05, 9.999999999998899e-05, 0.12388217910445964, 0.10733111334966638, 0.15336253888392037, 0.31564142607238277, 0.11450075832890905, 0.20553092651501237, 0.040925307506526565, 0.1383600121840698, 0.16659096356273495, 0.12361087787752567, 0.2533144197442091, 0.05266823395520681, 0.08591155972571962, 0.10458309039211766, 0.3224742634643104, 0.1044326138273578, 0.08152015823490821, 0.3988923020353301, 0.11196991910868637, 0.26455274191943645, 0.3371865558594286, 0.21578169366072264, 0.41576235392954686, 0.3983723732370047, 0.24228063128400068, 0.27325824478598304, 0.22371066401222428, 0.20668365735826055, 0.5201191191157766, 0.6263803211387085, 0.6035393828839798, 0.6871280391978821, 0.5364514011380341, 0.6736083715795043, 0.47654729138027263, 0.5123560491201455, 0.5151073945982061, 0.1468793348245454, 0.12162326361351317, 0.12182637554297959, 0.10202259746483999, 0.09436246793222325, 0.13500134021309063, 0.11733779182598425, 0.11136533323352615, 0.17950107122775294, 0.21431784968490464, 0.19341338962472154, 0.282999690574001, 0.22089944852478793, 0.1540206794703941, 0.2683765851308102, 0.1867941965606138, 0.268041724692877, 0.27011387549319565, 0.41971340391550105, 0.4268486648230849, 0.3942923472800406, 0.41116766285763984, 0.4268698743770316, 0.4337901573297477, 0.4650320782732553, 0.36221233750311865, 0.5413510480439812, 0.39647597043742944, 0.2773755172372113, 0.19629808007946903, 0.4359032246171981, 0.2806246225967459, 0.41747411393111633, 0.26045290357601003, 0.2898401447157315, 0.3438655768485227, 0.20991261804911887, 0.21013874594610416, 0.1966685530960799, 0.24494459326141482, 0.2095895045795909, 0.22098670831952583, 0.23560797455232874, 0.2365609051011106, 0.22483293602629129, 0.20905574731057663, 0.44687993887230637, 0.23859528496504667, 0.4334811508884513, 0.25491608707591673, 0.38842155998096695, 0.20954404550369055, 0.2280847923250039, 0.6138166520109698, 0.1685693578012908, 0.1885516739703641, 0.16613545991961787, 0.9311600276014782, 0.18911914894475723, 0.9439960064075382, 0.1593270514359807, 0.2116023496745172, 0.16728368972462193, 0.9169872792432874, 0.169395246082511, 0.646203251275977, 0.16990185157135185, 0.3297666399428142, 0.3482636300399071, 0.1051745445001383, 0.2136779253982608, 0.15670591693423153, 0.20217041155121496, 0.17517867612484173, 0.19397036235188558, 0.17798033306075156, 0.20183074252951072, 0.19240891304340635, 0.21444633624337672, 0.17936649922376457, 0.1999159240641295, 0.0751743061666541, 0.09099822186724704, 0.08010002029076368, 0.10181631110921585, 0.09973547010456407, 0.0997081678048386, 0.08566133727214342, 0.11068418441000272, 0.09258064058486104]}, "mutation_prompt": null}
{"id": "9ddf5c4e-8498-4e59-86db-7dd6c349c631", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "19905e53-7ba7-4b2b-8403-0c28c114990b", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
{"id": "e8a94994-d94d-4707-8f85-d842f3eecae5", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        # Self-adaptive mutation strategy\n        mutation_factor = 0.1 + 0.5 * progress\n        trial += mutation_factor * (np.random.uniform(self.lb, self.ub, self.dim) - trial)\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a self-adaptive mutation strategy to enhance exploration in differential evolution.", "configspace": "", "generation": 98, "fitness": 0.24595711216651697, "feedback": "The algorithm HybridHarmonyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.5636629603341785, 0.5005467825959463, 0.520275852312857, 0.487660012593664, 0.5284302615248719, 0.5006310980055844, 0.4748571588434194, 0.5081002753515819, 0.5194546205519419, 0.13710398232302068, 0.17192559889654346, 0.11950778597079081, 0.15074515134394628, 0.17872514246330484, 0.11288429809042877, 0.25212610503666166, 0.23917447287367966, 0.1257166573308769, 0.232133219803907, 0.1785713473516558, 0.21198300804340786, 0.2026681516502009, 0.17659617418044837, 0.21687525563813648, 0.2048417511567946, 0.16592153814736865, 0.1585234998561016, 0.22961516971289853, 0.15101974846224597, 0.14185727449310215, 0.14900137054585416, 0.13565178989820526, 0.20530314300013675, 0.15888730213972013, 0.16415486596552276, 0.17004447989681792, 0.9542096331574721, 0.961895015466323, 0.933468289281881, 0.9436604911099731, 0.9432651580076137, 0.9194421558020912, 0.9357931539893709, 0.9355987968854972, 0.9506576964239234, 0.31176448151841474, 0.29705741816436804, 0.297263717382219, 0.31236995975747284, 0.2924445313872276, 0.3053620617813365, 0.34255045226189074, 0.2772122310658589, 0.2832302705807628, 0.33988322210758504, 0.22844601428995115, 0.22757447386082963, 0.33993318301046427, 0.2624759157236426, 0.2686639448208611, 0.23536986038381824, 0.22322915443108293, 0.2568147956925626, 0.24780953257202687, 0.15656365606719902, 0.14900982621721737, 0.15492283279292518, 0.2229559566146586, 0.17292142289174595, 0.15662017622539004, 0.20536543573673594, 0.1540583301570101, 0.14883126680574055, 0.16594479835826592, 0.1513210888919575, 0.14144519673087907, 0.13670650577994004, 0.1468724847449424, 0.16371725595790887, 0.1722526298487097, 0.1680959953013358, 0.00490001341955193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004103197837461714, 9.999999999998899e-05, 0.08018239803091876, 0.08499853890837294, 0.09524495742316774, 0.08289116125290297, 0.11818016401977771, 0.07952424133473379, 0.09528106131171643, 0.07140661610721255, 0.09980594908407747, 0.021644439213306943, 0.020402643347092964, 0.00025650646058783533, 0.01386683552351986, 0.011802691988846203, 0.0005580843295203142, 0.005081061676250664, 0.008666316865733492, 0.00849266898577461, 0.08072191346486013, 0.08053566483677954, 0.12972445436295743, 0.12791096510539157, 0.11667450004459534, 0.11630487590807626, 0.09576065851012827, 0.09745008928401622, 0.11440795469420662, 0.4796261573798126, 0.47928087811081, 0.4375622681622465, 0.4354429665231232, 0.42293615255450245, 0.4378930187666822, 0.43740505687037334, 0.3821962896838631, 0.42135555734304986, 0.11229558370210868, 0.11242306855916318, 0.1359796148264728, 0.10724927936356743, 0.1086174156421934, 0.13283000383389376, 0.09464406809627912, 0.1707843245052454, 0.13142717019933858, 0.2696139378583432, 0.15440451731462002, 0.14457259514055953, 0.13085406923591758, 0.1797944546355107, 0.3022935208952814, 0.13387764028310611, 0.21448821696199571, 0.1293314362870862, 0.29565575920224807, 0.23928719593997005, 0.30854908369781264, 0.2860615489719446, 0.3105416650572843, 0.30054838358596336, 0.33624579343091987, 0.32404136283026175, 0.29846277344662164, 0.26172395556555095, 0.2581736025959672, 0.23793954415266505, 0.23487868435399117, 0.2419819151668341, 0.21641285331869275, 0.23863979905274368, 0.25501167425335713, 0.17075107380803822, 0.1969169288995698, 0.21151072349432498, 0.2065572057647248, 0.20432163597892716, 0.21058173952428683, 0.20742770166924074, 0.23901815278095095, 0.1923437561695972, 0.21950019159762135, 0.38667951901714304, 0.24829098758585544, 0.19550687088099872, 0.2174983421599167, 0.2000640700329953, 0.24416258367448573, 0.19085347454637724, 0.22011618993847448, 0.21307824873166004, 0.15979670252679612, 0.6749454390683605, 0.173011974291419, 0.6515066624939512, 0.687101261277616, 0.5980282268436283, 0.6707086377456295, 0.6829443545134997, 0.1672641542378447, 0.5297934797411706, 0.19743436242229206, 0.5743604209109363, 0.17421162083327602, 0.3670712711931474, 0.18060700609246083, 0.1262701600396383, 0.44110835222116684, 0.2734071186583783, 0.1864693805296841, 0.18665776396153344, 0.2003834129669716, 0.1886961786365423, 0.1817160618532192, 0.19728477101259867, 0.18529001701125847, 0.18233825850045215, 0.19091447995088584, 0.08935799876176642, 0.09415930087431956, 0.08088925833682536, 0.07873210679767528, 0.0786902065857219, 0.08720451289310238, 0.10571144273070021, 0.07632649580724815, 0.08381360033006935]}, "mutation_prompt": null}
{"id": "f4372d61-dd6b-4578-8e3f-082de48b9f54", "solution": "import numpy as np\n\nclass HybridHarmonyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.hms = 10  # Harmony Memory Size\n        self.hmcr = 0.9  # Harmony Memory Considering Rate\n        self.par_min = 0.1  # Minimum Pitch Adjustment Rate\n        self.par_max = 0.5  # Maximum Pitch Adjustment Rate\n        self.f_min = 0.4  # Min scaling factor for DE\n        self.f_max = 0.9  # Max scaling factor for DE\n        self.cr = 0.9  # Crossover rate\n        self.harmony_memory = np.random.uniform(self.lb, self.ub, (self.hms, dim))\n        self.hm_fitness = np.full(self.hms, np.inf)\n        self.eval_count = 0\n\n    def evaluate(self, solution, func):\n        if self.eval_count < self.budget:\n            self.eval_count += 1\n            return func(solution)\n        else:\n            return np.inf\n\n    def update_harmony_memory(self, candidate, candidate_fitness):\n        worst_index = np.argmax(self.hm_fitness)\n        if candidate_fitness < self.hm_fitness[worst_index]:\n            self.harmony_memory[worst_index] = candidate\n            self.hm_fitness[worst_index] = candidate_fitness\n\n    def new_harmony(self):\n        new_solution = np.zeros(self.dim)\n        progress = self.eval_count / self.budget\n        par_decay = 0.5  # Decay factor\n        par = self.par_min + (self.par_max - self.par_min) * ((1 - progress) ** par_decay)  # Adjusted for better exploration\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                new_solution[i] = self.harmony_memory[np.random.randint(self.hms), i]\n                if np.random.rand() < par:  # Dynamic PAR\n                    new_solution[i] += np.random.uniform(-0.5, 0.5)  # Slight adjustment\n            else:\n                new_solution[i] = np.random.uniform(self.lb, self.ub)\n        return np.clip(new_solution, self.lb, self.ub)\n\n    def differential_evolution(self):\n        candidates = np.random.choice(self.hms, 4, replace=False)  # Increased sample size for competition\n        a, b, c, d = self.harmony_memory[candidates]\n        progress = (self.eval_count / self.budget)\n        self.f = self.f_min + (self.f_max - self.f_min) * (1 - progress)\n        if np.random.rand() < 0.5:\n            mutant = np.clip(a + self.f * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(b + self.f * (c - d), self.lb, self.ub)\n        trial = np.copy(mutant)\n        j_rand = np.random.randint(self.dim)\n        cr_decay = 0.5  # Decay factor\n        for j in range(self.dim):\n            if np.random.rand() > (self.cr * ((1 - progress) ** cr_decay)) and j != j_rand:  # Adaptive CR with finer adjustment\n                trial[j] = a[j]\n        return trial\n\n    def __call__(self, func):\n        for i in range(self.hms):\n            self.hm_fitness[i] = self.evaluate(self.harmony_memory[i], func)\n\n        while self.eval_count < self.budget:\n            if np.random.rand() < 0.5:\n                new_solution = self.new_harmony()\n            else:\n                new_solution = self.differential_evolution()\n            \n            new_fitness = self.evaluate(new_solution, func)\n            self.update_harmony_memory(new_solution, new_fitness)\n\n        best_index = np.argmin(self.hm_fitness)\n        return self.harmony_memory[best_index]", "name": "HybridHarmonyDifferentialEvolution", "description": "Introduce a competition mechanism for selecting candidates in differential evolution to improve convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "139a1882-9215-4642-9165-aad9c1f61d84", "metadata": {"aucs": [0.786796986266231, 0.9406682880391642, 0.8085132304604894, 0.7802325889169053, 0.9299379289488405, 0.9266508293593907, 0.808996485357819, 0.9198209034464856, 0.9106081198837491, 0.5869875816062813, 0.8771700594072511, 0.5866568466122547, 0.652987640276054, 0.8390508916513025, 0.8671808550206718, 0.5869610049731806, 0.6381676276933277, 0.6836182506061816, 0.189565649174821, 0.15401429611443818, 0.1914780684425056, 0.2397753890900337, 0.419593055787588, 0.31209284999987374, 0.1856800814122863, 0.5655444194977839, 0.18674940742214752, 0.1610123175302084, 0.18183169383832554, 0.1824523712477205, 0.18180984550127155, 0.1645653007890503, 0.15297928967386087, 0.14396583064214286, 0.29799799068134114, 0.1358186534686845, 0.9931052299045957, 0.9701686196998994, 0.9769147132350958, 0.9723924198716054, 0.9876777918988743, 0.9803663616950287, 0.9785537413858492, 0.9777369683689342, 0.9921800706203205, 0.3591733502306075, 0.5387788125831652, 0.43057828080407445, 0.32123312752729793, 0.42034933609583136, 0.4085954528931822, 0.27118206559482594, 0.34461530014860475, 0.2956806463223717, 0.3292799176291539, 0.16896748474881895, 0.6934691744840027, 0.9134721554479086, 0.9309971094369673, 0.907200226067112, 0.17781256751495877, 0.28137957388892865, 0.9484574109283237, 0.21036132331597313, 0.2078383373144025, 0.3020881593420899, 0.1204278488358912, 0.23607218918122774, 0.1717246776340582, 0.26440933668318334, 0.21284398424940265, 0.2576763781966164, 0.18757865015002895, 0.11249399595077014, 0.2034132864849152, 0.1360896750688475, 0.13378289682018496, 0.2181317740152, 0.1897141945711034, 0.18846668028634317, 0.23693975288387825, 0.06136638323612986, 0.082824274089221, 0.2693216368352196, 0.06661230739214785, 0.08182922769719503, 0.04083482159239482, 0.022168489854332063, 0.15509072195702078, 0.08938100718799846, 0.10910518433596883, 0.30835595250750125, 0.17758289864853782, 0.22269946736684632, 0.14526772373011132, 0.07650121285239131, 0.1493177159559087, 0.13260454017070566, 0.1900942803316552, 0.13662293359799738, 0.2884778749758016, 0.14246308801473717, 0.12056472420951048, 0.09726872974241874, 0.12491201658762163, 0.14455703307075785, 0.4962436899037437, 0.07741856431580818, 0.2255580480287802, 0.22354324995732155, 0.3456126722329792, 0.24159611016583993, 0.3783103708617853, 0.41092903883041776, 0.14761139913486965, 0.08756115044334112, 0.08565679613541599, 0.6491877873429458, 0.6345161699131806, 0.5726898973995833, 0.5386155097426819, 0.5589996784896059, 0.5502175441623907, 0.7965620095704594, 0.5738075140586925, 0.6947007979925073, 0.15295849558929653, 0.1396905766290638, 0.10308152392420256, 0.11189273375374165, 0.1606742897283877, 0.14197110339961416, 0.15758763384868946, 0.11440575669369224, 0.11079274411066742, 0.14435062718515201, 0.1398319466419885, 0.2390405358832054, 0.3048673367178023, 0.15467726671124837, 0.566821435941786, 0.3023124835801424, 0.24822888698861156, 0.1483473714409087, 0.37987771837310524, 0.39246080289855, 0.35678078290940274, 0.3343658025844367, 0.23422588788290277, 0.37800892755492177, 0.4265888076689828, 0.34842513199146086, 0.41967375626842274, 0.25257073268791086, 0.3395005964835105, 0.34087658176973346, 0.4317945338431437, 0.32964752595761804, 0.457339848339116, 0.471654658889078, 0.3776911280550945, 0.3674990514223797, 0.24201577157169551, 0.22429454647954616, 0.19963671369630487, 0.20605818321177016, 0.1929207773308369, 0.22697308797910765, 0.20582206984750095, 0.20907473331797555, 0.21875921287298483, 0.8069866594622136, 0.23422844008908916, 0.22773643014517342, 0.2270993365669025, 0.20936888289551925, 0.20996018560013574, 0.48648463480166004, 0.24621725144189177, 0.2948752445035001, 0.20177685782201726, 0.16628833886859462, 0.17311273070152733, 0.9042753142809987, 0.20033777462090863, 0.16957156226733971, 0.1668684237625333, 0.21224303150317336, 0.1674084559280029, 0.6773797735977913, 0.15676865180800137, 0.31527226321457014, 0.16870285367373783, 0.21127574969204355, 0.21320928255999483, 0.5923133694098202, 0.21366091300333223, 0.11348683907958113, 0.18364317626659044, 0.19087053672440624, 0.1799424475955833, 0.19498589098977104, 0.19424737873710918, 0.2097875557366159, 0.21423532646875343, 0.18767244340196698, 0.19974789311928554, 0.08821308785535242, 0.10389976426278968, 0.11951780889332908, 0.13180021330629366, 0.10211847432082033, 0.0836690966787621, 0.0964997377728476, 0.07834548418168108, 0.10894975625019854]}, "mutation_prompt": null}
