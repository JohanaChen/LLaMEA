{"id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.17369742432127286, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": null, "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "abb628d1-89e9-496e-98c1-f1098ef01b6c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "9375abdd-2f37-40ae-8e12-70725a75be77", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "4d4aad89-d264-4555-afda-af82909799dd", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "2e89d402-1f34-4ef3-b6a5-04a06c7dceab", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "62f140a2-aa42-4a2b-a3af-d682368289c4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "0bc59629-c111-419a-830f-321dbfc5a3f1", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "1aaed3ce-2886-4de5-8eb3-de63fab91d7a", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "f7079f13-f5bb-43df-a967-33cf365e0fd8", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "e75b8411-2228-4ca7-aa8b-86baf7b0e95c", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "17a37d53-7ac1-4648-a2c5-40e7fa1da7d4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "92d2d3af-dcd3-4a87-a066-902a96a30e74", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "d5eb10f8-cce4-473c-a52c-432038e98bbd", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "c0dd8401-00e9-4267-b190-ecfb21d2995d", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "0ffef405-332d-4831-8ab5-febd51780de7", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "868c4640-7877-417f-9c7f-08395273a5c7", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "3bc2369b-cdd1-403c-a256-72e1ee663287", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / self.temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            self.temperature *= self.cooling_rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.32920141214380627, 0.32920141214380627, 0.32920141214380627, 0.32769152621612174, 0.32769152621612174, 0.32769152621612174, 0.36273165667503815, 0.36273165667503815, 0.36273165667503815, 0.12421399112637932, 0.12421399112637932, 0.12421399112637932, 0.1148106622225078, 0.1148106622225078, 0.1148106622225078, 0.1276791607528468, 0.1276791607528468, 0.1276791607528468, 0.09350687180106854, 0.09350687180106854, 0.09350687180106854, 0.09660828873871885, 0.09660828873871885, 0.09660828873871885, 0.08632125932983203, 0.08632125932983203, 0.08632125932983203, 0.07692381846388685, 0.07692381846388685, 0.07692381846388685, 0.06745055189015259, 0.06745055189015259, 0.06745055189015259, 0.07888796997703451, 0.07888796997703451, 0.07888796997703451, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.5506601774557798, 0.5506601774557798, 0.5506601774557798, 0.6814808953233071, 0.6814808953233071, 0.6814808953233071, 0.1462754587607431, 0.1462754587607431, 0.1462754587607431, 0.14824296858794028, 0.14824296858794028, 0.14824296858794028, 0.15043689099303825, 0.15043689099303825, 0.15043689099303825, 0.20476277377868024, 0.20476277377868024, 0.20476277377868024, 0.22070646414431005, 0.22070646414431005, 0.22070646414431005, 0.19523000607399, 0.19523000607399, 0.19523000607399, 0.09731420995790996, 0.09731420995790996, 0.09731420995790996, 0.10363793268996213, 0.10363793268996213, 0.10363793268996213, 0.09793840226951067, 0.09793840226951067, 0.09793840226951067, 0.11135144798202978, 0.11135144798202978, 0.11135144798202978, 0.09435841234687137, 0.09435841234687137, 0.09435841234687137, 0.10218827126301899, 0.10218827126301899, 0.10218827126301899, 0.04498062964972682, 0.04498062964972682, 0.04498062964972682, 0.052195846792560396, 0.052195846792560396, 0.052195846792560396, 0.04958879393881033, 0.04958879393881033, 0.04958879393881033, 0.1079383764702585, 0.1079383764702585, 0.1079383764702585, 0.1323887445218126, 0.1323887445218126, 0.1323887445218126, 0.13264289711978872, 0.13264289711978872, 0.13264289711978872, 0.0005593725350434564, 0.0005593725350434564, 0.0005593725350434564, 0.00835556109010649, 0.00835556109010649, 0.00835556109010649, 0.015362783178312744, 0.015362783178312744, 0.015362783178312744, 0.06835575178397724, 0.06835575178397724, 0.06835575178397724, 0.0759405468082961, 0.0759405468082961, 0.0759405468082961, 0.06270090694090213, 0.06270090694090213, 0.06270090694090213, 0.3270214986655695, 0.3270214986655695, 0.3270214986655695, 0.3219182763417845, 0.3219182763417845, 0.3219182763417845, 0.32749557719067246, 0.32749557719067246, 0.32749557719067246, 0.0958752974025936, 0.0958752974025936, 0.0958752974025936, 0.07869427410253815, 0.07869427410253815, 0.07869427410253815, 0.08396878525410922, 0.08396878525410922, 0.08396878525410922, 0.18037448213925977, 0.18037448213925977, 0.18037448213925977, 0.15299573980263848, 0.15299573980263848, 0.15299573980263848, 0.16149884508262802, 0.16149884508262802, 0.16149884508262802, 0.2179463406103399, 0.2179463406103399, 0.2179463406103399, 0.20803252434576425, 0.20803252434576425, 0.20803252434576425, 0.22208200159371316, 0.22208200159371316, 0.22208200159371316, 0.1636459716575699, 0.1636459716575699, 0.1636459716575699, 0.13468682572667767, 0.13468682572667767, 0.13468682572667767, 0.1935662132630358, 0.1935662132630358, 0.1935662132630358, 0.19616003128465953, 0.19616003128465953, 0.19616003128465953, 0.19176248031466947, 0.19176248031466947, 0.19176248031466947, 0.1837035149371894, 0.1837035149371894, 0.1837035149371894, 0.17125925356279126, 0.17125925356279126, 0.17125925356279126, 0.17673841878745422, 0.17673841878745422, 0.17673841878745422, 0.18643902834688286, 0.18643902834688286, 0.18643902834688286, 0.252922707159836, 0.252922707159836, 0.252922707159836, 0.2347682266188128, 0.2347682266188128, 0.2347682266188128, 0.21978699460115247, 0.21978699460115247, 0.21978699460115247, 0.17440283441461102, 0.17440283441461102, 0.17440283441461102, 0.15878883632216678, 0.15878883632216678, 0.15878883632216678, 0.19450123975105038, 0.19450123975105038, 0.19450123975105038, 0.1845530219700281, 0.1845530219700281, 0.1845530219700281, 0.18640384539749844, 0.18640384539749844, 0.18640384539749844, 0.19683380381560345, 0.19683380381560345, 0.19683380381560345, 0.06618295479694192, 0.06618295479694192, 0.06618295479694192, 0.0705207088197689, 0.0705207088197689, 0.0705207088197689, 0.07421572203616211, 0.07421572203616211, 0.07421572203616211]}, "mutation_prompt": null}
{"id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 17, "fitness": 0.2009929200354024, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "999a4adf-c2fd-4933-9b53-c273a44a3deb", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "19d162d7-e863-4473-ae57-d7b98e07b5f5", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "f821607f-665a-462d-a189-16b05ec1c4d8", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "c60faabe-5835-4ba5-9b90-cf2502818bce", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "200da06a-b203-4303-9b22-98f8e2d03c3c", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "2e589625-4d1e-4ade-86f4-d4c138d50327", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "5d3b52c2-7933-449c-86f4-477fe3e4657e", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "c7e90035-5184-4433-89f6-5076b27b56e3", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            diversity = np.std(population, axis=0).mean()  # Calculate diversity\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                dynamic_F = self.F * (1 + 0.5 * diversity)  # Dynamic adjustment\n                mutant = np.clip(x0 + dynamic_F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced adaptive strategy by adjusting mutation factor dynamically based on population diversity to improve convergence stability.", "configspace": "", "generation": 24, "fitness": 0.14193133817752063, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.18719327345873693, 0.18719327345873693, 0.18719327345873693, 0.35946759211068047, 0.35946759211068047, 0.35946759211068047, 0.3063792133806912, 0.3063792133806912, 0.3063792133806912, 0.05677219377357978, 0.05677219377357978, 0.05677219377357978, 0.012362983982037945, 0.012362983982037945, 0.012362983982037945, 0.0358027056803365, 0.0358027056803365, 0.0358027056803365, 0.061250844726759346, 0.061250844726759346, 0.061250844726759346, 0.06977867075768684, 0.06977867075768684, 0.06977867075768684, 0.07523559055750761, 0.07523559055750761, 0.07523559055750761, 0.035103472336015296, 0.035103472336015296, 0.035103472336015296, 0.04071607109356046, 0.04071607109356046, 0.04071607109356046, 0.031449465560707046, 0.031449465560707046, 0.031449465560707046, 0.9660039205652684, 0.9660039205652684, 0.9660039205652684, 0.9499655916116576, 0.9499655916116576, 0.9499655916116576, 0.7098380204676453, 0.7098380204676453, 0.7098380204676453, 0.10481535875208758, 0.10481535875208758, 0.10481535875208758, 0.1055245495633812, 0.1055245495633812, 0.1055245495633812, 0.12107342093420681, 0.12107342093420681, 0.12107342093420681, 0.0865447359764917, 0.0865447359764917, 0.0865447359764917, 0.11497749422632986, 0.11497749422632986, 0.11497749422632986, 0.11408257266259081, 0.11408257266259081, 0.11408257266259081, 0.04625705365391919, 0.04625705365391919, 0.04625705365391919, 0.046472772700861475, 0.046472772700861475, 0.046472772700861475, 0.05987339842721218, 0.05987339842721218, 0.05987339842721218, 0.11349585701524811, 0.11349585701524811, 0.11349585701524811, 0.015708752403790327, 0.015708752403790327, 0.015708752403790327, 0.048223311139875324, 0.048223311139875324, 0.048223311139875324, 0.0020221249184840806, 0.0020221249184840806, 0.0020221249184840806, 0.014154732639516943, 0.014154732639516943, 0.014154732639516943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0754913344623308, 0.0754913344623308, 0.0754913344623308, 0.06130086314104177, 0.06130086314104177, 0.06130086314104177, 0.04834422611907574, 0.04834422611907574, 0.04834422611907574, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0047424268828545335, 0.0047424268828545335, 0.0047424268828545335, 0.0499094627979092, 0.0499094627979092, 0.0499094627979092, 0.03714538279681545, 0.03714538279681545, 0.03714538279681545, 0.06315566889078073, 0.06315566889078073, 0.06315566889078073, 0.22151650303258852, 0.22151650303258852, 0.22151650303258852, 0.22512348749544475, 0.22512348749544475, 0.22512348749544475, 0.25238507838040947, 0.25238507838040947, 0.25238507838040947, 0.09943167342134951, 0.09943167342134951, 0.09943167342134951, 0.10205334868809257, 0.10205334868809257, 0.10205334868809257, 0.07148704572411557, 0.07148704572411557, 0.07148704572411557, 0.17816994914517037, 0.17816994914517037, 0.17816994914517037, 0.19557430769253847, 0.19557430769253847, 0.19557430769253847, 0.17267385764990062, 0.17267385764990062, 0.17267385764990062, 0.18582019718350862, 0.18582019718350862, 0.18582019718350862, 0.15915596760669937, 0.15915596760669937, 0.15915596760669937, 0.20514624244334112, 0.20514624244334112, 0.20514624244334112, 0.11590004827448752, 0.11590004827448752, 0.11590004827448752, 0.11452355705399186, 0.11452355705399186, 0.11452355705399186, 0.12062427071716997, 0.12062427071716997, 0.12062427071716997, 0.16590537306921582, 0.16590537306921582, 0.16590537306921582, 0.1600514835521446, 0.1600514835521446, 0.1600514835521446, 0.15678428152694346, 0.15678428152694346, 0.15678428152694346, 0.15083876148628528, 0.15083876148628528, 0.15083876148628528, 0.11590249764946026, 0.11590249764946026, 0.11590249764946026, 0.1183912649976051, 0.1183912649976051, 0.1183912649976051, 0.17164649682845212, 0.17164649682845212, 0.17164649682845212, 0.16730341491326595, 0.16730341491326595, 0.16730341491326595, 0.16060948243047135, 0.16060948243047135, 0.16060948243047135, 0.14915237950606375, 0.14915237950606375, 0.14915237950606375, 0.1445680709716276, 0.1445680709716276, 0.1445680709716276, 0.17179457930396602, 0.17179457930396602, 0.17179457930396602, 0.19596657381249238, 0.19596657381249238, 0.19596657381249238, 0.18697264683207393, 0.18697264683207393, 0.18697264683207393, 0.18505766168195326, 0.18505766168195326, 0.18505766168195326, 0.05752460665855541, 0.05752460665855541, 0.05752460665855541, 0.05687061141469385, 0.05687061141469385, 0.05687061141469385, 0.05319551746973217, 0.05319551746973217, 0.05319551746973217]}, "mutation_prompt": null}
{"id": "0f1c05b1-f93d-4f6a-ba65-a4f4d34a3c8f", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "99585e10-3797-4afe-9947-571d9418e301", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "d2206841-b664-4f85-ac72-4665fb306ba5", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "0eb00333-1079-4ded-946b-60f9f59d2402", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm combining Differential Evolution and Simulated Annealing with adaptive parameters for enhanced convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.39685573286364684, 0.39685573286364684, 0.39685573286364684, 0.3995852371000651, 0.3995852371000651, 0.3995852371000651, 0.4203657720998881, 0.4203657720998881, 0.4203657720998881, 0.14142876194605525, 0.14142876194605525, 0.14142876194605525, 0.13538894241696942, 0.13538894241696942, 0.13538894241696942, 0.1405528553625922, 0.1405528553625922, 0.1405528553625922, 0.10566257539145751, 0.10566257539145751, 0.10566257539145751, 0.0957996418489262, 0.0957996418489262, 0.0957996418489262, 0.11458654392470125, 0.11458654392470125, 0.11458654392470125, 0.07772561114444598, 0.07772561114444598, 0.07772561114444598, 0.06882970245089981, 0.06882970245089981, 0.06882970245089981, 0.0889020205974308, 0.0889020205974308, 0.0889020205974308, 0.9748465832213917, 0.9748465832213917, 0.9748465832213917, 0.7431550103784574, 0.7431550103784574, 0.7431550103784574, 0.6866029469315764, 0.6866029469315764, 0.6866029469315764, 0.17588671314332915, 0.17588671314332915, 0.17588671314332915, 0.17364789714110052, 0.17364789714110052, 0.17364789714110052, 0.2138767597499186, 0.2138767597499186, 0.2138767597499186, 0.25180960535749575, 0.25180960535749575, 0.25180960535749575, 0.3608782734098338, 0.3608782734098338, 0.3608782734098338, 0.25215832482276934, 0.25215832482276934, 0.25215832482276934, 0.11392375498269125, 0.11392375498269125, 0.11392375498269125, 0.15308072605276224, 0.15308072605276224, 0.15308072605276224, 0.14007030227459194, 0.14007030227459194, 0.14007030227459194, 0.11920308088536513, 0.11920308088536513, 0.11920308088536513, 0.18454284928833697, 0.18454284928833697, 0.18454284928833697, 0.15085489408057906, 0.15085489408057906, 0.15085489408057906, 0.06897324451048548, 0.06897324451048548, 0.06897324451048548, 0.07344071512779249, 0.07344071512779249, 0.07344071512779249, 0.04219939848206855, 0.04219939848206855, 0.04219939848206855, 0.17240925128625328, 0.17240925128625328, 0.17240925128625328, 0.16115929014649388, 0.16115929014649388, 0.16115929014649388, 0.21161697647663524, 0.21161697647663524, 0.21161697647663524, 0.0015496960602587873, 0.0015496960602587873, 0.0015496960602587873, 0.007321812631092328, 0.007321812631092328, 0.007321812631092328, 0.001317714027392558, 0.001317714027392558, 0.001317714027392558, 0.09316824787015399, 0.09316824787015399, 0.09316824787015399, 0.10069296331656263, 0.10069296331656263, 0.10069296331656263, 0.10402799144750952, 0.10402799144750952, 0.10402799144750952, 0.36584445923652287, 0.36584445923652287, 0.36584445923652287, 0.35540051797796646, 0.35540051797796646, 0.35540051797796646, 0.3693906529508433, 0.3693906529508433, 0.3693906529508433, 0.09473709670168518, 0.09473709670168518, 0.09473709670168518, 0.10504982719686373, 0.10504982719686373, 0.10504982719686373, 0.085205422768033, 0.085205422768033, 0.085205422768033, 0.1612697776489067, 0.1612697776489067, 0.1612697776489067, 0.20056085176975647, 0.20056085176975647, 0.20056085176975647, 0.21165897672250722, 0.21165897672250722, 0.21165897672250722, 0.21486502537343555, 0.21486502537343555, 0.21486502537343555, 0.23347360989780963, 0.23347360989780963, 0.23347360989780963, 0.22443135431522365, 0.22443135431522365, 0.22443135431522365, 0.16671039924372433, 0.16671039924372433, 0.16671039924372433, 0.16030457421920297, 0.16030457421920297, 0.16030457421920297, 0.1815607965340137, 0.1815607965340137, 0.1815607965340137, 0.18238413718897295, 0.18238413718897295, 0.18238413718897295, 0.19292768269681126, 0.19292768269681126, 0.19292768269681126, 0.19120769289949413, 0.19120769289949413, 0.19120769289949413, 0.18032593770498684, 0.18032593770498684, 0.18032593770498684, 0.1673374545609475, 0.1673374545609475, 0.1673374545609475, 0.179403548800512, 0.179403548800512, 0.179403548800512, 0.363434053969125, 0.363434053969125, 0.363434053969125, 0.36175767732689545, 0.36175767732689545, 0.36175767732689545, 0.27501504253198983, 0.27501504253198983, 0.27501504253198983, 0.1828877911577671, 0.1828877911577671, 0.1828877911577671, 0.18109704409060945, 0.18109704409060945, 0.18109704409060945, 0.19481706830394674, 0.19481706830394674, 0.19481706830394674, 0.18310638375765442, 0.18310638375765442, 0.18310638375765442, 0.1963353012340463, 0.1963353012340463, 0.1963353012340463, 0.18344138417721867, 0.18344138417721867, 0.18344138417721867, 0.0670857216697145, 0.0670857216697145, 0.0670857216697145, 0.06407472466063968, 0.06407472466063968, 0.06407472466063968, 0.07628983301116787, 0.07628983301116787, 0.07628983301116787]}, "mutation_prompt": null}
{"id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.23302397900302624, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "ac834756-0bc1-4b33-87c0-b16c98efcd8a", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "5e445008-2b7a-4089-9d4e-55ee7afda6b7", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n                \n            # Adaptive population size based on progress\n            if evals % 100 == 0:\n                self.population_size = max(10, int(self.population_size * 0.98))\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "An improved hybrid algorithm with adaptive population size for robust exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.23302397900302624, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "4806605b-2738-4a5a-823f-55420ae2aa98", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "c54a159e-a1a5-4ada-b147-9afb1d2f6680", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "e06fd887-f406-42e7-ab5e-db9edf2abfca", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "f35e047d-0a1f-4ad5-a59e-eb10fcde19d1", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "3a72db03-4bf8-4f65-b742-aa9f3caa1880", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "f53238a0-f09e-4dbb-862d-09921e9502d0", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "c5923033-f46f-490f-b9cc-839da0e58b00", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "578caff9-3a4d-4a07-aa38-cd06bd97c874", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "477c50af-af6a-4fb8-9ee4-b62903fb0458", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "502a6058-ce4c-4933-8bfc-0753dea1596e", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "d803f60e-b57d-4fe3-a22b-459897cd21e9", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "5f8b02a3-6e49-4c93-93e1-c8e66ad84a13", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "fb2fa930-4bc5-4471-a9dc-85986449dc58", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "6bca4042-b8ff-46cf-8b3e-024929f61e6c", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "ef819272-fbff-475e-8b94-bad4098e5f93", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                noise = np.random.uniform(-0.01, 0.01, self.dim)  # small noise for diversity\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2) + noise, self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhance population diversity and adaptability by introducing a small random noise during mutation operations.", "configspace": "", "generation": 45, "fitness": 0.23093747611940735, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.45889198482568094, 0.45889198482568094, 0.45889198482568094, 0.4618523827731853, 0.4618523827731853, 0.4618523827731853, 0.4766160662809674, 0.4766160662809674, 0.4766160662809674, 0.15376839288588484, 0.15376839288588484, 0.15376839288588484, 0.12456381752921153, 0.12456381752921153, 0.12456381752921153, 0.1343941933684708, 0.1343941933684708, 0.1343941933684708, 0.1399354919722029, 0.1399354919722029, 0.1399354919722029, 0.10698988017595334, 0.10698988017595334, 0.10698988017595334, 0.1193160263731392, 0.1193160263731392, 0.1193160263731392, 0.08283948564351462, 0.08283948564351462, 0.08283948564351462, 0.0929232287590317, 0.0929232287590317, 0.0929232287590317, 0.09875171383433756, 0.09875171383433756, 0.09875171383433756, 0.6975368932877559, 0.6975368932877559, 0.6975368932877559, 0.9461964045253636, 0.9461964045253636, 0.9461964045253636, 0.6888133146169795, 0.6888133146169795, 0.6888133146169795, 0.22987227764835594, 0.22987227764835594, 0.22987227764835594, 0.2328547784720525, 0.2328547784720525, 0.2328547784720525, 0.2330669771069227, 0.2330669771069227, 0.2330669771069227, 0.42713238145713217, 0.42713238145713217, 0.42713238145713217, 0.5115277428186261, 0.5115277428186261, 0.5115277428186261, 0.5311112521828888, 0.5311112521828888, 0.5311112521828888, 0.17849774724672984, 0.17849774724672984, 0.17849774724672984, 0.1423391308477423, 0.1423391308477423, 0.1423391308477423, 0.16854671076313066, 0.16854671076313066, 0.16854671076313066, 0.1434488185679793, 0.1434488185679793, 0.1434488185679793, 0.1831752975195038, 0.1831752975195038, 0.1831752975195038, 0.16448626112386988, 0.16448626112386988, 0.16448626112386988, 0.0774406979227491, 0.0774406979227491, 0.0774406979227491, 0.09811728025236066, 0.09811728025236066, 0.09811728025236066, 0.08277483057586998, 0.08277483057586998, 0.08277483057586998, 0.18353520101360377, 0.18353520101360377, 0.18353520101360377, 0.14656176798633058, 0.14656176798633058, 0.14656176798633058, 0.1657267198817184, 0.1657267198817184, 0.1657267198817184, 0.015566836885850921, 0.015566836885850921, 0.015566836885850921, 0.008320056186722158, 0.008320056186722158, 0.008320056186722158, 0.01459154908714555, 0.01459154908714555, 0.01459154908714555, 0.12735806590681908, 0.12735806590681908, 0.12735806590681908, 0.13108091456217041, 0.13108091456217041, 0.13108091456217041, 0.12406882129380281, 0.12406882129380281, 0.12406882129380281, 0.4125469776494721, 0.4125469776494721, 0.4125469776494721, 0.4068494250584216, 0.4068494250584216, 0.4068494250584216, 0.3936549604328824, 0.3936549604328824, 0.3936549604328824, 0.11794772341466708, 0.11794772341466708, 0.11794772341466708, 0.10870724015396915, 0.10870724015396915, 0.10870724015396915, 0.11900869979821727, 0.11900869979821727, 0.11900869979821727, 0.1878849659958598, 0.1878849659958598, 0.1878849659958598, 0.1718847409812253, 0.1718847409812253, 0.1718847409812253, 0.20583253251003542, 0.20583253251003542, 0.20583253251003542, 0.2656315156970892, 0.2656315156970892, 0.2656315156970892, 0.2711264253102882, 0.2711264253102882, 0.2711264253102882, 0.2783134676252611, 0.2783134676252611, 0.2783134676252611, 0.21320930698380214, 0.21320930698380214, 0.21320930698380214, 0.2009633934125774, 0.2009633934125774, 0.2009633934125774, 0.2267053510165209, 0.2267053510165209, 0.2267053510165209, 0.20540614932771872, 0.20540614932771872, 0.20540614932771872, 0.18642497969229777, 0.18642497969229777, 0.18642497969229777, 0.19999297795851068, 0.19999297795851068, 0.19999297795851068, 0.18842534719291537, 0.18842534719291537, 0.18842534719291537, 0.1872082382457787, 0.1872082382457787, 0.1872082382457787, 0.17773030843848825, 0.17773030843848825, 0.17773030843848825, 0.4289232814988331, 0.4289232814988331, 0.4289232814988331, 0.2946620387225758, 0.2946620387225758, 0.2946620387225758, 0.269584911770136, 0.269584911770136, 0.269584911770136, 0.18839418766227733, 0.18839418766227733, 0.18839418766227733, 0.33306763928309335, 0.33306763928309335, 0.33306763928309335, 0.48473953008546555, 0.48473953008546555, 0.48473953008546555, 0.19755912430738276, 0.19755912430738276, 0.19755912430738276, 0.17207255745145955, 0.17207255745145955, 0.17207255745145955, 0.1915400494797641, 0.1915400494797641, 0.1915400494797641, 0.0804465962995311, 0.0804465962995311, 0.0804465962995311, 0.07140508137136226, 0.07140508137136226, 0.07140508137136226, 0.08505716160769261, 0.08505716160769261, 0.08505716160769261]}, "mutation_prompt": null}
{"id": "cea1cfce-d8c9-47a3-aaa8-f6be50b86550", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "7fb5169b-cf42-4b96-a741-a27434261b81", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n        self.dynamic_crossover_factor = 0.95  # Dynamic crossover factor for improved diversity\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                self.CR *= self.dynamic_crossover_factor\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Improved exploration by incorporating a dynamic crossover probability adaptation for better diversity maintenance.", "configspace": "", "generation": 47, "fitness": 0.19840798689873823, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4853247543733227, 0.4853247543733227, 0.4853247543733227, 0.4661497997521622, 0.4661497997521622, 0.4661497997521622, 0.46967989425340406, 0.46967989425340406, 0.46967989425340406, 0.23750718931326642, 0.23750718931326642, 0.23750718931326642, 0.2604213313566177, 0.2604213313566177, 0.2604213313566177, 0.2465458850975365, 0.2465458850975365, 0.2465458850975365, 0.18445105418514218, 0.18445105418514218, 0.18445105418514218, 0.1806414156145847, 0.1806414156145847, 0.1806414156145847, 0.18130544856493502, 0.18130544856493502, 0.18130544856493502, 0.15019493148060625, 0.15019493148060625, 0.15019493148060625, 0.16889780111075703, 0.16889780111075703, 0.16889780111075703, 0.15612807918983396, 0.15612807918983396, 0.15612807918983396, 0.6838399137685574, 0.6838399137685574, 0.6838399137685574, 0.7312481139468548, 0.7312481139468548, 0.7312481139468548, 0.8791390870004525, 0.8791390870004525, 0.8791390870004525, 0.13908056013153636, 0.13908056013153636, 0.13908056013153636, 0.11988155711710002, 0.11988155711710002, 0.11988155711710002, 0.16547352089659162, 0.16547352089659162, 0.16547352089659162, 0.16203521380182906, 0.16203521380182906, 0.16203521380182906, 0.18396452868013324, 0.18396452868013324, 0.18396452868013324, 0.16274474987510057, 0.16274474987510057, 0.16274474987510057, 0.15651194377345723, 0.15651194377345723, 0.15651194377345723, 0.14724496673338072, 0.14724496673338072, 0.14724496673338072, 0.1607848483661226, 0.1607848483661226, 0.1607848483661226, 0.12069959118692164, 0.12069959118692164, 0.12069959118692164, 0.15933417576998232, 0.15933417576998232, 0.15933417576998232, 0.12160118794365682, 0.12160118794365682, 0.12160118794365682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018180435829219244, 0.0018180435829219244, 0.0018180435829219244, 0.09161422402537478, 0.09161422402537478, 0.09161422402537478, 0.0755100393015633, 0.0755100393015633, 0.0755100393015633, 0.09843542128915794, 0.09843542128915794, 0.09843542128915794, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003746836272119358, 0.0003746836272119358, 0.0003746836272119358, 0.055614347846212664, 0.055614347846212664, 0.055614347846212664, 0.09212855120459518, 0.09212855120459518, 0.09212855120459518, 0.06735423842642918, 0.06735423842642918, 0.06735423842642918, 0.36438425465015867, 0.36438425465015867, 0.36438425465015867, 0.3397119950966043, 0.3397119950966043, 0.3397119950966043, 0.32621358768568276, 0.32621358768568276, 0.32621358768568276, 0.09226223133036604, 0.09226223133036604, 0.09226223133036604, 0.11873088368751938, 0.11873088368751938, 0.11873088368751938, 0.08771158419627878, 0.08771158419627878, 0.08771158419627878, 0.22206723280936147, 0.22206723280936147, 0.22206723280936147, 0.1746753417161464, 0.1746753417161464, 0.1746753417161464, 0.17992680570502784, 0.17992680570502784, 0.17992680570502784, 0.17810210780805646, 0.17810210780805646, 0.17810210780805646, 0.21686047851935875, 0.21686047851935875, 0.21686047851935875, 0.21754521991089948, 0.21754521991089948, 0.21754521991089948, 0.14056447516125192, 0.14056447516125192, 0.14056447516125192, 0.14940591936224978, 0.14940591936224978, 0.14940591936224978, 0.15039768718175783, 0.15039768718175783, 0.15039768718175783, 0.1964136031443191, 0.1964136031443191, 0.1964136031443191, 0.2031764361704228, 0.2031764361704228, 0.2031764361704228, 0.1872706101390269, 0.1872706101390269, 0.1872706101390269, 0.19633209504188376, 0.19633209504188376, 0.19633209504188376, 0.19370694443613512, 0.19370694443613512, 0.19370694443613512, 0.1957660840799078, 0.1957660840799078, 0.1957660840799078, 0.3267659959978447, 0.3267659959978447, 0.3267659959978447, 0.2532250503603264, 0.2532250503603264, 0.2532250503603264, 0.27177868501641156, 0.27177868501641156, 0.27177868501641156, 0.23561152769537275, 0.23561152769537275, 0.23561152769537275, 0.212602258407379, 0.212602258407379, 0.212602258407379, 0.25730982537174496, 0.25730982537174496, 0.25730982537174496, 0.19342260021456736, 0.19342260021456736, 0.19342260021456736, 0.19383904074819858, 0.19383904074819858, 0.19383904074819858, 0.2088974045352514, 0.2088974045352514, 0.2088974045352514, 0.07230884494187118, 0.07230884494187118, 0.07230884494187118, 0.07796763741252666, 0.07796763741252666, 0.07796763741252666, 0.08633951558792996, 0.08633951558792996, 0.08633951558792996]}, "mutation_prompt": null}
{"id": "8be404bb-863d-4161-aacf-433720b09640", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1 / temperature, 0.1 / temperature, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced local search via adaptive perturbation bounds in simulated annealing for improved convergence.", "configspace": "", "generation": 48, "fitness": 0.21260364754138, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4489413488613352, 0.4489413488613352, 0.4489413488613352, 0.45905691476727073, 0.45905691476727073, 0.45905691476727073, 0.4814177400078521, 0.4814177400078521, 0.4814177400078521, 0.21557790408890987, 0.21557790408890987, 0.21557790408890987, 0.24318168221747627, 0.24318168221747627, 0.24318168221747627, 0.20389899454397364, 0.20389899454397364, 0.20389899454397364, 0.11659005621912677, 0.11659005621912677, 0.11659005621912677, 0.09372135011795157, 0.09372135011795157, 0.09372135011795157, 0.09292653672409923, 0.09292653672409923, 0.09292653672409923, 0.0818672863657477, 0.0818672863657477, 0.0818672863657477, 0.0910666298364411, 0.0910666298364411, 0.0910666298364411, 0.07140371203796692, 0.07140371203796692, 0.07140371203796692, 0.7664498982505665, 0.7664498982505665, 0.7664498982505665, 0.8238786510743408, 0.8238786510743408, 0.8238786510743408, 0.7880911819687002, 0.7880911819687002, 0.7880911819687002, 0.20581091386460626, 0.20581091386460626, 0.20581091386460626, 0.22016097844157734, 0.22016097844157734, 0.22016097844157734, 0.21705475597079515, 0.21705475597079515, 0.21705475597079515, 0.2534715398323235, 0.2534715398323235, 0.2534715398323235, 0.42322857045798823, 0.42322857045798823, 0.42322857045798823, 0.43630952718800553, 0.43630952718800553, 0.43630952718800553, 0.13550993452677396, 0.13550993452677396, 0.13550993452677396, 0.1315172107871001, 0.1315172107871001, 0.1315172107871001, 0.13780009616356914, 0.13780009616356914, 0.13780009616356914, 0.11280610497376076, 0.11280610497376076, 0.11280610497376076, 0.12616005421452103, 0.12616005421452103, 0.12616005421452103, 0.14383559139029, 0.14383559139029, 0.14383559139029, 0.06937941456177432, 0.06937941456177432, 0.06937941456177432, 0.08871993002001777, 0.08871993002001777, 0.08871993002001777, 0.07790685598401104, 0.07790685598401104, 0.07790685598401104, 0.23233109383937922, 0.23233109383937922, 0.23233109383937922, 0.2173544582225443, 0.2173544582225443, 0.2173544582225443, 0.22777329781326583, 0.22777329781326583, 0.22777329781326583, 0.006664215059562273, 0.006664215059562273, 0.006664215059562273, 0.010635007712941125, 0.010635007712941125, 0.010635007712941125, 0.032933308504736525, 0.032933308504736525, 0.032933308504736525, 0.11065753388983068, 0.11065753388983068, 0.11065753388983068, 0.12197072646053675, 0.12197072646053675, 0.12197072646053675, 0.13308599106298602, 0.13308599106298602, 0.13308599106298602, 0.4018485654372125, 0.4018485654372125, 0.4018485654372125, 0.3828797321995082, 0.3828797321995082, 0.3828797321995082, 0.3843146112205641, 0.3843146112205641, 0.3843146112205641, 0.07248182130999326, 0.07248182130999326, 0.07248182130999326, 0.09091030927917532, 0.09091030927917532, 0.09091030927917532, 0.10369472815498115, 0.10369472815498115, 0.10369472815498115, 0.14102092249605924, 0.14102092249605924, 0.14102092249605924, 0.15056664755974403, 0.15056664755974403, 0.15056664755974403, 0.15472686794446455, 0.15472686794446455, 0.15472686794446455, 0.2549279364840037, 0.2549279364840037, 0.2549279364840037, 0.25376476101791345, 0.25376476101791345, 0.25376476101791345, 0.25567414757007556, 0.25567414757007556, 0.25567414757007556, 0.18984014871137844, 0.18984014871137844, 0.18984014871137844, 0.17026743783115994, 0.17026743783115994, 0.17026743783115994, 0.19271643157736962, 0.19271643157736962, 0.19271643157736962, 0.18959119213682363, 0.18959119213682363, 0.18959119213682363, 0.18422667138596183, 0.18422667138596183, 0.18422667138596183, 0.2063352083120591, 0.2063352083120591, 0.2063352083120591, 0.18637810904400676, 0.18637810904400676, 0.18637810904400676, 0.17029792771621832, 0.17029792771621832, 0.17029792771621832, 0.17071996758035834, 0.17071996758035834, 0.17071996758035834, 0.36542703242890406, 0.36542703242890406, 0.36542703242890406, 0.17652566330689967, 0.17652566330689967, 0.17652566330689967, 0.24051290552292393, 0.24051290552292393, 0.24051290552292393, 0.18016445636248413, 0.18016445636248413, 0.18016445636248413, 0.17963032639079524, 0.17963032639079524, 0.17963032639079524, 0.17961355691844405, 0.17961355691844405, 0.17961355691844405, 0.20221000297837188, 0.20221000297837188, 0.20221000297837188, 0.1905291357245622, 0.1905291357245622, 0.1905291357245622, 0.2002790920095573, 0.2002790920095573, 0.2002790920095573, 0.07882585286913546, 0.07882585286913546, 0.07882585286913546, 0.08427067860063964, 0.08427067860063964, 0.08427067860063964, 0.07114277687295467, 0.07114277687295467, 0.07114277687295467]}, "mutation_prompt": null}
{"id": "38a0e425-d4f0-44c7-a269-a3e7caef5203", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "383ae387-e287-4987-871d-6d440a91896d", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "4b1f8fd9-13d2-4759-ae12-cb85aa520f54", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "a1a8aace-77c9-447c-9539-5ce7549369d6", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "1188c26c-d52e-4ded-955e-0d5364fcb977", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "794259d9-db2c-48a1-aae1-fb1e93a463ba", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "2776d73b-3244-46d0-85e7-d761c952bb08", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "64f00cbc-02ab-447d-842d-4cf2c4b72504", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "8aaafe40-7f30-424b-8a4b-2fc5c294448e", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "e61c06f7-3d62-4a5a-89da-34856bf8f55d", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.95  # Cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "A refined hybrid algorithm incorporating adaptive mutation strategies for enhanced exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.4817241787773251, 0.4817241787773251, 0.4817241787773251, 0.49517970612920026, 0.49517970612920026, 0.49517970612920026, 0.500812188899162, 0.500812188899162, 0.500812188899162, 0.22441905259447192, 0.22441905259447192, 0.22441905259447192, 0.24248081264958565, 0.24248081264958565, 0.24248081264958565, 0.2480512712526789, 0.2480512712526789, 0.2480512712526789, 0.11066334303271741, 0.11066334303271741, 0.11066334303271741, 0.11357934667534997, 0.11357934667534997, 0.11357934667534997, 0.12496828514353053, 0.12496828514353053, 0.12496828514353053, 0.09566870920893111, 0.09566870920893111, 0.09566870920893111, 0.096502809919641, 0.096502809919641, 0.096502809919641, 0.10154847594689598, 0.10154847594689598, 0.10154847594689598, 0.7617659149701576, 0.7617659149701576, 0.7617659149701576, 0.7406748738265139, 0.7406748738265139, 0.7406748738265139, 0.7095075662764355, 0.7095075662764355, 0.7095075662764355, 0.25964897953560573, 0.25964897953560573, 0.25964897953560573, 0.23295743428842686, 0.23295743428842686, 0.23295743428842686, 0.2496390540343878, 0.2496390540343878, 0.2496390540343878, 0.4452798174609206, 0.4452798174609206, 0.4452798174609206, 0.5135267273897196, 0.5135267273897196, 0.5135267273897196, 0.5537008742572089, 0.5537008742572089, 0.5537008742572089, 0.15336380345290745, 0.15336380345290745, 0.15336380345290745, 0.157899238354394, 0.157899238354394, 0.157899238354394, 0.18840096826286623, 0.18840096826286623, 0.18840096826286623, 0.10316709000122559, 0.10316709000122559, 0.10316709000122559, 0.15764880805604298, 0.15764880805604298, 0.15764880805604298, 0.16190898176042956, 0.16190898176042956, 0.16190898176042956, 0.11200357778073922, 0.11200357778073922, 0.11200357778073922, 0.13348695264409793, 0.13348695264409793, 0.13348695264409793, 0.1279044747683331, 0.1279044747683331, 0.1279044747683331, 0.23915055241872296, 0.23915055241872296, 0.23915055241872296, 0.22211546936327065, 0.22211546936327065, 0.22211546936327065, 0.24198278886470126, 0.24198278886470126, 0.24198278886470126, 0.02420955237885214, 0.02420955237885214, 0.02420955237885214, 0.013194743008009047, 0.013194743008009047, 0.013194743008009047, 0.031768516563349114, 0.031768516563349114, 0.031768516563349114, 0.13068779123340335, 0.13068779123340335, 0.13068779123340335, 0.1326599483345191, 0.1326599483345191, 0.1326599483345191, 0.142903651450345, 0.142903651450345, 0.142903651450345, 0.39680452983136927, 0.39680452983136927, 0.39680452983136927, 0.4040353136738557, 0.4040353136738557, 0.4040353136738557, 0.41699309827009146, 0.41699309827009146, 0.41699309827009146, 0.127558769207061, 0.127558769207061, 0.127558769207061, 0.10245947775013098, 0.10245947775013098, 0.10245947775013098, 0.10226148995733364, 0.10226148995733364, 0.10226148995733364, 0.17735960549267638, 0.17735960549267638, 0.17735960549267638, 0.19492831059217974, 0.19492831059217974, 0.19492831059217974, 0.17931961284829523, 0.17931961284829523, 0.17931961284829523, 0.25463975437204023, 0.25463975437204023, 0.25463975437204023, 0.2604304916470418, 0.2604304916470418, 0.2604304916470418, 0.2794265068386542, 0.2794265068386542, 0.2794265068386542, 0.1994358329005217, 0.1994358329005217, 0.1994358329005217, 0.2051869455143377, 0.2051869455143377, 0.2051869455143377, 0.21562640434033586, 0.21562640434033586, 0.21562640434033586, 0.1839489972463758, 0.1839489972463758, 0.1839489972463758, 0.197505616876281, 0.197505616876281, 0.197505616876281, 0.19276629319551397, 0.19276629319551397, 0.19276629319551397, 0.18998587309369308, 0.18998587309369308, 0.18998587309369308, 0.1812606331386486, 0.1812606331386486, 0.1812606331386486, 0.18946047515796194, 0.18946047515796194, 0.18946047515796194, 0.460043533761314, 0.460043533761314, 0.460043533761314, 0.212958527820158, 0.212958527820158, 0.212958527820158, 0.318728776915546, 0.318728776915546, 0.318728776915546, 0.18273535168823296, 0.18273535168823296, 0.18273535168823296, 0.2549798250790094, 0.2549798250790094, 0.2549798250790094, 0.13808397517327298, 0.13808397517327298, 0.13808397517327298, 0.19593817050958773, 0.19593817050958773, 0.19593817050958773, 0.1776314733596921, 0.1776314733596921, 0.1776314733596921, 0.17831348969603167, 0.17831348969603167, 0.17831348969603167, 0.07312922901571273, 0.07312922901571273, 0.07312922901571273, 0.07214288477558961, 0.07214288477558961, 0.07214288477558961, 0.08489088751426899, 0.08489088751426899, 0.08489088751426899]}, "mutation_prompt": null}
{"id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 59, "fitness": 0.23799208343126074, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.16.", "error": "", "parent_id": "73e44e46-a583-4511-b6e7-4acdda060ec8", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "b87e6a94-fadb-49e9-bcd5-c0fda070c99f", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "bc42ad0e-3f2a-4178-95d6-b138ed3760f9", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "01b3f750-f0bb-457f-89b0-e10f9841d5f0", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "8b658d06-e8ac-40c2-8417-395139e7e149", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "fb2d5743-7822-4913-a4a3-9b3b632147d1", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "34510043-bddf-40c4-8a10-f88303c67d27", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "7644bcb4-392a-4405-bc4e-f2b94e911272", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "f43a2745-b56e-42d4-9463-b00af621cf59", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "96342167-5a67-4302-88e9-497e47551ff8", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "7d9626a8-5c1e-498f-a8af-4c83815ff9aa", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "85118345-42be-4359-9cd6-bd01fd9d2c75", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "ebdb95f5-de1e-4988-8c59-a2733c2b5282", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "b3e9bc9b-5b80-4d75-a1a0-d4aa6a37c01e", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "06d2fd08-679a-4c81-8eb3-7d0ce7fbda35", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "8775d701-6fbb-418a-b9ec-b0853c8bd9ee", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate\n        self.dynamic_adaptation_factor = 0.99  # Adaptation factor for dynamic parameter adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Simulated annealing step with adaptive temperature\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)  # Adjusted perturbation range\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA_Adaptive by fine-tuning perturbation range and adjusting cooling rate for improved exploration.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5163926106405636, 0.5163926106405636, 0.5163926106405636, 0.5218354310356399, 0.5218354310356399, 0.5218354310356399, 0.5195508104317846, 0.5195508104317846, 0.5195508104317846, 0.23170238340985605, 0.23170238340985605, 0.23170238340985605, 0.2534622674128709, 0.2534622674128709, 0.2534622674128709, 0.26862455414092334, 0.26862455414092334, 0.26862455414092334, 0.11536140415132234, 0.11536140415132234, 0.11536140415132234, 0.11966704166262243, 0.11966704166262243, 0.11966704166262243, 0.11652257048410297, 0.11652257048410297, 0.11652257048410297, 0.08962083897137796, 0.08962083897137796, 0.08962083897137796, 0.10293400933718966, 0.10293400933718966, 0.10293400933718966, 0.09939342319327604, 0.09939342319327604, 0.09939342319327604, 0.7231781766680825, 0.7231781766680825, 0.7231781766680825, 0.7398823227101272, 0.7398823227101272, 0.7398823227101272, 0.7039477384803972, 0.7039477384803972, 0.7039477384803972, 0.22393627435892405, 0.22393627435892405, 0.22393627435892405, 0.23952056311660053, 0.23952056311660053, 0.23952056311660053, 0.24917695969471132, 0.24917695969471132, 0.24917695969471132, 0.4571566720111838, 0.4571566720111838, 0.4571566720111838, 0.4747757479228707, 0.4747757479228707, 0.4747757479228707, 0.4348469922396957, 0.4348469922396957, 0.4348469922396957, 0.16293134613036442, 0.16293134613036442, 0.16293134613036442, 0.13622247071731797, 0.13622247071731797, 0.13622247071731797, 0.1793804946261951, 0.1793804946261951, 0.1793804946261951, 0.21032193633036822, 0.21032193633036822, 0.21032193633036822, 0.1714358548816559, 0.1714358548816559, 0.1714358548816559, 0.14855137581373712, 0.14855137581373712, 0.14855137581373712, 0.11217601898123664, 0.11217601898123664, 0.11217601898123664, 0.10025670947323528, 0.10025670947323528, 0.10025670947323528, 0.1341259739544699, 0.1341259739544699, 0.1341259739544699, 0.2621705407730852, 0.2621705407730852, 0.2621705407730852, 0.2477665508190826, 0.2477665508190826, 0.2477665508190826, 0.2282288073358516, 0.2282288073358516, 0.2282288073358516, 0.030242983695238812, 0.030242983695238812, 0.030242983695238812, 0.04546376570660138, 0.04546376570660138, 0.04546376570660138, 0.035426680690201606, 0.035426680690201606, 0.035426680690201606, 0.13762343840094748, 0.13762343840094748, 0.13762343840094748, 0.14514796401707208, 0.14514796401707208, 0.14514796401707208, 0.135736888429132, 0.135736888429132, 0.135736888429132, 0.4398570954320571, 0.4398570954320571, 0.4398570954320571, 0.4201893520614475, 0.4201893520614475, 0.4201893520614475, 0.43050212952960853, 0.43050212952960853, 0.43050212952960853, 0.10640098938041542, 0.10640098938041542, 0.10640098938041542, 0.11313445734052752, 0.11313445734052752, 0.11313445734052752, 0.1170962412013723, 0.1170962412013723, 0.1170962412013723, 0.1755972714273839, 0.1755972714273839, 0.1755972714273839, 0.18039032092815155, 0.18039032092815155, 0.18039032092815155, 0.17055257161132054, 0.17055257161132054, 0.17055257161132054, 0.25978803754246627, 0.25978803754246627, 0.25978803754246627, 0.2541389738931119, 0.2541389738931119, 0.2541389738931119, 0.27268775364736086, 0.27268775364736086, 0.27268775364736086, 0.21527648025928714, 0.21527648025928714, 0.21527648025928714, 0.1978397632993204, 0.1978397632993204, 0.1978397632993204, 0.19775027944980939, 0.19775027944980939, 0.19775027944980939, 0.19946819773202773, 0.19946819773202773, 0.19946819773202773, 0.20545289028051217, 0.20545289028051217, 0.20545289028051217, 0.20946731065369972, 0.20946731065369972, 0.20946731065369972, 0.21275380024134005, 0.21275380024134005, 0.21275380024134005, 0.19654981740007305, 0.19654981740007305, 0.19654981740007305, 0.2043673558381951, 0.2043673558381951, 0.2043673558381951, 0.5782410786873724, 0.5782410786873724, 0.5782410786873724, 0.3218324261085158, 0.3218324261085158, 0.3218324261085158, 0.2758452110933127, 0.2758452110933127, 0.2758452110933127, 0.15495679916684935, 0.15495679916684935, 0.15495679916684935, 0.18272934337257285, 0.18272934337257285, 0.18272934337257285, 0.2211476151798898, 0.2211476151798898, 0.2211476151798898, 0.18388522011056652, 0.18388522011056652, 0.18388522011056652, 0.17907157566239817, 0.17907157566239817, 0.17907157566239817, 0.19146818475199778, 0.19146818475199778, 0.19146818475199778, 0.07818221425909866, 0.07818221425909866, 0.07818221425909866, 0.08674820118527493, 0.08674820118527493, 0.08674820118527493, 0.07736245547352172, 0.07736245547352172, 0.07736245547352172]}, "mutation_prompt": null}
{"id": "167a314f-5c42-4b73-acb4-40121b6804a5", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 75, "fitness": 0.24894357379835974, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "d8707cc9-c366-4719-8e74-74eb59b8bef4", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "7d58e400-35f4-465e-8b49-c1a0f1cb9835", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "63bf4585-68e8-4a5a-a4a1-4bea1070ae6d", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / (temperature * self.cooling_rate)):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by integrating dynamic adaptation of mutation factor and incorporating temperature scaling for simulated annealing.", "configspace": "", "generation": 77, "fitness": 0.24674274169254212, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5060694465230362, 0.5060694465230362, 0.5060694465230362, 0.5184598523664998, 0.5184598523664998, 0.5184598523664998, 0.5483507362038398, 0.5483507362038398, 0.5483507362038398, 0.26732141188855973, 0.26732141188855973, 0.26732141188855973, 0.25626520169830336, 0.25626520169830336, 0.25626520169830336, 0.28122700851739646, 0.28122700851739646, 0.28122700851739646, 0.13009165893062458, 0.13009165893062458, 0.13009165893062458, 0.13914732272254715, 0.13914732272254715, 0.13914732272254715, 0.1257620575648598, 0.1257620575648598, 0.1257620575648598, 0.0987273845267651, 0.0987273845267651, 0.0987273845267651, 0.11214701802211546, 0.11214701802211546, 0.11214701802211546, 0.09561431384439334, 0.09561431384439334, 0.09561431384439334, 0.7624826880519691, 0.7624826880519691, 0.7624826880519691, 0.7107501563633202, 0.7107501563633202, 0.7107501563633202, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.25710778074598895, 0.25710778074598895, 0.25710778074598895, 0.25807068240826747, 0.25807068240826747, 0.25807068240826747, 0.24304703916700998, 0.24304703916700998, 0.24304703916700998, 0.4586614093393395, 0.4586614093393395, 0.4586614093393395, 0.6070655272199497, 0.6070655272199497, 0.6070655272199497, 0.520551846928115, 0.520551846928115, 0.520551846928115, 0.1738416365257055, 0.1738416365257055, 0.1738416365257055, 0.19088890967371774, 0.19088890967371774, 0.19088890967371774, 0.1839398582869718, 0.1839398582869718, 0.1839398582869718, 0.1157474822993314, 0.1157474822993314, 0.1157474822993314, 0.15586653590485822, 0.15586653590485822, 0.15586653590485822, 0.15079285424987188, 0.15079285424987188, 0.15079285424987188, 0.15712577777991954, 0.15712577777991954, 0.15712577777991954, 0.137221661378363, 0.137221661378363, 0.137221661378363, 0.14683156439848644, 0.14683156439848644, 0.14683156439848644, 0.24485923565322076, 0.24485923565322076, 0.24485923565322076, 0.2137832162211356, 0.2137832162211356, 0.2137832162211356, 0.27993585155872025, 0.27993585155872025, 0.27993585155872025, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.1439806173645113, 0.1439806173645113, 0.1439806173645113, 0.14059993324359166, 0.14059993324359166, 0.14059993324359166, 0.14979902955809832, 0.14979902955809832, 0.14979902955809832, 0.44750355312218904, 0.44750355312218904, 0.44750355312218904, 0.4461052516829829, 0.4461052516829829, 0.4461052516829829, 0.4433824131134031, 0.4433824131134031, 0.4433824131134031, 0.10462746646901322, 0.10462746646901322, 0.10462746646901322, 0.12483014386570446, 0.12483014386570446, 0.12483014386570446, 0.11539867230006917, 0.11539867230006917, 0.11539867230006917, 0.1470770432869849, 0.1470770432869849, 0.1470770432869849, 0.16907776871643587, 0.16907776871643587, 0.16907776871643587, 0.17095883337729356, 0.17095883337729356, 0.17095883337729356, 0.3050425963400908, 0.3050425963400908, 0.3050425963400908, 0.2611917219649995, 0.2611917219649995, 0.2611917219649995, 0.28930121579984114, 0.28930121579984114, 0.28930121579984114, 0.21986619060521417, 0.21986619060521417, 0.21986619060521417, 0.21737011900955272, 0.21737011900955272, 0.21737011900955272, 0.22569922810966558, 0.22569922810966558, 0.22569922810966558, 0.20079042290133453, 0.20079042290133453, 0.20079042290133453, 0.20089648863382703, 0.20089648863382703, 0.20089648863382703, 0.2016549157467138, 0.2016549157467138, 0.2016549157467138, 0.1830812513206972, 0.1830812513206972, 0.1830812513206972, 0.18454425284954312, 0.18454425284954312, 0.18454425284954312, 0.22692286092712466, 0.22692286092712466, 0.22692286092712466, 0.4138953750286646, 0.4138953750286646, 0.4138953750286646, 0.4112849099759376, 0.4112849099759376, 0.4112849099759376, 0.23674287551730044, 0.23674287551730044, 0.23674287551730044, 0.18843662781425397, 0.18843662781425397, 0.18843662781425397, 0.15905275771053162, 0.15905275771053162, 0.15905275771053162, 0.196256923008846, 0.196256923008846, 0.196256923008846, 0.18844839483727105, 0.18844839483727105, 0.18844839483727105, 0.2057295101244625, 0.2057295101244625, 0.2057295101244625, 0.1921696594047304, 0.1921696594047304, 0.1921696594047304, 0.08166137045480448, 0.08166137045480448, 0.08166137045480448, 0.07963952940848318, 0.07963952940848318, 0.07963952940848318, 0.07342670871762524, 0.07342670871762524, 0.07342670871762524]}, "mutation_prompt": null}
{"id": "22f1fc5b-b2b9-47d2-a788-de71f6220216", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "678ec02b-398b-45db-a1b4-6d37a6e52dbe", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "fdd904d6-eb75-4d0f-9d2e-3c1227898ed6", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / (temperature + 1e-10)):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Refined exploration using adaptive differential weight update with minor stochastic modifications to enhance convergence.", "configspace": "", "generation": 80, "fitness": 0.24894357379835974, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "33da3881-feba-4162-90a4-113b91b7f640", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "d906ccda-658d-48c9-999e-58fcd2c73e30", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n            # New elitism strategy\n            if evals % (self.population_size * 2) == 0:\n                elite_indices = fitness.argsort()[:5]  # Top 5 elites\n                population[:5] = population[elite_indices]\n                fitness[:5] = fitness[elite_indices]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by strategic application of elitism and adaptive cooling to maintain diversity.", "configspace": "", "generation": 82, "fitness": 0.24894357379835974, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.17.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "e9bfd601-654c-45b5-ab42-e3c056f15a6c", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "89027539-4329-4fe0-a7ff-8683234aa5a9", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < (np.random.rand() * self.CR)  # Randomized CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor + 0.005  # Slightly modified cooling rate\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by introducing adaptive cooling rate modification and adding a random selection mechanism for crossover.", "configspace": "", "generation": 84, "fitness": 0.19525326115735184, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.15.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.4531900123712461, 0.4531900123712461, 0.4531900123712461, 0.4695592529533862, 0.4695592529533862, 0.4695592529533862, 0.4377899660935217, 0.4377899660935217, 0.4377899660935217, 0.23822851274353984, 0.23822851274353984, 0.23822851274353984, 0.22728326069495886, 0.22728326069495886, 0.22728326069495886, 0.248641412586998, 0.248641412586998, 0.248641412586998, 0.13652123661516236, 0.13652123661516236, 0.13652123661516236, 0.14249196513968654, 0.14249196513968654, 0.14249196513968654, 0.14160749080570023, 0.14160749080570023, 0.14160749080570023, 0.11987216605307016, 0.11987216605307016, 0.11987216605307016, 0.1193120418267184, 0.1193120418267184, 0.1193120418267184, 0.11871906528226461, 0.11871906528226461, 0.11871906528226461, 0.7615527267773362, 0.7615527267773362, 0.7615527267773362, 0.647149396768009, 0.647149396768009, 0.647149396768009, 0.7714893070243802, 0.7714893070243802, 0.7714893070243802, 0.16979171600472842, 0.16979171600472842, 0.16979171600472842, 0.17077014270952406, 0.17077014270952406, 0.17077014270952406, 0.18538660735213197, 0.18538660735213197, 0.18538660735213197, 0.2001093201604741, 0.2001093201604741, 0.2001093201604741, 0.2395174828131148, 0.2395174828131148, 0.2395174828131148, 0.21037444497593183, 0.21037444497593183, 0.21037444497593183, 0.13560059352241427, 0.13560059352241427, 0.13560059352241427, 0.11951252622022224, 0.11951252622022224, 0.11951252622022224, 0.1491095727005891, 0.1491095727005891, 0.1491095727005891, 0.1089858615444087, 0.1089858615444087, 0.1089858615444087, 0.15971435041449844, 0.15971435041449844, 0.15971435041449844, 0.1319585912355895, 0.1319585912355895, 0.1319585912355895, 0.054281945916522134, 0.054281945916522134, 0.054281945916522134, 0.011215376715051906, 0.011215376715051906, 0.011215376715051906, 0.0007464096352661764, 0.0007464096352661764, 0.0007464096352661764, 0.11584291973409677, 0.11584291973409677, 0.11584291973409677, 0.10573272419696644, 0.10573272419696644, 0.10573272419696644, 0.10209450794596309, 0.10209450794596309, 0.10209450794596309, 0.009482741415069773, 0.009482741415069773, 0.009482741415069773, 0.007866855425389785, 0.007866855425389785, 0.007866855425389785, 0.009855775081292428, 0.009855775081292428, 0.009855775081292428, 0.08285752163139115, 0.08285752163139115, 0.08285752163139115, 0.08788741209589102, 0.08788741209589102, 0.08788741209589102, 0.08155461099893313, 0.08155461099893313, 0.08155461099893313, 0.36902146403629543, 0.36902146403629543, 0.36902146403629543, 0.3724409480813885, 0.3724409480813885, 0.3724409480813885, 0.3633093620881471, 0.3633093620881471, 0.3633093620881471, 0.10291495506521564, 0.10291495506521564, 0.10291495506521564, 0.10870672281813354, 0.10870672281813354, 0.10870672281813354, 0.11418174285084204, 0.11418174285084204, 0.11418174285084204, 0.1560549085972902, 0.1560549085972902, 0.1560549085972902, 0.15203919812962308, 0.15203919812962308, 0.15203919812962308, 0.17124543705665818, 0.17124543705665818, 0.17124543705665818, 0.23628795658881763, 0.23628795658881763, 0.23628795658881763, 0.23902703956796278, 0.23902703956796278, 0.23902703956796278, 0.2352769719946064, 0.2352769719946064, 0.2352769719946064, 0.16284232904555462, 0.16284232904555462, 0.16284232904555462, 0.19189383674684757, 0.19189383674684757, 0.19189383674684757, 0.17602743953047484, 0.17602743953047484, 0.17602743953047484, 0.19978307011867047, 0.19978307011867047, 0.19978307011867047, 0.2022940487304743, 0.2022940487304743, 0.2022940487304743, 0.19364631427045764, 0.19364631427045764, 0.19364631427045764, 0.18656213362236918, 0.18656213362236918, 0.18656213362236918, 0.21255086697516123, 0.21255086697516123, 0.21255086697516123, 0.2158998698840917, 0.2158998698840917, 0.2158998698840917, 0.19977042320526028, 0.19977042320526028, 0.19977042320526028, 0.156137054522419, 0.156137054522419, 0.156137054522419, 0.2821591925919089, 0.2821591925919089, 0.2821591925919089, 0.16952869436882867, 0.16952869436882867, 0.16952869436882867, 0.15954792766513182, 0.15954792766513182, 0.15954792766513182, 0.2397240309609343, 0.2397240309609343, 0.2397240309609343, 0.19836050922432646, 0.19836050922432646, 0.19836050922432646, 0.17742153202863697, 0.17742153202863697, 0.17742153202863697, 0.19507136822850923, 0.19507136822850923, 0.19507136822850923, 0.07889737948511588, 0.07889737948511588, 0.07889737948511588, 0.08003874707195613, 0.08003874707195613, 0.08003874707195613, 0.07591350399578256, 0.07591350399578256, 0.07591350399578256]}, "mutation_prompt": null}
{"id": "14a6f89e-8cc6-41eb-948b-bdf965217780", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "be5c3c1f-8be9-4885-a687-9ae09a82c423", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "8750f97c-2c35-45af-a2a9-1ad7acc0f9fe", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor * (1 + 0.01 * np.sin(evals / self.budget * np.pi))\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Adaptive exploration and exploitation by dynamic adjustment of cooling rate and crossover probability.", "configspace": "", "generation": 87, "fitness": 0.23855775503355442, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.16.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.4493471354495606, 0.4493471354495606, 0.4493471354495606, 0.4722451520985125, 0.4722451520985125, 0.4722451520985125, 0.47167581767899736, 0.47167581767899736, 0.47167581767899736, 0.24615183580050803, 0.24615183580050803, 0.24615183580050803, 0.3040322648157662, 0.3040322648157662, 0.3040322648157662, 0.2684721891681001, 0.2684721891681001, 0.2684721891681001, 0.11522562877192954, 0.11522562877192954, 0.11522562877192954, 0.11362857786061087, 0.11362857786061087, 0.11362857786061087, 0.11607025329316656, 0.11607025329316656, 0.11607025329316656, 0.1076450848746845, 0.1076450848746845, 0.1076450848746845, 0.09418874189651993, 0.09418874189651993, 0.09418874189651993, 0.1053549343224458, 0.1053549343224458, 0.1053549343224458, 0.7488808985040606, 0.7488808985040606, 0.7488808985040606, 0.7001194658861736, 0.7001194658861736, 0.7001194658861736, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.24522938098425784, 0.24522938098425784, 0.24522938098425784, 0.24326131310094312, 0.24326131310094312, 0.24326131310094312, 0.2467949151184491, 0.2467949151184491, 0.2467949151184491, 0.46372907415633524, 0.46372907415633524, 0.46372907415633524, 0.538182483976777, 0.538182483976777, 0.538182483976777, 0.5266520892809192, 0.5266520892809192, 0.5266520892809192, 0.2237973933996018, 0.2237973933996018, 0.2237973933996018, 0.15860023362286846, 0.15860023362286846, 0.15860023362286846, 0.18641284315014095, 0.18641284315014095, 0.18641284315014095, 0.24359159214306625, 0.24359159214306625, 0.24359159214306625, 0.2140521406084216, 0.2140521406084216, 0.2140521406084216, 0.19025572295467152, 0.19025572295467152, 0.19025572295467152, 0.1378247206142722, 0.1378247206142722, 0.1378247206142722, 0.1439439456465279, 0.1439439456465279, 0.1439439456465279, 0.13589731000409688, 0.13589731000409688, 0.13589731000409688, 0.23904575287085883, 0.23904575287085883, 0.23904575287085883, 0.2522527381992954, 0.2522527381992954, 0.2522527381992954, 0.2801281108865792, 0.2801281108865792, 0.2801281108865792, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14210671152074794, 0.14210671152074794, 0.14210671152074794, 0.14353699687923327, 0.14353699687923327, 0.14353699687923327, 0.15943420214475046, 0.15943420214475046, 0.15943420214475046, 0.42451656405008487, 0.42451656405008487, 0.42451656405008487, 0.4260842027428995, 0.4260842027428995, 0.4260842027428995, 0.41792114953736714, 0.41792114953736714, 0.41792114953736714, 0.11364713126800907, 0.11364713126800907, 0.11364713126800907, 0.13494877475255396, 0.13494877475255396, 0.13494877475255396, 0.10639221611967076, 0.10639221611967076, 0.10639221611967076, 0.1753609779463845, 0.1753609779463845, 0.1753609779463845, 0.1592374194398144, 0.1592374194398144, 0.1592374194398144, 0.1773419511942187, 0.1773419511942187, 0.1773419511942187, 0.30175526368775785, 0.30175526368775785, 0.30175526368775785, 0.2566171130174918, 0.2566171130174918, 0.2566171130174918, 0.29099863273638726, 0.29099863273638726, 0.29099863273638726, 0.21472621321226348, 0.21472621321226348, 0.21472621321226348, 0.22409997995858477, 0.22409997995858477, 0.22409997995858477, 0.21877920452843436, 0.21877920452843436, 0.21877920452843436, 0.20539331071389688, 0.20539331071389688, 0.20539331071389688, 0.21077275516169836, 0.21077275516169836, 0.21077275516169836, 0.19166909984093927, 0.19166909984093927, 0.19166909984093927, 0.19624596272065364, 0.19624596272065364, 0.19624596272065364, 0.17550876974022722, 0.17550876974022722, 0.17550876974022722, 0.20180011449726243, 0.20180011449726243, 0.20180011449726243, 0.18083705727166055, 0.18083705727166055, 0.18083705727166055, 0.16487975226582507, 0.16487975226582507, 0.16487975226582507, 0.21732646493842833, 0.21732646493842833, 0.21732646493842833, 0.18827095382789572, 0.18827095382789572, 0.18827095382789572, 0.1590261412316658, 0.1590261412316658, 0.1590261412316658, 0.19612191905556453, 0.19612191905556453, 0.19612191905556453, 0.19230572670795842, 0.19230572670795842, 0.19230572670795842, 0.20304607778590456, 0.20304607778590456, 0.20304607778590456, 0.20130331046625172, 0.20130331046625172, 0.20130331046625172, 0.08019300993808032, 0.08019300993808032, 0.08019300993808032, 0.08965258321324399, 0.08965258321324399, 0.08965258321324399, 0.08033526457494788, 0.08033526457494788, 0.08033526457494788]}, "mutation_prompt": null}
{"id": "5980b24a-c86d-457d-8229-9bfadc0826f4", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "c7f5ddc6-bbb2-45ab-845f-cf210621a9df", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.995  # Adjusted factor for stability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Improved synergy between differential evolution and simulated annealing by stabilizing the dynamic adaptation factor.", "configspace": "", "generation": 89, "fitness": 0.23395604186005392, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.4547033474264055, 0.4547033474264055, 0.4547033474264055, 0.47873260807315143, 0.47873260807315143, 0.47873260807315143, 0.4753086618300758, 0.4753086618300758, 0.4753086618300758, 0.25556289717802516, 0.25556289717802516, 0.25556289717802516, 0.27664096931092974, 0.27664096931092974, 0.27664096931092974, 0.2460518673243105, 0.2460518673243105, 0.2460518673243105, 0.11506504929022499, 0.11506504929022499, 0.11506504929022499, 0.1221425150958323, 0.1221425150958323, 0.1221425150958323, 0.12186029013439326, 0.12186029013439326, 0.12186029013439326, 0.09767588553028395, 0.09767588553028395, 0.09767588553028395, 0.0897940055452684, 0.0897940055452684, 0.0897940055452684, 0.09821232740246488, 0.09821232740246488, 0.09821232740246488, 0.7488808985040606, 0.7488808985040606, 0.7488808985040606, 0.6983366732422767, 0.6983366732422767, 0.6983366732422767, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.23553127149520592, 0.23553127149520592, 0.23553127149520592, 0.24052828850362207, 0.24052828850362207, 0.24052828850362207, 0.2531376233782646, 0.2531376233782646, 0.2531376233782646, 0.47945430663140687, 0.47945430663140687, 0.47945430663140687, 0.5504529471680005, 0.5504529471680005, 0.5504529471680005, 0.4979219638640682, 0.4979219638640682, 0.4979219638640682, 0.16618855753633144, 0.16618855753633144, 0.16618855753633144, 0.14443866096215097, 0.14443866096215097, 0.14443866096215097, 0.1434548573211203, 0.1434548573211203, 0.1434548573211203, 0.14089431982058742, 0.14089431982058742, 0.14089431982058742, 0.15025634700664525, 0.15025634700664525, 0.15025634700664525, 0.16024576733758966, 0.16024576733758966, 0.16024576733758966, 0.16747426557072354, 0.16747426557072354, 0.16747426557072354, 0.1552957727685249, 0.1552957727685249, 0.1552957727685249, 0.1326592038878891, 0.1326592038878891, 0.1326592038878891, 0.22456414495031063, 0.22456414495031063, 0.22456414495031063, 0.2225568897615271, 0.2225568897615271, 0.2225568897615271, 0.2501201421472803, 0.2501201421472803, 0.2501201421472803, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.057304762016860744, 0.057304762016860744, 0.057304762016860744, 0.06176712546638974, 0.06176712546638974, 0.06176712546638974, 0.12903077247637518, 0.12903077247637518, 0.12903077247637518, 0.14499189347247798, 0.14499189347247798, 0.14499189347247798, 0.14656786324081894, 0.14656786324081894, 0.14656786324081894, 0.4164546415257302, 0.4164546415257302, 0.4164546415257302, 0.42052182793927617, 0.42052182793927617, 0.42052182793927617, 0.4087489219633532, 0.4087489219633532, 0.4087489219633532, 0.11896341511689257, 0.11896341511689257, 0.11896341511689257, 0.10853420435646366, 0.10853420435646366, 0.10853420435646366, 0.11093522840963266, 0.11093522840963266, 0.11093522840963266, 0.21247419663699607, 0.21247419663699607, 0.21247419663699607, 0.17011702422623853, 0.17011702422623853, 0.17011702422623853, 0.1742651495709775, 0.1742651495709775, 0.1742651495709775, 0.2916788242387278, 0.2916788242387278, 0.2916788242387278, 0.2636097061017686, 0.2636097061017686, 0.2636097061017686, 0.2955621172953974, 0.2955621172953974, 0.2955621172953974, 0.1958958407013971, 0.1958958407013971, 0.1958958407013971, 0.23054176034344653, 0.23054176034344653, 0.23054176034344653, 0.2020854859062361, 0.2020854859062361, 0.2020854859062361, 0.20781205898640243, 0.20781205898640243, 0.20781205898640243, 0.1837861283799893, 0.1837861283799893, 0.1837861283799893, 0.18812066032452968, 0.18812066032452968, 0.18812066032452968, 0.19298053518400393, 0.19298053518400393, 0.19298053518400393, 0.22658253474277212, 0.22658253474277212, 0.22658253474277212, 0.19022009717254384, 0.19022009717254384, 0.19022009717254384, 0.32524293083293054, 0.32524293083293054, 0.32524293083293054, 0.16440639655264422, 0.16440639655264422, 0.16440639655264422, 0.1892986932848194, 0.1892986932848194, 0.1892986932848194, 0.18926962725574614, 0.18926962725574614, 0.18926962725574614, 0.15904246837481584, 0.15904246837481584, 0.15904246837481584, 0.19621434383580294, 0.19621434383580294, 0.19621434383580294, 0.19418469581510045, 0.19418469581510045, 0.19418469581510045, 0.17904745884915774, 0.17904745884915774, 0.17904745884915774, 0.19690226983918446, 0.19690226983918446, 0.19690226983918446, 0.08345535627775535, 0.08345535627775535, 0.08345535627775535, 0.09002460511418542, 0.09002460511418542, 0.09002460511418542, 0.08343266824988727, 0.08343266824988727, 0.08343266824988727]}, "mutation_prompt": null}
{"id": "ee18e98f-fc43-4988-9011-83b24f20efce", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "a22a3b6c-8dd2-43cf-a42b-3434111d07cc", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            self.population_size = int(50 * (1 - (evals / self.budget))) + 1  # Dynamic population size\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate a dynamic population size based on current budget usage to enhance balance between exploration and exploitation.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {}, "mutation_prompt": null}
{"id": "44b59a9b-1dd2-40d0-82e9-abb7be396fdb", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhanced exploration by dynamic adjustment of differential weight and crossover probability within specified bounds.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5036328501742348, 0.5036328501742348, 0.5036328501742348, 0.5348401538634118, 0.5348401538634118, 0.5348401538634118, 0.5317841119576499, 0.5317841119576499, 0.5317841119576499, 0.2834697375613793, 0.2834697375613793, 0.2834697375613793, 0.2468823474275771, 0.2468823474275771, 0.2468823474275771, 0.2828097015541209, 0.2828097015541209, 0.2828097015541209, 0.11934205288865307, 0.11934205288865307, 0.11934205288865307, 0.11552341395646304, 0.11552341395646304, 0.11552341395646304, 0.11431019510038531, 0.11431019510038531, 0.11431019510038531, 0.09985312122313716, 0.09985312122313716, 0.09985312122313716, 0.08416402209870388, 0.08416402209870388, 0.08416402209870388, 0.09947900349199357, 0.09947900349199357, 0.09947900349199357, 0.7588778415576642, 0.7588778415576642, 0.7588778415576642, 0.7204579447587152, 0.7204579447587152, 0.7204579447587152, 0.8099424501585895, 0.8099424501585895, 0.8099424501585895, 0.26364379249946035, 0.26364379249946035, 0.26364379249946035, 0.24876489516738975, 0.24876489516738975, 0.24876489516738975, 0.2647440426624956, 0.2647440426624956, 0.2647440426624956, 0.5480530061199007, 0.5480530061199007, 0.5480530061199007, 0.5911049163864988, 0.5911049163864988, 0.5911049163864988, 0.5317481389179752, 0.5317481389179752, 0.5317481389179752, 0.2189922105499289, 0.2189922105499289, 0.2189922105499289, 0.1349027250897561, 0.1349027250897561, 0.1349027250897561, 0.15329079093693765, 0.15329079093693765, 0.15329079093693765, 0.26756846860189465, 0.26756846860189465, 0.26756846860189465, 0.16361639712074105, 0.16361639712074105, 0.16361639712074105, 0.1490988624052798, 0.1490988624052798, 0.1490988624052798, 0.13169355533154736, 0.13169355533154736, 0.13169355533154736, 0.15210342815312483, 0.15210342815312483, 0.15210342815312483, 0.15286580153720075, 0.15286580153720075, 0.15286580153720075, 0.241168293960484, 0.241168293960484, 0.241168293960484, 0.2518445722184617, 0.2518445722184617, 0.2518445722184617, 0.2585849975314233, 0.2585849975314233, 0.2585849975314233, 0.040674947688613794, 0.040674947688613794, 0.040674947688613794, 0.061700351679792376, 0.061700351679792376, 0.061700351679792376, 0.05895789306104349, 0.05895789306104349, 0.05895789306104349, 0.14883891868094667, 0.14883891868094667, 0.14883891868094667, 0.1574492537597576, 0.1574492537597576, 0.1574492537597576, 0.15840900574184957, 0.15840900574184957, 0.15840900574184957, 0.4550442298642926, 0.4550442298642926, 0.4550442298642926, 0.4647870950848577, 0.4647870950848577, 0.4647870950848577, 0.4497942290578604, 0.4497942290578604, 0.4497942290578604, 0.10719054400142392, 0.10719054400142392, 0.10719054400142392, 0.12549870682266795, 0.12549870682266795, 0.12549870682266795, 0.12012096654434212, 0.12012096654434212, 0.12012096654434212, 0.1641799893100777, 0.1641799893100777, 0.1641799893100777, 0.1716545941976425, 0.1716545941976425, 0.1716545941976425, 0.17933926994496774, 0.17933926994496774, 0.17933926994496774, 0.3023250857442433, 0.3023250857442433, 0.3023250857442433, 0.2627722896946598, 0.2627722896946598, 0.2627722896946598, 0.2859482443859923, 0.2859482443859923, 0.2859482443859923, 0.21771696678953867, 0.21771696678953867, 0.21771696678953867, 0.21890956374502135, 0.21890956374502135, 0.21890956374502135, 0.21111697668552687, 0.21111697668552687, 0.21111697668552687, 0.20272559393831924, 0.20272559393831924, 0.20272559393831924, 0.1977363089145574, 0.1977363089145574, 0.1977363089145574, 0.21886646813120803, 0.21886646813120803, 0.21886646813120803, 0.21909537333642737, 0.21909537333642737, 0.21909537333642737, 0.17621087427250404, 0.17621087427250404, 0.17621087427250404, 0.20432499566577356, 0.20432499566577356, 0.20432499566577356, 0.3913849463788911, 0.3913849463788911, 0.3913849463788911, 0.29042281571481, 0.29042281571481, 0.29042281571481, 0.2391234012312019, 0.2391234012312019, 0.2391234012312019, 0.18982449796935275, 0.18982449796935275, 0.18982449796935275, 0.15903041808923968, 0.15903041808923968, 0.15903041808923968, 0.1962376990081547, 0.1962376990081547, 0.1962376990081547, 0.19404306439535302, 0.19404306439535302, 0.19404306439535302, 0.18537631560933332, 0.18537631560933332, 0.18537631560933332, 0.1959786680262695, 0.1959786680262695, 0.1959786680262695, 0.09244955219017015, 0.09244955219017015, 0.09244955219017015, 0.09292835158897161, 0.09292835158897161, 0.09292835158897161, 0.08659100357306582, 0.08659100357306582, 0.08659100357306582]}, "mutation_prompt": null}
{"id": "d6d68a30-86ca-4843-8f66-1837957fc342", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate elite preservation by retaining the best candidate from each generation.", "configspace": "", "generation": 93, "fitness": 0.27334901501676173, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.18.", "error": "", "parent_id": "167a314f-5c42-4b73-acb4-40121b6804a5", "metadata": {"aucs": [0.5369434760535843, 0.5369434760535843, 0.5369434760535843, 0.5293726711018072, 0.5293726711018072, 0.5293726711018072, 0.5518876303173545, 0.5518876303173545, 0.5518876303173545, 0.2891700819514188, 0.2891700819514188, 0.2891700819514188, 0.2944786506799433, 0.2944786506799433, 0.2944786506799433, 0.3388867801526386, 0.3388867801526386, 0.3388867801526386, 0.1356218387706658, 0.1356218387706658, 0.1356218387706658, 0.11753920238350024, 0.11753920238350024, 0.11753920238350024, 0.12569691434173869, 0.12569691434173869, 0.12569691434173869, 0.10418577685336528, 0.10418577685336528, 0.10418577685336528, 0.10569591351844121, 0.10569591351844121, 0.10569591351844121, 0.10182218030346868, 0.10182218030346868, 0.10182218030346868, 0.8150677646370137, 0.8150677646370137, 0.8150677646370137, 0.6868464956362692, 0.6868464956362692, 0.6868464956362692, 0.8166363589320458, 0.8166363589320458, 0.8166363589320458, 0.262891639421832, 0.262891639421832, 0.262891639421832, 0.25797325432742824, 0.25797325432742824, 0.25797325432742824, 0.295964375099367, 0.295964375099367, 0.295964375099367, 0.5198699074762297, 0.5198699074762297, 0.5198699074762297, 0.5962597414801285, 0.5962597414801285, 0.5962597414801285, 0.5216301930109127, 0.5216301930109127, 0.5216301930109127, 0.15804470512896518, 0.15804470512896518, 0.15804470512896518, 0.19769267673056512, 0.19769267673056512, 0.19769267673056512, 0.19676018555197883, 0.19676018555197883, 0.19676018555197883, 0.23346384967452027, 0.23346384967452027, 0.23346384967452027, 0.1678523360461961, 0.1678523360461961, 0.1678523360461961, 0.14953826181876628, 0.14953826181876628, 0.14953826181876628, 0.15214465527204246, 0.15214465527204246, 0.15214465527204246, 0.19352811959491423, 0.19352811959491423, 0.19352811959491423, 0.20588358955173414, 0.20588358955173414, 0.20588358955173414, 0.33252278324364304, 0.33252278324364304, 0.33252278324364304, 0.24938405068809144, 0.24938405068809144, 0.24938405068809144, 0.30618351666277577, 0.30618351666277577, 0.30618351666277577, 0.05471497433815642, 0.05471497433815642, 0.05471497433815642, 0.06431296535108799, 0.06431296535108799, 0.06431296535108799, 0.056041693538322446, 0.056041693538322446, 0.056041693538322446, 0.16537810160146615, 0.16537810160146615, 0.16537810160146615, 0.1652132450016447, 0.1652132450016447, 0.1652132450016447, 0.17509155082586259, 0.17509155082586259, 0.17509155082586259, 0.43671602606698023, 0.43671602606698023, 0.43671602606698023, 0.4413324030944896, 0.4413324030944896, 0.4413324030944896, 0.45284443787557227, 0.45284443787557227, 0.45284443787557227, 0.12816247601343655, 0.12816247601343655, 0.12816247601343655, 0.1212670175318552, 0.1212670175318552, 0.1212670175318552, 0.11703198498479284, 0.11703198498479284, 0.11703198498479284, 0.1788219103447054, 0.1788219103447054, 0.1788219103447054, 0.2102613752833279, 0.2102613752833279, 0.2102613752833279, 0.21064637711557066, 0.21064637711557066, 0.21064637711557066, 0.2798791545340886, 0.2798791545340886, 0.2798791545340886, 0.2904201692465975, 0.2904201692465975, 0.2904201692465975, 0.29663524786761586, 0.29663524786761586, 0.29663524786761586, 0.2064191890024526, 0.2064191890024526, 0.2064191890024526, 0.2182664298980872, 0.2182664298980872, 0.2182664298980872, 0.2118856042193944, 0.2118856042193944, 0.2118856042193944, 0.20362356465073417, 0.20362356465073417, 0.20362356465073417, 0.2384089230273161, 0.2384089230273161, 0.2384089230273161, 0.20694173452968767, 0.20694173452968767, 0.20694173452968767, 0.21175028741876978, 0.21175028741876978, 0.21175028741876978, 0.19379763428803098, 0.19379763428803098, 0.19379763428803098, 0.1865583029472394, 0.1865583029472394, 0.1865583029472394, 0.637431107970212, 0.637431107970212, 0.637431107970212, 0.5311346997827564, 0.5311346997827564, 0.5311346997827564, 0.2547427348370591, 0.2547427348370591, 0.2547427348370591, 0.18256632025009623, 0.18256632025009623, 0.18256632025009623, 0.46496072890510143, 0.46496072890510143, 0.46496072890510143, 0.5158649674315613, 0.5158649674315613, 0.5158649674315613, 0.18338713809812623, 0.18338713809812623, 0.18338713809812623, 0.17948536133395898, 0.17948536133395898, 0.17948536133395898, 0.19778989399464786, 0.19778989399464786, 0.19778989399464786, 0.09214405640221646, 0.09214405640221646, 0.09214405640221646, 0.08203168784959203, 0.08203168784959203, 0.08203168784959203, 0.08972802734088148, 0.08972802734088148, 0.08972802734088148]}, "mutation_prompt": null}
{"id": "8cf2102e-56c5-43c8-9714-458fb2d441cc", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.15, 0.15)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhance adaptive mechanism by further tuning mutation and crossover strategies for better convergence.", "configspace": "", "generation": 94, "fitness": 0.2647435056109703, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.17.", "error": "", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.517815011340863, 0.517815011340863, 0.517815011340863, 0.5314168800544772, 0.5314168800544772, 0.5314168800544772, 0.5450448136487067, 0.5450448136487067, 0.5450448136487067, 0.27388542909414704, 0.27388542909414704, 0.27388542909414704, 0.2743723993282685, 0.2743723993282685, 0.2743723993282685, 0.31786629577379577, 0.31786629577379577, 0.31786629577379577, 0.1250712720049545, 0.1250712720049545, 0.1250712720049545, 0.12286740101441052, 0.12286740101441052, 0.12286740101441052, 0.11062146416711716, 0.11062146416711716, 0.11062146416711716, 0.10863685185339622, 0.10863685185339622, 0.10863685185339622, 0.1106534146518332, 0.1106534146518332, 0.1106534146518332, 0.10113606955776666, 0.10113606955776666, 0.10113606955776666, 0.7081302425548233, 0.7081302425548233, 0.7081302425548233, 0.7662807441518378, 0.7662807441518378, 0.7662807441518378, 0.7366833348240507, 0.7366833348240507, 0.7366833348240507, 0.28701923796721207, 0.28701923796721207, 0.28701923796721207, 0.253489457086036, 0.253489457086036, 0.253489457086036, 0.27904129229138896, 0.27904129229138896, 0.27904129229138896, 0.5310805676872269, 0.5310805676872269, 0.5310805676872269, 0.5966187873567207, 0.5966187873567207, 0.5966187873567207, 0.5824651723358492, 0.5824651723358492, 0.5824651723358492, 0.14821852986995987, 0.14821852986995987, 0.14821852986995987, 0.20908610170296082, 0.20908610170296082, 0.20908610170296082, 0.16473092308685666, 0.16473092308685666, 0.16473092308685666, 0.14646319269272667, 0.14646319269272667, 0.14646319269272667, 0.16585572004287386, 0.16585572004287386, 0.16585572004287386, 0.2333483003575587, 0.2333483003575587, 0.2333483003575587, 0.17526096123724222, 0.17526096123724222, 0.17526096123724222, 0.1620601210539777, 0.1620601210539777, 0.1620601210539777, 0.17061960431287226, 0.17061960431287226, 0.17061960431287226, 0.3016896637364611, 0.3016896637364611, 0.3016896637364611, 0.2645419629099368, 0.2645419629099368, 0.2645419629099368, 0.2827914435743679, 0.2827914435743679, 0.2827914435743679, 0.04199668551900981, 0.04199668551900981, 0.04199668551900981, 0.056156300093506584, 0.056156300093506584, 0.056156300093506584, 0.04747616473096883, 0.04747616473096883, 0.04747616473096883, 0.15737128356669217, 0.15737128356669217, 0.15737128356669217, 0.16142105308944443, 0.16142105308944443, 0.16142105308944443, 0.16266748734416836, 0.16266748734416836, 0.16266748734416836, 0.4643186513904175, 0.4643186513904175, 0.4643186513904175, 0.4591880585490512, 0.4591880585490512, 0.4591880585490512, 0.4312871148630958, 0.4312871148630958, 0.4312871148630958, 0.13217258365329376, 0.13217258365329376, 0.13217258365329376, 0.12771850120525996, 0.12771850120525996, 0.12771850120525996, 0.12109826912628019, 0.12109826912628019, 0.12109826912628019, 0.22950963903465527, 0.22950963903465527, 0.22950963903465527, 0.2129966911448502, 0.2129966911448502, 0.2129966911448502, 0.15791610764148933, 0.15791610764148933, 0.15791610764148933, 0.289242622130517, 0.289242622130517, 0.289242622130517, 0.31083801164661395, 0.31083801164661395, 0.31083801164661395, 0.306769926043859, 0.306769926043859, 0.306769926043859, 0.24061923471968893, 0.24061923471968893, 0.24061923471968893, 0.23151385915913902, 0.23151385915913902, 0.23151385915913902, 0.23578951131746062, 0.23578951131746062, 0.23578951131746062, 0.2082789582151121, 0.2082789582151121, 0.2082789582151121, 0.20251528584862388, 0.20251528584862388, 0.20251528584862388, 0.203524206498792, 0.203524206498792, 0.203524206498792, 0.19812088867136168, 0.19812088867136168, 0.19812088867136168, 0.18606474526377748, 0.18606474526377748, 0.18606474526377748, 0.19349151466098036, 0.19349151466098036, 0.19349151466098036, 0.3745930705753002, 0.3745930705753002, 0.3745930705753002, 0.3074265227745846, 0.3074265227745846, 0.3074265227745846, 0.3728955069580694, 0.3728955069580694, 0.3728955069580694, 0.21028376933546344, 0.21028376933546344, 0.21028376933546344, 0.3802385347897119, 0.3802385347897119, 0.3802385347897119, 0.4997837997773775, 0.4997837997773775, 0.4997837997773775, 0.21690262619242318, 0.21690262619242318, 0.21690262619242318, 0.1747859928137192, 0.1747859928137192, 0.1747859928137192, 0.19848527712102482, 0.19848527712102482, 0.19848527712102482, 0.08848840300379812, 0.08848840300379812, 0.08848840300379812, 0.08253067898808897, 0.08253067898808897, 0.08253067898808897, 0.08019220320951426, 0.08019220320951426, 0.08019220320951426]}, "mutation_prompt": null}
{"id": "4539d2c2-4bbe-4299-a1d3-980f7d0cb9b2", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate elite preservation by retaining the best candidate from each generation.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.5369434760535843, 0.5369434760535843, 0.5369434760535843, 0.5293726711018072, 0.5293726711018072, 0.5293726711018072, 0.5518876303173545, 0.5518876303173545, 0.5518876303173545, 0.2891700819514188, 0.2891700819514188, 0.2891700819514188, 0.2944786506799433, 0.2944786506799433, 0.2944786506799433, 0.3388867801526386, 0.3388867801526386, 0.3388867801526386, 0.1356218387706658, 0.1356218387706658, 0.1356218387706658, 0.11753920238350024, 0.11753920238350024, 0.11753920238350024, 0.12569691434173869, 0.12569691434173869, 0.12569691434173869, 0.10418577685336528, 0.10418577685336528, 0.10418577685336528, 0.10569591351844121, 0.10569591351844121, 0.10569591351844121, 0.10182218030346868, 0.10182218030346868, 0.10182218030346868, 0.8150677646370137, 0.8150677646370137, 0.8150677646370137, 0.6868464956362692, 0.6868464956362692, 0.6868464956362692, 0.8166363589320458, 0.8166363589320458, 0.8166363589320458, 0.262891639421832, 0.262891639421832, 0.262891639421832, 0.25797325432742824, 0.25797325432742824, 0.25797325432742824, 0.295964375099367, 0.295964375099367, 0.295964375099367, 0.5198699074762297, 0.5198699074762297, 0.5198699074762297, 0.5962597414801285, 0.5962597414801285, 0.5962597414801285, 0.5216301930109127, 0.5216301930109127, 0.5216301930109127, 0.15804470512896518, 0.15804470512896518, 0.15804470512896518, 0.19769267673056512, 0.19769267673056512, 0.19769267673056512, 0.19676018555197883, 0.19676018555197883, 0.19676018555197883, 0.23346384967452027, 0.23346384967452027, 0.23346384967452027, 0.1678523360461961, 0.1678523360461961, 0.1678523360461961, 0.14953826181876628, 0.14953826181876628, 0.14953826181876628, 0.15214465527204246, 0.15214465527204246, 0.15214465527204246, 0.19352811959491423, 0.19352811959491423, 0.19352811959491423, 0.20588358955173414, 0.20588358955173414, 0.20588358955173414, 0.33252278324364304, 0.33252278324364304, 0.33252278324364304, 0.24938405068809144, 0.24938405068809144, 0.24938405068809144, 0.30618351666277577, 0.30618351666277577, 0.30618351666277577, 0.05471497433815642, 0.05471497433815642, 0.05471497433815642, 0.06431296535108799, 0.06431296535108799, 0.06431296535108799, 0.056041693538322446, 0.056041693538322446, 0.056041693538322446, 0.16537810160146615, 0.16537810160146615, 0.16537810160146615, 0.1652132450016447, 0.1652132450016447, 0.1652132450016447, 0.17509155082586259, 0.17509155082586259, 0.17509155082586259, 0.43671602606698023, 0.43671602606698023, 0.43671602606698023, 0.4413324030944896, 0.4413324030944896, 0.4413324030944896, 0.45284443787557227, 0.45284443787557227, 0.45284443787557227, 0.12816247601343655, 0.12816247601343655, 0.12816247601343655, 0.1212670175318552, 0.1212670175318552, 0.1212670175318552, 0.11703198498479284, 0.11703198498479284, 0.11703198498479284, 0.1788219103447054, 0.1788219103447054, 0.1788219103447054, 0.2102613752833279, 0.2102613752833279, 0.2102613752833279, 0.21064637711557066, 0.21064637711557066, 0.21064637711557066, 0.2798791545340886, 0.2798791545340886, 0.2798791545340886, 0.2904201692465975, 0.2904201692465975, 0.2904201692465975, 0.29663524786761586, 0.29663524786761586, 0.29663524786761586, 0.2064191890024526, 0.2064191890024526, 0.2064191890024526, 0.2182664298980872, 0.2182664298980872, 0.2182664298980872, 0.2118856042193944, 0.2118856042193944, 0.2118856042193944, 0.20362356465073417, 0.20362356465073417, 0.20362356465073417, 0.2384089230273161, 0.2384089230273161, 0.2384089230273161, 0.20694173452968767, 0.20694173452968767, 0.20694173452968767, 0.21175028741876978, 0.21175028741876978, 0.21175028741876978, 0.19379763428803098, 0.19379763428803098, 0.19379763428803098, 0.1865583029472394, 0.1865583029472394, 0.1865583029472394, 0.637431107970212, 0.637431107970212, 0.637431107970212, 0.5311346997827564, 0.5311346997827564, 0.5311346997827564, 0.2547427348370591, 0.2547427348370591, 0.2547427348370591, 0.18256632025009623, 0.18256632025009623, 0.18256632025009623, 0.46496072890510143, 0.46496072890510143, 0.46496072890510143, 0.5158649674315613, 0.5158649674315613, 0.5158649674315613, 0.18338713809812623, 0.18338713809812623, 0.18338713809812623, 0.17948536133395898, 0.17948536133395898, 0.17948536133395898, 0.19778989399464786, 0.19778989399464786, 0.19778989399464786, 0.09214405640221646, 0.09214405640221646, 0.09214405640221646, 0.08203168784959203, 0.08203168784959203, 0.08203168784959203, 0.08972802734088148, 0.08972802734088148, 0.08972802734088148]}, "mutation_prompt": null}
{"id": "03104592-76e3-485a-b188-35bbe0b86e59", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate elite preservation by retaining the best candidate from each generation.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.5369434760535843, 0.5369434760535843, 0.5369434760535843, 0.5293726711018072, 0.5293726711018072, 0.5293726711018072, 0.5518876303173545, 0.5518876303173545, 0.5518876303173545, 0.2891700819514188, 0.2891700819514188, 0.2891700819514188, 0.2944786506799433, 0.2944786506799433, 0.2944786506799433, 0.3388867801526386, 0.3388867801526386, 0.3388867801526386, 0.1356218387706658, 0.1356218387706658, 0.1356218387706658, 0.11753920238350024, 0.11753920238350024, 0.11753920238350024, 0.12569691434173869, 0.12569691434173869, 0.12569691434173869, 0.10418577685336528, 0.10418577685336528, 0.10418577685336528, 0.10569591351844121, 0.10569591351844121, 0.10569591351844121, 0.10182218030346868, 0.10182218030346868, 0.10182218030346868, 0.8150677646370137, 0.8150677646370137, 0.8150677646370137, 0.6868464956362692, 0.6868464956362692, 0.6868464956362692, 0.8166363589320458, 0.8166363589320458, 0.8166363589320458, 0.262891639421832, 0.262891639421832, 0.262891639421832, 0.25797325432742824, 0.25797325432742824, 0.25797325432742824, 0.295964375099367, 0.295964375099367, 0.295964375099367, 0.5198699074762297, 0.5198699074762297, 0.5198699074762297, 0.5962597414801285, 0.5962597414801285, 0.5962597414801285, 0.5216301930109127, 0.5216301930109127, 0.5216301930109127, 0.15804470512896518, 0.15804470512896518, 0.15804470512896518, 0.19769267673056512, 0.19769267673056512, 0.19769267673056512, 0.19676018555197883, 0.19676018555197883, 0.19676018555197883, 0.23346384967452027, 0.23346384967452027, 0.23346384967452027, 0.1678523360461961, 0.1678523360461961, 0.1678523360461961, 0.14953826181876628, 0.14953826181876628, 0.14953826181876628, 0.15214465527204246, 0.15214465527204246, 0.15214465527204246, 0.19352811959491423, 0.19352811959491423, 0.19352811959491423, 0.20588358955173414, 0.20588358955173414, 0.20588358955173414, 0.33252278324364304, 0.33252278324364304, 0.33252278324364304, 0.24938405068809144, 0.24938405068809144, 0.24938405068809144, 0.30618351666277577, 0.30618351666277577, 0.30618351666277577, 0.05471497433815642, 0.05471497433815642, 0.05471497433815642, 0.06431296535108799, 0.06431296535108799, 0.06431296535108799, 0.056041693538322446, 0.056041693538322446, 0.056041693538322446, 0.16537810160146615, 0.16537810160146615, 0.16537810160146615, 0.1652132450016447, 0.1652132450016447, 0.1652132450016447, 0.17509155082586259, 0.17509155082586259, 0.17509155082586259, 0.43671602606698023, 0.43671602606698023, 0.43671602606698023, 0.4413324030944896, 0.4413324030944896, 0.4413324030944896, 0.45284443787557227, 0.45284443787557227, 0.45284443787557227, 0.12816247601343655, 0.12816247601343655, 0.12816247601343655, 0.1212670175318552, 0.1212670175318552, 0.1212670175318552, 0.11703198498479284, 0.11703198498479284, 0.11703198498479284, 0.1788219103447054, 0.1788219103447054, 0.1788219103447054, 0.2102613752833279, 0.2102613752833279, 0.2102613752833279, 0.21064637711557066, 0.21064637711557066, 0.21064637711557066, 0.2798791545340886, 0.2798791545340886, 0.2798791545340886, 0.2904201692465975, 0.2904201692465975, 0.2904201692465975, 0.29663524786761586, 0.29663524786761586, 0.29663524786761586, 0.2064191890024526, 0.2064191890024526, 0.2064191890024526, 0.2182664298980872, 0.2182664298980872, 0.2182664298980872, 0.2118856042193944, 0.2118856042193944, 0.2118856042193944, 0.20362356465073417, 0.20362356465073417, 0.20362356465073417, 0.2384089230273161, 0.2384089230273161, 0.2384089230273161, 0.20694173452968767, 0.20694173452968767, 0.20694173452968767, 0.21175028741876978, 0.21175028741876978, 0.21175028741876978, 0.19379763428803098, 0.19379763428803098, 0.19379763428803098, 0.1865583029472394, 0.1865583029472394, 0.1865583029472394, 0.637431107970212, 0.637431107970212, 0.637431107970212, 0.5311346997827564, 0.5311346997827564, 0.5311346997827564, 0.2547427348370591, 0.2547427348370591, 0.2547427348370591, 0.18256632025009623, 0.18256632025009623, 0.18256632025009623, 0.46496072890510143, 0.46496072890510143, 0.46496072890510143, 0.5158649674315613, 0.5158649674315613, 0.5158649674315613, 0.18338713809812623, 0.18338713809812623, 0.18338713809812623, 0.17948536133395898, 0.17948536133395898, 0.17948536133395898, 0.19778989399464786, 0.19778989399464786, 0.19778989399464786, 0.09214405640221646, 0.09214405640221646, 0.09214405640221646, 0.08203168784959203, 0.08203168784959203, 0.08203168784959203, 0.08972802734088148, 0.08972802734088148, 0.08972802734088148]}, "mutation_prompt": null}
{"id": "f99f3424-ba19-4699-a9c5-2875d021f412", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate elite preservation by retaining the best candidate from each generation.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.5369434760535843, 0.5369434760535843, 0.5369434760535843, 0.5293726711018072, 0.5293726711018072, 0.5293726711018072, 0.5518876303173545, 0.5518876303173545, 0.5518876303173545, 0.2891700819514188, 0.2891700819514188, 0.2891700819514188, 0.2944786506799433, 0.2944786506799433, 0.2944786506799433, 0.3388867801526386, 0.3388867801526386, 0.3388867801526386, 0.1356218387706658, 0.1356218387706658, 0.1356218387706658, 0.11753920238350024, 0.11753920238350024, 0.11753920238350024, 0.12569691434173869, 0.12569691434173869, 0.12569691434173869, 0.10418577685336528, 0.10418577685336528, 0.10418577685336528, 0.10569591351844121, 0.10569591351844121, 0.10569591351844121, 0.10182218030346868, 0.10182218030346868, 0.10182218030346868, 0.8150677646370137, 0.8150677646370137, 0.8150677646370137, 0.6868464956362692, 0.6868464956362692, 0.6868464956362692, 0.8166363589320458, 0.8166363589320458, 0.8166363589320458, 0.262891639421832, 0.262891639421832, 0.262891639421832, 0.25797325432742824, 0.25797325432742824, 0.25797325432742824, 0.295964375099367, 0.295964375099367, 0.295964375099367, 0.5198699074762297, 0.5198699074762297, 0.5198699074762297, 0.5962597414801285, 0.5962597414801285, 0.5962597414801285, 0.5216301930109127, 0.5216301930109127, 0.5216301930109127, 0.15804470512896518, 0.15804470512896518, 0.15804470512896518, 0.19769267673056512, 0.19769267673056512, 0.19769267673056512, 0.19676018555197883, 0.19676018555197883, 0.19676018555197883, 0.23346384967452027, 0.23346384967452027, 0.23346384967452027, 0.1678523360461961, 0.1678523360461961, 0.1678523360461961, 0.14953826181876628, 0.14953826181876628, 0.14953826181876628, 0.15214465527204246, 0.15214465527204246, 0.15214465527204246, 0.19352811959491423, 0.19352811959491423, 0.19352811959491423, 0.20588358955173414, 0.20588358955173414, 0.20588358955173414, 0.33252278324364304, 0.33252278324364304, 0.33252278324364304, 0.24938405068809144, 0.24938405068809144, 0.24938405068809144, 0.30618351666277577, 0.30618351666277577, 0.30618351666277577, 0.05471497433815642, 0.05471497433815642, 0.05471497433815642, 0.06431296535108799, 0.06431296535108799, 0.06431296535108799, 0.056041693538322446, 0.056041693538322446, 0.056041693538322446, 0.16537810160146615, 0.16537810160146615, 0.16537810160146615, 0.1652132450016447, 0.1652132450016447, 0.1652132450016447, 0.17509155082586259, 0.17509155082586259, 0.17509155082586259, 0.43671602606698023, 0.43671602606698023, 0.43671602606698023, 0.4413324030944896, 0.4413324030944896, 0.4413324030944896, 0.45284443787557227, 0.45284443787557227, 0.45284443787557227, 0.12816247601343655, 0.12816247601343655, 0.12816247601343655, 0.1212670175318552, 0.1212670175318552, 0.1212670175318552, 0.11703198498479284, 0.11703198498479284, 0.11703198498479284, 0.1788219103447054, 0.1788219103447054, 0.1788219103447054, 0.2102613752833279, 0.2102613752833279, 0.2102613752833279, 0.21064637711557066, 0.21064637711557066, 0.21064637711557066, 0.2798791545340886, 0.2798791545340886, 0.2798791545340886, 0.2904201692465975, 0.2904201692465975, 0.2904201692465975, 0.29663524786761586, 0.29663524786761586, 0.29663524786761586, 0.2064191890024526, 0.2064191890024526, 0.2064191890024526, 0.2182664298980872, 0.2182664298980872, 0.2182664298980872, 0.2118856042193944, 0.2118856042193944, 0.2118856042193944, 0.20362356465073417, 0.20362356465073417, 0.20362356465073417, 0.2384089230273161, 0.2384089230273161, 0.2384089230273161, 0.20694173452968767, 0.20694173452968767, 0.20694173452968767, 0.21175028741876978, 0.21175028741876978, 0.21175028741876978, 0.19379763428803098, 0.19379763428803098, 0.19379763428803098, 0.1865583029472394, 0.1865583029472394, 0.1865583029472394, 0.637431107970212, 0.637431107970212, 0.637431107970212, 0.5311346997827564, 0.5311346997827564, 0.5311346997827564, 0.2547427348370591, 0.2547427348370591, 0.2547427348370591, 0.18256632025009623, 0.18256632025009623, 0.18256632025009623, 0.46496072890510143, 0.46496072890510143, 0.46496072890510143, 0.5158649674315613, 0.5158649674315613, 0.5158649674315613, 0.18338713809812623, 0.18338713809812623, 0.18338713809812623, 0.17948536133395898, 0.17948536133395898, 0.17948536133395898, 0.19778989399464786, 0.19778989399464786, 0.19778989399464786, 0.09214405640221646, 0.09214405640221646, 0.09214405640221646, 0.08203168784959203, 0.08203168784959203, 0.08203168784959203, 0.08972802734088148, 0.08972802734088148, 0.08972802734088148]}, "mutation_prompt": null}
{"id": "c142de50-2534-42e4-bd5a-fc971412567f", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Incorporate elite preservation by retaining the best candidate from each generation.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.5369434760535843, 0.5369434760535843, 0.5369434760535843, 0.5293726711018072, 0.5293726711018072, 0.5293726711018072, 0.5518876303173545, 0.5518876303173545, 0.5518876303173545, 0.2891700819514188, 0.2891700819514188, 0.2891700819514188, 0.2944786506799433, 0.2944786506799433, 0.2944786506799433, 0.3388867801526386, 0.3388867801526386, 0.3388867801526386, 0.1356218387706658, 0.1356218387706658, 0.1356218387706658, 0.11753920238350024, 0.11753920238350024, 0.11753920238350024, 0.12569691434173869, 0.12569691434173869, 0.12569691434173869, 0.10418577685336528, 0.10418577685336528, 0.10418577685336528, 0.10569591351844121, 0.10569591351844121, 0.10569591351844121, 0.10182218030346868, 0.10182218030346868, 0.10182218030346868, 0.8150677646370137, 0.8150677646370137, 0.8150677646370137, 0.6868464956362692, 0.6868464956362692, 0.6868464956362692, 0.8166363589320458, 0.8166363589320458, 0.8166363589320458, 0.262891639421832, 0.262891639421832, 0.262891639421832, 0.25797325432742824, 0.25797325432742824, 0.25797325432742824, 0.295964375099367, 0.295964375099367, 0.295964375099367, 0.5198699074762297, 0.5198699074762297, 0.5198699074762297, 0.5962597414801285, 0.5962597414801285, 0.5962597414801285, 0.5216301930109127, 0.5216301930109127, 0.5216301930109127, 0.15804470512896518, 0.15804470512896518, 0.15804470512896518, 0.19769267673056512, 0.19769267673056512, 0.19769267673056512, 0.19676018555197883, 0.19676018555197883, 0.19676018555197883, 0.23346384967452027, 0.23346384967452027, 0.23346384967452027, 0.1678523360461961, 0.1678523360461961, 0.1678523360461961, 0.14953826181876628, 0.14953826181876628, 0.14953826181876628, 0.15214465527204246, 0.15214465527204246, 0.15214465527204246, 0.19352811959491423, 0.19352811959491423, 0.19352811959491423, 0.20588358955173414, 0.20588358955173414, 0.20588358955173414, 0.33252278324364304, 0.33252278324364304, 0.33252278324364304, 0.24938405068809144, 0.24938405068809144, 0.24938405068809144, 0.30618351666277577, 0.30618351666277577, 0.30618351666277577, 0.05471497433815642, 0.05471497433815642, 0.05471497433815642, 0.06431296535108799, 0.06431296535108799, 0.06431296535108799, 0.056041693538322446, 0.056041693538322446, 0.056041693538322446, 0.16537810160146615, 0.16537810160146615, 0.16537810160146615, 0.1652132450016447, 0.1652132450016447, 0.1652132450016447, 0.17509155082586259, 0.17509155082586259, 0.17509155082586259, 0.43671602606698023, 0.43671602606698023, 0.43671602606698023, 0.4413324030944896, 0.4413324030944896, 0.4413324030944896, 0.45284443787557227, 0.45284443787557227, 0.45284443787557227, 0.12816247601343655, 0.12816247601343655, 0.12816247601343655, 0.1212670175318552, 0.1212670175318552, 0.1212670175318552, 0.11703198498479284, 0.11703198498479284, 0.11703198498479284, 0.1788219103447054, 0.1788219103447054, 0.1788219103447054, 0.2102613752833279, 0.2102613752833279, 0.2102613752833279, 0.21064637711557066, 0.21064637711557066, 0.21064637711557066, 0.2798791545340886, 0.2798791545340886, 0.2798791545340886, 0.2904201692465975, 0.2904201692465975, 0.2904201692465975, 0.29663524786761586, 0.29663524786761586, 0.29663524786761586, 0.2064191890024526, 0.2064191890024526, 0.2064191890024526, 0.2182664298980872, 0.2182664298980872, 0.2182664298980872, 0.2118856042193944, 0.2118856042193944, 0.2118856042193944, 0.20362356465073417, 0.20362356465073417, 0.20362356465073417, 0.2384089230273161, 0.2384089230273161, 0.2384089230273161, 0.20694173452968767, 0.20694173452968767, 0.20694173452968767, 0.21175028741876978, 0.21175028741876978, 0.21175028741876978, 0.19379763428803098, 0.19379763428803098, 0.19379763428803098, 0.1865583029472394, 0.1865583029472394, 0.1865583029472394, 0.637431107970212, 0.637431107970212, 0.637431107970212, 0.5311346997827564, 0.5311346997827564, 0.5311346997827564, 0.2547427348370591, 0.2547427348370591, 0.2547427348370591, 0.18256632025009623, 0.18256632025009623, 0.18256632025009623, 0.46496072890510143, 0.46496072890510143, 0.46496072890510143, 0.5158649674315613, 0.5158649674315613, 0.5158649674315613, 0.18338713809812623, 0.18338713809812623, 0.18338713809812623, 0.17948536133395898, 0.17948536133395898, 0.17948536133395898, 0.19778989399464786, 0.19778989399464786, 0.19778989399464786, 0.09214405640221646, 0.09214405640221646, 0.09214405640221646, 0.08203168784959203, 0.08203168784959203, 0.08203168784959203, 0.08972802734088148, 0.08972802734088148, 0.08972802734088148]}, "mutation_prompt": null}
{"id": "900916aa-8f78-45c8-bcde-cd84588601e1", "solution": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.initial_temperature = 1000\n        self.cooling_rate = 0.93\n        self.dynamic_adaptation_factor = 0.99\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        while evals < self.budget:\n            new_population = np.empty_like(population)\n            # Preserve the best candidate from the current population\n            new_population[0] = best\n\n            for i in range(1, self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                random_factor = np.random.uniform(0.5, 1.0)\n                self.F = max(0.5, min(1.0, self.F + np.random.uniform(-0.1, 0.1)))  # Adjust F\n                mutant = np.clip(x0 + random_factor * self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                self.CR = max(0.7, min(0.95, self.CR + np.random.uniform(-0.05, 0.05)))  # Dynamic CR\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evals += 1\n                \n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            temperature *= self.cooling_rate\n            self.cooling_rate *= self.dynamic_adaptation_factor\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best = population[current_best_idx]\n                best_fitness = fitness[current_best_idx]\n\n        return best", "name": "HybridDE_SA_Adaptive", "description": "Enhance exploration by dynamically adapting the crossover probability.", "configspace": "", "generation": 99, "fitness": 0.25789948138370145, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "d6d68a30-86ca-4843-8f66-1837957fc342", "metadata": {"aucs": [0.5194608621453733, 0.5194608621453733, 0.5194608621453733, 0.5366589264819802, 0.5366589264819802, 0.5366589264819802, 0.5270657922675757, 0.5270657922675757, 0.5270657922675757, 0.28093849808387084, 0.28093849808387084, 0.28093849808387084, 0.276068423846201, 0.276068423846201, 0.276068423846201, 0.2979071577143959, 0.2979071577143959, 0.2979071577143959, 0.12189260928200474, 0.12189260928200474, 0.12189260928200474, 0.12402659193248422, 0.12402659193248422, 0.12402659193248422, 0.15103244959952222, 0.15103244959952222, 0.15103244959952222, 0.10456853985458325, 0.10456853985458325, 0.10456853985458325, 0.12154614129372499, 0.12154614129372499, 0.12154614129372499, 0.10277914358243212, 0.10277914358243212, 0.10277914358243212, 0.859712967892885, 0.859712967892885, 0.859712967892885, 0.9235518770218597, 0.9235518770218597, 0.9235518770218597, 0.8889325097618859, 0.8889325097618859, 0.8889325097618859, 0.22820000081991432, 0.22820000081991432, 0.22820000081991432, 0.23606177773440573, 0.23606177773440573, 0.23606177773440573, 0.24110679925064993, 0.24110679925064993, 0.24110679925064993, 0.45562622863200164, 0.45562622863200164, 0.45562622863200164, 0.526007748832138, 0.526007748832138, 0.526007748832138, 0.5155674637630634, 0.5155674637630634, 0.5155674637630634, 0.1915134536752937, 0.1915134536752937, 0.1915134536752937, 0.17480683541695907, 0.17480683541695907, 0.17480683541695907, 0.16103458718598962, 0.16103458718598962, 0.16103458718598962, 0.1911498556152046, 0.1911498556152046, 0.1911498556152046, 0.1845844829546308, 0.1845844829546308, 0.1845844829546308, 0.15925079093783168, 0.15925079093783168, 0.15925079093783168, 0.11746665543182866, 0.11746665543182866, 0.11746665543182866, 0.10408610098337445, 0.10408610098337445, 0.10408610098337445, 0.10167489591984014, 0.10167489591984014, 0.10167489591984014, 0.26482874922964816, 0.26482874922964816, 0.26482874922964816, 0.21917131356205588, 0.21917131356205588, 0.21917131356205588, 0.19491250084760137, 0.19491250084760137, 0.19491250084760137, 0.035309627618213435, 0.035309627618213435, 0.035309627618213435, 0.033305085274891066, 0.033305085274891066, 0.033305085274891066, 0.03188386984332281, 0.03188386984332281, 0.03188386984332281, 0.12132721438279026, 0.12132721438279026, 0.12132721438279026, 0.13763446185264383, 0.13763446185264383, 0.13763446185264383, 0.13528807396181308, 0.13528807396181308, 0.13528807396181308, 0.4321726545532669, 0.4321726545532669, 0.4321726545532669, 0.41352391485799855, 0.41352391485799855, 0.41352391485799855, 0.4181390358225946, 0.4181390358225946, 0.4181390358225946, 0.13006575288644495, 0.13006575288644495, 0.13006575288644495, 0.11275464041088035, 0.11275464041088035, 0.11275464041088035, 0.11257101134021374, 0.11257101134021374, 0.11257101134021374, 0.14390045900986093, 0.14390045900986093, 0.14390045900986093, 0.1521743736591339, 0.1521743736591339, 0.1521743736591339, 0.18496785588609144, 0.18496785588609144, 0.18496785588609144, 0.2643788815652758, 0.2643788815652758, 0.2643788815652758, 0.2807759610538971, 0.2807759610538971, 0.2807759610538971, 0.26808091383399313, 0.26808091383399313, 0.26808091383399313, 0.1946773128539958, 0.1946773128539958, 0.1946773128539958, 0.1800995299074719, 0.1800995299074719, 0.1800995299074719, 0.23152069439342837, 0.23152069439342837, 0.23152069439342837, 0.2012138760048462, 0.2012138760048462, 0.2012138760048462, 0.20487078708873918, 0.20487078708873918, 0.20487078708873918, 0.21241709515578444, 0.21241709515578444, 0.21241709515578444, 0.20626354203285568, 0.20626354203285568, 0.20626354203285568, 0.194099459756236, 0.194099459756236, 0.194099459756236, 0.20529997764274344, 0.20529997764274344, 0.20529997764274344, 0.573206856953858, 0.573206856953858, 0.573206856953858, 0.5391579544745458, 0.5391579544745458, 0.5391579544745458, 0.357304349126509, 0.357304349126509, 0.357304349126509, 0.2760472035721676, 0.2760472035721676, 0.2760472035721676, 0.3137038445337793, 0.3137038445337793, 0.3137038445337793, 0.348376545685953, 0.348376545685953, 0.348376545685953, 0.18222763752954263, 0.18222763752954263, 0.18222763752954263, 0.19118983587905103, 0.19118983587905103, 0.19118983587905103, 0.19099131996796082, 0.19099131996796082, 0.19099131996796082, 0.09137356000691343, 0.09137356000691343, 0.09137356000691343, 0.07813474387129393, 0.07813474387129393, 0.07813474387129393, 0.08514001382229563, 0.08514001382229563, 0.08514001382229563]}, "mutation_prompt": null}
