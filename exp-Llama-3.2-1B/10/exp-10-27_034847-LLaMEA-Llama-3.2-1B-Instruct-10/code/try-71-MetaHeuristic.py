# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
import numpy as np
import random

class MetaHeuristic:
    """
    A metaheuristic algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of local search, gradient-based optimization, and evolutionary strategy to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    population (list): The current population of individuals.
    fitness (list): The fitness of the individuals in the population.
    """

    def __init__(self, budget, dim):
        """
        Initializes the MetaHeuristic algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        """
        self.budget = budget
        self.dim = dim
        self.func = None
        self.search_space = None
        self.bounds = None
        self.population = None
        self.fitness = None

    def __call__(self, func):
        """
        Optimizes the black box function using MetaHeuristic.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform local search
        for _ in range(self.budget):
            # Generate a new solution by perturbing the current solution
            new_solution = self.perturb(self.search_space, self.bounds)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def perturb(self, search_space, bounds):
        """
        Generates a new solution by perturbing the current solution.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: A new solution generated by perturbing the current solution.
        """
        # Generate a new solution by randomly perturbing the current solution
        new_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

    def evolve(self, population_size):
        """
        Evolves the population using evolutionary strategy.
        
        Args:
        population_size (int): The size of the population.
        
        Returns:
        list: The evolved population.
        """
        # Initialize the population
        self.population = []
        for _ in range(population_size):
            # Generate a random individual
            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]
            
            # Evaluate the fitness of the individual
            fitness = self.func(individual)
            
            # Add the individual to the population
            self.population.append((individual, fitness))
        
        # Return the evolved population
        return self.population

    def train(self, population_size, budget):
        """
        Trains the algorithm using evolutionary strategy.
        
        Args:
        population_size (int): The size of the population.
        budget (int): The maximum number of function evaluations allowed.
        
        Returns:
        list: The trained population.
        """
        # Evolve the population
        self.population = self.evolve(population_size)
        
        # Evaluate the fitness of the population
        self.fitness = [individual[1] for individual in self.population]
        
        # Return the trained population
        return self.population

# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
# ```python
# import numpy as np
# import random
# import math

class EvolutionaryStrategy:
    """
    An evolutionary strategy algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of genetic algorithm, evolutionary strategy, and gradient-based optimization to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    population (list): The current population of individuals.
    fitness (list): The fitness of the individuals in the population.
    """

    def __init__(self, budget, dim):
        """
        Initializes the EvolutionaryStrategy algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        """
        self.budget = budget
        self.dim = dim
        self.func = None
        self.search_space = None
        self.bounds = None
        self.population = None
        self.fitness = None

    def __call__(self, func):
        """
        Optimizes the black box function using EvolutionaryStrategy.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform genetic algorithm
        for _ in range(self.budget):
            # Initialize the population
            self.population = []
            for _ in range(100):
                # Generate a random individual
                individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]
                
                # Evaluate the fitness of the individual
                fitness = self.func(individual)
                
                # Add the individual to the population
                self.population.append((individual, fitness))
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def train(self, population_size, budget):
        """
        Trains the algorithm using evolutionary strategy.
        
        Args:
        population_size (int): The size of the population.
        budget (int): The maximum number of function evaluations allowed.
        
        Returns:
        list: The trained population.
        """
        # Train the algorithm using evolutionary strategy
        self.population = self.train_strategy(population_size, budget)
        
        # Return the trained population
        return self.population

    def train_strategy(self, population_size, budget):
        """
        Trains the algorithm using evolutionary strategy.
        
        Args:
        population_size (int): The size of the population.
        budget (int): The maximum number of function evaluations allowed.
        
        Returns:
        list: The trained population.
        """
        # Initialize the population
        self.population = []
        for _ in range(population_size):
            # Generate a random individual
            individual = [random.uniform(-5.0, 5.0) for _ in range(self.dim)]
            
            # Evaluate the fitness of the individual
            fitness = self.func(individual)
            
            # Add the individual to the population
            self.population.append((individual, fitness))
        
        # Return the trained population
        return self.population

# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
# ```python
# import numpy as np
# import random
# import math

class MetaHeuristic:
    """
    A metaheuristic algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of local search, gradient-based optimization, and evolutionary strategy to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    """

    def __init__(self, budget, dim):
        """
        Initializes the MetaHeuristic algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        """
        self.budget = budget
        self.dim = dim
        self.func = None
        self.search_space = None
        self.bounds = None

    def __call__(self, func):
        """
        Optimizes the black box function using MetaHeuristic.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform local search
        for _ in range(self.budget):
            # Generate a new solution by perturbing the current solution
            new_solution = self.perturb(self.search_space, self.bounds)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def perturb(self, search_space, bounds):
        """
        Generates a new solution by perturbing the current solution.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: A new solution generated by perturbing the current solution.
        """
        # Generate a new solution by randomly perturbing the current solution
        new_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
# ```python
# import numpy as np
# import random
# import math

def evaluate_bbo(func, individual, bounds):
    """
    Evaluates the fitness of an individual using the black box function.
    
    Args:
    func (function): The black box function to evaluate.
    individual (list): The individual to evaluate.
    bounds (list): The bounds of the search space.
    
    Returns:
    float: The fitness of the individual.
    """
    return func(individual)

def perturb_space(individual, bounds):
    """
    Perturbs the current solution by randomly changing its values.
    
    Args:
    individual (list): The current solution.
    bounds (list): The current bounds of the search space.
    
    Returns:
    list: The perturbed solution.
    """
    new_solution = individual.copy()
    for i in range(len(individual)):
        new_solution[i] += np.random.uniform(-1, 1) * (bounds[i] - individual[i])
    return new_solution

# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
# ```python
# import numpy as np
# import random
# import math

def train_metaheuristic(budget, dim):
    """
    Trains the MetaHeuristic algorithm using evolutionary strategy.
    
    Args:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    
    Returns:
    list: The trained population.
    """
    # Initialize the MetaHeuristic algorithm
    metaheuristic = MetaHeuristic(budget, dim)
    
    # Train the algorithm using evolutionary strategy
    population = metaheuristic.train(100, budget)
    
    # Return the trained population
    return population

# Description: Black Box Optimization using MetaHeuristic Algorithm with Evolutionary Strategy
# Code: 
# ```python
# import numpy as np
# import random
# import math

def main():
    # Define the budget and dimensionality
    budget = 1000
    dim = 10
    
    # Train the MetaHeuristic algorithm
    population = train_metaheuristic(budget, dim)
    
    # Evaluate the fitness of the population
    fitness = [evaluate_bbo(func, individual, bounds) for individual, _ in population]
    
    # Print the results
    print("Optimal solution:", population[fitness.index(max(fitness))])
    print("Optimal cost:", max(fitness))
    
    # Train the MetaHeuristic algorithm again with a smaller budget
    budget = 500
    dim = 5
    population = train_metaheuristic(budget, dim)
    
    # Evaluate the fitness of the population
    fitness = [evaluate_bbo(func, individual, bounds) for individual, _ in population]
    
    # Print the results
    print("Optimal solution:", population[fitness.index(max(fitness))])
    print("Optimal cost:", max(fitness))

if __name__ == "__main__":
    main()