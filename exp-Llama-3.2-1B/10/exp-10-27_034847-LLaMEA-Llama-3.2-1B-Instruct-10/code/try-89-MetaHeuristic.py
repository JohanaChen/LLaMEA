import numpy as np
from scipy.optimize import minimize

class MetaHeuristic:
    """
    A metaheuristic algorithm for solving black box optimization problems.
    
    The algorithm uses a combination of local search and gradient-based optimization to find the optimal solution.
    
    Attributes:
    budget (int): The maximum number of function evaluations allowed.
    dim (int): The dimensionality of the search space.
    func (function): The black box function to optimize.
    search_space (list): The range of the search space.
    bounds (list): The bounds of the search space.
    evolution_strategy (str): The evolutionary strategy to use.
    mutation_rate (float): The mutation rate to use.
    """

    def __init__(self, budget, dim, evolution_strategy, mutation_rate):
        """
        Initializes the MetaHeuristic algorithm.
        
        Args:
        budget (int): The maximum number of function evaluations allowed.
        dim (int): The dimensionality of the search space.
        evolution_strategy (str): The evolutionary strategy to use.
        mutation_rate (float): The mutation rate to use.
        """
        self.budget = budget
        self.dim = dim
        self.func = None
        self.search_space = None
        self.bounds = None
        self evolution_strategy = evolution_strategy
        self.mutation_rate = mutation_rate

    def __call__(self, func):
        """
        Optimizes the black box function using MetaHeuristic.
        
        Args:
        func (function): The black box function to optimize.
        
        Returns:
        tuple: A tuple containing the optimal solution and its cost.
        """
        if self.func is None:
            raise ValueError("The black box function must be initialized before calling this method.")
        
        # Initialize the search space
        self.search_space = [self.bounds] * self.dim
        self.bounds = [(-5.0, 5.0)] * self.dim
        
        # Initialize the optimal solution and its cost
        opt_solution = None
        opt_cost = float('inf')
        
        # Perform local search
        for _ in range(self.budget):
            # Generate a new solution by perturbing the current solution
            new_solution = self.perturb(self.search_space, self.bounds)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        
        # Apply evolutionary strategy
        if self.evolution_strategy == "mutation":
            # Generate a new solution by mutation
            new_solution = self.mutation(new_solution, self.mutation_rate)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        elif self.evolution_strategy == "crossover":
            # Generate two new solutions by crossover
            child1 = self.crossover(self.search_space, self.bounds)
            child2 = self.crossover(self.search_space, self.bounds)
            
            # Evaluate the new solutions using the black box function
            child1_cost = self.func(child1)
            child2_cost = self.func(child2)
            
            # Update the optimal solution and its cost if necessary
            if child1_cost < opt_cost:
                opt_solution = child1
                opt_cost = child1_cost
            elif child2_cost < opt_cost:
                opt_solution = child2
                opt_cost = child2_cost
        elif self.evolution_strategy == "regression":
            # Generate a new solution by regression
            new_solution = self.regression(self.search_space, self.bounds)
            
            # Evaluate the new solution using the black box function
            new_cost = self.func(new_solution)
            
            # Update the optimal solution and its cost if necessary
            if new_cost < opt_cost:
                opt_solution = new_solution
                opt_cost = new_cost
        else:
            raise ValueError("Invalid evolutionary strategy.")
        
        # Return the optimal solution and its cost
        return opt_solution, opt_cost

    def perturb(self, search_space, bounds):
        """
        Generates a new solution by perturbing the current solution.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: A new solution generated by perturbing the current solution.
        """
        # Generate a new solution by randomly perturbing the current solution
        new_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

    def mutation(self, solution, mutation_rate):
        """
        Applies mutation to the solution.
        
        Args:
        solution (list): The current solution.
        mutation_rate (float): The mutation rate to use.
        
        Returns:
        list: The mutated solution.
        """
        # Generate a new solution by mutation
        mutated_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        mutated_solution = [max(self.bounds[i], min(mutated_solution[i], self.bounds[i])) for i in range(self.dim)]
        
        # Apply mutation with specified rate
        for _ in range(int(self.budget * mutation_rate)):
            if np.random.rand() < mutation_rate:
                mutated_solution = self.mutation_with_rate(mutated_solution)
        
        return mutated_solution

    def crossover(self, search_space, bounds):
        """
        Applies crossover to the search space.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: The new search space generated by crossover.
        """
        # Generate two new solutions by crossover
        child1 = search_space[:self.dim // 2] + bounds[:self.dim // 2]
        child2 = search_space[self.dim // 2:] + bounds[self.dim // 2:]
        
        return child1, child2

    def regression(self, search_space, bounds):
        """
        Applies regression to the search space.
        
        Args:
        search_space (list): The current search space.
        bounds (list): The current bounds of the search space.
        
        Returns:
        list: The new search space generated by regression.
        """
        # Generate a new solution by regression
        new_solution = [self.bounds[0] + np.random.uniform(-1, 1) * (self.bounds[1] - self.bounds[0]) for _ in range(self.dim)]
        
        # Ensure the new solution is within the bounds
        new_solution = [max(bounds[i], min(new_solution[i], bounds[i])) for i in range(self.dim)]
        
        return new_solution

# Description: Black Box Optimization using Evolutionary Strategies
# Code: 