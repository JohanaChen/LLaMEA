{"id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 24, in __call__\nTypeError: unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 24, in __call__\nTypeError: unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "295cfe3e-0bd6-4367-8df7-897fde2d11e1", "solution": "import numpy as np\nimport random\nfrom copy import deepcopy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Clone the current population and add the new individual\n            self.population.append(deepcopy(self.best_func))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# import numpy as np\n# import random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Clone the current population and add the new individual\n            self.population.append(deepcopy(new_func))\n\n            num_evals += 1\n\n        return self.best_func\n\n# Function to evaluate the fitness of a function\ndef evaluate_fitness(func, budget):\n    for _ in range(budget):\n        func()\n    return func\n\n# Function to generate a new individual\ndef generate_individual(func, dim):\n    return func()\n\n# Function to mutate an individual\ndef mutate(individual):\n    return individual + np.random.uniform(-1, 1)\n\n# Function to update the population\ndef update_population(population, func):\n    for i in range(len(population)):\n        new_individual = generate_individual(func, len(population))\n        population[i] = mutate(new_individual)\n    return population\n\n# Main function\ndef main():\n    # Set the parameters\n    budget = 1000\n    dim = 10\n    alpha = 0.5\n    mu = 0.1\n    tau = 0.9\n\n    # Create an instance of the metaheuristic\n    metaheuristic = NonLocalTemperatureMetaheuristic(budget, dim, alpha, mu, tau)\n\n    # Evaluate the fitness of the function\n    func = lambda: np.sin(np.linspace(0, 2*np.pi, 100))\n    fitness = evaluate_fitness(func, budget)\n\n    # Update the population\n    population = update_population(metaheuristic.population, func)\n\n    # Print the best individual\n    best_individual = max(population, key=fitness)\n    print(\"Best individual:\", best_individual)\n\nif __name__ == \"__main__\":\n    main()", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('max() arg is an empty sequence').", "error": "ValueError('max() arg is an empty sequence')", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "66881110-56b0-4e81-a906-3d43cbda8407", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.tau\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "bbb0bf2b-495c-4813-bc8c-9a0137de7472", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Limit the number of evaluations\n            num_evals = min(num_evals + 1, self.budget)\n\n        # Return the best function found so far\n        return self.best_func", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "d38f15e0-e247-4394-a244-018d0d49a413", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9, mu_adapt=0.05, tau_adapt=0.95):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.mu_adapt = mu_adapt\n        self.tau_adapt = tau_adapt\n        self.temp = 1.0\n        self.best_func = None\n        self.iteration = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update mu and tau if necessary\n            if self.iteration >= 10 and self.iteration % 10 == 0:\n                self.mu_adapt = max(0.1, self.mu_adapt * 1.2)\n                self.tau_adapt = max(0.9, self.tau_adapt * 0.95)\n\n            self.iteration += 1\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "d5dcc559-2acd-4773-8bff-bd305454514e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Description: A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.\n# Code: \n# ```python\nimport numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Description: A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Description: A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Description: A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Description: A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evolve(self, func, initial_func, budget):\n        # Initialize the population\n        population = [initial_func]\n\n        for _ in range(self.budget):\n            # Select the fittest individual\n            fittest_individual = population[-1]\n\n            # Generate a new individual\n            new_individual = fittest_individual + np.random.uniform(-self.dim, self.dim)\n\n            # Check if the new individual is within the search space\n            if np.random.rand() < self.alpha:\n                new_individual = fittest_individual - self.dim\n            else:\n                # If the new individual is not better, revert the perturbation\n                new_individual *= self.tau\n\n            # Evaluate the new individual\n            new_func = func(new_individual)\n\n            # Update the population\n            population.append(new_individual)\n\n            # Check if the budget is reached\n            if len(population) >= budget:\n                break\n\n        return population\n\n    def mutate(self, individual):\n        # Generate a random mutation\n        mutation = np.random.uniform(-self.dim, self.dim)\n\n        # Apply the mutation to the individual\n        mutated_individual = individual + mutation\n\n        # Check if the mutated individual is within the search space\n        if np.random.rand() < self.alpha:\n            mutated_individual = individual - self.dim\n        else:\n            # If the mutated individual is not better, revert the mutation\n            mutated_individual *= self.tau\n\n        return mutated_individual", "name": "NonLocalTemperatureMetaheuristic", "description": "A novel metaheuristic algorithm that combines non-local temperature and adaptive mutation to optimize black box functions.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "430afdbf-4c93-4962-82bf-ab96eb9b009a", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.best_fitness = float('-inf')\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_fitness == float('-inf'):\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = np.min([np.min(new_func), np.min(func)])\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.best_fitness = np.min([np.min(new_func), np.min(func)])\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "ed6f6fe4-39b1-46f7-a20e-22664b5c2537", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Store the new individual\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        # Select the best individual based on the probability distribution\n        probabilities = [self.population.count(new_func) / self.population.size for new_func in self.population]\n        selected_individual = random.choices(self.population, weights=probabilities, k=1)[0]\n\n        # Revert the perturbation\n        perturbation = np.random.uniform(-self.dim, self.dim)\n        new_func = selected_individual + perturbation\n\n        # Check if the new function is better\n        if np.random.rand() < self.alpha:\n            self.best_func = new_func\n        else:\n            # If the new function is not better, revert the perturbation\n            perturbation *= self.tau\n            new_func = selected_individual + perturbation\n\n        return new_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "93c895ea-fdd4-495a-9dc0-1a1f676ce999", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature\n            self.temp *= (1 - self.alpha) * (1 - self.mu)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "7d425d50-be69-4350-886d-a6a49a2a2d76", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp - 0.05)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "4abf4e7c-aac0-4bfe-8053-4cbc26608d32", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Add the new individual to the population\n            self.population.append((new_func, perturbation))\n\n            num_evals += 1\n\n        # Select the fittest individual\n        self.population.sort(key=lambda x: x[0], reverse=True)\n        self.best_func = self.population[0][0]\n\n        # Return the best function\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "dc2fb321-8707-4073-a76a-ef5a18b92eef", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.iterations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function and iterations\n            self.best_func = new_func\n            self.iterations += 1\n\n            # Apply non-local temperature\n            self.temp = min(self.temp * np.exp(-self.iterations / 1000), 1.0)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "991a4a5c-4b09-4c63-9b3b-7c0ab589dd15", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Limit the number of evaluations\n            num_evals = min(num_evals + 1, self.budget)\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "f6ceb371-25d9-41e9-a3e0-639383f47040", "solution": "import numpy as np\nimport random\nimport copy\nfrom scipy.optimize import differential_evolution\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def optimize(self, func, bounds, initial_population, budget):\n        # Create an initial population\n        population = initial_population\n\n        # Run the evolutionary algorithm\n        for _ in range(budget):\n            # Evaluate the fitness of each individual\n            fitness = [self.__call__(func) for individual in population]\n\n            # Select the fittest individuals\n            fittest_individuals = sorted(zip(fitness, population), key=lambda x: x[0], reverse=True)[:self.budget // 2]\n\n            # Create a new population\n            new_population = [copy.deepcopy(individual) for individual, _ in fittest_individuals]\n\n            # Update the population\n            population = new_population\n\n        # Return the best individual\n        return max(population, key=lambda x: x[0])\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "226411d2-88ff-4317-92ac-bddc2e4aa97d", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.perturbation = 0.0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            self.perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + self.perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                self.perturbation *= self.tau\n                new_func = func + self.perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "0afec8a8-c21e-46ff-aec7-64350316ce2b", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "38832e21-c36e-426b-b4ab-f2157365985b", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "ff0d3742-d3b8-453e-a664-a15492a0598a", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.iterations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                # Update the temperature using adaptive non-local temperature\n                self.update_temp(perturbation)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def update_temp(self, perturbation):\n        # Update the temperature using adaptive non-local temperature\n        self.temp *= self.tau\n        self.temp = max(self.temp, 0.01)\n        self.temp = min(self.temp, 1.0)\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# ```", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e76c6534-e359-45c8-b69e-1f345361eb41", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature\n            self.temp = max(0.1, self.temp * (1 - self.alpha))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "87fbfd65-01f0-4537-8054-d97c155d34a3", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Add the new individual to the population\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        # Evaluate the population to get the best individual\n        self.best_func = min(self.population, key=func)\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# ```\n# ```python\ndef optimize_bbob(func, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n    \"\"\"Optimize a black box function using Non-Local Temperature and Adaptive Mutation\"\"\"\n    metaheuristic = NonLocalTemperatureMetaheuristic(budget, dim, alpha, mu, tau)\n    best_func = metaheuristic(func)\n    return best_func\n\n# Evaluate the BBOB test suite of 24 noiseless functions\n# ```python\n# BBOB test suite of 24 noiseless functions\n# ```\n# ```python\n# import numpy as np\n# import random\n# from scipy.optimize import minimize\n\n# def func(x):\n#     return x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2 + x[4]**2 + x[5]**2\n\n# best_func = optimize_bbob(func, 1000, 6)\n# print(best_func)", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "472d850a-5538-4d56-8966-31cce81b39fa", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def initialize(self, func, dim):\n        self.population = [func(np.random.uniform(-dim, dim)) for _ in range(100)]\n\n    def fitness(self, individual):\n        return np.mean([self.evaluate_fitness(individual) for individual in self.population])\n\n    def mutate(self, individual):\n        # Refine the strategy\n        perturbation = np.random.uniform(-self.dim, self.dim)\n        updated_individual = individual + perturbation\n        updated_individual = np.clip(updated_individual, -self.dim, self.dim)\n        return updated_individual\n\n    def evaluate_fitness(self, individual):\n        new_func = self.population[0] + individual + random.uniform(-self.dim, self.dim)\n        return np.mean([self.evaluate_fitness(new_func) for _ in range(self.budget)])\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "73549d96-60a0-4edc-b1c6-ba2050ea54c2", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "0787219c-9d7a-453a-872f-cd15eff6f010", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Add the new individual to the population\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        return self.best_func\n\n    def mutate(self, individual):\n        # Randomly select an individual from the population\n        idx = np.random.randint(0, len(self.population))\n\n        # Revert the perturbation\n        perturbation = self.population[idx]\n        self.population[idx] = individual + perturbation\n\n        # Check if the individual is better\n        if np.random.rand() < self.alpha:\n            # If the individual is not better, revert the perturbation again\n            self.population[idx] = individual + perturbation\n        else:\n            # If the individual is better, revert the perturbation one more time\n            self.population[idx] = individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "8fb118e6-4d28-45e5-ad57-32bbea61e0c5", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.mini = False\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = func(new_func)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.best_fitness = func(new_func)\n\n            num_evals += 1\n\n        return self.best_func\n\n    def update(self, func, alpha, mu, tau):\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.mini = False\n        self.best_fitness = np.inf\n\n        # Re-initialize the search space\n        self.dim = func.shape[1]\n        self.temp = 1.0\n        self.best_func = None\n\n        # Update the individual lines of the selected solution\n        for _ in range(100):\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = func(new_func)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.best_fitness = func(new_func)\n\n            # Update the search space\n            self.dim += 1\n            self.temp *= 0.9\n\n            # Check for convergence\n            if self.best_fitness == func(self.best_func):\n                self.mini = True\n                break\n\n        return self.best_func", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "53a6cc8a-6897-4d61-8604-7d13062e13c6", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp - 0.01)\n\n            num_evals += 1\n\n        return self.best_func\n\nclass EvolutionaryOptimizationMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n        self.population_history = []\n\n    def __call__(self, func, population_size=100):\n        for _ in range(population_size):\n            # Generate a random population\n            population = [copy.deepcopy(func) for _ in range(population_size)]\n\n            # Evaluate the population\n            fitnesses = self.evaluate_fitness(population)\n\n            # Select the fittest individuals\n            self.population = self.select_fittest(population, fitnesses)\n\n            # Optimize the fittest individuals\n            self.population_history.append(self.population)\n\n            # Optimize the fittest individual\n            self.population = self.optimize_fittest_individual(population)\n\n            # Update the best function\n            self.best_func = self.population[0]\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp - 0.01)\n\n            # Check if the optimization is complete\n            if np.random.rand() < 0.25:\n                break\n\n        return self.best_func\n\n    def evaluate_fitness(self, population):\n        # Evaluate the fitness of each individual in the population\n        fitnesses = []\n        for individual in population:\n            # Evaluate the function using the given function\n            func = self.evaluate_function(individual)\n            fitnesses.append(func)\n\n        return fitnesses\n\n    def select_fittest(self, population, fitnesses):\n        # Select the fittest individuals based on their fitness\n        fittest_individuals = []\n        for fitness in fitnesses:\n            if fitness == max(fitnesses):\n                fittest_individuals.append(population[fitnesses.index(max(fitnesses))])\n            else:\n                fittest_individuals.append(population[np.argmin(fitnesses)])\n\n        return fittest_individuals\n\n    def optimize_fittest_individual(self, population):\n        # Optimize the fittest individual using a genetic algorithm\n        # This is a simple example and may need to be modified based on the specific problem\n        fitnesses = self.evaluate_fitness(population)\n        fittest_individuals = self.select_fittest(population, fitnesses)\n        # Optimize the fittest individual using a genetic algorithm\n        # This is a simple example and may need to be modified based on the specific problem\n        return fittest_individuals[0]\n\n    def evaluate_function(self, individual):\n        # Evaluate the function using the given function\n        func = self.evaluate_function(individual)\n        return func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "98305927-817b-42c1-950c-446bd801938a", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.perturbations = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                # Store the perturbation\n                self.perturbations.append(perturbation)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                # Store the perturbation\n                self.perturbations.append(perturbation)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "2f6e1b6f-a59c-45be-a45c-55f4cea5de00", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.evaluations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function and the evaluation count\n            self.best_func = new_func\n            self.evaluations += 1\n\n            # Check if the budget has been reached\n            if self.evaluations >= self.budget:\n                break\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "da1d6d4c-f537-46a0-8b48-af708a9421af", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature\n            self.temp *= self.mu\n\n            # Limit temperature to [0, 1]\n            self.temp = max(0, min(self.temp, 1))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "97432ab3-c620-456a-a184-9a890aff74bb", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\n    def update(self, func):\n        # Refine the strategy\n        if np.random.rand() < self.temp:\n            # Non-Local Temperature: Increase temperature for better exploration\n            self.temp *= self.alpha\n        else:\n            # Adaptive Mutation: Increase mutation rate for better exploration\n            self.alpha *= self.mu\n\n        return func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "a1c8fa69-c90a-4545-bca6-10a62654fd73", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature using Non-Local Temperature\n            self.temp = np.exp((self.mu * (self.best_func - new_func) ** 2 / (2 * self.dim)) + self.alpha * self.tau)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "a07237a7-82e0-4b66-82c4-e0d84c9ef116", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "65f43287-062c-46b7-95fd-6f394db769cc", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = np.exp(-self.alpha * np.random.rand())\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "cb26c90f-cbe3-4ea7-ac42-1835211fc694", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.iterations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.iterations = 0\n            else:\n                # If the new function is not better, revert the perturbation\n                self.iterations += 1\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        # Refine the strategy based on the number of iterations\n        if self.iterations % 100 == 0:\n            if self.best_func is not None:\n                self.temp *= 0.9\n            self.best_func = None\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e5a6e775-05bf-4009-b4c2-7ebc8332aaba", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def __str__(self):\n        return \"NonLocalTemperatureMetaheuristic\"\n\n# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code:", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "b2342699-2d98-44d6-9a48-a96e5e936fba", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = min(self.temp + 0.01 * np.random.rand(), 1.0)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "eb431144-893f-4db4-a77c-d051992c2928", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        # Reconstruct the new individual\n        new_individual = copy.deepcopy(func)\n        for i in range(self.dim):\n            new_individual[i] += perturbation[i]\n\n        # Evaluate the new individual\n        new_func = self.evaluate_fitness(new_individual)\n\n        return new_func\n\n    def evaluate_fitness(self, func):\n        # Reconstruct the problem\n        problem = ioh.iohcpp.Sphere(func, self.dim)\n\n        # Evaluate the new function\n        new_func = problem.evaluate()\n\n        # Return the score\n        return new_func.score()\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "c157ceed-f484-4c51-bdd1-42dfcfe95274", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Store the new individual\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        # Select the fittest individual\n        self.best_func = min(self.population, key=self.evaluate_fitness)\n\n        return self.best_func\n\n    def evaluate_fitness(self, func):\n        # Evaluate the function at the fittest individual\n        return func(self.best_func)\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "59ad640e-8135-47b4-ad19-efabbcc7bfac", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.iterations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "aca7f971-cfcd-474c-9e67-86bbbcffe716", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Evaluate the new function using minimize\n            new_func_score = minimize(lambda x: -func(x), new_func, method=\"SLSQP\", bounds=[(-self.dim, self.dim)])\n\n            # Update the best function if it's better\n            if new_func_score.fun < self.best_func_score.fun:\n                self.best_func = new_func\n                self.best_func_score = new_func_score.fun\n\n            num_evals += 1\n\n        return self.best_func, self.best_func_score\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "938b63a5-2624-4ddc-99b9-c121deddd94b", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e69145e4-b56f-4a55-8c28-831e30e8ea5d", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = min(1.0, self.temp * (1.0 + 0.1 * np.random.rand()))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "31e6a268-b3c7-4e44-b157-0c0d2d5bd41c", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = min(self.temp + self.alpha * (self.budget - num_evals), self.mu)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "070cae4a-5427-4367-92f9-f3feba08e57b", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def mutate(self, individual):\n        if len(self.population) < self.budget:\n            self.population.append(copy.deepcopy(individual))\n        else:\n            self.population = self.population[:self.budget]\n\n        # Refine the strategy\n        perturbation = np.random.uniform(-self.dim, self.dim)\n        if random.random() < 0.25:\n            perturbation *= self.mu\n        new_individual = individual + perturbation\n\n        # Check if the new individual is better\n        if np.random.rand() < self.alpha:\n            new_individual = copy.deepcopy(new_individual)\n        else:\n            new_individual *= self.tau\n\n        # Update the population\n        self.population = self.population[:self.budget]\n\n        return new_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "37a2567d-fe6e-4d8e-be43-088871e42c8a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "27214c0c-4bbf-4c83-bd03-3e97f8c59757", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature\n            self.temp = min(1.0, self.temp * self.mu)\n\n            num_evals += 1\n\n        return self.best_func\n\nclass NonLocalTemperatureEvolutionaryMetaheuristic(NonLocalTemperatureMetaheuristic):\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        super().__init__(budget, dim, alpha, mu, tau)\n\n    def __call__(self, func):\n        # Refine strategy using non-local temperature\n        updated_func = self.f(func, self.temp)\n        self.temp = max(0.1, self.temp * self.mu)\n        return updated_func\n\n    def f(self, func, temp):\n        # Evaluate the function with updated temperature\n        return self.budget * func / temp\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "4535ea3a-ec85-4d31-af16-887e10bd14b6", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def optimize(self, func, bounds, iterations=100):\n        \"\"\"\n        Optimize the black box function using Non-Local Temperature Metaheuristic.\n\n        Parameters:\n        func (function): The black box function to optimize.\n        bounds (list): The bounds for each dimension.\n        iterations (int): The number of iterations to run the optimization algorithm.\n\n        Returns:\n        The optimized function.\n        \"\"\"\n        # Run differential evolution optimization\n        result = differential_evolution(lambda x: -func(x), bounds, args=(func, self.alpha, self.mu, self.tau, self.budget, iterations))\n\n        # Get the optimized function\n        optimized_func = result.fun\n\n        return optimized_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic(budget, dim).optimize(func, bounds)", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "476b0586-e7da-4eb0-ba9f-284a2a4573b6", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the population with the best function\n            self.population = [new_func]\n            if len(self.population) > 1:\n                # Select the next individual based on the probability distribution\n                selected_individuals = np.random.choice(self.population, self.budget, replace=False)\n                self.population = [func for func in self.population if func in selected_individuals]\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "c8250259-8fde-47a2-bdd6-24066267a008", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\nclass BBOBOptimizer:\n    def __init__(self, budget, dim, nonlocal_temperature_metaheuristic, noiseless_functions, noiseless_random_functions):\n        self.budget = budget\n        self.dim = dim\n        self.nonlocal_temperature_metaheuristic = nonlocal_temperature_metaheuristic\n        self.noiseless_functions = noiseless_functions\n        self.noiseless_random_functions = noiseless_random_functions\n\n    def __call__(self, func, num_evals):\n        # Evaluate the function using the provided number of evaluations\n        if num_evals < self.budget:\n            num_evals = self.budget\n\n        # Initialize the best function and its score\n        best_func = None\n        best_score = -np.inf\n\n        # Iterate over the noiseless functions\n        for func in self.noiseless_functions:\n            # Evaluate the function using the provided number of evaluations\n            score = self.nonlocal_temperature_metaheuristic(func, num_evals)\n\n            # Update the best function and its score if necessary\n            if score > best_score:\n                best_func = func\n                best_score = score\n\n        # Update the best function and its score using the provided number of evaluations\n        self.nonlocal_temperature_metaheuristic(best_func, num_evals)\n\n        return best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "67062165-a26d-4fcd-a40c-90e3219efbb4", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\nclass BBOOptimization:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        # Create a new individual\n        new_individual = np.random.uniform(-self.dim, self.dim)\n\n        # Add the new individual to the population\n        self.population.append(new_individual)\n\n        # Evaluate the new individual\n        new_func = func + new_individual\n\n        # Check if the new function is better\n        if np.random.rand() < self.alpha:\n            # Update the best function\n            self.best_func = new_func\n\n        # Update the temperature\n        self.temp *= self.mu\n\n        # Revert the perturbation\n        new_individual = np.random.uniform(-self.dim, self.dim)\n\n        # Add the new individual to the population\n        self.population.append(new_individual)\n\n        # Evaluate the new individual\n        new_func = func + new_individual\n\n        # Check if the new function is better\n        if np.random.rand() < self.alpha:\n            # Update the best function\n            self.best_func = new_func\n\n        # Update the temperature\n        self.temp *= self.mu\n\n        return new_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e707abe9-217e-430e-93c2-ccb8bf85de7f", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the population\n            self.population.append((new_func, perturbation))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "2f14d277-2adb-46f4-b907-bfbb33425fb4", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.history.append((new_func, num_evals))\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.history.append((new_func, num_evals))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "0011506b-ce04-4867-8820-d1e8f1b88db8", "solution": "import numpy as np\nimport random\nimport math\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Non-Local Temperature adjustment\n            self.temp = math.exp(-self.alpha * num_evals / self.budget)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "d1925528-f4a3-476f-b63d-7e803fc07e34", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.mutations = np.random.uniform(-0.1, 0.1, size=(dim, dim))\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.mutations = np.random.uniform(-0.1, 0.1, size=(dim, dim))\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.mutations = np.random.uniform(-0.1, 0.1, size=(dim, dim))\n\n            num_evals += 1\n\n        return self.best_func, self.mutations\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "ff72e51b-3c30-4fed-b984-d79773ca3162", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Refine the strategy using Non-Local Temperature\n            self.temp = max(0.1, self.temp - 0.05 * (1 - self.temp) * (num_evals / self.budget))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "45220fd5-e37f-4a54-8ce8-01a612f29e91", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9, gamma=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n        self.logistic = False\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the population\n            self.population = self.population + [new_func]\n\n            # Update the temperature\n            self.temp *= (1 - self.mu) * self.alpha\n\n            num_evals += 1\n\n        # Normalize the population\n        self.population = self.population / self.population.sum()\n\n        # Evaluate the best function\n        self.best_func = self.population[np.argmax(self.population)]\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "8f6318d3-9fde-4461-82f1-aa5b7dae14bf", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "8ac2c091-555a-4c3b-b565-8b2d2e6374b3", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n            self.population.append((new_func, perturbation))\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "59429450-6ca0-44dd-90c3-202ade811806", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Limit the number of evaluations\n            if num_evals >= self.budget:\n                break\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "3efd18ee-f2d5-4238-b21a-48df3af02549", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.perturbations = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Store the perturbation for later use\n            self.perturbations.append(perturbation)\n\n            num_evals += 1\n\n        # Reconstruct the best function\n        self.best_func = self.reconstruct_best_func()\n\n        return self.best_func\n\n    def reconstruct_best_func(self):\n        if self.best_func is None:\n            return None\n\n        # Get the perturbations\n        perturbations = self.perturbations[:self.budget]\n\n        # Initialize the new function\n        new_func = None\n\n        # Iterate over the perturbations\n        for perturbation in perturbations:\n            # Evaluate the new function\n            new_func = self.f(self.best_func, perturbation)\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = self.best_func + perturbation\n\n        return new_func\n\n    def f(self, func, perturbation):\n        # Evaluate the new function\n        return func + perturbation\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e26468bb-3315-4c6b-ae63-febc9663f934", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def optimize(self, func, initial_individual, max_iter=1000, tol=1e-6):\n        \"\"\"\n        Optimize the black box function using the Non-Local Temperature Metaheuristic.\n\n        Parameters:\n        func (function): The black box function to optimize.\n        initial_individual (list): The initial individual to start with.\n        max_iter (int): The maximum number of iterations.\n        tol (float): The tolerance for convergence.\n\n        Returns:\n        The optimized individual.\n        \"\"\"\n        # Create a copy of the initial individual\n        individual = initial_individual.copy()\n\n        # Initialize the temperature\n        self.temp = 1.0\n\n        # Run the optimization algorithm\n        for _ in range(max_iter):\n            # Evaluate the fitness of the individual\n            fitness = self.evaluate_fitness(individual)\n\n            # If the fitness is better, return the individual\n            if fitness > 0:\n                return individual\n\n            # If the fitness is not better, decrease the temperature\n            self.temp *= 0.9\n\n            # Generate a new individual\n            new_individual = individual.copy()\n            for i in range(self.dim):\n                new_individual[i] += np.random.uniform(-1, 1)\n\n            # Evaluate the fitness of the new individual\n            new_fitness = self.evaluate_fitness(new_individual)\n\n            # If the fitness is better, update the individual\n            if new_fitness > fitness:\n                individual = new_individual\n\n        # If the maximum number of iterations is reached, return the best individual found so far\n        return individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "e462e82b-436e-4f8e-b3a6-bf0721886745", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def mutate(self, individual):\n        perturbation = np.random.uniform(-self.dim, self.dim)\n        individual += perturbation\n        if np.random.rand() < self.tau:\n            perturbation *= self.mu\n            individual -= perturbation\n        return individual\n\n    def update(self, func, initial_func):\n        self.population = [initial_func]\n        for _ in range(self.budget):\n            self.population.append(func(self.mutate(initial_func)))\n\n        self.best_func = min(self.population, key=lambda x: x.score())\n\n    def evaluate_fitness(self, func, individual):\n        return func(individual)\n\n    def score(self, func, individual):\n        return func(individual).score\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "a5d3a230-080d-4d52-a026-9b28a9c917a7", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Store the new individual\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        # Select the best individual\n        self.best_func = self.population[np.argmax([self.population[i] for i in range(len(self.population))])]\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "39ab0fba-eb54-4be3-a59f-701d93e04174", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = copy.deepcopy(func)\n            new_func += perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = copy.deepcopy(func)\n                new_func -= perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def mutate(self, individual):\n        # Apply mutation strategy\n        if random.random() < self.alpha:\n            # Randomly select a mutation point\n            mutation_point = random.randint(0, self.dim - 1)\n\n            # Swap the elements at the mutation point\n            individual[mutation_point], individual[mutation_point + 1] = individual[mutation_point + 1], individual[mutation_point]\n\n            # Check if the mutation point is within the bounds\n            if random.random() < self.mu:\n                # If the mutation point is within the bounds, swap the elements again\n                individual[mutation_point], individual[mutation_point + 1] = individual[mutation_point + 1], individual[mutation_point]\n\n            # Check if the mutation point is within the bounds of the problem\n            if random.random() < self.tau:\n                # If the mutation point is within the bounds of the problem, swap the elements again\n                individual[mutation_point], individual[mutation_point + 1] = individual[mutation_point + 1], individual[mutation_point]\n\n            return individual\n        else:\n            return individual\n\n    def __repr__(self):\n        return f\"NonLocalTemperatureMetaheuristic(budget={self.budget}, dim={self.dim}, alpha={self.alpha}, mu={self.mu}, tau={self.tau})\"", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"cannot pickle 'ioh.iohcpp.problem.Sphere' object\").", "error": "TypeError(\"cannot pickle 'ioh.iohcpp.problem.Sphere' object\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "a4babe74-c549-4b61-ba08-34788f1ba3f1", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.x = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evaluate_fitness(self, func):\n        if self.x is None:\n            # Initialize the initial solution\n            self.x = np.array([0.0] * self.dim)\n\n        # Perform the optimization\n        res = minimize(lambda x: func(x), self.x, method=\"SLSQP\", bounds=[(-self.dim, self.dim)], options={\"maxiter\": 1000})\n        self.x = res.x\n\n        # Update the best function\n        if np.random.rand() < self.alpha:\n            self.best_func = func\n        else:\n            # If the new function is not better, revert the perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n            self.x = self.x + perturbation\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "a56e501f-ceed-40d8-a7e4-dc082ecae6d4", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "10fc9e2f-f502-4252-b969-865a23bcc54a", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9, mu_new=0.2, tau_new=0.8):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.mu_new = mu_new\n        self.tau_new = tau_new\n        self.temp = 1.0\n        self.best_func = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_fitness > 0:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = np.inf\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                # Update the mutation strategy\n                if random.random() < self.mu_new:\n                    self.mu_new *= 0.9\n                    self.tau_new *= 0.99\n                self.best_fitness = np.inf\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "9264b8f1-1301-4ae8-9fd2-6e22ab9c530a", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.perturbations = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n            # Update the perturbations\n            if self.perturbations is None:\n                self.perturbations = np.zeros((self.dim, self.dim))\n            self.perturbations = np.concatenate((self.perturbations, perturbation))\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "aa33a76b-1a3c-4228-af2a-3dcc92e9e4eb", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Create a new individual\n            new_individual = copy.deepcopy(func)\n            new_individual.perturbations.append(perturbation)\n\n            num_evals += 1\n\n        return self.best_func\n\n    def __next__(self):\n        # Select the best individual\n        best_func = self.best_func\n        best_individual = copy.deepcopy(best_func)\n\n        # Refine the strategy\n        if random.random() < 0.25:\n            # Apply mutation\n            mutation = np.random.uniform(-self.dim, self.dim)\n            new_individual = copy.deepcopy(best_func)\n            new_individual.mutations.append(mutation)\n\n            # Update the best individual\n            best_func = copy.deepcopy(best_individual)\n            best_individual.perturbations.append(best_func.mutations[-1])\n\n        return best_func, best_individual\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "5396cd42-c4ea-4797-a339-7b7ab16c750a", "solution": "import numpy as np\nimport random\nimport copy\nfrom collections import deque\nfrom operator import add\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\nclass NonLocalTemperatureMutationMetaheuristic(NonLocalTemperatureMetaheuristic):\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                # Apply mutation with probability 1 - mu\n                if random.random() < (1 - self.mu):\n                    new_func = func + perturbation\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\nclass NonLocalTemperatureCrossoverMetaheuristic(NonLocalTemperatureMetaheuristic):\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        super().__init__(budget, dim, alpha, mu, tau)\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate two random parents\n            parent1 = np.random.uniform(-self.dim, self.dim)\n            parent2 = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + parent1 + parent2\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                # Apply crossover with probability 1 - mu\n                if random.random() < (1 - self.mu):\n                    new_func = func + parent1 + parent2\n            else:\n                # If the new function is not better, revert the parents\n                parent1 *= self.tau\n                parent2 *= self.tau\n                new_func = func + parent1 + parent2\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "ff021f91-88a6-4980-8f6b-02f86fe8701d", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def optimize(self, func):\n        # Evaluate the function with the given budget\n        self.best_func = self.__call__(func)\n\n        # Refine the strategy using Non-Local Temperature and Adaptive Mutation\n        for _ in range(self.budget):\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                # If the new function is better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n            else:\n                # If the new function is not better, add it to the population\n                self.population.append(new_func)\n\n        # Select the best individual\n        self.population = self.population[:1]\n\n        # Normalize the population\n        self.population = np.array(self.population) / np.sum(self.population)\n\n        # Update the best function\n        self.best_func = self.population[np.argmax(self.population)]\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "edcc30ef-6796-46e9-a1e8-87d7ba6802ec", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Non-Local Temperature adjustment\n            self.temp = max(0.1, min(1.0, self.temp * 0.95 + 0.05))\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "34a455d5-bb85-4604-85c8-4f9f9edcecdd", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature for next iteration\n            self.temp *= self.mu\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "75077382-5a94-4e6a-992a-ce10af68b997", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_fitness == np.inf:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = func(new_func)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.best_fitness = func(new_func)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "b420e00b-147b-4d36-868c-1cfec7d024c8", "solution": "import numpy as np\nimport random\nimport copy\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9, sigma=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.sigma = sigma\n        self.temp = 1.0\n        self.best_func = None\n        self mutation_rate = 0.01\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Adapt the temperature\n            self.temp *= (1 - self.alpha * (num_evals / self.budget))\n\n            num_evals += 1\n\n        # Apply mutation\n        if random.random() < self.mutation_rate:\n            perturbation = np.random.uniform(-self.dim, self.dim)\n            new_func = func + perturbation\n            if np.random.rand() < self.alpha:\n                new_func = func + perturbation\n            else:\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n        return new_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 15, 14, '        self mutation_rate = 0.01\\n', 15, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 15, 14, '        self mutation_rate = 0.01\\n', 15, 27))", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "924a938e-95d5-4909-947b-748703c4ca83", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp * 0.95)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# ```python\nimport numpy as np\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                # Update the best function\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp * 0.95)\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \n# ```python\n# NonLocalTemperatureMetaheuristic: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# ```python\nimport numpy as np\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                # Update the best function\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp = max(0.1, self.temp * 0.95)\n\n            # Update the best function\n            self.best_func = new_func\n\n            num_evals += 1\n\n        return self.best_func\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Define the problem\n    func = lambda x: x**2\n    budget = 10\n    dim = 5\n\n    # Initialize the metaheuristic\n    metaheuristic = NonLocalTemperatureMetaheuristic(budget, dim)\n\n    # Optimize the function\n    best_func = metaheuristic(func)\n    print(f\"Optimized function: {best_func}\")\n    print(f\"Best fitness: {best_func(x=0)}\")", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'function' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'function' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "7a35a82d-5898-4f94-88a3-201981ebc705", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Limit the number of evaluations\n            if num_evals >= self.budget:\n                self.temp *= self.mu\n                self.best_func = None\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "2f49384e-2945-43d7-b555-20932b126b00", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature using Non-Local Temperature\n            self.temp *= (1 - self.alpha * self.tau)\n            self.temp = max(self.temp, 0.01)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "36443321-50ab-4f27-9cd3-5b2d99de36e3", "solution": "import numpy as np\nimport random\nimport math\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.temp = math.exp(self.alpha * (self.best_func - func))\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                self.temp = math.exp(self.alpha * (self.best_func - func))\n\n            num_evals += 1\n\n        return self.best_func, self.temp\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "cdd54eaf-ffa4-486e-ac74-c20229070845", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_fitness == np.inf:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = np.min([func(new_func) for new_func in self.evaluate_fitness(self.best_func)])\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                if np.random.rand() < self.alpha:\n                    self.best_func = new_func\n                    self.best_fitness = np.min([func(new_func) for new_func in self.evaluate_fitness(self.best_func)])\n\n            num_evals += 1\n\n        return self.best_func\n\n    def evaluate_fitness(self, func):\n        # Evaluate the function at a specified number of points\n        num_points = min(10, self.budget // 0.25)  # 10 points with 0.25 probability\n        points = np.random.choice(self.dim, num_points, replace=False)\n        return func(points)\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "277644b6-aedd-43bd-b6f7-af7e79327ca5", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.perturbations = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the population\n            self.perturbations += 1\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "dbc2024e-cc90-4bdc-b0d3-b391dad46f5c", "solution": "import numpy as np\nimport random\nimport math\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Calculate the non-local temperature\n            non_local_temp = math.exp((self.temp - self.alpha * self.mu) / 100)\n\n            # Apply mutation\n            if random.random() < self.mutation_rate:\n                # Randomly select an individual from the search space\n                individual = np.random.choice(self.dim, size=self.dim, replace=False)\n\n                # Update the individual using the non-local temperature\n                updated_individual = self.evaluate_fitness(individual + perturbation, non_local_temp)\n\n                # Revert the perturbation\n                perturbation *= self.tau\n                updated_individual = individual + perturbation\n\n                # Check if the updated individual is better\n                if np.random.rand() < self.alpha:\n                    updated_func = self.evaluate_fitness(updated_individual, non_local_temp)\n                else:\n                    updated_func = func + perturbation\n\n                # Update the best function\n                self.best_func = updated_func\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "ff95eca1-9c2a-4d39-ae22-75baf5e263f8", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def update(self, func):\n        # Refine the strategy by changing the individual lines of the selected solution\n        for _ in range(self.budget):\n            # Generate a new perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                func = func + perturbation\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "6b03fa9f-454f-4e20-b062-bafe2c626025", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\nclass EvolutionaryOptimization:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func, population_size=100):\n        for _ in range(population_size):\n            # Select a random individual from the population\n            individual = np.random.uniform(-self.dim, self.dim, self.dim)\n\n            # Evaluate the fitness of the individual\n            fitness = self.evaluate_fitness(individual, func)\n\n            # Add the individual to the population\n            self.population.append((individual, fitness))\n\n        # Select the best individual\n        self.best_func = self.population[0][1]\n\n        # Refine the strategy\n        for _ in range(self.budget):\n            # Select a random individual from the population\n            individual = np.random.choice(self.population, self.dim, replace=False)\n\n            # Evaluate the fitness of the individual\n            fitness = self.evaluate_fitness(individual, func)\n\n            # Update the individual\n            self.population[self.population.index((individual, fitness))][0] = individual\n\n            # Check if the new individual is better\n            if np.random.rand() < self.alpha:\n                self.population[self.population.index((individual, fitness))][1] = fitness\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "bc985b46-0a9d-4abc-985f-5ae87411830a", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_fitness == np.inf:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.best_fitness = np.min(np.abs(new_func - func))\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "6606ef3d-8bba-4102-af05-e16790fa1a95", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n    def __repr__(self):\n        return f\"NonLocalTemperatureMetaheuristic(budget={self.budget}, dim={self.dim}, alpha={self.alpha}, mu={self.mu}, tau={self.tau})\"\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "5399c659-3568-4fe8-8c18-3537ca6daaa2", "solution": "import numpy as np\nimport random\nimport math\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the best function\n            self.history.append((new_func, self.temp))\n\n            num_evals += 1\n\n        # Refine the strategy\n        self.temp *= self.mu\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "b9cabfcd-ae82-4383-bb97-f25fb27a636a", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9, mu_new=0.2):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.mu_new = mu_new\n        self.temp = 1.0\n        self.best_func = None\n        self.population = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n            # Update the population using adaptive mutation\n            self.population = [self.evaluate_fitness(individual) for individual in self.population]\n            self.population = [self.mu * individual + self.mu_new * (1 - self.mu) * (individual - self.mu) for individual in self.population]\n            self.temp *= self.tau\n\n        return self.best_func\n\n    def evaluate_fitness(self, func):\n        return np.random.uniform(-self.dim, self.dim) * func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "edc4852c-adb3-4cf0-a75a-2d3cdb39bf89", "solution": "import numpy as np\nimport random\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self mutation_prob = 0.25\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update temperature\n            self.temp = min(1.0, self.temp + self.alpha * (1.0 - self.temp) * (num_evals / self.budget))\n\n            num_evals += 1\n\n        # Apply mutation\n        if random.random() < self.mutation_prob:\n            # Generate a random mutation\n            mutation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the mutated function\n            mutated_func = func + mutation\n\n            # Check if the mutated function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = mutated_func\n            else:\n                # If the mutated function is not better, revert the mutation\n                mutated_func = func + mutation\n                mutation *= self.tau\n\n            # Update temperature\n            self.temp = min(1.0, self.temp + self.alpha * (1.0 - self.temp) * (num_evals / self.budget))\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 13, 14, '        self mutation_prob = 0.25\\n', 13, 27)).", "error": "SyntaxError('invalid syntax', ('<string>', 13, 14, '        self mutation_prob = 0.25\\n', 13, 27))", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "9c327c31-4e56-4af6-9a22-6ccfec628e47", "solution": "import numpy as np\nimport random\nimport math\n\nclass AdaptiveNonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.mutation_rate = 0.01\n        self.num_evals = 0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= 0.99\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation\n# Code: ", "name": "AdaptiveNonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Adaptive Non-Local Temperature and Mutation", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "f075cfc1-b3f2-4247-8215-384e68ab4c0f", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.temp = min(self.temp + self.alpha * (self.temp - self.alpha) / num_evals, 1.0)\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                self.best_func = func + perturbation\n                self.temp = max(self.temp - self.alpha * (self.temp - self.alpha) / num_evals, 0.0)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "4fc4ebdd-bef2-40d7-944a-6b35ebbb4a22", "solution": "import numpy as np\nimport random\nimport copy\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Refine the strategy using Non-Local Temperature\n            self.temp = self.tau * self.temp + self.mu\n\n            # Select a new individual\n            new_individual = copy.deepcopy(func)\n            if np.random.rand() < self.temp:\n                # Use Non-Local Temperature to adapt the mutation\n                new_individual = np.random.uniform(-self.dim, self.dim)\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "75a8b8fc-58a4-4f4a-8c3c-b1d316262b22", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Apply Non-Local Temperature and Adaptive Mutation\n            self.temp = max(0.5, self.temp - 0.05 * (num_evals / self.budget))\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "40eb469b-c48f-4bd9-b4be-e3e3b0f325b5", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature\n            self.temp *= (1 - self.alpha)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code:", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "0026c4a4-8826-422d-b300-c599a43e107c", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.population = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Store the new individual in the population\n            self.population.append(new_func)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "6d4f9e26-825c-4482-b157-414e8a680fbd", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Use a non-local temperature strategy to adapt the mutation probability\n            self.temp = max(0.1, self.temp * 0.9)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "fc5f0c03-0c4b-4f0b-a0f5-e283519ffae7", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Refine the strategy using Non-Local Temperature\n            self.temp *= self.mu if np.random.rand() < 0.5 else 1.0\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "27b20ce5-e129-41f1-8a5b-cf404f61abce", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Perform a local search\n            func_eval = minimize(lambda x: -self.budget, x, method=\"SLSQP\", bounds=[(-self.dim, self.dim)], options={\"xtol\": 1e-10, \"ftol\": 1e-10})\n            new_func = func + func_eval.x[0]\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "f1504c42-abc9-4c57-af1f-a49d0a3a23bf", "solution": "# Description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: \nimport numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            # Update the temperature using non-local temperature strategy\n            self.temp = max(0.5, self.temp - 0.1)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "bfb8bcbe-cdf1-423a-a1a3-71e1d9d9b6ae", "solution": "import numpy as np\nimport random\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                # Refine the strategy\n                self.temp *= self.mu\n                perturbation *= self.tau\n                new_func = func + perturbation\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
{"id": "62aaf481-ec66-4187-899b-9ddb6cf17cb0", "solution": "import numpy as np\nimport random\nimport math\n\nclass NonLocalTemperatureMetaheuristic:\n    def __init__(self, budget, dim, alpha=0.5, mu=0.1, tau=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.alpha = alpha\n        self.mu = mu\n        self.tau = tau\n        self.temp = 1.0\n        self.best_func = None\n        self.variance = 1.0  # Initialize variance to 1.0\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            raise ValueError(\"Budget cannot be zero or negative\")\n\n        num_evals = 0\n        while num_evals < self.budget and self.best_func is None:\n            # Generate a random perturbation\n            perturbation = np.random.uniform(-self.dim, self.dim)\n\n            # Evaluate the new function\n            new_func = func + perturbation\n\n            # Check if the new function is better\n            if np.random.rand() < self.alpha:\n                self.best_func = new_func\n                self.variance = 1.0  # Reset variance\n            else:\n                # If the new function is not better, revert the perturbation\n                perturbation *= self.tau\n                new_func = func + perturbation\n                # Update variance using the formula: variance = (1 / num_evals) * (1 + self.alpha * (1 - self.variance))\n                self.variance = 1.0 + self.alpha * (1 - self.variance)\n\n            num_evals += 1\n\n        return self.best_func\n\n# One-line description: Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation\n# Code: ", "name": "NonLocalTemperatureMetaheuristic", "description": "Evolutionary Optimization using Non-Local Temperature and Adaptive Mutation", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'ioh.iohcpp.problem.Sphere' and 'float'\")", "parent_id": "f9e5afa0-d10f-48f4-8fbf-2f741c0a9ff0", "metadata": {}, "mutation_prompt": null}
