{"id": "713ed15c-2917-4b04-a8ac-90af135945fc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "An adaptive hybrid algorithm combining Differential Evolution and Particle Swarm Optimization for efficient exploration and exploitation in dynamic search spaces.  ", "configspace": "", "generation": 0, "fitness": 0.058371843118032896, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.061976933716266225, 0.05529185909132672, 0.05784673654650574]}, "mutation_prompt": null}
{"id": "ad891e16-374f-41a8-987b-126f7d5f8d5a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "A slight increase in the differential weight improves exploration capabilities by diversifying mutation strength.", "configspace": "", "generation": 1, "fitness": 0.055799823479042186, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "713ed15c-2917-4b04-a8ac-90af135945fc", "metadata": {"aucs": [0.058285284088020695, 0.05130504627218313, 0.05780914007692273]}, "mutation_prompt": null}
{"id": "dc0a88e9-1363-45a8-a7b0-e895e09a5ae1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced HybridDEPSO by dynamically adjusting inertia weight for improved convergence.", "configspace": "", "generation": 2, "fitness": 0.05839703008570422, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "713ed15c-2917-4b04-a8ac-90af135945fc", "metadata": {"aucs": [0.061977617673323215, 0.055281189661638086, 0.05793228292215136]}, "mutation_prompt": null}
{"id": "160c2de1-9071-4482-a279-9eeb2bf1dd29", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.8  # Adjusted differential weight\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improved convergence by fine-tuning the differential weight in DE mutation.", "configspace": "", "generation": 3, "fitness": 0.057345591648625405, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "dc0a88e9-1363-45a8-a7b0-e895e09a5ae1", "metadata": {"aucs": [0.06187874388785042, 0.05586123473715321, 0.05429679632087259]}, "mutation_prompt": null}
{"id": "bc2e44c6-e101-424e-a4b3-5c185139793f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the cognitive coefficient to enhance exploration towards personal best solutions.", "configspace": "", "generation": 4, "fitness": 0.05845748829944456, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "dc0a88e9-1363-45a8-a7b0-e895e09a5ae1", "metadata": {"aucs": [0.06200925784619149, 0.055284481285995835, 0.058078725766146366]}, "mutation_prompt": null}
{"id": "50c0cad9-becd-4ef4-a5a3-e549a23365a7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.3 + 0.6 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjust the inertia weight to dynamically decrease faster, enhancing convergence speed.", "configspace": "", "generation": 5, "fitness": 0.05844695696885227, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bc2e44c6-e101-424e-a4b3-5c185139793f", "metadata": {"aucs": [0.06201437306153956, 0.05528493611083507, 0.05804156173418218]}, "mutation_prompt": null}
{"id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decrease social coefficient slightly to enhance local search capabilities.", "configspace": "", "generation": 6, "fitness": 0.05846517423046357, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bc2e44c6-e101-424e-a4b3-5c185139793f", "metadata": {"aucs": [0.062000863197054445, 0.05528597107580746, 0.05810868841852879]}, "mutation_prompt": null}
{"id": "d6d6d171-88b5-4b2c-9751-7b5799e6105f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.7  # Increased from 1.6 to 1.7\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune cognitive coefficient to balance exploration and exploitation.", "configspace": "", "generation": 7, "fitness": 0.0584631601723495, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.062002673318349744, 0.05528901594286628, 0.058097791255832476]}, "mutation_prompt": null}
{"id": "563f60c2-9e63-43e2-98aa-6829c14f4843", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decrease social coefficient slightly to enhance local search capabilities.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.062000863197054445, 0.05528597107580746, 0.05810868841852879]}, "mutation_prompt": null}
{"id": "b33a44a2-f53b-419b-a14f-0bdc09a5b36b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.7  # Increased from 1.6 to 1.7\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the cognitive coefficient to enhance particle exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.0584631601723495, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.062002673318349744, 0.05528901594286628, 0.058097791255832476]}, "mutation_prompt": null}
{"id": "d4ba0fe7-d9d0-4aae-bded-322d9c40ae55", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decrease social coefficient slightly to enhance local search capabilities.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.062000863197054445, 0.05528597107580746, 0.05810868841852879]}, "mutation_prompt": null}
{"id": "1174582c-98cc-4ab5-9066-99e52ce801f3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Increased from 1.6 to 1.65\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increase cognitive coefficient slightly to enhance individual search capabilities.", "configspace": "", "generation": 11, "fitness": 0.058464351586577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.06200177505007365, 0.0552875690174327, 0.05810371069222464]}, "mutation_prompt": null}
{"id": "dabb4ed0-c2fd-4d0c-8333-c2b9cbd54529", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Increased from 1.6 to 1.65\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increase cognitive coefficient slightly to enhance personal search capabilities.", "configspace": "", "generation": 12, "fitness": 0.058464351586577, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.06200177505007365, 0.0552875690174327, 0.05810371069222464]}, "mutation_prompt": null}
{"id": "3f00cdf8-5341-4d95-a3ae-ad946ca14b8b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly adjust the differential weight to enhance exploration during mutation.", "configspace": "", "generation": 13, "fitness": 0.05566779052657026, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.05830012720189004, 0.050776566649423094, 0.05792667772839766]}, "mutation_prompt": null}
{"id": "ff54f80f-60a7-4fef-bd83-f502bc6be071", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.7  # Increased from 1.6 to 1.7\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increase the cognitive coefficient slightly to encourage more exploration.", "configspace": "", "generation": 14, "fitness": 0.0584631601723495, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.062002673318349744, 0.05528901594286628, 0.058097791255832476]}, "mutation_prompt": null}
{"id": "93c9ea77-ab1c-4026-9da7-ad5b515445a3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance exploration by slightly increasing the differential weight in DE for better diversity.", "configspace": "", "generation": 15, "fitness": 0.05566779052657026, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.05830012720189004, 0.050776566649423094, 0.05792667772839766]}, "mutation_prompt": null}
{"id": "dd5bc323-19d6-4f97-b2e5-fa09f77161d7", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.6  # Increased from 1.5 to 1.6\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decrease crossover rate slightly to enhance exploitation phase.", "configspace": "", "generation": 16, "fitness": 0.05878739823462886, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a01d7ab9-2cd2-4202-9619-84379c907ff0", "metadata": {"aucs": [0.06190612941132556, 0.05523179872700057, 0.05922426656556046]}, "mutation_prompt": null}
{"id": "f4ab3c0a-860a-4f3e-948e-8517cdf851e3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance exploitation by slightly increasing the cognitive coefficient for better local search.", "configspace": "", "generation": 17, "fitness": 0.05879157735581194, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "dd5bc323-19d6-4f97-b2e5-fa09f77161d7", "metadata": {"aucs": [0.061905520424532456, 0.05524422916879679, 0.05922498247410657]}, "mutation_prompt": null}
{"id": "7525b564-00b0-4def-8cae-16e0a4fac981", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.45  # Decreased from 1.5 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Refine exploration by slightly increasing the differential weight to improve diversity in the search space.", "configspace": "", "generation": 18, "fitness": 0.05751746546267544, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "f4ab3c0a-860a-4f3e-948e-8517cdf851e3", "metadata": {"aucs": [0.05684417238315598, 0.05776620459513082, 0.05794201940973953]}, "mutation_prompt": null}
{"id": "e155a167-c3cd-4d68-b97d-81700454d29c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.46  # Increased from 1.45 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance exploration by slightly increasing the social coefficient for better exploration balance.", "configspace": "", "generation": 19, "fitness": 0.05878888861892306, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "f4ab3c0a-860a-4f3e-948e-8517cdf851e3", "metadata": {"aucs": [0.061905657288439775, 0.055236775916294834, 0.05922423265203458]}, "mutation_prompt": null}
{"id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improve exploration by slightly decreasing the social coefficient to enhance the search space diversity.", "configspace": "", "generation": 20, "fitness": 0.05879159366159566, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "f4ab3c0a-860a-4f3e-948e-8517cdf851e3", "metadata": {"aucs": [0.06189524108103117, 0.05525158359528559, 0.05922795630847022]}, "mutation_prompt": null}
{"id": "093d54c0-7c0e-4c3d-ad84-9b2ea986d6a1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.55  # Changed from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Further improve exploration by slightly increasing the differential weight to enhance diversity.", "configspace": "", "generation": 21, "fitness": 0.05751719719905801, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.056843921053524205, 0.05776563137834445, 0.05794203916530538]}, "mutation_prompt": null}
{"id": "fc162d67-c9bb-4369-a51b-8e1a6fe98abd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Increased from 1.62 to 1.63\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance convergence by slightly increasing the cognitive coefficient to encourage personal exploration.", "configspace": "", "generation": 22, "fitness": 0.05879053779442659, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.061884012242246045, 0.05525758463292407, 0.05923001650810966]}, "mutation_prompt": null}
{"id": "28464088-1d38-44de-bc2b-8b7c6a46301f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Adjusted from 20 to 21\n        self.crossover_rate = 0.68  \n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9 \n        self.cognitive_coefficient = 1.62 \n        self.social_coefficient = 1.44 \n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly adjust the population size to enhance diversity and exploration capabilities.", "configspace": "", "generation": 23, "fitness": 0.05846943876967566, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06073215213888239, 0.05717287341945809, 0.0575032907506865]}, "mutation_prompt": null}
{"id": "52595980-3c69-49e2-971f-f4cfebdc9d7e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Increased from 1.62 to 1.65\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance convergence by adjusting the cognitive coefficient for improved individual learning.", "configspace": "", "generation": 24, "fitness": 0.05872798520044531, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06210002367373302, 0.055269338468320384, 0.05881459345928253]}, "mutation_prompt": null}
{"id": "b124cb58-cf5f-445f-9cca-71706b2baecf", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Increased from 1.62 to 1.65\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly adjust the cognitive coefficient to enhance the search space exploration.", "configspace": "", "generation": 25, "fitness": 0.05872798520044531, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06210002367373302, 0.055269338468320384, 0.05881459345928253]}, "mutation_prompt": null}
{"id": "70cf28a4-aaa0-4212-ad7e-bef0269001b1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.43  # Decreased from 1.44 to 1.43\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly adjusted the social coefficient to improve exploration and convergence balance. ", "configspace": "", "generation": 26, "fitness": 0.058790678632351843, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06188283775004433, 0.05525883912662044, 0.059230359020390755]}, "mutation_prompt": null}
{"id": "dd9d7e99-67b3-4247-9295-452374f08797", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Increased from 1.62 to 1.63\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the cognitive coefficient to balance personal influence and social influence for better convergence.", "configspace": "", "generation": 27, "fitness": 0.05879053779442659, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.061884012242246045, 0.05525758463292407, 0.05923001650810966]}, "mutation_prompt": null}
{"id": "1acc97ce-3628-40f1-b231-842141208b08", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Increased from 1.62 to 1.65\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjust the cognitive coefficient to improve individual learning in dynamic environments.", "configspace": "", "generation": 28, "fitness": 0.05872798520044531, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06210002367373302, 0.055269338468320384, 0.05881459345928253]}, "mutation_prompt": null}
{"id": "a3c0fdf5-184f-404b-b53a-2a04fd9249fb", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.89  # Adjusted initial inertia weight from 0.9 to 0.89\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly decrease the inertia weight to improve convergence speed by reducing the impact of previous velocities.", "configspace": "", "generation": 29, "fitness": 0.05879127969442658, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.06189536880946134, 0.05525057219679275, 0.059227898077025665]}, "mutation_prompt": null}
{"id": "19130e7d-bf55-4aef-985e-7ffbb5deb4a6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.55  # Adjusted from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Increased from 1.6 to 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Refine the strategy by slightly adjusting the differential weight to improve convergence.", "configspace": "", "generation": 30, "fitness": 0.05751719719905801, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.056843921053524205, 0.05776563137834445, 0.05794203916530538]}, "mutation_prompt": null}
{"id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the cognitive coefficient to balance exploration and exploitation in the search process.", "configspace": "", "generation": 31, "fitness": 0.05879216140314477, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b0958747-e9ac-4ba4-b934-d6f5326206e0", "metadata": {"aucs": [0.061905689580846635, 0.05524549984384164, 0.05922529478474603]}, "mutation_prompt": null}
{"id": "72060a1f-f74c-408b-b624-fd82562ab947", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.46  # Changed from 1.44 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjust the social coefficient to enhance convergence speed while maintaining solution quality.", "configspace": "", "generation": 32, "fitness": 0.058786944040164345, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.061905960324544984, 0.05523051192744499, 0.05922435986850305]}, "mutation_prompt": null}
{"id": "4e8b8a65-2df7-4b31-98a5-3e7667ef8b6d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.69  # Increased from 0.68 to 0.69\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the crossover rate to improve exploration capabilities.", "configspace": "", "generation": 33, "fitness": 0.055639052314793234, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.057428701714377195, 0.0541822807722212, 0.0553061744577813]}, "mutation_prompt": null}
{"id": "868bb24c-ffd8-49f1-bcb9-36c2132497af", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.43  # Decreased from 1.44 to 1.43\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduce a small adjustment to the social coefficient to enhance global exploration.", "configspace": "", "generation": 34, "fitness": 0.058791721688668606, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.06189404569084955, 0.05525284555954968, 0.05922827381560658]}, "mutation_prompt": null}
{"id": "15e90cea-f694-4bc4-bd04-313a3633c09b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.60  # Decreased from 1.61 to 1.60\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the cognitive coefficient to balance exploration and exploitation in the search process.", "configspace": "", "generation": 35, "fitness": 0.058789798358040955, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.061905995532203884, 0.055239333404771274, 0.0592240661371477]}, "mutation_prompt": null}
{"id": "7e5d5483-2ed9-46e6-aed6-5ca0b305e5e8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance the exploration phase by slightly increasing the differential weight.", "configspace": "", "generation": 36, "fitness": 0.057517776830927736, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.05684579588695893, 0.05776552473173768, 0.0579420098740866]}, "mutation_prompt": null}
{"id": "b8d7a1f8-6dc3-4fe5-b31b-4223be202e9f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.69  # Increased from 0.68 to 0.69\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduce a slight increase in the crossover rate to enhance exploration during DE operations.", "configspace": "", "generation": 37, "fitness": 0.055639052314793234, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.057428701714377195, 0.0541822807722212, 0.0553061744577813]}, "mutation_prompt": null}
{"id": "2a4b2a02-43fd-4d5b-86fc-da78b16cd5b2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * (1 - evaluations / self.budget)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the inertia weight decay function for more effective exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.05880681005117102, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bab6d9a2-b9a3-45ae-90ae-f2884e1cc76a", "metadata": {"aucs": [0.061929920046053244, 0.055247497930534295, 0.059243012176925514]}, "mutation_prompt": null}
{"id": "13006aa2-9865-434e-a14b-1d9c2dc2486a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced a nonlinear dynamic inertia weight adjustment for enhanced convergence speed.", "configspace": "", "generation": 39, "fitness": 0.05882758050732798, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2a4b2a02-43fd-4d5b-86fc-da78b16cd5b2", "metadata": {"aucs": [0.061971715048585785, 0.055248946726903836, 0.059262079746494334]}, "mutation_prompt": null}
{"id": "d398081d-c1a9-48f9-af56-cd943c7897b1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n            self.crossover_rate = 0.5 + 0.18 * np.sin(evaluations / self.budget * np.pi)  # Adjusted crossover rate\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced a dynamic crossover rate adjustment for better exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.058260606892377886, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "13006aa2-9865-434e-a14b-1d9c2dc2486a", "metadata": {"aucs": [0.05766388158868585, 0.05624343401595755, 0.06087450507249026]}, "mutation_prompt": null}
{"id": "38bd8ff0-b780-4ab2-9227-7f7f8561afd8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            std_dev = np.std(population, axis=0)  # Calculate population diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                adaptive_weight = self.differential_weight * np.mean(std_dev)  # Adaptive mutation\n                mutant = a + adaptive_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Implemented adaptive mutation strategy based on population diversity to enhance exploration.", "configspace": "", "generation": 41, "fitness": 0.05086928097271792, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "13006aa2-9865-434e-a14b-1d9c2dc2486a", "metadata": {"aucs": [0.04773507412953015, 0.049550237586695745, 0.05532253120192787]}, "mutation_prompt": null}
{"id": "550822c8-b8f1-48dd-a5cd-b0ab78afa5e6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.7  # Adjusted from 0.68 to 0.7 for better exploration\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.61  # Decreased from 1.62 to 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improved convergence by fine-tuning the crossover rate in DE mutation step.", "configspace": "", "generation": 42, "fitness": 0.058477030405574094, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "13006aa2-9865-434e-a14b-1d9c2dc2486a", "metadata": {"aucs": [0.06200092833156301, 0.055285882998396874, 0.05814427988676241]}, "mutation_prompt": null}
{"id": "05815e1c-1d78-4659-9850-c11398037a88", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the cognitive coefficient for enhanced exploration.", "configspace": "", "generation": 43, "fitness": 0.05882791969602078, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "13006aa2-9865-434e-a14b-1d9c2dc2486a", "metadata": {"aucs": [0.061964261536528675, 0.05525504067000497, 0.059264456881528704]}, "mutation_prompt": null}
{"id": "c1dc0b1b-2edf-4cfb-8029-578006730ea3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.43  # Decreased from 1.44 to 1.43\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly decrease the social coefficient for more local search focus.", "configspace": "", "generation": 44, "fitness": 0.05882740196299374, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06195238691003224, 0.05526229250740777, 0.05926752647154121]}, "mutation_prompt": null}
{"id": "ce9cbe3b-f0dd-46ca-b1a4-d71c9e6a4c9e", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.69  # Increased from 0.68 to 0.69\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly adjust the crossover rate for more robust solutions.", "configspace": "", "generation": 45, "fitness": 0.05570901742927278, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.05744438738395696, 0.054179841835511056, 0.055502823068350304]}, "mutation_prompt": null}
{"id": "9b443ff9-4458-42ce-b0ec-119766c3726d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.45  # Increased from 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjust global best position influence by slightly increasing social coefficient to improve convergence.", "configspace": "", "generation": 46, "fitness": 0.05882691177795533, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06197157484590221, 0.055247690085145074, 0.059261470402818706]}, "mutation_prompt": null}
{"id": "fd9cfd6f-21a7-49cd-bd96-81ec75b74331", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.43  # Decreased from 1.44 to 1.43\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Further decrease the social coefficient for better convergence.", "configspace": "", "generation": 47, "fitness": 0.05882740196299374, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06195238691003224, 0.05526229250740777, 0.05926752647154121]}, "mutation_prompt": null}
{"id": "be88ca09-2599-4c2b-a343-816b4e2cba24", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.67  # Decreased from 0.68 to 0.67\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Further enhance exploration by slightly decreasing the crossover rate.", "configspace": "", "generation": 48, "fitness": 0.05743610937277366, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.061918968686663134, 0.056408591203222946, 0.053980768228434894]}, "mutation_prompt": null}
{"id": "b0ea5eeb-5a54-4322-b795-47693584b169", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n            self.crossover_rate = 0.68 + 0.12 * (1 - evaluations / self.budget)  # Dynamic crossover rate update\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduce a dynamic update to the crossover rate to balance exploration and exploitation effectively.", "configspace": "", "generation": 49, "fitness": 0.055946378395592654, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.05370413780606098, 0.05240037212597881, 0.06173462525473816]}, "mutation_prompt": null}
{"id": "b96a11db-68d2-4db6-9c8c-c585333d99e5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.45  # Increased from 1.44 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the social coefficient for improved exploitation.", "configspace": "", "generation": 50, "fitness": 0.05882691177795533, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06197157484590221, 0.055247690085145074, 0.059261470402818706]}, "mutation_prompt": null}
{"id": "d36b2c65-404b-4945-a9da-6fce11bb5236", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.46  # Increased from 1.44 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the social coefficient to enhance information sharing among particles.", "configspace": "", "generation": 51, "fitness": 0.05882347328793539, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.061971706284840056, 0.055240240821426756, 0.05925847275753937]}, "mutation_prompt": null}
{"id": "aaced57c-8555-48e4-a07f-5e06a5f5dea2", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.52  # Increased from 0.5 to 0.52\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increase the differential weight slightly to enhance exploration in DE mutation.", "configspace": "", "generation": 52, "fitness": 0.05635352913172705, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.0511998842469743, 0.057696109430522946, 0.0601645937176839]}, "mutation_prompt": null}
{"id": "b84a0844-2868-4459-ab60-110ce5943e6b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n            self.cognitive_coefficient = 1.62 + 0.2 * np.sin(evaluations / self.budget * np.pi / 2)  # Added dynamic adjustment\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduce a dynamic adjustment for the cognitive coefficient to balance exploration and exploitation.", "configspace": "", "generation": 53, "fitness": 0.05870426194002613, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06192911078294361, 0.0552546745392406, 0.05892900049789418]}, "mutation_prompt": null}
{"id": "c33f2c12-101d-4837-bc57-5d397097e3c1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Further increase the cognitive coefficient to 1.63 for enhanced personal exploration.", "configspace": "", "generation": 54, "fitness": 0.058827277602121066, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06195352969098, 0.05526105173627516, 0.059267251379108044]}, "mutation_prompt": null}
{"id": "b4e7667f-9d87-4b6a-ac31-e264a804055b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.46  # Increased from 1.44 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the social coefficient for improved collective behavior.", "configspace": "", "generation": 55, "fitness": 0.05882347328793539, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.061971706284840056, 0.055240240821426756, 0.05925847275753937]}, "mutation_prompt": null}
{"id": "a1b892d4-4eda-473d-9e28-aada7fa32478", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.48  # Slightly decreased from 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly decrease the differential weight for more controlled exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.05747365009447843, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06012809355451432, 0.0578331222176075, 0.05445973451131347]}, "mutation_prompt": null}
{"id": "2a627942-9eab-489b-9863-1be9fa333130", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.55  # Increased from 0.5 to 0.55\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhance exploration by increasing differential weight.", "configspace": "", "generation": 57, "fitness": 0.05753565405353552, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.05689213869795706, 0.05776535316446085, 0.05794947029818864]}, "mutation_prompt": null}
{"id": "2396abcc-dc60-407c-9acd-033db75f10d9", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.46  # Increased from 1.44 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the social coefficient for enhanced exploitation.", "configspace": "", "generation": 58, "fitness": 0.05882347328793539, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.061971706284840056, 0.055240240821426756, 0.05925847275753937]}, "mutation_prompt": null}
{"id": "f0a297c3-0aea-4974-94e2-882153b02d38", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.52  # Increased from 0.5 to 0.52\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjust the differential weight slightly to enhance exploration while maintaining stability.", "configspace": "", "generation": 59, "fitness": 0.05635352913172705, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.0511998842469743, 0.057696109430522946, 0.0601645937176839]}, "mutation_prompt": null}
{"id": "2b234fd1-1e28-477a-b438-59ac9f3bca61", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.85  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tune the initial inertia weight for improved convergence balance.", "configspace": "", "generation": 60, "fitness": 0.05882628656873053, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.061964893096594365, 0.05524998887978594, 0.05926397772981129]}, "mutation_prompt": null}
{"id": "7f598979-9310-435b-ad81-8e967082fc67", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced adaptive cognitive coefficient tuning for better exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.0589698558870407, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "05815e1c-1d78-4659-9850-c11398037a88", "metadata": {"aucs": [0.06189797076535397, 0.05570518123485668, 0.05930641566091144]}, "mutation_prompt": null}
{"id": "a1011add-5976-4f12-8312-e3504623b18f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Increased from 20 to 21\n        self.crossover_rate = 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.62\n        self.social_coefficient = 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increased population size slightly to enhance diversity and exploration.", "configspace": "", "generation": 62, "fitness": 0.05851341109615893, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.06077344900166526, 0.05710267295983007, 0.05766411132698146]}, "mutation_prompt": null}
{"id": "beba74b3-4be1-4c53-a23e-c264f2e732ab", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i] + np.random.uniform(-0.01, 0.01, self.dim)  # Added perturbation\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced global best position update by introducing a random perturbation aspect for improved exploration.", "configspace": "", "generation": 63, "fitness": 0.05857587590179832, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.05875384159592312, 0.0547177075073324, 0.06225607860213944]}, "mutation_prompt": null}
{"id": "2fbc18c1-1e24-44c0-bfa6-974dd2cc5262", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Improved Mutation\n                mutant = np.mean([a, b, c], axis=0) + np.random.normal(0, 1, self.dim) * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_social_coefficient = self.social_coefficient + 0.1 * (evaluations / self.budget)  # Dynamic change\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +\n                                 dynamic_social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced dynamic social coefficient adjustment and improved mutation strategy for better convergence.", "configspace": "", "generation": 64, "fitness": 0.05765734709666089, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.05331346908060808, 0.05883998773964516, 0.06081858446972943]}, "mutation_prompt": null}
{"id": "e13bfac9-4cd7-4915-8140-515eeba50cdc", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.crossover_rate = 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.62\n        self.social_coefficient = 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population_size = self.initial_population_size\n        population = np.random.uniform(lb, ub, (population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cog_coef = self.cognitive_coefficient * (1 - (evaluations/self.budget)**2)  # Non-linear decrease\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 cog_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight and adaptive population size\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n            population_size = self.initial_population_size + int((self.budget - evaluations) / self.budget * 5)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced global search by introducing a non-linear decreasing cognitive coefficient and adaptive population size for improved convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {}, "mutation_prompt": null}
{"id": "dbd9f5ea-4270-48ad-a19e-48e9408df8ec", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * (0.8 + 0.2 * evaluations/self.budget) * r2 * (global_best_position - population[i]))  # Adaptive social coefficient\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced adaptive social coefficient tuning for enhanced convergence dynamics.", "configspace": "", "generation": 66, "fitness": 0.058645357066977044, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.061302364408236776, 0.055339755949227465, 0.05929395084346689]}, "mutation_prompt": null}
{"id": "879532e3-2bc7-41f8-acae-0e9c9ae53514", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Changed from 1.62 to 1.63\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjusted cognitive coefficient slightly to improve exploration in early phases.", "configspace": "", "generation": 67, "fitness": 0.058969629594868254, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.06189722249371532, 0.05570485074668641, 0.05930681554420303]}, "mutation_prompt": null}
{"id": "e50dcb28-44c4-41cf-b14c-c595a4f810cf", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.5\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.5 + 0.4 * np.cos(evaluations / self.budget * np.pi / 2)  # Slight adjustment\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Optimized inertia weight dynamic adjustment for improved convergence performance.", "configspace": "", "generation": 68, "fitness": 0.05896348690550757, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.06188845134102683, 0.05570395701265152, 0.059298052362844356]}, "mutation_prompt": null}
{"id": "3e3e18ba-109d-4e7f-ade9-7f126185f404", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.45  # Reduced from 0.5 to 0.45\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Reduced the differential weight from 0.5 to 0.45 for better convergence control.", "configspace": "", "generation": 69, "fitness": 0.05901468433378809, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7f598979-9310-435b-ad81-8e967082fc67", "metadata": {"aucs": [0.06123543536442699, 0.05850540123303516, 0.057303216403902124]}, "mutation_prompt": null}
{"id": "1a8321ba-8fff-4668-9a02-4493a6bac817", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.45  # Reduced from 0.5 to 0.45\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Adjusted cognitive coefficient from 1.62 to 1.63 for slightly improved exploration.", "configspace": "", "generation": 70, "fitness": 0.05901304877995306, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3e3e18ba-109d-4e7f-ade9-7f126185f404", "metadata": {"aucs": [0.06123481617077986, 0.05850087349450217, 0.05730345667457715]}, "mutation_prompt": null}
{"id": "b315a414-d1c1-4d30-aaeb-5c9fdb66663a", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.68  # Decreased from 0.7 to 0.68\n        self.differential_weight = 0.45  # Reduced from 0.5 to 0.45\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the cognitive coefficient to improve exploration.", "configspace": "", "generation": 71, "fitness": 0.05901304877995306, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3e3e18ba-109d-4e7f-ade9-7f126185f404", "metadata": {"aucs": [0.06123481617077986, 0.05850087349450217, 0.05730345667457715]}, "mutation_prompt": null}
{"id": "a1f6419e-43eb-48d1-8d67-ad3fb4038c3b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.69  # Increased from 0.68 to 0.69\n        self.differential_weight = 0.45  # Reduced from 0.5 to 0.45\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the crossover rate from 0.68 to 0.69 to enhance exploration in the DE phase.", "configspace": "", "generation": 72, "fitness": 0.060377220753738636, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3e3e18ba-109d-4e7f-ade9-7f126185f404", "metadata": {"aucs": [0.06094655111613523, 0.05667944337992292, 0.06350566776515776]}, "mutation_prompt": null}
{"id": "47b8af1a-367f-452e-a5fc-59648f68d4c1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.69  # Increased from 0.68 to 0.69\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decreased the differential weight from 0.45 to 0.44 to improve convergence diversity.  ", "configspace": "", "generation": 73, "fitness": 0.060934643125054255, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "a1f6419e-43eb-48d1-8d67-ad3fb4038c3b", "metadata": {"aucs": [0.060033229375286545, 0.05895554362165223, 0.06381515637822399]}, "mutation_prompt": null}
{"id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the crossover rate from 0.69 to 0.70 to encourage more exploration.", "configspace": "", "generation": 74, "fitness": 0.06187083996089212, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "47b8af1a-367f-452e-a5fc-59648f68d4c1", "metadata": {"aucs": [0.06288928595622867, 0.05900773630245015, 0.06371549762399753]}, "mutation_prompt": null}
{"id": "7a80e3ad-3509-484e-b921-7218db598666", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.55 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Decrease the inertia weight's lower bound from 0.6 to 0.55 to increase the algorithm's ability to fine-tune solutions towards the budget’s end.", "configspace": "", "generation": 75, "fitness": 0.06186437581495885, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06286702092101526, 0.05900810883858487, 0.06371799768527642]}, "mutation_prompt": null}
{"id": "8636a847-0bbe-42aa-b299-cf48d07765df", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Initial crossover rate\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                self.crossover_rate = 0.7 + 0.2 * np.cos(evaluations / self.budget * np.pi)  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced dynamic crossover rate to balance exploration and exploitation based on the evaluation budget.", "configspace": "", "generation": 76, "fitness": 0.060270305870885, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06019699770902931, 0.06012823811539514, 0.06048568178823055]}, "mutation_prompt": null}
{"id": "99c2e57b-63c2-4165-b34a-70412d5c2c11", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Increased from 20 to 21\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the population size to encourage better diversity and exploration.", "configspace": "", "generation": 77, "fitness": 0.061248418888504186, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06396913166873763, 0.06014480674827116, 0.05963131824850376]}, "mutation_prompt": null}
{"id": "95ce2396-d754-48c4-a804-133b1ca1b908", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.85  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Change the initial inertia weight adjustment to enhance convergence speed.", "configspace": "", "generation": 78, "fitness": 0.06186710377212453, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06288823941328969, 0.059007140542065795, 0.0637059313610181]}, "mutation_prompt": null}
{"id": "3e69d0d2-3cf6-4e09-86eb-ee62c62e7600", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Decreased from 0.45 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment with randomness\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2) * (1 + 0.05 * np.random.rand())\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced randomness in inertia weight adjustment to enhance exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.059529841996045496, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06167587999551827, 0.05743896621996081, 0.05947467977265741]}, "mutation_prompt": null}
{"id": "763b068a-0b19-4cb4-aeae-c9b3bf6b73a6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.62  # Slightly increased from 1.61\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly decreased the differential weight from 0.44 to 0.43 to fine-tune mutation strength for better exploration-exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.06193296534550249, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "2bb1c4e9-244a-4c3b-8f48-29812a027ed0", "metadata": {"aucs": [0.06219464208468106, 0.060343742681918444, 0.06326051126990795]}, "mutation_prompt": null}
{"id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the cognitive coefficient from 1.62 to 1.63 to enhance individual learning and exploit potential better.", "configspace": "", "generation": 81, "fitness": 0.061936267200844886, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "763b068a-0b19-4cb4-aeae-c9b3bf6b73a6", "metadata": {"aucs": [0.06219441150015603, 0.060353890216229056, 0.06326049988614957]}, "mutation_prompt": null}
{"id": "9df26bc9-2e66-4535-8730-f295531402a3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.44  # Increased from 0.43 to 0.44\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improved global exploration by slightly increasing the differential weight for mutation.", "configspace": "", "generation": 82, "fitness": 0.06187043417452298, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06288814111669216, 0.059007757768806623, 0.06371540363807016]}, "mutation_prompt": null}
{"id": "08bc7362-8083-44ef-9ee4-811d69322ed8", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.45  # Increased from 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increase the social coefficient to enhance swarm intelligence and improve convergence speed.", "configspace": "", "generation": 83, "fitness": 0.061932622991452045, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06219495322191959, 0.060342633235994425, 0.06326028251644211]}, "mutation_prompt": null}
{"id": "ab9fcd49-24ed-4963-8aad-f5d5d50dddf5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.71  # Increased from 0.70 to 0.71\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the crossover rate from 0.70 to 0.71 to enhance exploration and diverse solutions.", "configspace": "", "generation": 84, "fitness": 0.059035815236685295, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.05745679495490563, 0.05350163070691527, 0.06614902004823497]}, "mutation_prompt": null}
{"id": "68480de6-e341-44af-93c1-ebd7f1b146af", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.45  # Increased from 1.44 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the social coefficient from 1.44 to 1.45 to enhance swarm interaction and collective exploration efficiency.", "configspace": "", "generation": 85, "fitness": 0.061932622991452045, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06219495322191959, 0.060342633235994425, 0.06326028251644211]}, "mutation_prompt": null}
{"id": "33b3c22c-7505-48c0-a62f-f963d2aafa7d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.45  # Slightly increased from 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Further refined the balance between exploration and exploitation by slightly adjusting the social coefficient for improved convergence.", "configspace": "", "generation": 86, "fitness": 0.061932622991452045, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06219495322191959, 0.060342633235994425, 0.06326028251644211]}, "mutation_prompt": null}
{"id": "371afa3d-c6fd-43da-99b0-f4631d6e470f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Increased from 20 to 21\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Increase the population size slightly from 20 to 21 to enhance exploration.", "configspace": "", "generation": 87, "fitness": 0.06074765360512128, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06417586499479966, 0.06050594532626574, 0.05756115049429844]}, "mutation_prompt": null}
{"id": "c83acef5-2134-42da-bf3d-84991479e40b", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c) + np.random.uniform(-0.1, 0.1, self.dim)  # Added random noise\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration by refining the mutation mechanism in DE to potentially increase solution diversity.", "configspace": "", "generation": 88, "fitness": 0.05807271559382502, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.05387706861672925, 0.05769133518171732, 0.0626497429830285]}, "mutation_prompt": null}
{"id": "5868fb31-9b6e-4e85-bf9f-4ce722813b48", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.42  # Decreased from 0.43 to 0.42\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.6 + 0.3 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Fine-tuned the differential weight from 0.43 to 0.42 to enhance the diversity and convergence balance.", "configspace": "", "generation": 89, "fitness": 0.06107842079536696, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06290090866368436, 0.05592145283158423, 0.06441290089083229]}, "mutation_prompt": null}
{"id": "14e6b468-b247-49f9-aa61-9ad668beb9f6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Slightly increased the inertia weight adjustment by modifying the dynamic calculation to enhance exploration during the early stages of the search. ", "configspace": "", "generation": 90, "fitness": 0.06195800120561631, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "58a0e4fd-1b27-4ca8-aa71-c8b36e5b21da", "metadata": {"aucs": [0.06221544121252165, 0.06038484059439442, 0.06327372180993285]}, "mutation_prompt": null}
{"id": "167f97bd-502e-4c4d-82b1-c316c84f18c6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.42  # Decreased from 0.43 to 0.42\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploration in early stages by reducing differential weight for broader search coverage.", "configspace": "", "generation": 91, "fitness": 0.06108225724253443, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "14e6b468-b247-49f9-aa61-9ad668beb9f6", "metadata": {"aucs": [0.0629049221981044, 0.0559246279442025, 0.06441722158529639]}, "mutation_prompt": null}
{"id": "f4543e5d-5ce5-4057-befc-c27f95a56cc4", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.63  # Slightly increased from 1.62\n        self.social_coefficient = 1.45  # Increased from 1.44 to 1.45\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced a slight increase in social coefficient to strengthen the global convergence mechanism.", "configspace": "", "generation": 92, "fitness": 0.06195457412309099, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "14e6b468-b247-49f9-aa61-9ad668beb9f6", "metadata": {"aucs": [0.062216011509100944, 0.060374215480909266, 0.06327349537926275]}, "mutation_prompt": null}
{"id": "130d9568-7424-47f4-a20c-1a1348d8446d", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Slightly increased from 1.63\n        self.social_coefficient = 1.44  # Decreased from 1.45 to 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improved convergence by adjusting the cognitive coefficient to enhance individual learning.", "configspace": "", "generation": 93, "fitness": 0.06196273024340604, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "14e6b468-b247-49f9-aa61-9ad668beb9f6", "metadata": {"aucs": [0.06221498342472953, 0.060399480312078535, 0.06327372699341005]}, "mutation_prompt": null}
{"id": "87586ac2-307b-4f04-838c-4b1df8950e94", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Slightly increased from 1.63\n        self.social_coefficient = 1.46  # Increased from 1.44 to 1.46\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Improved global exploration by slightly adjusting the social coefficient for better convergence.", "configspace": "", "generation": 94, "fitness": 0.06195739416629087, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "130d9568-7424-47f4-a20c-1a1348d8446d", "metadata": {"aucs": [0.062216125512507214, 0.06038278102991679, 0.0632732759564486]}, "mutation_prompt": null}
{"id": "ab7aa196-b07a-4b93-9260-9e18e3f405c6", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Increased from 20 to 21\n        self.crossover_rate = 0.70\n        self.differential_weight = 0.43\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.65\n        self.social_coefficient = 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced balance between exploration and exploitation by slightly increasing the population size.", "configspace": "", "generation": 95, "fitness": 0.0606910055722986, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "130d9568-7424-47f4-a20c-1a1348d8446d", "metadata": {"aucs": [0.0640240827273999, 0.06046971135813706, 0.05757922263135884]}, "mutation_prompt": null}
{"id": "80e73ec6-f01c-4caa-a114-a48888d26b0c", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 21  # Increased from 20 to 21 for better diversity\n        self.crossover_rate = 0.70\n        self.differential_weight = 0.43\n        self.inertia_weight = 0.9\n        self.cognitive_coefficient = 1.65\n        self.social_coefficient = 1.44\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced exploratory capability by adjusting the population size to improve diversity.", "configspace": "", "generation": 96, "fitness": 0.0606910055722986, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "130d9568-7424-47f4-a20c-1a1348d8446d", "metadata": {"aucs": [0.0640240827273999, 0.06046971135813706, 0.05757922263135884]}, "mutation_prompt": null}
{"id": "0713ce59-dc56-41b3-aa9f-6f871a0fb2dd", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Slightly increased from 1.63\n        self.social_coefficient = 1.40  # Decreased from 1.44 to 1.40\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Enhanced global search by decreasing the social coefficient to reduce premature convergence.", "configspace": "", "generation": 97, "fitness": 0.06196646982545014, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "130d9568-7424-47f4-a20c-1a1348d8446d", "metadata": {"aucs": [0.06221269398492191, 0.06041210364846339, 0.06327461184296512]}, "mutation_prompt": null}
{"id": "8332016e-3321-4b27-816f-353336eecbe5", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Slightly increased from 1.63\n        self.social_coefficient = 1.40  # Decreased from 1.44 to 1.40\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation with adaptive differential weight\n                self.differential_weight = 0.4 + 0.3 * np.sin(evaluations / self.budget * np.pi)  # Adaptive change\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduced adaptive differential weight in DE strategy to enhance exploration-exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.05822567430120329, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "0713ce59-dc56-41b3-aa9f-6f871a0fb2dd", "metadata": {"aucs": [0.06051239767702843, 0.05814839596749377, 0.05601622925908767]}, "mutation_prompt": null}
{"id": "dd40eed3-a8c3-498a-937f-ec1bbf308181", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # You can adjust this size\n        self.crossover_rate = 0.70  # Increased from 0.69 to 0.70\n        self.differential_weight = 0.43  # Decreased from 0.44 to 0.43\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.65  # Slightly increased from 1.63\n        self.social_coefficient = 1.40  # Decreased from 1.44 to 1.40\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_scores = np.full(self.population_size, np.inf)\n\n        global_best_position = None\n        global_best_score = np.inf\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate individual\n                current_score = func(population[i])\n                evaluations += 1\n\n                # Update personal best\n                if current_score < personal_best_scores[i]:\n                    personal_best_scores[i] = current_score\n                    personal_best_positions[i] = population[i]\n\n                # Update global best\n                if current_score < global_best_score:\n                    global_best_score = current_score\n                    global_best_position = population[i]\n\n            # DE mutation and crossover\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.differential_weight * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                adaptive_crossover_rate = self.crossover_rate * (1 - evaluations / self.budget)\n                trial = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant, population[i])\n\n                # Evaluate trial\n                trial_score = func(trial)\n                evaluations += 1\n\n                # Selection\n                if trial_score < current_score:\n                    population[i] = trial\n\n            # PSO update\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * (1 - evaluations/self.budget) * r1 * (personal_best_positions[i] - population[i]) +  # Adaptive change\n                                 self.social_coefficient * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -1, 1)\n\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.65 + 0.35 * np.cos(evaluations / self.budget * np.pi / 2)\n\n        return global_best_position, global_best_score", "name": "HybridDEPSO", "description": "Introduce adaptive crossover rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.057315170743860056, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "0713ce59-dc56-41b3-aa9f-6f871a0fb2dd", "metadata": {"aucs": [0.05666284169511526, 0.05599041280735584, 0.059292257729109066]}, "mutation_prompt": null}
