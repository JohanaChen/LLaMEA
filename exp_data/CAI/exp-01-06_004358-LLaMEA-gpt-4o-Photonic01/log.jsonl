{"id": "3775601f-056f-4633-9035-932ee5ec3e0f", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Hybrid Quantum-Inspired Particle Swarm Optimization with Adaptive Mutation for robust global optimization in photonic structures.", "configspace": "", "generation": 0, "fitness": 0.06966220530319256, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.06966220530319256, 0.06966220530319256, 0.06966220530319256]}, "mutation_prompt": null}
{"id": "a1fd023f-167d-4147-b2a3-0a763fdfce90", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_term + social_term)\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n                \n            # Dynamic inertia weight\n            self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced Quantum-Inspired PSO with dynamic inertia weight adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "5ef35701-1c5f-4858-a351-c83f42414697", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                self.inertia_weight = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Dynamic inertia weight\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhancement by adjusting the inertia weight dynamically based on the evaluation ratio to improve convergence speed.", "configspace": "", "generation": 2, "fitness": 0.06789746948795539, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06789746948795539, 0.06789746948795539, 0.06789746948795539]}, "mutation_prompt": null}
{"id": "c589339b-8b21-4732-8a64-4cf3f7acaa18", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            # Linearly decrease inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Added line for inertia weight\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with Linearly Decreasing Inertia Weight for improved convergence speed.", "configspace": "", "generation": 3, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "a65f6815-7224-457b-9986-07ad866de788", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Initial high inertia\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Dynamic inertia weight update\n            self.inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with dynamic inertia weight adjustment for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "ffa4def5-91d0-4b19-acbf-6bd34ab7af88", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_initial - (self.inertia_weight_initial - self.inertia_weight_final) * (evaluations / self.budget)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with Linearly Decreasing Inertia for improved convergence in photonic structure optimization.", "configspace": "", "generation": 5, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "0542925a-9082-428f-b407-2c275bd14451", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Dynamic adjustment of inertia weight\n            self.inertia_weight = 0.9 - (0.9 - 0.4) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introducing dynamic inertia weight adjustment in QuantumAdaptivePSO to enhance convergence speed and solution quality.", "configspace": "", "generation": 6, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "5e5505e7-bea0-4a95-873f-f8d82d1d6cd3", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # Dynamic inertia weight\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by adjusting the inertia weight dynamically based on evaluation progress for enhanced exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.06794104751028418, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06794104751028418, 0.06794104751028418, 0.06794104751028418]}, "mutation_prompt": null}
{"id": "ad12780a-b879-408c-a39f-116a4deba35f", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Adjusted for better exploration-exploitation balance\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced Quantum-Inspired PSO with Adaptive Inertia for improved exploration-exploitation balance in photonic structure optimization.", "configspace": "", "generation": 8, "fitness": 0.06415780049320063, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06415780049320063, 0.06415780049320063, 0.06415780049320063]}, "mutation_prompt": null}
{"id": "2ece0d61-f890-4875-ab69-710792968c69", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.2, 0.2, self.dim)  # Changed mutation range\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Added inertia weight decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced cognitive diversity by modifying the mutation range and inertia weight decay for improved global exploration.", "configspace": "", "generation": 9, "fitness": 0.0696388719513148, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.0696388719513148, 0.0696388719513148, 0.0696388719513148]}, "mutation_prompt": null}
{"id": "5b59902f-7d29-4feb-a248-f4155870ce10", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight_initial = 0.9  # Changed from 0.5 to enable dynamic inertia\n        self.inertia_weight_final = 0.4\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            inertia_weight = self.inertia_weight_initial - (evaluations / self.budget) * (self.inertia_weight_initial - self.inertia_weight_final)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with dynamic inertia weight for improved convergence in photonic structure optimization.", "configspace": "", "generation": 10, "fitness": 0.06794104751028418, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06794104751028418, 0.06794104751028418, 0.06794104751028418]}, "mutation_prompt": null}
{"id": "f3c93043-40b8-4303-86a2-2a0f1cf9e673", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line: Increased initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Changed line: Dynamic inertia weight adjustment\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with dynamic inertia weight adjustment for improved convergence in photonic structure optimization.", "configspace": "", "generation": 11, "fitness": 0.06777489079676402, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06777489079676402, 0.06777489079676402, 0.06777489079676402]}, "mutation_prompt": null}
{"id": "af222731-a8c3-450c-83a5-bf018eac13f0", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with Dynamic Inertia Weight for improved exploration-exploitation balance in photonic structure optimization.", "configspace": "", "generation": 12, "fitness": 0.06860714624589703, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.06860714624589703, 0.06860714624589703, 0.06860714624589703]}, "mutation_prompt": null}
{"id": "be9bb7c7-e023-4876-a7bb-eeb7f93c4d7f", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n        success_count = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n                    success_count += 1\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Dynamic inertia weight adjustment\n            if success_count > 0:\n                self.inertia_weight = 0.5 + 0.5 * (success_count / self.population_size)\n            else:\n                self.inertia_weight = 0.5\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance convergence by dynamically adjusting inertia weight based on success rate.", "configspace": "", "generation": 13, "fitness": 0.056911038498472566, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.056911038498472566, 0.056911038498472566, 0.056911038498472566]}, "mutation_prompt": null}
{"id": "96635549-d446-431a-9e1c-904c39640c93", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  # Modified line\n        self.social_coefficient = 1.3     # Modified line\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced Cognitive-Social Balancing in Quantum-Inspired PSO for improved convergence.", "configspace": "", "generation": 14, "fitness": 0.07050244819005302, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "3775601f-056f-4633-9035-932ee5ec3e0f", "metadata": {"aucs": [0.07050244819005302, 0.07050244819005302, 0.07050244819005302]}, "mutation_prompt": null}
{"id": "738eeec9-7f17-433c-903f-42710ed1c366", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Adjusted inertia weight dynamically\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce dynamic adjustment of inertia weight and an adaptive social coefficient for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.06923948247594047, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06923948247594047, 0.06923948247594047, 0.06923948247594047]}, "mutation_prompt": null}
{"id": "c1aa259c-ccc1-4f52-9900-639ee71e735b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Changed line: increased initial inertia weight\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = (self.inertia_weight - 0.2 * (evaluations / self.budget)) * velocities[i] + cognitive_term + social_term  # Changed line: dynamic inertia weight adjustment\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "QuantumAdaptivePSO with dynamic inertia for enhanced exploration and convergence control.", "configspace": "", "generation": 16, "fitness": 0.07024276368938542, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.07024276368938542, 0.07024276368938542, 0.07024276368938542]}, "mutation_prompt": null}
{"id": "75eb037d-b2da-4130-a466-49687c2a7c28", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                self.inertia_weight = 0.9 - 0.7 * (evaluations / self.budget)  # Dynamic inertia weight\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce a dynamic inertia weight strategy in QuantumAdaptivePSO for balanced exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.0688608264590107, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.0688608264590107, 0.0688608264590107, 0.0688608264590107]}, "mutation_prompt": null}
{"id": "82f97440-9349-4398-ac3c-77aaaeccbde0", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line for dynamic update\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line for inertia weight adjustment\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved velocity update using a time-varying inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.06923948247594047, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06923948247594047, 0.06923948247594047, 0.06923948247594047]}, "mutation_prompt": null}
{"id": "ac63399f-a4a7-4a8d-b1ab-2bbe46da752b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = (self.inertia_weight * (1 - evaluations / self.budget) + 0.4) * velocities[i] + cognitive_term + social_term  # Modified line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce a time-varying inertia weight to improve exploration and exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.06612806482283473, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06612806482283473, 0.06612806482283473, 0.06612806482283473]}, "mutation_prompt": null}
{"id": "6c762e0e-3215-42ee-8d27-9b86b5f45e44", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Changed line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced a dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.06916879151509914, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06916879151509914, 0.06916879151509914, 0.06916879151509914]}, "mutation_prompt": null}
{"id": "4692148c-9309-44ad-b423-eb1f2922dd9e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Dynamic inertia weight\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia weight adjustment for enhanced convergence in Quantum-Inspired PSO.", "configspace": "", "generation": 21, "fitness": 0.06916879151509914, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06916879151509914, 0.06916879151509914, 0.06916879151509914]}, "mutation_prompt": null}
{"id": "efceadfd-377f-46d6-bde4-2f0f74242262", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                self.inertia_weight = 0.9 - (0.8 * (evaluations / self.budget))  # Dynamic inertia weight adjustment\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced a dynamic inertia weight adjustment based on budget consumption to balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.06885191452531825, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.06885191452531825, 0.06885191452531825, 0.06885191452531825]}, "mutation_prompt": null}
{"id": "ec951fad-1cd8-4adc-aafb-352ec1f391e3", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  # Modified line\n        self.social_coefficient = 1.3     # Modified line\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced velocity decay for dynamic inertia weight adjustment to enhance convergence control.", "configspace": "", "generation": 23, "fitness": 0.07054022118724101, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96635549-d446-431a-9e1c-904c39640c93", "metadata": {"aucs": [0.07054022118724101, 0.07054022118724101, 0.07054022118724101]}, "mutation_prompt": null}
{"id": "557f6dcd-6a39-46de-88bc-2efdb51af860", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Adjusted line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98  # Adjusted line with a slightly faster decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced velocity update with a non-linear inertia weight decay for better exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.07016863824199215, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec951fad-1cd8-4adc-aafb-352ec1f391e3", "metadata": {"aucs": [0.07016863824199215, 0.07016863824199215, 0.07016863824199215]}, "mutation_prompt": null}
{"id": "5c033423-3635-4858-b379-bc2b35ceb112", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.5  # Modified line\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98 - 0.01 * (evaluations / self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced nonlinear inertia weight decay and adaptive cognitive coefficient for more effective exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.07042397665858235, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec951fad-1cd8-4adc-aafb-352ec1f391e3", "metadata": {"aucs": [0.07042397665858235, 0.07042397665858235, 0.07042397665858235]}, "mutation_prompt": null}
{"id": "41639a93-75a2-4537-965c-0a9ed4f8731b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  # Modified line\n        self.social_coefficient = 1.3     # Modified line\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  # Change line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  # Change line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced local search boost through directional mutation for improved local exploration.", "configspace": "", "generation": 26, "fitness": 0.07059627130113921, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ec951fad-1cd8-4adc-aafb-352ec1f391e3", "metadata": {"aucs": [0.07059627130113921, 0.07059627130113921, 0.07059627130113921]}, "mutation_prompt": null}
{"id": "db2c15f7-b41f-460c-b965-a5b1cff4b250", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Changed line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced exploration through adaptive inertia weight and mutation scaling adjustment for improved global search capability.", "configspace": "", "generation": 27, "fitness": 0.07029633820138259, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "41639a93-75a2-4537-965c-0a9ed4f8731b", "metadata": {"aucs": [0.07029633820138259, 0.07029633820138259, 0.07029633820138259]}, "mutation_prompt": null}
{"id": "e65232de-c195-4aef-90cb-25838c72ddbb", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced global exploration by adjusting social coefficient based on iteration progress.", "configspace": "", "generation": 28, "fitness": 0.07079781986734857, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "41639a93-75a2-4537-965c-0a9ed4f8731b", "metadata": {"aucs": [0.07079781986734857, 0.07079781986734857, 0.07079781986734857]}, "mutation_prompt": null}
{"id": "bf1ec500-701a-44ed-90c8-d1c5b24f5843", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.cognitive_coefficient = 1.7 + 0.3 * (1 - evaluations / self.budget)  # Modified line\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved global exploration by dynamically adjusting social coefficient and cognitive coefficient based on iteration progress.", "configspace": "", "generation": 29, "fitness": 0.07067876085203373, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "e65232de-c195-4aef-90cb-25838c72ddbb", "metadata": {"aucs": [0.07067876085203373, 0.07067876085203373, 0.07067876085203373]}, "mutation_prompt": null}
{"id": "5953239e-f8b0-4007-a586-eec2b25c7fc2", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line 1: Adjusted initial inertia weight\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98  # Changed line 2: Adjusted velocity decay rate\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced swarm diversity by introducing an adaptive inertia weight based on the evaluation progress.", "configspace": "", "generation": 30, "fitness": 0.06842483125748744, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "e65232de-c195-4aef-90cb-25838c72ddbb", "metadata": {"aucs": [0.06842483125748744, 0.06842483125748744, 0.06842483125748744]}, "mutation_prompt": null}
{"id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced social-cognitive balance by dynamically adjusting coefficients based on evaluation ratio.", "configspace": "", "generation": 31, "fitness": 0.07086647539468172, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "e65232de-c195-4aef-90cb-25838c72ddbb", "metadata": {"aucs": [0.07086647539468172, 0.07086647539468172, 0.07086647539468172]}, "mutation_prompt": null}
{"id": "6e2e52cd-84a5-4060-a4d4-2b02f48955b6", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.5 - 0.2 * (evaluations / self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia weight adaptation for better exploration-exploitation trade-off.", "configspace": "", "generation": 32, "fitness": 0.07086178477384464, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07086178477384464, 0.07086178477384464, 0.07086178477384464]}, "mutation_prompt": null}
{"id": "96f07fca-e694-4857-a530-93dc43a25b06", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.7 * (evaluations / self.budget)  # Modified line (increased influence)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98  # Modified line (adjusted decay rate)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Incrementally adapt social influence and inertia decay for enhanced exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.07053819637420511, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07053819637420511, 0.07053819637420511, 0.07053819637420511]}, "mutation_prompt": null}
{"id": "8b6d7a5d-0ec1-4fb9-9579-f3627168ce27", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.6 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.2 * direction * np.random.uniform(0, 1, self.dim)  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introducing learning factor decay and improved particle mutation to balance exploration and exploitation over the budget.", "configspace": "", "generation": 34, "fitness": 0.07085985064880196, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07085985064880196, 0.07085985064880196, 0.07085985064880196]}, "mutation_prompt": null}
{"id": "742cf904-a73c-42a0-bc9a-5d2c29a1d866", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  \n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  \n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)  # Added velocity clamping\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by introducing velocity clamping for stability under high learning rates.", "configspace": "", "generation": 35, "fitness": 0.049993949133484206, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.049993949133484206, 0.049993949133484206, 0.049993949133484206]}, "mutation_prompt": null}
{"id": "78db0c91-332d-4f8f-a40e-a399cdaca559", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.5 * (1 - evaluations / self.budget) + 0.2  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia weight adjustment based on evaluation ratio to balance exploration and exploitation.", "configspace": "", "generation": 36, "fitness": 0.07013896802546771, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07013896802546771, 0.07013896802546771, 0.07013896802546771]}, "mutation_prompt": null}
{"id": "70c88a06-2fc1-49d0-a5a0-b4783c2273ad", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * (1 - evaluations/self.budget) * direction * np.random.uniform(0, 1, self.dim)  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.985  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance exploration by modifying velocity decay and introducing a nonlinear mutation scaling with budget usage.", "configspace": "", "generation": 37, "fitness": 0.07081978521602883, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07081978521602883, 0.07081978521602883, 0.07081978521602883]}, "mutation_prompt": null}
{"id": "fe3810ca-202a-4016-8d6e-c859b7868892", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * (1 - evaluations / self.budget)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99 + 0.01 * (1 - evaluations / self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced exploration by introducing nonlinear inertia weight decay and dynamic mutation scaling.", "configspace": "", "generation": 38, "fitness": 0.07084180718463795, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07084180718463795, 0.07084180718463795, 0.07084180718463795]}, "mutation_prompt": null}
{"id": "bfe206d3-79e5-4c1b-bd5d-79ad11e00afc", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  \n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  \n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Enhanced adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (evaluations / self.budget - 0.5)))  # Modified line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(-0.5, 0.5, self.dim)  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "QuantumAdaptivePSO with enhanced adaptive mutation based on dynamic exploration-exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.07063523503950497, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07063523503950497, 0.07063523503950497, 0.07063523503950497]}, "mutation_prompt": null}
{"id": "6a1d7769-216c-4b7b-9da0-0b7d92616162", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.985  # Updated velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved exploitation-exploration balance by adjusting inertia weight decay rate.", "configspace": "", "generation": 40, "fitness": 0.07082153427448568, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07082153427448568, 0.07082153427448568, 0.07082153427448568]}, "mutation_prompt": null}
{"id": "ecbe87ba-02fa-4805-bc05-ce0b482e28a7", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.9 - 0.8 * (evaluations / self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced adaptive inertia weight strategy based on evaluation ratio to enhance exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.0688577013628986, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.0688577013628986, 0.0688577013628986, 0.0688577013628986]}, "mutation_prompt": null}
{"id": "bbcf6f64-4fc4-4828-9c73-bd536241a839", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                random_jump = np.random.uniform(-0.1, 0.1, self.dim) if np.random.rand() < 0.05 else 0  # Added line\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term + random_jump  # Modified line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance exploration by incorporating a random jump mechanism in the velocity update phase.", "configspace": "", "generation": 42, "fitness": 0.06879059520578534, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.06879059520578534, 0.06879059520578534, 0.06879059520578534]}, "mutation_prompt": null}
{"id": "0787753b-1495-4490-a6e0-0fe25cbe4658", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)\n                self.social_coefficient = 1.3 + 0.5 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5))) * (1.0 - (self.global_best_value / np.max(personal_best_values)))  # Modified line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance mutation by adjusting mutation probability based on fitness improvement rate.", "configspace": "", "generation": 43, "fitness": 0.07063039292949058, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07063039292949058, 0.07063039292949058, 0.07063039292949058]}, "mutation_prompt": null}
{"id": "7a94f220-5bc0-4024-8e62-89ae38360641", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced convergence by making social coefficient adjustment more aggressive based on evaluations.", "configspace": "", "generation": 44, "fitness": 0.07086733523829247, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "ded7fbaa-c48f-48dd-af5b-b81d070dddad", "metadata": {"aucs": [0.07086733523829247, 0.07086733523829247, 0.07086733523829247]}, "mutation_prompt": null}
{"id": "87164ae7-ed7f-40f2-986c-086a16be52b2", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Modified line\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced convergence by including dynamic inertia weight adjustment based on evaluations.", "configspace": "", "generation": 45, "fitness": 0.06909990301039881, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.06909990301039881, 0.06909990301039881, 0.06909990301039881]}, "mutation_prompt": null}
{"id": "c20cabe4-5660-4315-885b-5380dfb7b2cf", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            improvement_ratio = (self.global_best_value - fitness) / abs(fitness) if fitness != 0 else 0\n            self.inertia_weight *= 1.0 + 0.01 * improvement_ratio  # Updated for dynamic adjustment\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by introducing a dynamic inertia weight increasing based on fitness improvement ratio.", "configspace": "", "generation": 46, "fitness": 0.070758460022324, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.070758460022324, 0.070758460022324, 0.070758460022324]}, "mutation_prompt": null}
{"id": "20ddad55-e9e0-4ff5-850d-b2758a2d8d8b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.9 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved exploration by incorporating adaptive inertia weight behavior based on function evaluations.", "configspace": "", "generation": 47, "fitness": 0.06822041830714431, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.06822041830714431, 0.06822041830714431, 0.06822041830714431]}, "mutation_prompt": null}
{"id": "38da9c7e-fd8d-497d-883f-cec8b84bcc3d", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.4 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n            if evaluations % (self.budget // 10) == 0:  # New line\n                velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))  # New line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced convergence by dynamically adjusting inertia weight based on evaluations and introducing a position reset mechanism to escape local optima.", "configspace": "", "generation": 48, "fitness": 0.07077928415769275, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.07077928415769275, 0.07077928415769275, 0.07077928415769275]}, "mutation_prompt": null}
{"id": "7932fd08-187c-4cd3-9830-f5a233e8afea", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce dynamic inertia weight and turbulence factor to enhance exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.06923238756826933, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.06923238756826933, 0.06923238756826933, 0.06923238756826933]}, "mutation_prompt": null}
{"id": "88281db6-625e-45b6-a9a2-a48fe039ee8e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (evaluations / self.budget - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)  # Adjusted velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia weight adjustment based on evaluations to better balance exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.06922635172750835, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.06922635172750835, 0.06922635172750835, 0.06922635172750835]}, "mutation_prompt": null}
{"id": "bc2d61f7-cc03-455e-b06b-544822b65c18", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  # Introduced velocity decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced exploration by increasing mutation probability based on velocity magnitude.", "configspace": "", "generation": 51, "fitness": 0.07086817547248248, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "7a94f220-5bc0-4024-8e62-89ae38360641", "metadata": {"aucs": [0.07086817547248248, 0.07086817547248248, 0.07086817547248248]}, "mutation_prompt": null}
{"id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance convergence by applying non-linear decay to inertia weight, improving exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.07086898278364151, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bc2d61f7-cc03-455e-b06b-544822b65c18", "metadata": {"aucs": [0.07086898278364151, 0.07086898278364151, 0.07086898278364151]}, "mutation_prompt": null}
{"id": "e8437259-19ba-47f5-a06f-6df1176bb31d", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n            if evaluations % (self.budget // 10) == 0:  # New line  (Change 1 line)\n                self.inertia_weight = max(0.4, self.inertia_weight)  # New line  (Change 1 line)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce an adaptive inertia weight reset to improve exploration balance.", "configspace": "", "generation": 53, "fitness": 0.07086894541899635, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07086894541899635, 0.07086894541899635, 0.07086894541899635]}, "mutation_prompt": null}
{"id": "500c7e71-6b52-41eb-9b32-f7965415835d", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            # Introduce change: Adjust inertia decay rate based on progress\n            progress_factor = 1 - evaluations / self.budget\n            self.inertia_weight *= (0.99 * progress_factor)**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce dynamic adjustment to the inertia weight decay rate based on convergence speed for improved balance.", "configspace": "", "generation": 54, "fitness": 0.07009538861151421, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07009538861151421, 0.07009538861151421, 0.07009538861151421]}, "mutation_prompt": null}
{"id": "c7e106bf-c607-466d-926e-7c423dcede8d", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n        prev_global_best_value = self.global_best_value\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    prev_global_best_value = self.global_best_value  # New line\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                improvement_rate = (prev_global_best_value - self.global_best_value) / abs(prev_global_best_value + 1e-10)  # New line\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget) + 0.1 * improvement_rate  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget) - 0.1 * improvement_rate  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce dynamic adaption for velocity and cognitive-social factors based on fitness improvement rate.", "configspace": "", "generation": 55, "fitness": 0.07086523961513802, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07086523961513802, 0.07086523961513802, 0.07086523961513802]}, "mutation_prompt": null}
{"id": "d66d2af2-1931-4230-9a0b-a2682d2447a0", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n        last_global_best_value = self.global_best_value\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            improvement_rate = (last_global_best_value - self.global_best_value) / (abs(last_global_best_value) + 1e-9)\n            mutation_prob = 1.0 - np.tanh(improvement_rate)  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob:\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n            last_global_best_value = self.global_best_value\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce a dynamic mutation rate influenced by the fitness improvement rate to enhance exploration.", "configspace": "", "generation": 56, "fitness": 0.07035897781022371, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07035897781022371, 0.07035897781022371, 0.07035897781022371]}, "mutation_prompt": null}
{"id": "f273e7df-d4a7-4595-94dc-5ce50ea32920", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n\n            if evaluations % 10 == 0:  # Dynamic adjustment introduced\n                fitness_variance = np.var(personal_best_values)\n                self.population_size = int(np.clip(10 + fitness_variance * 50, 5, 40))  # Change the line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce dynamic population size adjustment based on fitness variance to enhance adaptability.", "configspace": "", "generation": 57, "fitness": 0.070839511970064, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.070839511970064, 0.070839511970064, 0.070839511970064]}, "mutation_prompt": null}
{"id": "5086ff89-96bf-47a4-bfac-f1c174d38b3e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n        last_global_best_value = self.global_best_value\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n            if self.global_best_value < last_global_best_value:\n                self.inertia_weight *= 1.01  # Slight increase when improvement is made\n                last_global_best_value = self.global_best_value\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce a dynamic inertia weight that increases slightly when the best global fitness improves, enhancing exploration when stuck in local optima.", "configspace": "", "generation": 58, "fitness": 0.07078414622633489, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07078414622633489, 0.07078414622633489, 0.07078414622633489]}, "mutation_prompt": null}
{"id": "807dba70-2856-46aa-a58f-096f6933ab44", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, np.abs(direction), self.dim)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance adaptive mutation by introducing diversity in mutation magnitude based on velocity direction to improve exploration. ", "configspace": "", "generation": 59, "fitness": 0.07086898278364151, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07086898278364151, 0.07086898278364151, 0.07086898278364151]}, "mutation_prompt": null}
{"id": "5c064d79-0ebf-44f3-b81b-bae2e93e1960", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.4 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.15 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(personal_best_positions[i] - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Introduced non-linear decay\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Adjust adaptive mutation probability threshold to improve exploration phases.", "configspace": "", "generation": 60, "fitness": 0.07086945450963833, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "36d4ebea-8903-41a9-9e77-3da7281d95f5", "metadata": {"aucs": [0.07086945450963833, 0.07086945450963833, 0.07086945450963833]}, "mutation_prompt": null}
{"id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by refining adaptation thresholds and improving directional mutation for more robust exploration and convergence.", "configspace": "", "generation": 61, "fitness": 0.07139365003809073, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "5c064d79-0ebf-44f3-b81b-bae2e93e1960", "metadata": {"aucs": [0.07139365003809073, 0.07139365003809073, 0.07139365003809073]}, "mutation_prompt": null}
{"id": "2eaad9c0-35ca-43a8-8904-ce6fc8b2fa8c", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = (0.9 - evaluations / (2 * self.budget)) * velocities[i] + cognitive_term + social_term  # Changed line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by enhancing velocity update with dynamic inertia weight adjustment for better convergence.", "configspace": "", "generation": 62, "fitness": 0.06971289084118892, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.06971289084118892, 0.06971289084118892, 0.06971289084118892]}, "mutation_prompt": null}
{"id": "45aa5ee0-98b6-417d-b908-cb679114c519", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + 0.5 * cognitive_term + 1.5 * social_term  # Changed line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 0.5 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.random.standard_normal(self.dim)  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Refine QuantumAdaptivePSO by adjusting velocity updates and enhancing adaptive mutation to improve exploration and convergence.", "configspace": "", "generation": 63, "fitness": 0.06849767043324884, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.06849767043324884, 0.06849767043324884, 0.06849767043324884]}, "mutation_prompt": null}
{"id": "1b95315b-dbba-4963-a6e9-fdd311439fd1", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line\n        self.cognitive_coefficient = 1.5  # Modified line\n        self.social_coefficient = 1.5  # Modified line\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.1 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Modified line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    mutation_vector = 0.05 * np.random.normal(size=self.dim)  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with adaptive inertia weight and stochastic control parameters for dynamic exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.06608288357623826, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.06608288357623826, 0.06608288357623826, 0.06608288357623826]}, "mutation_prompt": null}
{"id": "bbb992bd-923d-4307-9696-0d729226a01b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Adjusted the inertia weight control strategy to enhance balance between exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.0691654402102383, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.0691654402102383, 0.0691654402102383, 0.0691654402102383]}, "mutation_prompt": null}
{"id": "4c493579-714f-4c17-9e68-6c62e83fd2c5", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Changed line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.8 - 0.4 * (evaluations / self.budget)  # Changed line\n                self.social_coefficient = 1.2 + 0.7 * (evaluations / self.budget)  # Changed line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.25 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  \n                    direction = np.sign(self.global_best_position - particles[i])  \n                    mutation_vector = 0.2 * direction * np.random.uniform(0, 1, self.dim)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Refined QuantumAdaptivePSO with dynamic inertia weight adjustment and enhanced mutation for improved exploration and convergence.", "configspace": "", "generation": 66, "fitness": 0.07004973473445164, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07004973473445164, 0.07004973473445164, 0.07004973473445164]}, "mutation_prompt": null}
{"id": "a987fd8e-9215-4686-97d4-68f914987a18", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + 1.1 * social_term  # Changed line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Slightly enhance the convergence by increasing the impact of the best global position in velocity update.", "configspace": "", "generation": 67, "fitness": 0.07104889921745516, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07104889921745516, 0.07104889921745516, 0.07104889921745516]}, "mutation_prompt": null}
{"id": "e2749176-cb34-442d-971b-ccd2b5724b2e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation with leadership direction\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  \n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic inertia update\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by implementing dynamic inertia adaptation and integrating a leadership-driven mutation strategy to boost diversity and convergence.", "configspace": "", "generation": 68, "fitness": 0.0691654402102383, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.0691654402102383, 0.0691654402102383, 0.0691654402102383]}, "mutation_prompt": null}
{"id": "fe4b46e9-3237-4627-aa52-338a31839c90", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.uniform(0.3, 1.0, self.dim), np.random.rand(self.dim)  # Changed line\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved convergence by introducing a dynamic inertia weight reduction and a stochastic cognitive component.", "configspace": "", "generation": 69, "fitness": 0.07093228216366465, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07093228216366465, 0.07093228216366465, 0.07093228216366465]}, "mutation_prompt": null}
{"id": "91e104d5-28ca-4f2f-a331-03891244bb10", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight_initial = 0.9  # Changed line\n        self.inertia_weight_final = 0.4  # Changed line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Update inertia weight\n            self.inertia_weight = (self.inertia_weight_initial - self.inertia_weight_final) * \\\n                                  ((self.budget - evaluations) / self.budget) + self.inertia_weight_final\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduce a time-varying inertia weight strategy to balance exploration and exploitation dynamically.", "configspace": "", "generation": 70, "fitness": 0.06974549895569582, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.06974549895569582, 0.06974549895569582, 0.06974549895569582]}, "mutation_prompt": null}
{"id": "181c38aa-a61f-4ca7-92f8-9a0567a80f4c", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  \n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  \n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                velocities[i] *= 0.9  # Modified line for velocity scaling\n                particles[i] += velocities[i]\n                # Ensure particles are within adjusted bounds\n                adjusted_lb = lb - 0.1 * (ub - lb)  # Modified line for dynamic boundary adjustment\n                adjusted_ub = ub + 0.1 * (ub - lb)  # Modified line for dynamic boundary adjustment\n                particles[i] = np.clip(particles[i], adjusted_lb, adjusted_ub)  # Modified line\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]: \n                    direction = np.sign(self.global_best_position - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhance convergence by introducing dynamic boundary adjustments and modified velocity scaling.", "configspace": "", "generation": 71, "fitness": 0.07139167570495752, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07139167570495752, 0.07139167570495752, 0.07139167570495752]}, "mutation_prompt": null}
{"id": "7de43dc1-9a41-4a50-b7b6-3bb07211748d", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Modified line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                max_velocity = 0.1 * (ub - lb)  # Added line\n                velocities[i] = np.clip(velocities[i], -max_velocity, max_velocity)  # Added line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with dynamic velocity clamping and improved inertia weight adaptation for better convergence.", "configspace": "", "generation": 72, "fitness": 0.071106790079278, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.071106790079278, 0.071106790079278, 0.071106790079278]}, "mutation_prompt": null}
{"id": "4db4f67e-1cdc-43d4-a737-95a386c92a19", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.5 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO with dynamic inertia weight adjustment and reinforced mutation probability for enhanced convergence.", "configspace": "", "generation": 73, "fitness": 0.07002020138608578, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07002020138608578, 0.07002020138608578, 0.07002020138608578]}, "mutation_prompt": null}
{"id": "d251a5a0-06ee-4f0d-a03d-41d17e31a5d5", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.05 * direction * np.random.uniform(0, 1, self.dim)  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.995**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by optimizing inertia weight dynamics and mutation magnitude scaling for improved convergence and stability.", "configspace": "", "generation": 74, "fitness": 0.07136888634701677, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07136888634701677, 0.07136888634701677, 0.07136888634701677]}, "mutation_prompt": null}
{"id": "9c697d13-3429-42d4-9816-281f16c1f36e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Changed line\n        self.cognitive_coefficient = 1.7\n        self.social_coefficient = 1.3\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                # Introduce stochastic component for diversified exploration\n                stochastic_component = np.random.uniform(-0.05, 0.05, self.dim)  # New line\n                particles[i] += velocities[i] + stochastic_component  # Changed line\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia adjustment and stochastic component for enhanced exploration and exploitation balance in QuantumAdaptivePSO.", "configspace": "", "generation": 75, "fitness": 0.06924209514252466, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.06924209514252466, 0.06924209514252466, 0.06924209514252466]}, "mutation_prompt": null}
{"id": "326f7c19-a36a-4bf0-8fe5-e2047f83791e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Changed line\n        self.cognitive_coefficient = 1.5  # Changed line\n        self.social_coefficient = 1.5  # Changed line\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.7 - 0.6 * (evaluations / self.budget)  # Changed line\n                self.social_coefficient = 1.3 + 0.6 * (evaluations / self.budget)  # Changed line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation with scaling\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.3 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.random.choice([-1, 1], self.dim) * np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * (ub - lb)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO with adaptive mutation scaling and adjusted exploration-exploitation balance for improved convergence on photonic structure optimization.", "configspace": "", "generation": 76, "fitness": 0.0697612375070139, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.0697612375070139, 0.0697612375070139, 0.0697612375070139]}, "mutation_prompt": null}
{"id": "1167759b-d32e-41e4-b410-ada9e5d7112c", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(3 * np.sqrt(self.dim))  # Changed line\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.97**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by dynamically adjusting population size and inertia weight decay for enhanced exploration and convergence efficiency.", "configspace": "", "generation": 77, "fitness": 0.07034822800104334, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07034822800104334, 0.07034822800104334, 0.07034822800104334]}, "mutation_prompt": null}
{"id": "1d2168da-b7fe-48d8-ac02-a24ab328f3d6", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Changed line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    mutation_vector = 0.1 * np.random.randn(self.dim)  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99  \n            if evaluations % (self.budget // 10) == 0:  # Changed line\n                self.inertia_weight = 0.5 + 0.4 * np.random.rand()  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by introducing a dynamic inertia weight adjustment for better exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.07094211855897736, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07094211855897736, 0.07094211855897736, 0.07094211855897736]}, "mutation_prompt": null}
{"id": "d5d6d2b1-0433-4890-8b42-985dc3a2242a", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 2.0 - 0.6 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 0.9 + 0.9 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.25 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  \n                    direction = np.sign(self.global_best_position - particles[i])  \n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Refined the inertia weight and mutation strategy in QuantumAdaptivePSO to enhance exploration diversity and convergence speed.", "configspace": "", "generation": 79, "fitness": 0.07123164704791174, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07123164704791174, 0.07123164704791174, 0.07123164704791174]}, "mutation_prompt": null}
{"id": "52848d3b-478a-45a0-b305-25bf6f9b11fb", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])  # Changed line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight = 0.7 - 0.4 * (evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by dynamically adjusting inertia weight, leading to more balanced exploration and exploitation.", "configspace": "", "generation": 80, "fitness": 0.07064105429360423, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07064105429360423, 0.07064105429360423, 0.07064105429360423]}, "mutation_prompt": null}
{"id": "5c920800-0d1e-467d-b991-6b9ad0241656", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n        previous_best_value = self.global_best_value\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim)  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            improvement = previous_best_value - self.global_best_value\n            self.inertia_weight += 0.01 * improvement / max(1e-8, abs(previous_best_value))  # Changed line\n            self.inertia_weight = np.clip(self.inertia_weight, 0.3, 0.9)  # Prevent extreme values\n            previous_best_value = self.global_best_value\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Introduced dynamic inertia weight adjustment based on fitness improvement rate for better convergence.", "configspace": "", "generation": 81, "fitness": 0.0629492389191042, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.0629492389191042, 0.0629492389191042, 0.0629492389191042]}, "mutation_prompt": null}
{"id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / np.abs(personal_best_values[i] + 1e-9)\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved directional mutation by incorporating fitness proportional adjustment to maintain exploration-exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.07139394167905722, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "dc3c9bfc-a44a-4095-af27-189800e2a2f4", "metadata": {"aucs": [0.07139394167905722, 0.07139394167905722, 0.07139394167905722]}, "mutation_prompt": null}
{"id": "6d83fa62-f620-4946-b249-58cb0c855487", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.6)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / np.abs(personal_best_values[i] + 1e-9)\n                    mutation_vector = 0.2 * direction * np.random.uniform(-1, 1, self.dim) * mutation_strength  # Changed line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced particle diversity via adaptive dynamic inertia and mutation for improved convergence.", "configspace": "", "generation": 83, "fitness": 0.07138988153149894, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "metadata": {"aucs": [0.07138988153149894, 0.07138988153149894, 0.07138988153149894]}, "mutation_prompt": null}
{"id": "56112b64-51e2-4dea-a5e1-18e0855fc6cd", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = 1.1 * (self.inertia_weight * velocities[i] + cognitive_term + social_term)  # Changed line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / np.abs(personal_best_values[i] + 1e-9)\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced exploration via velocity scaling to improve convergence dynamics.", "configspace": "", "generation": 84, "fitness": 0.07095983456994337, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "metadata": {"aucs": [0.07095983456994337, 0.07095983456994337, 0.07095983456994337]}, "mutation_prompt": null}
{"id": "91235a33-41c2-42df-ad0c-9c791be88e08", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / np.abs(personal_best_values[i] + 1e-9)\n                    improvement_rate = (1 - evaluations / self.budget)  # Added line\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength * improvement_rate  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced adaptive mutation mechanism by introducing dynamic scaling based on global best improvement rate.", "configspace": "", "generation": 85, "fitness": 0.07139392475104211, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "metadata": {"aucs": [0.07139392475104211, 0.07139392475104211, 0.07139392475104211]}, "mutation_prompt": null}
{"id": "c1d770d2-3840-46e8-8b32-d5e2317d5354", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.9  # Modified line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation with stochastic universal sampling\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  \n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  \n                    # Use a stochastic universal sampling inspired method\n                    direction = np.sign(self.global_best_position - particles[i])\n                    slots = 1 + np.random.randint(0, 3)  # Modified line\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / np.abs(personal_best_values[i] + 1e-9)\n                    mutation_vector = 0.1 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength / slots  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  \n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Integrate a non-linear inertia weight adjustment and stochastic universal sampling for mutation to enhance exploration.", "configspace": "", "generation": 86, "fitness": 0.06976211648787489, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "metadata": {"aucs": [0.06976211648787489, 0.06976211648787489, 0.06976211648787489]}, "mutation_prompt": null}
{"id": "4eb7b4d7-1e94-452f-ba71-a69f57d7362e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.8)  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by fine-tuning mutation strength and adaptive velocity damping for improved global exploration.", "configspace": "", "generation": 87, "fitness": 0.0713978173235349, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "44ce9cbe-5519-4911-b352-5f43681b8e18", "metadata": {"aucs": [0.0713978173235349, 0.0713978173235349, 0.0713978173235349]}, "mutation_prompt": null}
{"id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9)  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.97**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by adjusting mutation influence and inertia weight decay for better convergence.", "configspace": "", "generation": 88, "fitness": 0.07140747963742533, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "4eb7b4d7-1e94-452f-ba71-a69f57d7362e", "metadata": {"aucs": [0.07140747963742533, 0.07140747963742533, 0.07140747963742533]}, "mutation_prompt": null}
{"id": "458ef620-f02a-4e20-a2c5-b01950f5ce7f", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9)  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.99**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by fine-tuning the inertia weight decay rate for improved convergence stability.", "configspace": "", "generation": 89, "fitness": 0.07139442568060927, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07139442568060927, 0.07139442568060927, 0.07139442568060927]}, "mutation_prompt": null}
{"id": "7dfc22a3-c7f2-4087-b5bc-81b1d188428e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.2 + 0.7 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = np.minimum(0.5, (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9))  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.97**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by fine-tuning social influence and adaptive mutation strength for improved exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.07127248769568495, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07127248769568495, 0.07127248769568495, 0.07127248769568495]}, "mutation_prompt": null}
{"id": "e54666a9-0d94-46c2-9b6d-60cb57622b6e", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.7  # Modified line\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.95**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by dynamically adjusting inertia weight decay, improving convergence speed and precision in complex landscapes.", "configspace": "", "generation": 91, "fitness": 0.07065558631589886, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07065558631589886, 0.07065558631589886, 0.07065558631589886]}, "mutation_prompt": null}
{"id": "4bbc1781-6040-4717-b997-4e35afec5820", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Dynamically adjust population size\n        population_size = self.initial_population_size * (1 + self.budget // 1000)  # Changed line\n        \n        particles = np.random.uniform(lb, ub, (population_size, self.dim))  # Changed line\n        velocities = np.random.uniform(-1, 1, (population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Improved adaptive mutation strategy\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(population_size):\n                if np.random.rand() < mutation_prob[i] * (1 - evaluations/self.budget):  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.97**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by dynamically adjusting population size and improving mutation strategy for faster convergence.", "configspace": "", "generation": 92, "fitness": 0.07139720606731637, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07139720606731637, 0.07139720606731637, 0.07139720606731637]}, "mutation_prompt": null}
{"id": "9af2205b-9837-4731-87f2-05abb62ec4d8", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.adaptive_population_rate = 0.05  # Changed line\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            self.population_size = max(5, int(self.population_size * (1 + self.adaptive_population_rate * (np.random.rand() - 0.5))))  # Changed line\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.3 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):  # Changed line\n                if np.random.rand() < mutation_prob[i]:  \n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.9)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.97**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by incorporating dynamic particle count adaptation and improved mutation probability for robust convergence.", "configspace": "", "generation": 93, "fitness": 0.07137874626150997, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07137874626150997, 0.07137874626150997, 0.07137874626150997]}, "mutation_prompt": null}
{"id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.95)  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.95**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by introducing dynamic inertia weight and mutation probability adjustments based on evaluation progress for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.07143605157446231, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c322535d-6c7e-4a9f-ad17-aa0a39c58a2e", "metadata": {"aucs": [0.07143605157446231, 0.07143605157446231, 0.07143605157446231]}, "mutation_prompt": null}
{"id": "300e3e36-14d9-4928-995c-997c4477c007", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.2 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.95)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.93**(1 + evaluations/self.budget)  # Changed line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved convergence by adjusting the adaptive mutation and inertia weight decay to optimize exploration and exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.07142448974442839, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "metadata": {"aucs": [0.07142448974442839, 0.07142448974442839, 0.07142448974442839]}, "mutation_prompt": null}
{"id": "202c7b64-bd58-49a4-a954-a930699c2857", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.95)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced QuantumAdaptivePSO by adapting inertia weight and using a sigmoid function for mutation probability to ensure diverse exploration and improved convergence.", "configspace": "", "generation": 96, "fitness": 0.07139774296330714, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "metadata": {"aucs": [0.07139774296330714, 0.07139774296330714, 0.07139774296330714]}, "mutation_prompt": null}
{"id": "2dcefb59-59f9-443c-b23c-8c27891a10dc", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                # Modified line to use sin for non-linear progression\n                self.social_coefficient = 1.1 + 0.8 * np.sin((np.pi / 2) * (evaluations / self.budget))  \n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.95)\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  \n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            # Modified line to introduce exponential decay\n            self.inertia_weight *= np.exp(-0.01 * evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improve convergence by dynamically adjusting inertia weight and incorporating a non-linear update strategy for social coefficient.", "configspace": "", "generation": 97, "fitness": 0.0713647117584878, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "metadata": {"aucs": [0.0713647117584878, 0.0713647117584878, 0.0713647117584878]}, "mutation_prompt": null}
{"id": "d43b30ac-815f-4add-99cb-5cbbdeb2472b", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)  # Modified line\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)  # Modified line\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = self.inertia_weight * velocities[i] + cognitive_term + social_term\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))  # Changed line\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:  # Changed line\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.95) \n                    adaptive_velocity_factor = 0.1 * np.linalg.norm(velocities[i])  # New line\n                    mutation_vector = (0.15 + adaptive_velocity_factor) * direction * np.random.uniform(0, 1, self.dim) * mutation_strength  # Modified line\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.98**(1 + evaluations/self.budget)  # Modified line\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Enhanced convergence by refining inertia weight decay and mutation vector with adaptive velocity influence.", "configspace": "", "generation": 98, "fitness": 0.07138873232619969, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "metadata": {"aucs": [0.07138873232619969, 0.07138873232619969, 0.07138873232619969]}, "mutation_prompt": null}
{"id": "c191f620-effa-40b4-b72b-501e5260600a", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 + int(2 * np.sqrt(self.dim))\n        self.inertia_weight = 0.5\n        self.cognitive_coefficient = 1.7  \n        self.social_coefficient = 1.3     \n        self.global_best_position = None\n        self.global_best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        lb, ub = func.bounds.lb, func.bounds.ub\n        particles = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Modified line\n        personal_best_positions = particles.copy()\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                fitness = func(particles[i])\n                evaluations += 1\n\n                if fitness < personal_best_values[i]:\n                    personal_best_values[i] = fitness\n                    personal_best_positions[i] = particles[i].copy()\n\n                if fitness < self.global_best_value:\n                    self.global_best_value = fitness\n                    self.global_best_position = particles[i].copy()\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                cognitive_term = self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i])\n                self.cognitive_coefficient = 1.9 - 0.5 * (evaluations / self.budget)\n                self.social_coefficient = 1.1 + 0.8 * (evaluations / self.budget)\n                social_term = self.social_coefficient * r2 * (self.global_best_position - particles[i])  \n                velocities[i] = 0.95 * (self.inertia_weight * velocities[i] + cognitive_term + social_term) # Modified line\n                particles[i] += velocities[i]\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lb, ub)\n\n            # Adaptive mutation\n            velocity_magnitude = np.linalg.norm(velocities, axis=1)\n            mutation_prob = 1.0 / (1.0 + np.exp(-0.4 * (velocity_magnitude / np.max(velocity_magnitude) - 0.5)))\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_prob[i]:\n                    direction = np.sign(self.global_best_position - particles[i])\n                    mutation_strength = (personal_best_values[i] - self.global_best_value) / (np.abs(personal_best_values[i] + 1e-9) * 0.8)  # Modified line\n                    mutation_vector = 0.15 * direction * np.random.uniform(0, 1, self.dim) * mutation_strength\n                    particles[i] += mutation_vector\n                    particles[i] = np.clip(particles[i], lb, ub)\n\n            self.inertia_weight *= 0.95**(1 + evaluations/self.budget)\n\n        return self.global_best_position", "name": "QuantumAdaptivePSO", "description": "Improved QuantumAdaptivePSO by introducing velocity decay and optimized mutation scaling for enhanced global search capabilities.", "configspace": "", "generation": 99, "fitness": 0.07144957798051699, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c19e5fd9-bce7-4b2b-a96a-b2e6531a41e0", "metadata": {"aucs": [0.07144957798051699, 0.07144957798051699, 0.07144957798051699]}, "mutation_prompt": null}
