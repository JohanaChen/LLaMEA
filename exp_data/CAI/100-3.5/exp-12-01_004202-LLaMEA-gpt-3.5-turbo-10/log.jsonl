{"id": "2705619d-a015-4ae8-82de-98c72a65007c", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim, pop_size=10, f=0.5, cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.f = f\n        self.cr = cr\n\n    def select_parents(self, population, target_idx):\n        idxs = np.random.choice(len(population), 3, replace=False)\n        idxs = idxs[idxs != target_idx]\n        return population[idxs]\n\n    def mutate(self, population, target_idx):\n        parents = self.select_parents(population, target_idx)\n        mutant = parents[0] + self.f * (parents[1] - parents[2])\n        return np.clip(mutant, -5.0, 5.0)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.cr\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        population = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        best_solution = population[np.argmin([func(ind) for ind in population])]\n        \n        for _ in range(self.budget - self.pop_size):\n            new_population = []\n            for idx, target in enumerate(population):\n                mutant = self.mutate(population, idx)\n                trial = self.crossover(target, mutant)\n                if func(trial) < func(target):\n                    population[idx] = trial\n                    if func(trial) < func(best_solution):\n                        best_solution = trial\n            \n        return best_solution", "name": "AdaptiveDE", "description": "An adaptive multi-population differential evolution algorithm with dynamic population size and adaptive parameter control for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\nTypeError: 'AdaptiveDE' object is not callable\n.", "error": "TypeError(\"'AdaptiveDE' object is not callable\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\nTypeError: 'AdaptiveDE' object is not callable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "23a97d9c-f317-4997-8c46-98a099c6d42f", "solution": "import numpy as np\n\nclass SelfAdaptiveDE(AdaptiveDE):\n    def __init__(self, budget, dim, pop_size=10, f=0.5, cr=0.9, mutation_prob=0.1):\n        super().__init__(budget, dim, pop_size, f, cr)\n        self.mutation_prob = mutation_prob\n\n    def mutate(self, population, target_idx):\n        parents = self.select_parents(population, target_idx)\n        best = population[np.argmin([func(ind) for ind in population])]\n        mutant = population[target_idx] + self.f * (best - population[target_idx]) + self.mutation_prob * np.random.uniform(-5.0, 5.0, self.dim)\n        return np.clip(mutant, -5.0, 5.0)", "name": "SelfAdaptiveDE", "description": "Implementing a self-adaptive differential evolution with a mutation strategy based on best and random individuals to enhance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'SelfAdaptiveDE' object is not callable\").", "error": "TypeError(\"'SelfAdaptiveDE' object is not callable\")", "parent_id": "2705619d-a015-4ae8-82de-98c72a65007c", "metadata": {}, "mutation_prompt": null}
