{"id": "6c19bca6-f7bc-4c86-9960-f0ea874f2f98", "solution": "import numpy as np\n\nclass PSOGWO:\n    def __init__(self, budget, dim, swarm_size=20, alpha=0.1, beta=0.1, delta=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.delta = delta\n\n    def __call__(self, func):\n        def fitness(position):\n            return func(position)\n\n        def initialize_population():\n            return np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n\n        def update_position(position, velocity):\n            return np.clip(position + velocity, -5.0, 5.0)\n\n        def pso_update_position(pos, vel, pbest, gbest):\n            r1, r2 = np.random.rand(2)\n            new_vel = self.alpha * vel + self.beta * r1 * (pbest - pos) + self.delta * r2 * (gbest - pos)\n            new_pos = update_position(pos, new_vel)\n            return new_pos, new_vel\n\n        def gwo_update_position(alpha, beta, delta, position):\n            a, b, c = position\n            r1, r2 = np.random.rand(2)\n            A1 = 2 * r1 - 1\n            A2 = 2 * r2 - 1\n            D_alpha = abs(self.alpha * alpha - a)\n            D_beta = abs(self.beta * beta - b)\n            D_delta = abs(self.delta * delta - c)\n            new_pos = np.clip(alpha - self.alpha * A1 * D_alpha, -5.0, 5.0)\n            new_pos = np.clip(new_pos + beta - self.beta * A2 * D_beta, -5.0, 5.0)\n            new_pos = np.clip(new_pos + delta - self.delta * A2 * D_delta, -5.0, 5.0)\n            return new_pos\n\n        population = initialize_population()\n        velocities = np.zeros((self.swarm_size, self.dim))\n        best_positions = population.copy()\n        best_fitness = np.array([fitness(pos) for pos in best_positions])\n        gbest_idx = np.argmin(best_fitness)\n        gbest = best_positions[gbest_idx]\n\n        for _ in range(self.budget):\n            for i in range(self.swarm_size):\n                pos = population[i]\n                vel = velocities[i]\n\n                # PSO update\n                new_pos, new_vel = pso_update_position(pos, vel, best_positions[i], gbest)\n                population[i] = new_pos\n                velocities[i] = new_vel\n\n                # GWO update\n                new_pos = gwo_update_position(gbest, best_positions[i], best_positions[gbest_idx], new_pos)\n                population[i] = new_pos\n\n                # Update best positions\n                curr_fitness = fitness(new_pos)\n                if curr_fitness < best_fitness[i]:\n                    best_positions[i] = new_pos\n                    best_fitness[i] = curr_fitness\n                    if curr_fitness < best_fitness[gbest_idx]:\n                        gbest_idx = i\n                        gbest = new_pos\n\n        return gbest", "name": "PSOGWO", "description": "Novel Bio-Inspired Algorithm combining Particle Swarm Optimization (PSO) with Grey Wolf Optimization (GWO) for Black Box Optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 29, in gwo_update_position\nValueError: too many values to unpack (expected 3)\n.", "error": "ValueError('too many values to unpack (expected 3)')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 59, in __call__\n  File \"<string>\", line 29, in gwo_update_position\nValueError: too many values to unpack (expected 3)\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "8d197e22-8cdf-4cf8-b06e-de803c63836a", "solution": "import numpy as np\n\nclass PSOGWO:\n    def __init__(self, budget, dim, swarm_size=20, alpha=0.1, beta=0.1, delta=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n        self.delta = delta\n\n    def __call__(self, func):\n        def fitness(position):\n            return func(position)\n\n        def initialize_population():\n            return np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n\n        def update_position(position, velocity):\n            return np.clip(position + velocity, -5.0, 5.0)\n\n        def pso_update_position(pos, vel, pbest, gbest):\n            r1, r2 = np.random.rand(2)\n            new_vel = self.alpha * vel + self.beta * r1 * (pbest - pos) + self.delta * r2 * (gbest - pos)\n            new_pos = update_position(pos, new_vel)\n            return new_pos, new_vel\n\n        def gwo_update_position(alpha, beta, delta, position):\n            a, b, c = position\n            r1, r2 = np.random.rand(2)\n            A1 = 2 * r1 - 1\n            A2 = 2 * r2 - 1\n            D_alpha = abs(self.alpha * alpha - a)\n            D_beta = abs(self.beta * beta - b)\n            D_delta = abs(self.delta * delta - c)\n            new_pos = np.clip(alpha - self.alpha * A1 * D_alpha, -5.0, 5.0)\n            new_pos = np.clip(new_pos + beta - self.beta * A2 * D_beta, -5.0, 5.0)\n            new_pos = np.clip(new_pos + delta - self.delta * A2 * D_delta, -5.0, 5.0)\n            return new_pos\n\n        population = initialize_population()\n        velocities = np.zeros((self.swarm_size, self.dim))\n        best_positions = population.copy()\n        best_fitness = np.array([fitness(pos) for pos in best_positions])\n        gbest_idx = np.argmin(best_fitness)\n        gbest = best_positions[gbest_idx]\n\n        for _ in range(self.budget):\n            for i in range(self.swarm_size):\n                pos = population[i]\n                vel = velocities[i]\n\n                # PSO update\n                new_pos, new_vel = pso_update_position(pos, vel, best_positions[i], gbest)\n                population[i] = new_pos\n                velocities[i] = new_vel\n\n                # GWO update\n                new_pos = gwo_update_position(gbest, best_positions[i], best_positions[gbest_idx], new_pos)\n                population[i] = new_pos\n\n                # Update best positions\n                curr_fitness = fitness(new_pos)\n                if curr_fitness < best_fitness[i]:\n                    best_positions[i] = new_pos\n                    best_fitness[i] = curr_fitness\n                    if curr_fitness < best_fitness[gbest_idx]:\n                        gbest_idx = i\n                        gbest = new_pos\n\n        return gbest", "name": "PSOGWO", "description": "Novel Bio-Inspired Algorithm combining Particle Swarm Optimization (PSO) with Grey Wolf Optimization (GWO) for Black Box Optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6c19bca6-f7bc-4c86-9960-f0ea874f2f98", "metadata": {}, "mutation_prompt": null}
