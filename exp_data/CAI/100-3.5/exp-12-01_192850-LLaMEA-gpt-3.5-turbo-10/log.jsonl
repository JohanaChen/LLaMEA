{"id": "70795477-1241-4159-bc1c-a0e7f1d3ad5f", "solution": "import numpy as np\n\nclass QIGSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.num_iterations = budget // self.num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def levy_flight():\n            beta = 1.5\n            sigma = (gamma(1 + beta) * np.sin(np.pi * beta / 2) / (gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / beta)\n            return 0.01 * step\n\n        def fitness(x):\n            return func(x)\n\n        g_best = None\n        g_best_fitness = np.inf\n\n        for _ in range(self.num_iterations):\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            for i in range(self.num_particles):\n                particle = particles[i]\n                cost = fitness(particle)\n                if cost < g_best_fitness:\n                    g_best = particle\n                    g_best_fitness = cost\n                step = levy_flight()\n                new_particle = particle + step\n                new_particle = np.clip(new_particle, self.lower_bound, self.upper_bound)\n                new_cost = fitness(new_particle)\n                if new_cost < cost:\n                    particles[i] = new_particle\n\n        return g_best", "name": "QIGSA", "description": "An innovative algorithm called Quantum-Inspired Gravitational Search Algorithm (QIGSA) combines the principles of quantum mechanics and gravitational search for efficient global optimization in continuous search spaces.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 35, in __call__\n  File \"<string>\", line 15, in levy_flight\nNameError: name 'gamma' is not defined\n.", "error": "NameError(\"name 'gamma' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 35, in __call__\n  File \"<string>\", line 15, in levy_flight\nNameError: name 'gamma' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a03ec01d-18ae-4d0e-afdb-41b766f67aad", "solution": "import numpy as np\n\nclass QIGSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.num_iterations = budget // self.num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def levy_flight():\n            beta = 1.5\n            sigma = (gamma(1 + beta) * np.sin(np.pi * beta / 2) / (gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / beta)\n            return 0.01 * step\n\n        def fitness(x):\n            return func(x)\n\n        g_best = None\n        g_best_fitness = np.inf\n\n        for _ in range(self.num_iterations):\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n            for i in range(self.num_particles):\n                particle = particles[i]\n                cost = fitness(particle)\n                if cost < g_best_fitness:\n                    g_best = particle\n                    g_best_fitness = cost\n                step = levy_flight()\n                new_particle = particle + step\n                new_particle = np.clip(new_particle, self.lower_bound, self.upper_bound)\n                new_cost = fitness(new_particle)\n                if new_cost < cost:\n                    particles[i] = new_particle\n\n        return g_best", "name": "QIGSA", "description": "An innovative algorithm called Quantum-Inspired Gravitational Search Algorithm (QIGSA) combines the principles of quantum mechanics and gravitational search for efficient global optimization in continuous search spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "70795477-1241-4159-bc1c-a0e7f1d3ad5f", "metadata": {}, "mutation_prompt": null}
