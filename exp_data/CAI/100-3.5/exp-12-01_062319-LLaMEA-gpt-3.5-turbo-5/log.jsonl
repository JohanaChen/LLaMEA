{"id": "1873f071-fffe-440a-b9ef-f0c1b50441d1", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        pop_size = 30\n        evals_per_iter = pop_size\n        bounds = (-5.0, 5.0)\n        cr = 0.9\n        f = 0.8\n        max_mut_step = 1.0\n        min_mut_step = 0.01\n        mut_step_size = 0.5 * (max_mut_step - min_mut_step)\n\n        population = np.random.uniform(bounds[0], bounds[1], size=(pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        \n        for _ in range(self.budget // evals_per_iter):\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(population[a] + f * (population[b] - population[c]), bounds[0], bounds[1])\n                mask = np.random.rand(self.dim) < cr\n                new_ind = np.where(mask, mutant, population[i])\n                new_fitness = func(new_ind)\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_ind\n                    fitness[i] = new_fitness\n                    mut_step_size = max(min_mut_step, min(max_mut_step, mut_step_size * 0.85))\n                else:\n                    mut_step_size = max(min_mut_step, min(max_mut_step, mut_step_size * 1.15))\n            \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveEvolutionaryAlgorithm", "description": "An Evolutionary Algorithm (EA) with a novel adaptive mutation strategy based on a combination of polynomial mutation and self-adaptive mutation step size.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 25, in __call__\nIndexError: arrays used as indices must be of integer (or boolean) type\n.", "error": "IndexError('arrays used as indices must be of integer (or boolean) type')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 25, in __call__\nIndexError: arrays used as indices must be of integer (or boolean) type\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "b5923d54-0479-42ce-b02c-f3db1e220353", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        pop_size = 30\n        evals_per_iter = pop_size\n        bounds = (-5.0, 5.0)\n        cr = 0.9\n        f = 0.8\n        max_mut_step = 1.0\n        min_mut_step = 0.01\n        mut_step_size = 0.5 * (max_mut_step - min_mut_step)\n\n        population = np.random.uniform(bounds[0], bounds[1], size=(pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        \n        for _ in range(self.budget // evals_per_iter):\n            for i in range(pop_size):\n                idxs = [idx for idx in range(pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(population[a] + f * (population[b] - population[c]), bounds[0], bounds[1])\n                mask = np.random.rand(self.dim) < cr\n                new_ind = np.where(mask, mutant, population[i])\n                new_fitness = func(new_ind)\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_ind\n                    fitness[i] = new_fitness\n                    mut_step_size = max(min_mut_step, min(max_mut_step, mut_step_size * 0.85))\n                else:\n                    mut_step_size = max(min_mut_step, min(max_mut_step, mut_step_size * 1.15))\n            \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveEvolutionaryAlgorithm", "description": "An Evolutionary Algorithm (EA) with a novel adaptive mutation strategy based on a combination of polynomial mutation and self-adaptive mutation step size.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1873f071-fffe-440a-b9ef-f0c1b50441d1", "metadata": {}, "mutation_prompt": null}
