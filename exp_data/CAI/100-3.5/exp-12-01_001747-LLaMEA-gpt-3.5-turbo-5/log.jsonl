{"id": "7b08a2ff-c18b-49b4-8339-0a4c6269c1aa", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.cr = 0.5\n        self.f = 0.5\n        self.max_iter = budget // self.pop_size\n        \n    def __call__(self, func):\n        def mutate(x, pop, f):\n            a, b, c = np.random.choice(pop, 3, replace=False)\n            return np.clip(a + f * (b - c), -5, 5)\n        \n        def crossover(x, mutant, cr):\n            mask = np.random.rand(self.dim) < cr\n            trial = np.where(mask, mutant, x)\n            return trial\n        \n        pop = np.random.uniform(-5, 5, (self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in pop])\n        best_idx = np.argmin(fitness)\n        best = pop[best_idx]\n        \n        for _ in range(self.max_iter):\n            new_pop = np.zeros((self.pop_size, self.dim))\n            for i in range(self.pop_size):\n                mutant = mutate(pop[i], pop, self.f)\n                trial = crossover(pop[i], mutant, self.cr)\n                f_trial = func(trial)\n                if f_trial < fitness[i]:\n                    new_pop[i] = trial\n                else:\n                    new_pop[i] = pop[i]\n                    \n            pop = new_pop\n            fitness = np.array([func(x) for x in pop])\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < func(best):\n                best = pop[best_idx]\n                \n        return best", "name": "AdaptiveDE", "description": "An ensemble of Differential Evolution (DE) variants with adaptive control parameters to efficiently optimize black box functions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 30, in __call__\n  File \"<string>\", line 14, in mutate\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 30, in __call__\n  File \"<string>\", line 14, in mutate\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "570ea313-687c-4bba-8ded-c8bc585f6266", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.cr = 0.5\n        self.f = 0.5\n        self.max_iter = budget // self.pop_size\n        \n    def __call__(self, func):\n        def mutate(x, pop, f):\n            a, b, c = np.random.choice(pop, 3, replace=False)\n            return np.clip(a + f * (b - c), -5, 5)\n        \n        def crossover(x, mutant, cr):\n            mask = np.random.rand(self.dim) < cr\n            trial = np.where(mask, mutant, x)\n            return trial\n        \n        pop = np.random.uniform(-5, 5, (self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in pop])\n        best_idx = np.argmin(fitness)\n        best = pop[best_idx]\n        \n        for _ in range(self.max_iter):\n            new_pop = np.zeros((self.pop_size, self.dim))\n            for i in range(self.pop_size):\n                mutant = mutate(pop[i], pop, self.f)\n                trial = crossover(pop[i], mutant, self.cr)\n                f_trial = func(trial)\n                if f_trial < fitness[i]:\n                    new_pop[i] = trial\n                else:\n                    new_pop[i] = pop[i]\n                    \n            pop = new_pop\n            fitness = np.array([func(x) for x in pop])\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < func(best):\n                best = pop[best_idx]\n                \n        return best", "name": "AdaptiveDE", "description": "An ensemble of Differential Evolution (DE) variants with adaptive control parameters to efficiently optimize black box functions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b08a2ff-c18b-49b4-8339-0a4c6269c1aa", "metadata": {}, "mutation_prompt": null}
