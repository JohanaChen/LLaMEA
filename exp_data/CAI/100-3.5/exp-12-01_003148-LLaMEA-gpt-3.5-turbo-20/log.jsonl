{"id": "f5cff42c-4371-4bc5-8160-615e3615f48f", "solution": "import numpy as np\n\nclass DE_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10\n        self.mutation_factor = 0.5\n        self.crossover_prob = 0.7\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.1\n        self.alpha = 0.99\n\n    def __call__(self, func):\n        def random_vector(bounds):\n            return bounds[0] + (bounds[1] - bounds[0]) * np.random.rand(self.dim)\n\n        def clipToBounds(x, bounds):\n            return np.clip(x, bounds[0], bounds[1])\n\n        def mutate(x, population, bounds):\n            indices = np.random.choice(len(population), 3, replace=False)\n            a, b, c = population[indices]\n            mutant = clipToBounds(a + self.mutation_factor * (b - c), bounds)\n            return mutant\n\n        def crossover(x, mutant, bounds):\n            trial = np.copy(x)\n            j = np.random.randint(self.dim)\n            for indx in range(self.dim):\n                if np.random.rand() > self.crossover_prob and indx != j:\n                    trial[indx] = mutant[indx]\n            return clipToBounds(trial, bounds)\n\n        def accept(candidate, x, temperature):\n            if candidate < x:\n                return candidate\n            elif np.random.uniform() < np.exp((x - candidate) / temperature):\n                return candidate\n            return x\n\n        def anneal(x, population, bounds, temperature):\n            candidate = mutate(x, population, bounds)\n            trial = crossover(x, candidate, bounds)\n            return accept(func(trial), x, temperature)\n\n        bounds = (-5.0, 5.0)\n        population = [random_vector(bounds) for _ in range(self.population_size)]\n        x = random_vector(bounds)\n        temperature = self.initial_temperature\n\n        for _ in range(self.budget):\n            x = anneal(x, population, bounds, temperature)\n            temperature *= self.alpha\n        return x", "name": "DE_SA_Optimizer", "description": "Metaheuristic algorithm based on a combination of Differential Evolution (DE) and Simulated Annealing (SA) to balance exploration and exploitation for solving black box optimization problems efficiently.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 43, in anneal\n  File \"<string>\", line 23, in mutate\nTypeError: only integer scalar arrays can be converted to a scalar index\n.", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 43, in anneal\n  File \"<string>\", line 23, in mutate\nTypeError: only integer scalar arrays can be converted to a scalar index\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "599cad76-7ee4-4fff-b0c7-2e6036ef07a3", "solution": "import numpy as np\n\nclass DE_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10\n        self.initial_mutation_factor = 0.5\n        self.final_mutation_factor = 0.1\n        self.crossover_prob = 0.7\n        self.initial_temperature = 1.0\n        self.final_temperature = 0.1\n        self.alpha = 0.99\n\n    def __call__(self, func):\n        def random_vector(bounds):\n            return bounds[0] + (bounds[1] - bounds[0]) * np.random.rand(self.dim)\n\n        def clipToBounds(x, bounds):\n            return np.clip(x, bounds[0], bounds[1])\n\n        def mutate(x, population, bounds, mutation_factor):\n            indices = np.random.choice(len(population), 3, replace=False)\n            a, b, c = population[indices]\n            mutant = clipToBounds(a + mutation_factor * (b - c), bounds)\n            return mutant\n\n        def crossover(x, mutant, bounds):\n            trial = np.copy(x)\n            j = np.random.randint(self.dim)\n            for indx in range(self.dim):\n                if np.random.rand() > self.crossover_prob and indx != j:\n                    trial[indx] = mutant[indx]\n            return clipToBounds(trial, bounds)\n\n        def adjust_mutation_factor(iteration):\n            return self.initial_mutation_factor - (self.initial_mutation_factor - self.final_mutation_factor) * iteration / self.budget\n\n        def accept(candidate, x, temperature):\n            if candidate < x:\n                return candidate\n            elif np.random.uniform() < np.exp((x - candidate) / temperature):\n                return candidate\n            return x\n\n        def anneal(x, population, bounds, temperature, mutation_factor):\n            candidate = mutate(x, population, bounds, mutation_factor)\n            trial = crossover(x, candidate, bounds)\n            return accept(func(trial), x, temperature)\n\n        bounds = (-5.0, 5.0)\n        population = [random_vector(bounds) for _ in range(self.population_size)]\n        x = random_vector(bounds)\n        temperature = self.initial_temperature\n\n        for i in range(self.budget):\n            mutation_factor = adjust_mutation_factor(i)\n            x = anneal(x, population, bounds, temperature, mutation_factor)\n            temperature *= self.alpha\n        return x", "name": "DE_SA_Optimizer", "description": "Improved DE_SA_Optimizer with adaptive mutation and enhanced simulated annealing.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "f5cff42c-4371-4bc5-8160-615e3615f48f", "metadata": {}, "mutation_prompt": null}
