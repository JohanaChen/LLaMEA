{"id": "7dc7349d-eb80-43c3-9254-95024a2f8756", "solution": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 20\n        self.max_iterations = budget // self.swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.initial_temperature = 100.0\n        self.final_temperature = 0.1\n        self.alpha = 0.85\n\n    def __call__(self, func):\n        def random_solution():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def within_bounds(solution):\n            return np.clip(solution, self.lower_bound, self.upper_bound)\n\n        def objective(solution):\n            return func(solution)\n\n        def pso():\n            swarm = np.array([random_solution() for _ in range(self.swarm_size)])\n            swarm_best = swarm[np.argmin([objective(sol) for sol in swarm])]\n            global_best = swarm_best.copy()\n\n            for _ in range(self.max_iterations):\n                for i in range(self.swarm_size):\n                    velocity = self.inertia_weight * velocity + self.c1 * np.random.rand(self.dim) * (swarm_best - swarm[i]) + self.c2 * np.random.rand(self.dim) * (global_best - swarm[i])\n                    candidate_position = swarm[i] + velocity\n                    swarm[i] = within_bounds(candidate_position)\n                    if objective(swarm[i]) < objective(swarm_best):\n                        swarm_best = swarm[i]\n                    if objective(swarm[i]) < objective(global_best):\n                        global_best = swarm[i]\n            return global_best\n\n        def sa(initial_solution):\n            current_solution = initial_solution\n            current_cost = objective(current_solution)\n            temperature = self.initial_temperature\n\n            for _ in range(self.max_iterations):\n                candidate_solution = current_solution + np.random.normal(0, temperature, self.dim)\n                candidate_solution = within_bounds(candidate_solution)\n                candidate_cost = objective(candidate_solution)\n                \n                if candidate_cost < current_cost or np.random.rand() < np.exp((current_cost - candidate_cost) / temperature):\n                    current_solution = candidate_solution\n                    current_cost = candidate_cost\n\n                temperature *= self.alpha\n                if temperature < self.final_temperature:\n                    break\n\n            return current_solution\n\n        best_solution = random_solution()\n        for _ in range(self.budget // self.swarm_size):\n            pso_solution = pso()\n            sa_solution = sa(pso_solution)\n            if objective(sa_solution) < objective(best_solution):\n                best_solution = sa_solution\n\n        return best_solution", "name": "PSO_SA_Optimizer", "description": "A novel metaheuristic algorithm based on a combination of Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently optimize black box functions within a given budget. ", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 66, in __call__\n  File \"<string>\", line 35, in pso\nUnboundLocalError: local variable 'velocity' referenced before assignment\n.", "error": "UnboundLocalError(\"local variable 'velocity' referenced before assignment\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 66, in __call__\n  File \"<string>\", line 35, in pso\nUnboundLocalError: local variable 'velocity' referenced before assignment\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "87fc7fab-11e7-44f3-a5e2-b63d2306d5cd", "solution": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 20\n        self.max_iterations = budget // self.swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.5\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.initial_temperature = 100.0\n        self.final_temperature = 0.1\n        self.alpha = 0.85\n\n    def __call__(self, func):\n        def random_solution():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def within_bounds(solution):\n            return np.clip(solution, self.lower_bound, self.upper_bound)\n\n        def objective(solution):\n            return func(solution)\n\n        def pso():\n            swarm = np.array([random_solution() for _ in range(self.swarm_size)])\n            swarm_best = swarm[np.argmin([objective(sol) for sol in swarm])]\n            global_best = swarm_best.copy()\n\n            for _ in range(self.max_iterations):\n                for i in range(self.swarm_size):\n                    velocity = self.inertia_weight * velocity + self.c1 * np.random.rand(self.dim) * (swarm_best - swarm[i]) + self.c2 * np.random.rand(self.dim) * (global_best - swarm[i])\n                    candidate_position = swarm[i] + velocity\n                    swarm[i] = within_bounds(candidate_position)\n                    if objective(swarm[i]) < objective(swarm_best):\n                        swarm_best = swarm[i]\n                    if objective(swarm[i]) < objective(global_best):\n                        global_best = swarm[i]\n            return global_best\n\n        def sa(initial_solution):\n            current_solution = initial_solution\n            current_cost = objective(current_solution)\n            temperature = self.initial_temperature\n\n            for _ in range(self.max_iterations):\n                candidate_solution = current_solution + np.random.normal(0, temperature, self.dim)\n                candidate_solution = within_bounds(candidate_solution)\n                candidate_cost = objective(candidate_solution)\n                \n                if candidate_cost < current_cost or np.random.rand() < np.exp((current_cost - candidate_cost) / temperature):\n                    current_solution = candidate_solution\n                    current_cost = candidate_cost\n\n                temperature *= self.alpha\n                if temperature < self.final_temperature:\n                    break\n\n            return current_solution\n\n        best_solution = random_solution()\n        for _ in range(self.budget // self.swarm_size):\n            pso_solution = pso()\n            sa_solution = sa(pso_solution)\n            if objective(sa_solution) < objective(best_solution):\n                best_solution = sa_solution\n\n        return best_solution", "name": "PSO_SA_Optimizer", "description": "A novel metaheuristic algorithm based on a combination of Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently optimize black box functions within a given budget. ", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7dc7349d-eb80-43c3-9254-95024a2f8756", "metadata": {}, "mutation_prompt": null}
