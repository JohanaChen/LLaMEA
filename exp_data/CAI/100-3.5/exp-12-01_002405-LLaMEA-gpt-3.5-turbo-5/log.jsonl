{"id": "81ed686f-67e7-4222-8725-2201f58ba2e0", "solution": "import numpy as np\n\nclass MultiSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = 5\n        self.swarm_size = 10\n        self.max_swarm_size = 20\n        self.min_swarm_size = 5\n        self.swarms = [np.random.uniform(-5.0, 5.0, (self.swarm_size, dim)) for _ in range(self.num_swarms)]\n    \n    def __call__(self, func):\n        for _ in range(self.budget):\n            for swarm in self.swarms:\n                fitness = [func(p) for p in swarm]\n                best_idx = np.argmin(fitness)\n                best_particle = swarm[best_idx]\n\n                for i, particle in enumerate(swarm):\n                    if i != best_idx:\n                        rand_swarm = np.random.choice(self.swarms)\n                        rand_particle = rand_swarm[np.random.randint(0, len(rand_swarm))]\n                        new_particle = particle + np.random.uniform(0, 1, self.dim) * (best_particle - particle) + np.random.uniform(0, 1, self.dim) * (rand_particle - particle)\n                        if func(new_particle) < fitness[i]:\n                            swarm[i] = new_particle\n            \n            # Dynamic swarm size adjustment\n            avg_fitness = np.mean([func(p) for p in np.concatenate(self.swarms)])\n            if avg_fitness < np.min([func(p) for p in best_swarm for best_swarm in self.swarms]):\n                if self.swarm_size < self.max_swarm_size:\n                    self.swarm_size += 1\n            else:\n                if self.swarm_size > self.min_swarm_size:\n                    self.swarm_size -= 1\n\n        final_best_swarm = min(self.swarms, key=lambda x: np.min([func(p) for p in x]))\n        return min(final_best_swarm, key=lambda x: func(x))", "name": "MultiSwarmOptimization", "description": "Multi-swarm optimization algorithm that uses a dynamic memory structure to share information among multiple swarms and adaptively adjust swarm size.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 22, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 22, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "afdb431f-200a-4fcd-8a89-f51340324de2", "solution": "import numpy as np\n\nclass MultiSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = 5\n        self.swarm_size = 10\n        self.max_swarm_size = 20\n        self.min_swarm_size = 5\n        self.swarms = [np.random.uniform(-5.0, 5.0, (self.swarm_size, dim)) for _ in range(self.num_swarms)]\n    \n    def __call__(self, func):\n        for _ in range(self.budget):\n            for swarm in self.swarms:\n                fitness = [func(p) for p in swarm]\n                best_idx = np.argmin(fitness)\n                best_particle = swarm[best_idx]\n\n                for i, particle in enumerate(swarm):\n                    if i != best_idx:\n                        rand_swarm = np.random.choice(self.swarms)\n                        rand_particle = rand_swarm[np.random.randint(0, len(rand_swarm))]\n                        new_particle = particle + np.random.uniform(0, 1, self.dim) * (best_particle - particle) + np.random.uniform(0, 1, self.dim) * (rand_particle - particle)\n                        if func(new_particle) < fitness[i]:\n                            swarm[i] = new_particle\n            \n            # Dynamic swarm size adjustment\n            avg_fitness = np.mean([func(p) for p in np.concatenate(self.swarms)])\n            if avg_fitness < np.min([func(p) for p in best_swarm for best_swarm in self.swarms]):\n                if self.swarm_size < self.max_swarm_size:\n                    self.swarm_size += 1\n            else:\n                if self.swarm_size > self.min_swarm_size:\n                    self.swarm_size -= 1\n\n        final_best_swarm = min(self.swarms, key=lambda x: np.min([func(p) for p in x]))\n        return min(final_best_swarm, key=lambda x: func(x))", "name": "MultiSwarmOptimization", "description": "Multi-swarm optimization algorithm that uses a dynamic memory structure to share information among multiple swarms and adaptively adjust swarm size.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "81ed686f-67e7-4222-8725-2201f58ba2e0", "metadata": {}, "mutation_prompt": null}
