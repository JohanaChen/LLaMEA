{"id": "d4e1ed84-f482-4b19-8b54-b79c54a2b294", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        def de_opponent(pop, F, CR):\n            idxs = np.random.choice(len(pop), 3, replace=False)\n            a, b, c = pop[idxs]\n            mutant = np.clip(a + F * (b - c), -5.0, 5.0)\n            cross_points = np.random.rand(self.dim) < CR\n            trial = np.where(cross_points, mutant, pop)\n            return trial\n\n        pop_size = 10 * self.dim\n        pop = np.random.uniform(-5.0, 5.0, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n\n        F, CR = 0.5, 0.9\n        T0, alpha = 1.0, 0.99\n\n        for _ in range(self.budget):\n            new_pop = np.empty_like(pop)\n            for i in range(pop_size):\n                trial = de_opponent(pop, F, CR)\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    pop[i], fitness[i] = trial, trial_fitness\n\n            T = T0 * alpha**_\n            for i in range(pop_size):\n                current, proposed = pop[i], np.clip(pop[i] + np.random.normal(0, T, self.dim), -5.0, 5.0)\n                current_fitness, proposed_fitness = fitness[i], func(proposed)\n                if proposed_fitness < current_fitness:\n                    pop[i], fitness[i] = proposed, proposed_fitness\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx]", "name": "HybridDESA", "description": "Hybrid Differential Evolution with Simulated Annealing (DESA) combines the global exploration of Differential Evolution with the local exploitation of Simulated Annealing, enhancing convergence speed and accuracy.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 29, in __call__\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n.", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 29, in __call__\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "014a0a7a-a4e5-4d6e-aa21-c96a1b999e5a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        def de_opponent(pop, F, CR):\n            idxs = np.random.choice(len(pop), 3, replace=False)\n            a, b, c = pop[idxs]\n            mutant = np.clip(a + F * (b - c), -5.0, 5.0)\n            cross_points = np.random.rand(self.dim) < CR\n            trial = np.where(cross_points, mutant, pop)\n            return trial\n\n        pop_size = 10 * self.dim\n        pop = np.random.uniform(-5.0, 5.0, (pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n\n        F, CR = 0.5, 0.9\n        T0, alpha = 1.0, 0.99\n\n        for _ in range(self.budget):\n            new_pop = np.empty_like(pop)\n            for i in range(pop_size):\n                trial = de_opponent(pop, F, CR)\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    pop[i], fitness[i] = trial, trial_fitness\n\n            T = T0 * alpha**_\n            for i in range(pop_size):\n                current, proposed = pop[i], np.clip(pop[i] + np.random.normal(0, T, self.dim), -5.0, 5.0)\n                current_fitness, proposed_fitness = fitness[i], func(proposed)\n                if proposed_fitness < current_fitness:\n                    pop[i], fitness[i] = proposed, proposed_fitness\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx]", "name": "HybridDESA", "description": "Hybrid Differential Evolution with Simulated Annealing (DESA) combines the global exploration of Differential Evolution with the local exploitation of Simulated Annealing, enhancing convergence speed and accuracy.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4e1ed84-f482-4b19-8b54-b79c54a2b294", "metadata": {}, "mutation_prompt": null}
