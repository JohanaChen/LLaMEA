{"id": "25eacfb6-9f5c-4e1d-b4f2-d6a40f24a86d", "solution": "import numpy as np\n\nclass DynamicEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.NP = 10\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def clipToBounds(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n\n    def ensure_bounds(self, vec):\n        vec_new = []\n        for i in range(len(vec)):\n            if vec[i] < self.lower_bound:\n                vec_new.append(self.lower_bound)\n            elif vec[i] > self.upper_bound:\n                vec_new.append(self.upper_bound)\n            else:\n                vec_new.append(vec[i])\n        return vec_new\n\n    def mutation(self, x_r1, x_r2, x_r3):\n        return self.clipToBounds(x_r1 + self.F * (x_r2 - x_r3))\n\n    def crossover(self, x_current, x_mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = [x_mutant[i] if (np.random.uniform(0, 1) < self.CR or i == j_rand) else x_current[i] for i in range(self.dim)]\n        return self.ensure_bounds(trial)\n\n    def __call__(self, func):\n        population = [np.random.uniform(self.lower_bound, self.upper_bound, self.dim) for _ in range(self.NP)]\n        fitness = [func(x) for x in population]\n        \n        for _ in range(self.budget):\n            trial_population = []\n            for i in range(self.NP):\n                random_indices = np.random.choice(range(self.NP), 3, replace=False)\n                x_r1, x_r2, x_r3 = population[random_indices]\n                x_mutant = self.mutation(x_r1, x_r2, x_r3)\n                trial = self.crossover(population[i], x_mutant)\n                f_trial = func(trial)\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < func(best):\n                best = population[best_idx]\n        return best", "name": "DynamicEvolution", "description": "An optimized version of the Differential Evolution algorithm that utilizes a dynamic mutation strategy and a novel boundary handling technique to efficiently explore the search space and exploit promising regions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 43, in __call__\nTypeError: only integer scalar arrays can be converted to a scalar index\n.", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 43, in __call__\nTypeError: only integer scalar arrays can be converted to a scalar index\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "9eda21ae-1c29-4ec7-a9e5-311b5bc4b925", "solution": "import numpy as np\n\nclass DynamicEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.NP = 10\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def clipToBounds(self, x):\n        return np.clip(x, self.lower_bound, self.upper_bound)\n\n    def ensure_bounds(self, vec):\n        vec_new = []\n        for i in range(len(vec)):\n            if vec[i] < self.lower_bound:\n                vec_new.append(self.lower_bound)\n            elif vec[i] > self.upper_bound:\n                vec_new.append(self.upper_bound)\n            else:\n                vec_new.append(vec[i])\n        return vec_new\n\n    def mutation(self, x_r1, x_r2, x_r3):\n        return self.clipToBounds(x_r1 + self.F * (x_r2 - x_r3))\n\n    def crossover(self, x_current, x_mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = [x_mutant[i] if (np.random.uniform(0, 1) < self.CR or i == j_rand) else x_current[i] for i in range(self.dim)]\n        return self.ensure_bounds(trial)\n\n    def __call__(self, func):\n        population = [np.random.uniform(self.lower_bound, self.upper_bound, self.dim) for _ in range(self.NP)]\n        fitness = [func(x) for x in population]\n        \n        for _ in range(self.budget):\n            trial_population = []\n            for i in range(self.NP):\n                random_indices = np.random.choice(range(self.NP), 3, replace=False)\n                x_r1, x_r2, x_r3 = population[random_indices]\n                x_mutant = self.mutation(x_r1, x_r2, x_r3)\n                trial = self.crossover(population[i], x_mutant)\n                f_trial = func(trial)\n                if f_trial < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = f_trial\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < func(best):\n                best = population[best_idx]\n        return best", "name": "DynamicEvolution", "description": "An optimized version of the Differential Evolution algorithm that utilizes a dynamic mutation strategy and a novel boundary handling technique to efficiently explore the search space and exploit promising regions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25eacfb6-9f5c-4e1d-b4f2-d6a40f24a86d", "metadata": {}, "mutation_prompt": null}
