{"id": "1b713f9e-28fb-4d5e-9534-c1d05981f739", "solution": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim, swarm_size=20, alpha=0.9, beta=0.999):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n\n    def __call__(self, func):\n        def pso_sa(func, budget, dim, swarm_size, alpha, beta):\n            def objective_function(x):\n                return func(x)\n\n            def initialize_swarm(dim, swarm_size):\n                return np.random.uniform(-5.0, 5.0, (swarm_size, dim)), np.full(swarm_size, np.inf)\n\n            swarm, best_position = initialize_swarm(dim, swarm_size)\n            best_value = np.inf\n\n            for _ in range(budget):\n                for i in range(swarm_size):\n                    candidate = swarm[i] + alpha * np.random.normal(0, 1, dim)\n                    candidate = np.clip(candidate, -5.0, 5.0)\n                    candidate_value = objective_function(candidate)\n                    if candidate_value < best_value:\n                        best_value = candidate_value\n                        best_position = candidate\n                    if candidate_value < best_position[i]:\n                        swarm[i] = candidate\n                        best_position[i] = candidate_value\n                    else:\n                        delta = candidate_value - best_position[i]\n                        acceptance_prob = np.exp(-delta / beta)\n                        if np.random.rand() < acceptance_prob:\n                            swarm[i] = candidate\n                            best_position[i] = candidate_value\n\n            return best_position\n\n        return pso_sa(func, self.budget, self.dim, self.swarm_size, self.alpha, self.beta)", "name": "PSO_SA_Optimizer", "description": "Novel metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 42, in __call__\n  File \"<string>\", line 30, in pso_sa\nIndexError: index 5 is out of bounds for axis 0 with size 5\n.", "error": "IndexError('index 5 is out of bounds for axis 0 with size 5')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 42, in __call__\n  File \"<string>\", line 30, in pso_sa\nIndexError: index 5 is out of bounds for axis 0 with size 5\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "5c8f830f-b095-4156-aeab-b2246fb65483", "solution": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim, swarm_size=20, alpha=0.9, beta=0.999):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.alpha = alpha\n        self.beta = beta\n\n    def __call__(self, func):\n        def pso_sa(func, budget, dim, swarm_size, alpha, beta):\n            def objective_function(x):\n                return func(x)\n\n            def initialize_swarm(dim, swarm_size):\n                return np.random.uniform(-5.0, 5.0, (swarm_size, dim)), np.full(swarm_size, np.inf)\n\n            swarm, best_position = initialize_swarm(dim, swarm_size)\n            best_value = np.inf\n\n            for _ in range(budget):\n                for i in range(swarm_size):\n                    candidate = swarm[i] + alpha * np.random.normal(0, 1, dim)\n                    candidate = np.clip(candidate, -5.0, 5.0)\n                    candidate_value = objective_function(candidate)\n                    if candidate_value < best_value:\n                        best_value = candidate_value\n                        best_position = candidate\n                    if candidate_value < best_position[i]:\n                        swarm[i] = candidate\n                        best_position[i] = candidate_value\n                    else:\n                        delta = candidate_value - best_position[i]\n                        acceptance_prob = np.exp(-delta / beta)\n                        if np.random.rand() < acceptance_prob:\n                            swarm[i] = candidate\n                            best_position[i] = candidate_value\n\n            return best_position\n\n        return pso_sa(func, self.budget, self.dim, self.swarm_size, self.alpha, self.beta)", "name": "PSO_SA_Optimizer", "description": "Novel metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1b713f9e-28fb-4d5e-9534-c1d05981f739", "metadata": {}, "mutation_prompt": null}
