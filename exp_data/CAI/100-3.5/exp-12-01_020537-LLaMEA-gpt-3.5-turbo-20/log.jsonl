{"id": "158cb506-e965-4104-93a9-2be3a57b045d", "solution": "import numpy as np\n\nclass HSAPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.low_bound = -5.0\n        self.up_bound = 5.0\n        self.HM_size = 20\n        self.HMCR = 0.7\n        self.PAR_min = 0.3\n        self.PAR_max = 0.9\n        self.bw_min = 0.01\n        self.bw_max = 1.0\n        self.adaptive_rate = 0.1\n\n    def harmony_search(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.low_bound, self.up_bound, (self.HM_size, self.dim))\n\n        def adjust_parameter(value, min_val, max_val, rate):\n            return max(min_val, min(max_val, value * (1 + np.random.uniform(-rate, rate)))\n\n        def evaluate_solution(solution):\n            return func(solution)\n\n        def improvise_new_solution():\n            new_solution = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.uniform(0, 1) < self.HMCR:\n                    new_solution[i] = self.harmony_memory[np.random.randint(self.HM_size)][i]\n                else:\n                    new_solution[i] = np.random.uniform(self.low_bound, self.up_bound)\n                    if np.random.uniform(0, 1) < self.PAR:\n                        new_solution[i] += np.random.uniform(-1, 1) * self.bandwidth\n            return new_solution\n\n        self.harmony_memory = initialize_harmony_memory()\n        self.PAR = self.PAR_max\n        self.bandwidth = self.bw_max\n\n        for _ in range(self.budget):\n            new_solution = improvise_new_solution()\n            new_solution_fitness = evaluate_solution(new_solution)\n\n            if new_solution_fitness < min(self.fitness_values):\n                min_index = np.argmin(self.fitness_values)\n                self.harmony_memory[min_index] = new_solution\n                self.fitness_values[min_index] = new_solution_fitness\n\n            self.PAR = adjust_parameter(self.PAR, self.PAR_min, self.PAR_max, self.adaptive_rate)\n            self.bandwidth = adjust_parameter(self.bandwidth, self.bw_min, self.bw_max, self.adaptive_rate)\n\n        best_index = np.argmin(self.fitness_values)\n        return self.harmony_memory[best_index]\n\n    def __call__(self, func):\n        self.fitness_values = [np.inf] * self.HM_size\n        return self.harmony_search(func)", "name": "HSAPA", "description": "A novel metaheuristic algorithm called Harmony Search with Adaptive Pitch Adjustment (HSAPA) that combines harmony search with adaptive pitch adjustment for solving black box optimization problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 24\n    def evaluate_solution(solution):\n    ^\nSyntaxError: invalid syntax\n.", "error": "SyntaxError('invalid syntax', ('<string>', 24, 9, '        def evaluate_solution(solution):\\n'))Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 24\n    def evaluate_solution(solution):\n    ^\nSyntaxError: invalid syntax\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "cd76db00-e1b7-4431-8bb2-c0d84484877c", "solution": "import numpy as np\n\nclass HSAPA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.low_bound = -5.0\n        self.up_bound = 5.0\n        self.HM_size = 20\n        self.HMCR = 0.7\n        self.PAR_min = 0.3\n        self.PAR_max = 0.9\n        self.bw_min = 0.01\n        self.bw_max = 1.0\n        self.adaptive_rate = 0.1\n\n    def harmony_search(self, func):\n        def initialize_harmony_memory():\n            return np.random.uniform(self.low_bound, self.up_bound, (self.HM_size, self.dim))\n\n        def adjust_parameter(value, min_val, max_val, rate):\n            return max(min_val, min(max_val, value * (1 + np.random.uniform(-rate, rate)))\n\n        def evaluate_solution(solution):\n            return func(solution)\n\n        def improvise_new_solution():\n            new_solution = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.uniform(0, 1) < self.HMCR:\n                    new_solution[i] = self.harmony_memory[np.random.randint(self.HM_size)][i]\n                else:\n                    new_solution[i] = np.random.uniform(self.low_bound, self.up_bound)\n                    if np.random.uniform(0, 1) < self.PAR:\n                        new_solution[i] += np.random.uniform(-1, 1) * self.bandwidth\n            return new_solution\n\n        self.harmony_memory = initialize_harmony_memory()\n        self.PAR = self.PAR_max\n        self.bandwidth = self.bw_max\n\n        for _ in range(self.budget):\n            new_solution = improvise_new_solution()\n            new_solution_fitness = evaluate_solution(new_solution)\n\n            if new_solution_fitness < min(self.fitness_values):\n                min_index = np.argmin(self.fitness_values)\n                self.harmony_memory[min_index] = new_solution\n                self.fitness_values[min_index] = new_solution_fitness\n\n            self.PAR = adjust_parameter(self.PAR, self.PAR_min, self.PAR_max, self.adaptive_rate)\n            self.bandwidth = adjust_parameter(self.bandwidth, self.bw_min, self.bw_max, self.adaptive_rate)\n\n            if np.random.uniform() < 0.1:  # Introduce dynamic bandwidth adjustment\n                self.bandwidth = np.clip(self.bandwidth * np.random.choice([0.9, 1.1]), self.bw_min, self.bw_max)\n\n        best_index = np.argmin(self.fitness_values)\n        return self.harmony_memory[best_index]\n\n    def __call__(self, func):\n        self.fitness_values = [np.inf] * self.HM_size\n        return self.harmony_search(func)", "name": "HSAPA", "description": "Enhance the Harmony Search with Adaptive Pitch Adjustment algorithm by incorporating dynamic band adjustment during the search process.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 24, 9, '        def evaluate_solution(solution):\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 24, 9, '        def evaluate_solution(solution):\\n'))", "parent_id": "158cb506-e965-4104-93a9-2be3a57b045d", "metadata": {}, "mutation_prompt": null}
