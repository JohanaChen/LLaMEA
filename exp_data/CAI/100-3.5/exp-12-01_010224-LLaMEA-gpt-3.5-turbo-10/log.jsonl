{"id": "ed67cb2c-30fc-4681-bce5-c0bff5307f31", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim, num_particles=30, omega=0.5, phi_p=0.5, phi_g=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = num_particles\n        self.omega = omega\n        self.phi_p = phi_p\n        self.phi_g = phi_g\n\n    def __call__(self, func):\n        def quantum_rotation(particle, global_best):\n            theta = np.arccos(np.dot(particle, global_best) / (np.linalg.norm(particle) * np.linalg.norm(global_best)))\n            rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n            return np.dot(rotation_matrix, particle)\n\n        def objective_function(x):\n            return func(x)\n\n        def initialize_particles():\n            return np.random.uniform(-5.0, 5.0, size=(self.num_particles, self.dim))\n\n        particles = initialize_particles()\n        best_particle = particles[np.argmin([objective_function(p) for p in particles])]\n        global_best = best_particle.copy()\n\n        for _ in range(self.budget):\n            for i in range(self.num_particles):\n                r_p, r_g = np.random.uniform(0, 1, size=2)\n                velocity = self.omega * particles[i] + self.phi_p * r_p * (best_particle - particles[i]) + self.phi_g * r_g * (global_best - particles[i])\n                particles[i] = quantum_rotation(velocity, global_best)\n                if objective_function(particles[i]) < objective_function(best_particle):\n                    best_particle = particles[i].copy()\n                if objective_function(particles[i]) < objective_function(global_best):\n                    global_best = particles[i].copy()\n\n        return global_best", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) algorithm that combines principles of quantum computing and particle swarm optimization to explore the search space efficiently and exploit global best solutions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 32, in __call__\n  File \"<string>\", line 16, in quantum_rotation\n  File \"<__array_function__ internals>\", line 200, in dot\nValueError: shapes (2,2) and (5,) not aligned: 2 (dim 1) != 5 (dim 0)\n.", "error": "ValueError('shapes (2,2) and (5,) not aligned: 2 (dim 1) != 5 (dim 0)')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 32, in __call__\n  File \"<string>\", line 16, in quantum_rotation\n  File \"<__array_function__ internals>\", line 200, in dot\nValueError: shapes (2,2) and (5,) not aligned: 2 (dim 1) != 5 (dim 0)\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "4ddc2cc6-20f5-461a-9387-9d083ff0d7ed", "solution": "import numpy as np\n\nclass QIPSO:\n    def __init__(self, budget, dim, num_particles=30, omega=0.5, phi_p=0.5, phi_g=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = num_particles\n        self.omega = omega\n        self.phi_p = phi_p\n        self.phi_g = phi_g\n\n    def __call__(self, func):\n        def quantum_rotation(particle, global_best):\n            theta = np.arccos(np.dot(particle, global_best) / (np.linalg.norm(particle) * np.linalg.norm(global_best)))\n            rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n            return np.dot(rotation_matrix, particle)\n\n        def objective_function(x):\n            return func(x)\n\n        def initialize_particles():\n            return np.random.uniform(-5.0, 5.0, size=(self.num_particles, self.dim))\n\n        particles = initialize_particles()\n        best_particle = particles[np.argmin([objective_function(p) for p in particles])]\n        global_best = best_particle.copy()\n\n        for _ in range(self.budget):\n            for i in range(self.num_particles):\n                r_p, r_g = np.random.uniform(0, 1, size=2)\n                velocity = self.omega * particles[i] + self.phi_p * r_p * (best_particle - particles[i]) + self.phi_g * r_g * (global_best - particles[i])\n                particles[i] = quantum_rotation(velocity, global_best)\n                if objective_function(particles[i]) < objective_function(best_particle):\n                    best_particle = particles[i].copy()\n                if objective_function(particles[i]) < objective_function(global_best):\n                    global_best = particles[i].copy()\n\n        return global_best", "name": "QIPSO", "description": "Quantum-Inspired Particle Swarm Optimization (QIPSO) algorithm that combines principles of quantum computing and particle swarm optimization to explore the search space efficiently and exploit global best solutions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ed67cb2c-30fc-4681-bce5-c0bff5307f31", "metadata": {}, "mutation_prompt": null}
