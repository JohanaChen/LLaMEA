{"id": "0f354e3d-e246-4962-839e-88c7e04f6b37", "solution": "import numpy as np\n\nclass PSO_DE:\n    def __init__(self, budget, dim, swarm_size=30, pso_w=0.5, pso_c1=1.5, pso_c2=1.5, de_f=0.8, de_cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.pso_w = pso_w\n        self.pso_c1 = pso_c1\n        self.pso_c2 = pso_c2\n        self.de_f = de_f\n        self.de_cr = de_cr\n\n    def __call__(self, func):\n        def evaluate_particle(particle):\n            return func(particle)\n\n        def initialize_swarm():\n            return np.random.uniform(-5.0, 5.0, size=(self.swarm_size, self.dim))\n\n        def optimize_swarm(swarm):\n            for i in range(self.budget):\n                for idx, particle in enumerate(swarm):\n                    p_best = swarm[np.argmin([evaluate_particle(p) for p in swarm])]\n                    g_best = p_best if evaluate_particle(p_best) < evaluate_particle(swarm[idx]) else swarm[idx]\n\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    new_velocity = self.pso_w * swarm[idx] + self.pso_c1 * r1 * (p_best - swarm[idx]) + self.pso_c2 * r2 * (g_best - swarm[idx])\n\n                    mutant = swarm[np.random.choice(np.delete(np.arange(self.swarm_size), idx, 0), 3, replace=False)]\n                    trial = swarm[idx] + self.de_f * (mutant[0] - mutant[1]) + self.de_f * (mutant[2] - mutant[3])\n\n                    crossover_mask = np.random.rand(self.dim) < self.de_cr\n                    swarm[idx] = np.where(crossover_mask, trial, new_velocity)\n\n            return swarm[np.argmin([evaluate_particle(p) for p in swarm])]\n\n        swarm = initialize_swarm()\n        return optimize_swarm(swarm)", "name": "PSO_DE", "description": "Metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to explore and exploit search space efficiently.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 39, in __call__\n  File \"<string>\", line 31, in optimize_swarm\nIndexError: index 3 is out of bounds for axis 0 with size 3\n.", "error": "IndexError('index 3 is out of bounds for axis 0 with size 3')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 39, in __call__\n  File \"<string>\", line 31, in optimize_swarm\nIndexError: index 3 is out of bounds for axis 0 with size 3\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "b0640cef-228d-419e-8dfb-81a97c24a8ce", "solution": "import numpy as np\n\nclass PSO_DE:\n    def __init__(self, budget, dim, swarm_size=30, pso_w=0.5, pso_c1=1.5, pso_c2=1.5, de_f=0.8, de_cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.pso_w = pso_w\n        self.pso_c1 = pso_c1\n        self.pso_c2 = pso_c2\n        self.de_f = de_f\n        self.de_cr = de_cr\n\n    def __call__(self, func):\n        def evaluate_particle(particle):\n            return func(particle)\n\n        def initialize_swarm():\n            return np.random.uniform(-5.0, 5.0, size=(self.swarm_size, self.dim))\n\n        def optimize_swarm(swarm):\n            for i in range(self.budget):\n                for idx, particle in enumerate(swarm):\n                    p_best = swarm[np.argmin([evaluate_particle(p) for p in swarm])]\n                    g_best = p_best if evaluate_particle(p_best) < evaluate_particle(swarm[idx]) else swarm[idx]\n\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    new_velocity = self.pso_w * swarm[idx] + self.pso_c1 * r1 * (p_best - swarm[idx]) + self.pso_c2 * r2 * (g_best - swarm[idx])\n\n                    mutant = swarm[np.random.choice(np.delete(np.arange(self.swarm_size), idx, 0), 3, replace=False)]\n                    trial = swarm[idx] + self.de_f * (mutant[0] - mutant[1]) + self.de_f * (mutant[2] - mutant[3])\n\n                    crossover_mask = np.random.rand(self.dim) < self.de_cr\n                    swarm[idx] = np.where(crossover_mask, trial, new_velocity)\n\n            return swarm[np.argmin([evaluate_particle(p) for p in swarm])]\n\n        swarm = initialize_swarm()\n        return optimize_swarm(swarm)", "name": "PSO_DE", "description": "Metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to explore and exploit search space efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0f354e3d-e246-4962-839e-88c7e04f6b37", "metadata": {}, "mutation_prompt": null}
