{"id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)  # Adaptive population size\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8   # Differential weight\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic sequence generation\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:  # Ensure unique parents\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx], fitness[idx]\n\n    def mutate(self, target_idx, bounds, population):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        target = population[target_idx]\n        mutant_vector = population[a] + self.F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        # Initialize chaotic sequences\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        # Initialize population\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population)\n                trial = self.crossover(target, mutant)\n\n                # Enhance trial vector with chaotic sequence\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDifferentialEvolutionWithChaos", "description": "Adaptive Differential Evolution with Chaos-enhanced Mutation integrates chaotic sequences to enhance diversity and adaptively tunes parameters for robust black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.06499023218764732, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.065 with standard deviation 0.003. And the mean value of best solutions found was 0.273 (0. is the best).", "error": "", "parent_id": null, "metadata": {"aucs": [0.06826954213625103, 0.06561187391285106, 0.06108928051383988], "final_y": [0.2693846761138875, 0.2752479653863996, 0.2735441811631866]}, "mutation_prompt": null}
{"id": "6a5e4923-0173-417c-9759-b65b1ac2ad12", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.alpha = 0.5  # Entanglement parameter\n        self.beta = 0.05  # Mutation rate\n        self.current_evaluations = 0\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def quantum_superposition(self, population):\n        q_population = np.cos(population) + 1j * np.sin(population)\n        return q_population\n\n    def collapse_wave_function(self, q_population, bounds):\n        angles = np.angle(q_population)\n        real_population = (angles / (2 * np.pi)) * (bounds.ub - bounds.lb) + bounds.lb\n        return np.real(real_population)\n\n    def entangle(self, q_population):\n        num_pairs = self.population_size // 2\n        indices = np.random.permutation(self.population_size)\n        for i in range(num_pairs):\n            idx1, idx2 = indices[2*i], indices[2*i + 1]\n            phi = 2 * np.pi * np.random.rand()\n            q_population[idx1] = self.alpha * q_population[idx1] + (1 - self.alpha) * np.exp(1j * phi) * q_population[idx2]\n            q_population[idx2] = self.alpha * q_population[idx2] + (1 - self.alpha) * np.exp(-1j * phi) * q_population[idx1]\n        return q_population\n\n    def mutate(self, q_population):\n        mutation_mask = np.random.rand(self.population_size, self.dim) < self.beta\n        q_population[mutation_mask] *= np.exp(1j * np.pi * (2 * np.random.rand() - 1))\n        return q_population\n\n    def optimize(self, func, bounds):\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n        \n        q_population = self.quantum_superposition(population)\n\n        while self.current_evaluations < self.budget:\n            q_population = self.entangle(q_population)\n            q_population = self.mutate(q_population)\n\n            population = self.collapse_wave_function(q_population, bounds)\n            new_fitness = self.evaluate(func, population)\n\n            better = new_fitness < fitness\n            fitness[better] = new_fitness[better]\n            population[better] = population[better]\n\n            if self.current_evaluations >= self.budget:\n                break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "QuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-inspired Evolutionary Algorithm uses quantum superposition and entanglement principles to explore and exploit the search space efficiently in black-box optimization tasks.", "configspace": "", "generation": 1, "fitness": 0.04887903728920432, "feedback": "The algorithm QuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.049 with standard deviation 0.001. And the mean value of best solutions found was 0.404 (0. is the best).", "error": "", "parent_id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "metadata": {"aucs": [0.048774380295480646, 0.04796023551767703, 0.04990249605445529], "final_y": [0.4073425911909888, 0.41379549904142643, 0.3912955772983081]}, "mutation_prompt": null}
{"id": "96e1774d-9d4d-455c-8de1-41a0f72ae304", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)  # Adaptive population size\n        self.CR = 0.9  # Initial crossover probability\n        self.F = 0.8   # Differential weight\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic sequence generation\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:  # Ensure unique parents\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx], fitness[idx]\n\n    def mutate(self, target_idx, bounds, population):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        target = population[target_idx]\n        mutant_vector = population[a] + self.F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        # Initialize chaotic sequences\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        # Initialize population\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population)\n                trial = self.crossover(target, mutant)\n\n                # Enhance trial vector with chaotic sequence\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                    self.CR = min(1.0, self.CR + 0.01)  # Dynamic adaptation\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDifferentialEvolutionWithChaos", "description": "Enhanced Adaptive Differential Evolution with Chaotic Mutation incorporates a dynamic crossover probability for improved exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.06434990559123159, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.064 with standard deviation 0.001. And the mean value of best solutions found was 0.263 (0. is the best).", "error": "", "parent_id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "metadata": {"aucs": [0.06557997133735438, 0.06463864998651003, 0.06283109544983034], "final_y": [0.2394793634328053, 0.244255158194013, 0.3042258470685427]}, "mutation_prompt": null}
{"id": "5cd210f7-523c-4d58-847e-38b1237ce8af", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)  # Adaptive population size\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.85  # Tuned differential weight\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Enhanced chaotic sequence generation using a Tent map\n        return 2.0 * x if x < 0.5 else 2.0 * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:  # Ensure unique parents\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx], fitness[idx]\n\n    def mutate(self, target_idx, bounds, population):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        target = population[target_idx]\n        mutant_vector = population[a] + self.F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        # Initialize chaotic sequences\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        # Initialize population\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population)\n                trial = self.crossover(target, mutant)\n\n                # Enhance trial vector with chaotic sequence\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDifferentialEvolutionWithChaos", "description": "Adaptive Differential Evolution with Chaos-enhanced Mutation now uses an enhanced chaotic map and tuned differential weight for improved exploration.", "configspace": "", "generation": 3, "fitness": 0.06287464271321357, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.063 with standard deviation 0.002. And the mean value of best solutions found was 0.261 (0. is the best).", "error": "", "parent_id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "metadata": {"aucs": [0.06300525357126985, 0.06472921377643781, 0.060889460791933026], "final_y": [0.2703544633704985, 0.23791973586878679, 0.2753481516266504]}, "mutation_prompt": null}
{"id": "f5f10be8-6541-49f3-9440-703a307daba7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)  # Adaptive population size\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8   # Differential weight\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic sequence generation\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:  # Ensure unique parents\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx], fitness[idx]\n\n    def mutate(self, target_idx, bounds, population):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        target = population[target_idx]\n        mutant_vector = population[a] + self.F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        # Initialize chaotic sequences\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        # Initialize population\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population)\n                trial = self.crossover(target, mutant)\n\n                # Enhance trial vector with chaotic sequence\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.05\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDifferentialEvolutionWithChaos", "description": "Improved Adaptive Differential Evolution with Chaos, adjusting the chaotic influence scale for enhanced exploration.", "configspace": "", "generation": 4, "fitness": 0.06450183626828498, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.065 with standard deviation 0.003. And the mean value of best solutions found was 0.259 (0. is the best).", "error": "", "parent_id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "metadata": {"aucs": [0.061855030411318124, 0.06855318327263227, 0.06309729512090456], "final_y": [0.25530539991094536, 0.25948158823178236, 0.2607483836002428]}, "mutation_prompt": null}
{"id": "70cb386d-fb17-4d58-ae66-f2fb4e3b3bbb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)  # Adaptive population size\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8   # Differential weight\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic sequence generation\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:  # Ensure unique parents\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx], fitness[idx]\n\n    def mutate(self, target_idx, bounds, population):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        target = population[target_idx]\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        mutant_vector = population[a] + chaotic_factor * self.F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        # Initialize chaotic sequences\n        chaotic_sequence = np.random.rand(self.population_size)\n\n        # Initialize population\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population)\n                trial = self.crossover(target, mutant)\n\n                # Enhance trial vector with chaotic sequence\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDifferentialEvolutionWithChaos", "description": "Chaotic Mutation Boost introduces periodic mutation scaling adjustments based on chaotic sequences to prevent premature convergence and enhance exploration.", "configspace": "", "generation": 5, "fitness": 0.06570591268010406, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.066 with standard deviation 0.003. And the mean value of best solutions found was 0.268 (0. is the best).", "error": "", "parent_id": "7955382e-7416-44e8-9b1f-01e8ea06b942", "metadata": {"aucs": [0.0628111117086384, 0.07010297343042204, 0.06420365290125174], "final_y": [0.28293922253862813, 0.24448498152884868, 0.277173599911135]}, "mutation_prompt": null}
{"id": "6d3229ea-1d74-41e9-b014-6183776d4a74", "solution": "import numpy as np\n\nclass AdaptiveDynamicScalingWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDynamicScalingWithChaos", "description": "Adaptive Dynamic Scaling (ADS) enhances exploration by dynamically adjusting the differential weight and crossover rate based on population diversity and incorporates a chaotic sequence for refining exploitation.", "configspace": "", "generation": 6, "fitness": 0.06810935966589342, "feedback": "The algorithm AdaptiveDynamicScalingWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.068 with standard deviation 0.003. And the mean value of best solutions found was 0.259 (0. is the best).", "error": "", "parent_id": "70cb386d-fb17-4d58-ae66-f2fb4e3b3bbb", "metadata": {"aucs": [0.07245355239118612, 0.06642313014094126, 0.06545139646555287], "final_y": [0.22431993301647768, 0.2753400274480222, 0.2782478376201173]}, "mutation_prompt": null}
{"id": "08c26859-358f-4e60-a277-5b57b34befae", "solution": "import numpy as np\nimport scipy.stats\n\nclass AdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * 0.01\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveDynamicScalingWithLevyFlight", "description": "Adaptive Dynamic Scaling with Lévy Flight (ADS-LF) integrates Lévy Flight for enhanced exploration and adapts local search strategies based on population diversity.", "configspace": "", "generation": 7, "fitness": 0.07259823580394036, "feedback": "The algorithm AdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.073 with standard deviation 0.002. And the mean value of best solutions found was 0.234 (0. is the best).", "error": "", "parent_id": "6d3229ea-1d74-41e9-b014-6183776d4a74", "metadata": {"aucs": [0.0730587402424453, 0.07435116556557864, 0.07038480160379712], "final_y": [0.2400237915248844, 0.21317361594944562, 0.24915412559327166]}, "mutation_prompt": null}
{"id": "82cbf458-6729-4210-970f-c72a3b79b0ad", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced ADS-LF with random scaling factor and adaptive crossover for improved convergence.", "configspace": "", "generation": 8, "fitness": 0.07365718736542885, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.074 with standard deviation 0.005. And the mean value of best solutions found was 0.238 (0. is the best).", "error": "", "parent_id": "08c26859-358f-4e60-a277-5b57b34befae", "metadata": {"aucs": [0.08039130170835829, 0.07192821549387352, 0.06865204489405474], "final_y": [0.2171875330708437, 0.2391671803254365, 0.25848486498864376]}, "mutation_prompt": null}
{"id": "6b00528a-5904-44b3-af82-4a44cbd0c154", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)\n        chaotic_factor_b = 0.5 + 0.5 * self.chaotic_map(population[b].sum())\n        mutant_vector = population[a] + adaptive_F * chaotic_factor_b * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=np.random.uniform(0.01, 0.02))\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced ADS-LF with chaotic differential mutation and adaptive Levy scaling for improved convergence.", "configspace": "", "generation": 9, "fitness": 0.04860315746028706, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.049 with standard deviation 0.000. And the mean value of best solutions found was 0.409 (0. is the best).", "error": "", "parent_id": "82cbf458-6729-4210-970f-c72a3b79b0ad", "metadata": {"aucs": [0.04876568152448779, 0.04796365155541349, 0.04908013930095989], "final_y": [0.4073425911909888, 0.41379549904142643, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "d6fa5431-428b-4a08-9890-ea5dfd8f5f98", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        logistic_perturbation = 0.05 * (4 * np.random.rand() * (1 - np.random.rand()))  # New line\n        mutant_vector += levy_step + logistic_perturbation  # Modified line\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduced adaptive perturbation using logistic map for enhanced exploration in mutation step.", "configspace": "", "generation": 10, "fitness": 0.06991402340973174, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.070 with standard deviation 0.008. And the mean value of best solutions found was 0.264 (0. is the best).", "error": "", "parent_id": "82cbf458-6729-4210-970f-c72a3b79b0ad", "metadata": {"aucs": [0.08065172418044764, 0.06601716869071328, 0.0630731773580343], "final_y": [0.21280576687939012, 0.2818783963426704, 0.2960708304742903]}, "mutation_prompt": null}
{"id": "2c8887bb-ae39-45c5-9ed0-02152cc6b700", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step + np.random.normal(0, 0.01, self.dim)  # Gaussian mutation\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced ADS-LF with chaotic selection, adaptive scaling, and Gaussian mutation for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.06990604502085355, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.070 with standard deviation 0.007. And the mean value of best solutions found was 0.262 (0. is the best).", "error": "", "parent_id": "82cbf458-6729-4210-970f-c72a3b79b0ad", "metadata": {"aucs": [0.0794603825782686, 0.06582106606515248, 0.06443668641913958], "final_y": [0.21427213035455506, 0.28328177758679596, 0.2881766635828642]}, "mutation_prompt": null}
{"id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce stochastic crossover rate adjustment to enhance exploration in the Enhanced ADS-LF algorithm.", "configspace": "", "generation": 12, "fitness": 0.0810160841696373, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.081 with standard deviation 0.007. And the mean value of best solutions found was 0.199 (0. is the best).", "error": "", "parent_id": "82cbf458-6729-4210-970f-c72a3b79b0ad", "metadata": {"aucs": [0.0737570672289003, 0.08954763972025082, 0.07974354555976082], "final_y": [0.2339494931969398, 0.17335491188049756, 0.18857228118975322]}, "mutation_prompt": null}
{"id": "38adeefb-6fb6-477a-b228-4a0aaa9ae7ac", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        # Change 1: Introduce dynamic scaling based on remaining budget\n        dynamic_scale = scale * (1 - self.current_evaluations / self.budget)\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=dynamic_scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        # Change 2: Enhance chaotic factor with a different random range\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.2 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce dynamic scaling for Levy flight to balance exploration and exploitation in Enhanced ADS-LF.", "configspace": "", "generation": 13, "fitness": 0.07639855760620977, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.076 with standard deviation 0.010. And the mean value of best solutions found was 0.225 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.07384346203703807, 0.08910310616860972, 0.0662491046129815], "final_y": [0.23035741592138925, 0.17460057197570567, 0.2703757964415252]}, "mutation_prompt": null}
{"id": "770234c2-3ea9-4f04-b1bc-cd9273badc0e", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand()) * np.random.uniform(0.5, 1.5)  # Line changed\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce a dynamic adjustment to the chaotic factor for improved balancing of exploration and exploitation.", "configspace": "", "generation": 14, "fitness": 0.0761971831616441, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.076 with standard deviation 0.007. And the mean value of best solutions found was 0.229 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.08513591286908628, 0.06895797833547368, 0.07449765828037236], "final_y": [0.1979182007080632, 0.2624695386610708, 0.2254516509930301]}, "mutation_prompt": null}
{"id": "83c43694-1fed-41b6-8c68-f2069250ff47", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.88, 1.12)  # Stochastic crossover adjustment (changed line)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Slightly increase the stochastic crossover adjustment range to boost exploitation in local regions.", "configspace": "", "generation": 15, "fitness": 0.07484518983479034, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.075 with standard deviation 0.006. And the mean value of best solutions found was 0.228 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.07387268549490489, 0.08277543538083554, 0.06788744862863061], "final_y": [0.2297171597509695, 0.18751118663998678, 0.265504736547584]}, "mutation_prompt": null}
{"id": "67735f45-492b-4e2d-9f2f-03f1f157ef82", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size) * 0.5 + 0.5  # Updated scaling\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improve solution quality by introducing a diversity-based scaling factor in mutation and updating initial chaotic sequence.", "configspace": "", "generation": 16, "fitness": 0.0766461766885781, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.077 with standard deviation 0.007. And the mean value of best solutions found was 0.213 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.07183239871976965, 0.0868610715017416, 0.07124505984422302], "final_y": [0.23438637386777395, 0.17863538344622154, 0.2274085631763343]}, "mutation_prompt": null}
{"id": "16df83e9-6224-482f-9b12-3e975fbbd84f", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        chaotic_mutation = self.chaotic_map(np.random.rand(self.dim)) * (bounds.ub - bounds.lb) * 0.02\n        mutant_vector += chaotic_mutation # Line changed\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Integrate an adaptive mutation operator using chaos theory to enhance exploration and diversity control.", "configspace": "", "generation": 17, "fitness": 0.0786471663471255, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.079 with standard deviation 0.003. And the mean value of best solutions found was 0.219 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.08261127237318977, 0.07727099761523937, 0.07605922905294737], "final_y": [0.20311366945135978, 0.2246806831478655, 0.2284309188874044]}, "mutation_prompt": null}
{"id": "d2b97359-ccb5-4b26-8177-be7c0d64cf9d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def local_search(self, individual, bounds):\n        perturbation = np.random.normal(0, 0.01, size=self.dim)\n        new_individual = individual + perturbation\n        new_individual = np.clip(new_individual, bounds.lb, bounds.ub)\n        return new_individual\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity)\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                if np.random.rand() < 0.2:  # 20% chance for local search\n                    trial = self.local_search(trial, bounds)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce adaptive local search using Gaussian perturbation to enhance local exploitation and refine solutions in the Enhanced ADS-LF algorithm.", "configspace": "", "generation": 18, "fitness": 0.07742409367436946, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.077 with standard deviation 0.007. And the mean value of best solutions found was 0.221 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.0864055567263291, 0.07693747426344599, 0.06892925003333328], "final_y": [0.1770872623890153, 0.22766078059488337, 0.258002967108106]}, "mutation_prompt": null}
{"id": "3b8953c9-02ce-4191-ab09-c99870905051", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce a nonlinear diversity factor adjustment to enhance convergence in the Enhanced ADS-LF algorithm.", "configspace": "", "generation": 19, "fitness": 0.08988981081749366, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.003. And the mean value of best solutions found was 0.172 (0. is the best).", "error": "", "parent_id": "589c72b6-dbff-4fef-8362-7fcf726bb5cd", "metadata": {"aucs": [0.09202709789782404, 0.0922583417499151, 0.08538399280474185], "final_y": [0.16683764327171502, 0.16959753855693016, 0.1802579367404754]}, "mutation_prompt": null}
{"id": "b143be08-7a86-42ae-94da-6149b6586376", "solution": "import numpy as np\nimport scipy.stats\n\nclass QuantumInspiredDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Slightly larger population\n        self.CR = 0.85  # Adjusted crossover rate\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_variation(self, lower, upper):\n        return lower + (upper - lower) * np.sin(np.random.rand(self.dim) * np.pi)\n\n    def levy_flight(self, scale=0.02):  # Adjusted Levy flight scale\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * ((1.0 - diversity_factor) ** 2)  # Smooth diversity control\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        quantum_step = self.quantum_variation(bounds.lb, bounds.ub)\n        mutant_vector += 0.3 * quantum_step  # Quantum-inspired variation\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.15 * (1.0 - diversity_factor)  # More responsive CR\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.exp(-diversity))  # Smooth sigmoid adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = 0.9 * chaotic_sequence[i] + 0.1 * np.random.rand()\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "QuantumInspiredDynamicScalingWithLevyFlight", "description": "Introduce quantum-inspired variation and enhanced mutation strategies with a smooth diversity management for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.06648871049192147, "feedback": "The algorithm QuantumInspiredDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.066 with standard deviation 0.004. And the mean value of best solutions found was 0.282 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.06937096343988947, 0.06036013311814736, 0.06973503491772759], "final_y": [0.2760969766879606, 0.30277751239359063, 0.26853111247923733]}, "mutation_prompt": null}
{"id": "ba1aad95-ea6c-4b89-a606-4f87f2bef4e5", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.5, 1.5)  # Changed scaling range for dynamic adjustment\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.85, 1.15)  # Adjusted stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n        \n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.005, 0.025)  # Adjusted chaotic step\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n            \n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce self-adaptive control parameters and incorporate a balanced chaos strategy to enhance convergence and diversity.", "configspace": "", "generation": 21, "fitness": 0.0886238986257351, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.089 with standard deviation 0.003. And the mean value of best solutions found was 0.174 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.09059324362202192, 0.09074730673537013, 0.08453114551981322], "final_y": [0.16824795315386376, 0.16770742172839992, 0.18621224029331862]}, "mutation_prompt": null}
{"id": "ca96891e-ee4f-4ae4-817c-911d3a2dcf39", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Increased population size for diversity\n        self.CR = 0.85  # Adjusted crossover rate\n        self.F = 0.7  # Adjusted differential weight factor\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.02):  # Adjusted scale for more exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.3, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 4, replace=False)  # Select 4 for better diversity\n        while len(set(idx)) < 4:\n            idx = np.random.choice(len(population), 4, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c, d = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 4, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.3)  # More variability in scaling\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c] + population[d] - population[a])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.15 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.85, 1.15)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + diversity**2)  # More pronounced nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.015, 0.025)  # Slightly adjusted perturbation\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Utilize environment-adaptive search intensification and diversification strategies to enhance convergence in the EADS-LF algorithm for photonic structures.", "configspace": "", "generation": 22, "fitness": 0.07890313955118018, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.079 with standard deviation 0.008. And the mean value of best solutions found was 0.212 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.08819404083049054, 0.07948038210384434, 0.06903499571920568], "final_y": [0.17861224134330433, 0.207174089083765, 0.2501928148556851]}, "mutation_prompt": null}
{"id": "1ff8f2e4-5319-42f9-8596-c96806d1d619", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        dynamic_F = self.F * (1 + np.log(1 + diversity_factor))\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = dynamic_F * chaotic_factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1 + 0.1 * diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce dynamic scaling of `F` based on population diversity and adaptive crossover to improve exploration-exploitation balance in Enhanced ADS-LF.", "configspace": "", "generation": 23, "fitness": 0.0631782690705072, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.063 with standard deviation 0.002. And the mean value of best solutions found was 0.269 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.06557342490731133, 0.06008407037617458, 0.0638773119280357], "final_y": [0.2379668287858946, 0.27664453824355295, 0.2913064994134835]}, "mutation_prompt": null}
{"id": "a05fcdac-cd03-4e09-b5f1-63f4159a0322", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial + np.random.normal(0, 0.001, self.dim))  # Perturbation added\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce a small random perturbation in the trial vector to enhance exploration capabilities.", "configspace": "", "generation": 24, "fitness": 0.08686112436663913, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.004. And the mean value of best solutions found was 0.180 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.09077593905030967, 0.08086634042996432, 0.08894109361964342], "final_y": [0.16803208891799581, 0.20102956742186584, 0.17057983716767877]}, "mutation_prompt": null}
{"id": "0752cc49-9553-4472-9d12-5be55652b3a7", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 120)  # Slight increase to 120\n        self.CR = 0.85  # Slight reduction in crossover rate\n        self.F = 0.7  # Reduced scaling factor for diversity\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.02):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.2 * self.chaotic_map(np.random.rand())  # Increased chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.7, 1.3)  # Wider random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        neighborhood_factor = (population[target_idx] - mutant_vector) * 0.05  # Neighborhood exploration\n        mutant_vector += neighborhood_factor\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.15 * (1.0 - diversity_factor)  # Slightly increased CR variation\n        adaptive_CR *= np.random.uniform(0.85, 1.15)  # Broader stochastic adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Nonlinear adjustment\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.015, 0.025)  # Enhanced random scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Combine nonlinear diversity adjustment with chaos-enhanced dynamic mutation and neighborhood exploration for robust optimization.", "configspace": "", "generation": 25, "fitness": 0.08926700933724833, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.089 with standard deviation 0.003. And the mean value of best solutions found was 0.175 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.0908028142726125, 0.08546334034141179, 0.0915348733977207], "final_y": [0.17316305361338458, 0.18499739150765648, 0.1662327272811589]}, "mutation_prompt": null}
{"id": "f725c8fe-bc09-4d7c-a196-f3baaa159b42", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight()\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity)) * np.random.uniform(0.9, 1.1)  # Nonlinear adjustment with stochastic weighting\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce stochastic weighting in the diversity factor for enhanced exploration.", "configspace": "", "generation": 26, "fitness": 0.08786398754457352, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.088 with standard deviation 0.002. And the mean value of best solutions found was 0.180 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.08969541181377061, 0.08912209030039653, 0.0847744605195534], "final_y": [0.176512783137186, 0.1773064742786855, 0.18633084506420117]}, "mutation_prompt": null}
{"id": "e7c16ab0-f519-4149-b5fe-e0753d622275", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithOppositionalLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        inertial_weight = 0.5 + np.random.rand() * 0.5  # adaptive inertia\n        adaptive_F *= np.random.uniform(0.8, 1.2)\n        mutant_vector = inertial_weight * population[a] + adaptive_F * (population[b] - population[c])\n        \n        # Oppositional learning\n        opposite_vector = bounds.lb + bounds.ub - mutant_vector\n        levy_step = self.levy_flight()\n        mutant_vector = np.clip(mutant_vector + levy_step, bounds.lb, bounds.ub)\n        \n        # Choose better between mutant and opposite vector\n        mutant_fitness = func(mutant_vector)\n        opposite_fitness = func(opposite_vector)\n        self.current_evaluations += 2\n        \n        if opposite_fitness < mutant_fitness:\n            mutant_vector = opposite_vector\n        \n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithOppositionalLearning", "description": "Introduce a dynamic mutation strategy with adaptive inertia and oppositional learning to enhance exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {}, "mutation_prompt": null}
{"id": "674a25ce-bae9-4a3c-95cb-d666e846358d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_perturbation(self, scale=0.01):\n        return np.random.normal(0, scale, self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def select_parents(self, population, fitness):\n        idx = np.random.choice(len(population), 3, replace=False)\n        while len(set(idx)) < 3:\n            idx = np.random.choice(len(population), 3, replace=False)\n        return population[idx]\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  \n\n        # Introduce an adaptive learning factor\n        learning_factor = (np.random.rand() + diversity_factor) / 2\n        mutant_vector = (1 - learning_factor) * population[a] + learning_factor * (population[b] - population[c])\n        \n        levy_step = self.levy_flight()\n        gaussian_step = self.gaussian_perturbation(scale=0.005)  # Gaussian perturbation\n        mutant_vector += levy_step + gaussian_step\n\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR + 0.1 * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.9, 1.1)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial = trial + chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce adaptive learning factors and a Gaussian perturbation to improve convergence in Enhanced ADS-LF.", "configspace": "", "generation": 28, "fitness": 0.07517145616550198, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.075 with standard deviation 0.003. And the mean value of best solutions found was 0.229 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.07809155044410576, 0.0708862534781427, 0.0765365645742575], "final_y": [0.223750210355382, 0.2471933182363134, 0.21489266466283197]}, "mutation_prompt": null}
{"id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved diversity and local search efficiency using adaptive differential mutation and dynamic crossover strategies.", "configspace": "", "generation": 29, "fitness": 0.0923201971361312, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "3b8953c9-02ce-4191-ab09-c99870905051", "metadata": {"aucs": [0.0912599829653098, 0.09274547696465929, 0.09295513147842449], "final_y": [0.16583475900177125, 0.16555915424345846, 0.16524405421844923]}, "mutation_prompt": null}
{"id": "d04837ba-619e-4a3b-a46f-1e35c360fdc0", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        inertia_weight = 0.5 + 0.5 * np.random.rand()  # Adaptive inertia weight\n        mutant_vector = inertia_weight * (population[a] + adaptive_F * (population[b] - population[c]))\n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        quantum_factor = np.random.rand(self.dim)  # Quantum-inspired component\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant + quantum_factor * (mutant - target), target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduced adaptive inertia weight and quantum-inspired crossover to improve exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.06484885846221944, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.065 with standard deviation 0.004. And the mean value of best solutions found was 0.261 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0707649650012383, 0.06025319049682276, 0.06352841988859725], "final_y": [0.24291527318449824, 0.2702476677689698, 0.2712434065189403]}, "mutation_prompt": null}
{"id": "08135194-ee1e-4fc2-9a63-6dd89311fafa", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithOpposition:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def opposition_based_learning(self, individual, bounds):\n        center = (bounds.lb + bounds.ub) / 2\n        return bounds.lb + bounds.ub - individual\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                \n                # Opposition-based learning\n                opposite = self.opposition_based_learning(trial, bounds)\n                opposite_fitness = func(opposite)\n                self.current_evaluations += 1\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i] and trial_fitness < opposite_fitness:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                elif opposite_fitness < fitness[i]:\n                    new_population.append(opposite)\n                    new_fitness.append(opposite_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithOpposition", "description": "Enhanced exploration and exploitation balance using opposition-based learning and chaotic maps for improved convergence.", "configspace": "", "generation": 31, "fitness": 0.08643033972489471, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithOpposition got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.086 with standard deviation 0.001. And the mean value of best solutions found was 0.168 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08544468015029194, 0.08584843851390034, 0.08799790051049183], "final_y": [0.1696384064176807, 0.16744761131522956, 0.16680344387447799]}, "mutation_prompt": null}
{"id": "a9b7b213-2446-4521-969d-22f421abcbb5", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.05, 0.1)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved exploration by adjusting the scale of the chaotic sequence, enhancing global search capability.", "configspace": "", "generation": 32, "fitness": 0.08580034331125881, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.086 with standard deviation 0.004. And the mean value of best solutions found was 0.176 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08824307088646999, 0.08077865472815848, 0.08837930431914798], "final_y": [0.16920562756657043, 0.18723132875441695, 0.17095609265869227]}, "mutation_prompt": null}
{"id": "717bd00f-52aa-4bf8-9653-be8eb78bf5d5", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.03)  # Slightly increased scale for exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.04)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced adaptive diversity and exploration leveraging chaotic maps and Levy flights for robust optimization.", "configspace": "", "generation": 33, "fitness": 0.09070969719900772, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09019549012339789, 0.09024515103813957, 0.09168845043548568], "final_y": [0.1658692342189484, 0.16628514528139615, 0.16585832613261253]}, "mutation_prompt": null}
{"id": "ec7029b2-a547-4e1a-9a10-a8aaadcb16b7", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.8 * x * (1.0 - x)  # Adjusted chaotic map parameter for different dynamics\n\n    def levy_flight(self, scale=0.015):  # Adjusted levy scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced diversity and exploration by tweaking chaotic map influence and levy scale.", "configspace": "", "generation": 34, "fitness": 0.08995377550059196, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.002. And the mean value of best solutions found was 0.169 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09096331919598599, 0.08755083087602411, 0.09134717642976575], "final_y": [0.16732389141755155, 0.17182177363089812, 0.16671981152012283]}, "mutation_prompt": null}
{"id": "6bcde0f0-da66-473c-b6f7-1996cdcadc49", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved diversity and local search efficiency using adaptive differential mutation and dynamic crossover strategies.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0912599829653098, 0.09274547696465929, 0.09295513147842449], "final_y": [0.16583475900177125, 0.16555915424345846, 0.16524405421844923]}, "mutation_prompt": null}
{"id": "ff11d987-9745-41a0-afc4-50af14629937", "solution": "import numpy as np\nimport scipy.stats\n\nclass AdvancedDynamicScalingWithChaoticLevySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.02):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdvancedDynamicScalingWithChaoticLevySearch", "description": "Enhanced exploration and exploitation using chaotic maps, Levy flights, and adaptive control parameters for diversity and convergence.", "configspace": "", "generation": 36, "fitness": 0.0923201971361312, "feedback": "The algorithm AdvancedDynamicScalingWithChaoticLevySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0912599829653098, 0.09274547696465929, 0.09295513147842449], "final_y": [0.16583475900177125, 0.16555915424345846, 0.16524405421844923]}, "mutation_prompt": null}
{"id": "a3d17150-967a-4917-b383-ddbb2732fe3c", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.8 * x * (1.0 - x)  # Adjusted from 4.0 to 3.8 for better global exploration\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=0.03, size=self.dim)  # Increased scale for better exploration\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced local search by adjusting chaotic map scaling and increasing Levy flight exploration.", "configspace": "", "generation": 37, "fitness": 0.09012138602984143, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.001. And the mean value of best solutions found was 0.169 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09136022655091625, 0.08833170951170144, 0.09067222202690661], "final_y": [0.16602351820326033, 0.17113589416595976, 0.1693871697875804]}, "mutation_prompt": null}
{"id": "510b2e35-5b6d-4b0c-9a12-2eefc6b2cb8b", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.57 * x * (1.0 - x)  # Modified chaotic map parameter\n\n    def levy_flight(self, scale=0.015):  # Reduced scale for more precise steps\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.25)  # Slightly broader scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.018)  # Adjusted scale for exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.04)  # Modified range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced diversity and exploration through adaptive chaotic mutation and stochastic scaling.", "configspace": "", "generation": 38, "fitness": 0.087763791452713, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.088 with standard deviation 0.003. And the mean value of best solutions found was 0.175 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08946801126204118, 0.08388418880712745, 0.08993917428897036], "final_y": [0.16939897605401777, 0.18666388039449588, 0.1686996069729748]}, "mutation_prompt": null}
{"id": "2d2e1c9d-adf8-494a-a831-5b9814ea2cd2", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Line changed: Reduced scale for focused exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target) + 0.1 * (mutant - target)  # Line changed: Added refinement for trial vector\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved exploitation by adjusting the scale of Levy flights and refining trial vector generation.", "configspace": "", "generation": 39, "fitness": 0.08725093773357699, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0876476928921125, 0.08701298666583313, 0.08709213364278534], "final_y": [0.16757925068973767, 0.16776630502438739, 0.16625271767828964]}, "mutation_prompt": null}
{"id": "4630da3b-8331-49ec-bd68-f6d0e1f5e081", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.03)  # Enhanced scale for exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.85, 1.15)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.04)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced exploration and exploitation using adaptive dynamic scaling, chaotic maps, and enhanced Levy flight mechanism.", "configspace": "", "generation": 40, "fitness": 0.09106633420884665, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09134498021337534, 0.09182949662174089, 0.09002452579142373], "final_y": [0.16547158408234652, 0.16598691208982586, 0.16802237729941782]}, "mutation_prompt": null}
{"id": "57abdd5a-b6fe-4fb3-953e-7a9bb5ec7979", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.87, 1.33)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.022)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Fine-tuned adaptive scaling and chaotic influence for enhanced exploration in differential evolution.", "configspace": "", "generation": 41, "fitness": 0.09191708936411651, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09032585458376285, 0.09258471617886266, 0.092840697329724], "final_y": [0.1680036147649886, 0.1653899806115634, 0.16555224839736893]}, "mutation_prompt": null}
{"id": "b8484a5d-30df-48da-b984-3d8e8b15d018", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 120)  # Increased population size for diversity\n        self.CR = 0.85  # Slightly reduced to increase exploration\n        self.F = 0.9  # Increased for stronger mutation\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.8 * x * (1.0 - x)  # Modified coefficient for the chaotic map\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for finer step adjustments\n        return scipy.stats.levy_stable.rvs(alpha=1.7, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.95, 1.2)  # Narrowed random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.018)  # Adjusted scale for better balance\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.75, 1.25)  # Adjusted crossover range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.015, 0.035)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Integration of chaotic maps and adaptive strategies to enhance exploration and exploitation balance for optimization.", "configspace": "", "generation": 42, "fitness": 0.08974820860067285, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.001. And the mean value of best solutions found was 0.169 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08929303648590026, 0.08826880578407104, 0.09168278353204729], "final_y": [0.16867924206868723, 0.1685289925729876, 0.16865060338991678]}, "mutation_prompt": null}
{"id": "cd39b313-7676-441b-97ef-3c8d7dc910fd", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Increased population size\n        self.CR = 0.7  # Altered crossover rate\n        self.F = 0.9  # Altered scaling factor\n        self.current_evaluations = 0\n        self.chaotic_sequence = np.random.rand(self.population_size) * 0.5  # Initial chaotic sequence\n\n    def chaotic_map(self, x):\n        return 3.8 * x * (1.0 - x)  # Modified chaotic map parameter\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for levy flight\n        return scipy.stats.levy_stable.rvs(alpha=1.7, beta=0, scale=scale, size=self.dim)  # Changed distribution parameters\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.2 * self.chaotic_map(self.chaotic_sequence[target_idx])  # Increased influence of chaotic factor\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.4)  # Altered scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.03)  # Further increased scale\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.75, 1.25)  # Expanded stochastic crossover adjustment range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity + 1e-9))  # Added a small constant for stability\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                self.chaotic_sequence[i] = self.chaotic_map(self.chaotic_sequence[i])\n                trial += self.chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.05)  # Increased range for chaotic sequence\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced exploration and exploitation using chaotic sequences and dynamic scaling of mutation and crossover parameters.", "configspace": "", "generation": 43, "fitness": 0.08687147263054044, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.001. And the mean value of best solutions found was 0.173 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08767966261554139, 0.08560479006763655, 0.08732996520844338], "final_y": [0.1746365989146702, 0.17328916266440175, 0.17005958429325108]}, "mutation_prompt": null}
{"id": "10bedc3d-292b-4965-a6f8-d1c33bf19115", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Adjusted population size for better exploration\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n        self.elitism_rate = 0.1  # New elitism rate for retaining top individuals\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for balanced exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.015)  # Consistent scale\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elites = population[elite_indices]\n\n            for i in range(self.population_size - elite_count):  # Adjust loop for elitism\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            new_population.extend(elites)  # Include elites in the new population\n            population = np.array(new_population)\n            fitness = np.array(new_fitness + list(fitness[elite_indices]))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced searching capability by integrating chaotic maps and levy flights with adaptive population management.", "configspace": "", "generation": 44, "fitness": 0.09192822933978684, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.002. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09416104463154207, 0.09000103183223529, 0.09162261155558316], "final_y": [0.16509133041249424, 0.16583245322885543, 0.16580441077022834]}, "mutation_prompt": null}
{"id": "0562a625-2d82-4885-8edf-9c2eb77ba4bf", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithRotationalMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for balanced exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def rotate_mutation(self, vector, bounds, angle=0.1):\n        # Apply rotational mutation for additional diversity\n        rotation_matrix = np.eye(self.dim)\n        theta = np.random.uniform(-angle, angle)\n        for i in range(self.dim - 1):\n            for j in range(i + 1, self.dim):\n                rotation_matrix[i, j] = np.cos(theta)\n                rotation_matrix[j, i] = np.sin(theta)\n        rotated_vector = np.dot(rotation_matrix, vector)\n        return np.clip(rotated_vector, bounds.lb, bounds.ub)\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        mutant_vector = self.rotate_mutation(mutant_vector, bounds)  # Added rotational mutation\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithRotationalMutation", "description": "Enhanced Adaptation with Stochastic Rotational Mutation to improve exploration and convergence balance.", "configspace": "", "generation": 45, "fitness": 0.0499222575803742, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithRotationalMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.050 with standard deviation 0.002. And the mean value of best solutions found was 0.386 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.04910664967055289, 0.04796365155541349, 0.05269647151515622], "final_y": [0.4045069239892908, 0.41379549904142643, 0.3395063942952564]}, "mutation_prompt": null}
{"id": "094233bf-7483-4ec5-9ff5-de56a87e7b61", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumLeap:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Adjusted population size\n        self.CR = 0.85  # Modified crossover rate\n        self.F = 0.7  # Modified scaling factor\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_leap(self, upper, lower):\n        return np.random.uniform(lower, upper, self.dim)  # Quantum-inspired random step\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.05 * self.chaotic_map(np.random.rand())  # Adjusted chaotic factor\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.2)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.015)  # Adjusted scale\n        mutant_vector = np.clip(mutant_vector + levy_step, bounds.lb, bounds.ub)\n        if np.random.rand() < 0.1:  # Quantum leap with a small probability\n            mutant_vector += self.quantum_leap(bounds.ub, bounds.lb)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.7, 1.15)  # Adjusted stochastic factor\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumLeap", "description": "Enhanced search efficiency by integrating a quantum-inspired mechanism with adaptive step sizes and optimized mutation strategy.", "configspace": "", "generation": 46, "fitness": 0.08926020427135439, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumLeap got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.089 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.08844727690968102, 0.08905523963109174, 0.09027809627329042], "final_y": [0.16528906721357262, 0.16564092986468748, 0.16546264142517408]}, "mutation_prompt": null}
{"id": "391f7aec-250e-40f6-857e-bfc551a05a5d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.initial_population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(len(population)), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.5)  # Broader range for random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.03)  # Increased scale for exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.7, 1.3)  # Broader stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.initial_population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(len(population)):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.05)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhanced exploration and exploitation balance using adaptive population size and chaotic dynamics integration.", "configspace": "", "generation": 47, "fitness": 0.08936401043161686, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.089 with standard deviation 0.001. And the mean value of best solutions found was 0.167 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09074139651623991, 0.08907916407716343, 0.08827147070144725], "final_y": [0.1661805488600252, 0.16745827262755253, 0.16701473781654308]}, "mutation_prompt": null}
{"id": "41797fe4-1488-4451-b0c6-429b717781de", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        perturbation = np.random.normal(0, 0.01, size=self.dim)  # Added perturbation\n        mutant_vector += perturbation  # Apply perturbation\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introducing a small perturbation in the mutation step to enhance exploration.", "configspace": "", "generation": 48, "fitness": 0.09141644982041186, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09269176521912015, 0.09086705141937435, 0.09069053282274109], "final_y": [0.16557743535002944, 0.16591540054523957, 0.16531520403030975]}, "mutation_prompt": null}
{"id": "dc26b39a-74a5-455e-9ef4-e65cba5363b4", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlightV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c, d, e = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 5, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.8, 1.3)\n        \n        if np.random.rand() < 0.5:\n            mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        else:\n            mutant_vector = population[a] + adaptive_F * (population[b] - population[c] + population[d] - population[e])\n        \n        levy_step = self.levy_flight(scale=0.02)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        \n        chaos_factor = self.chaotic_map(np.random.rand())\n        trial_vector += chaos_factor * (mutant - target) * np.random.uniform(0.02, 0.05)\n        trial_vector = np.clip(trial_vector, bounds.lb, bounds.ub)\n        \n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlightV2", "description": "Introduced multi-strategy mutation and chaos-enhanced crossover to improve global exploration and convergence speed.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'bounds' is not defined\").", "error": "NameError(\"name 'bounds' is not defined\")", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {}, "mutation_prompt": null}
{"id": "df35ab36-850c-4710-890a-8e567d162b5a", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithCauchyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Slightly reduced to increase mutation influence\n        self.F = 0.9  # Increased to enhance exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return np.sin(np.pi * x)  # Changed from logistic map to sine map for different chaotic behavior\n\n    def cauchy_flight(self, scale=0.01):\n        return scipy.stats.cauchy.rvs(loc=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.95, 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        cauchy_step = self.cauchy_flight(scale=0.02)\n        mutant_vector += cauchy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.85, 1.15)  # Adjusted stochastic adjustment range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.04) \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithCauchyFlight", "description": "Improved exploration and exploitation balance using chaotic sequences, adaptive mutation, and Cauchy distribution-based steps.", "configspace": "", "generation": 50, "fitness": 0.08994232227570205, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithCauchyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.090 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09123151552435704, 0.08918061875343608, 0.08941483254931304], "final_y": [0.16563732024139988, 0.16700053301894957, 0.1663777272119662]}, "mutation_prompt": null}
{"id": "27ae797a-52d3-4ba2-a438-f474464af82c", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover rate\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved balance between exploration and exploitation by adjusting the mutation and crossover factors.", "configspace": "", "generation": 51, "fitness": 0.0909575559670021, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09138102946492621, 0.0899836390720864, 0.09150799936399368], "final_y": [0.1652847727633192, 0.1659402592185858, 0.1656365518033336]}, "mutation_prompt": null}
{"id": "1c889140-b3a7-46db-80d7-211d37ef8071", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower * 0.99  # Slightly more random\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved exploration through a slightly more random initial population for better global search.", "configspace": "", "generation": 52, "fitness": 0.0923201971361312, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0912599829653098, 0.09274547696465929, 0.09295513147842449], "final_y": [0.16583475900177125, 0.16555915424345846, 0.16524405421844923]}, "mutation_prompt": null}
{"id": "0a0c2586-ae01-4f62-8c25-458ab67613e5", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)  # Adjusted random scaling factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)  # Increased scale for better exploration\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)  # Stochastic crossover adjustment\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Adjusted range\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Improved diversity and local search efficiency using adaptive differential mutation and dynamic crossover strategies.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.0912599829653098, 0.09274547696465929, 0.09295513147842449], "final_y": [0.16583475900177125, 0.16555915424345846, 0.16524405421844923]}, "mutation_prompt": null}
{"id": "a2c38a26-db2d-4bfd-a3ac-0fb9d475c131", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Incorporate adaptive opponent-based learning and diversity maintenance to enhance exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.09332739198818807, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "442ccc8f-28ec-4701-b1ae-b473d88d3e37", "metadata": {"aucs": [0.09346065705356321, 0.09310315319099105, 0.09341836572000994], "final_y": [0.16542426219977935, 0.16511225029178778, 0.1654324710069569]}, "mutation_prompt": null}
{"id": "604fd97c-1d1f-4001-8713-e385fdbce065", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n        self.inertia_weight = 0.9  # Initialize inertia weight for PSO dynamics\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def update_inertia_weight(self):\n        self.inertia_weight = 0.9 - (self.current_evaluations / self.budget) * (0.5)\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                self.update_inertia_weight()  # Update inertia weight adaptively\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhance global search by integrating an adaptive inertia weight mechanism inspired by Particle Swarm Optimization (PSO) dynamics.", "configspace": "", "generation": 55, "fitness": 0.09332739198818807, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a2c38a26-db2d-4bfd-a3ac-0fb9d475c131", "metadata": {"aucs": [0.09346065705356321, 0.09310315319099105, 0.09341836572000994], "final_y": [0.16542426219977935, 0.16511225029178778, 0.1654324710069569]}, "mutation_prompt": null}
{"id": "db8553d1-28af-4d1a-94d8-f2469f4ab2ca", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        differential_grouping = np.random.randint(0, 2, self.dim)\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) * differential_grouping\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Integrate differential grouping for dimensionality reduction and strengthen opponent learning to enhance convergence.", "configspace": "", "generation": 56, "fitness": 0.09313063851569785, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a2c38a26-db2d-4bfd-a3ac-0fb9d475c131", "metadata": {"aucs": [0.09336511017646276, 0.09311097575111105, 0.09291582961951972], "final_y": [0.1653792240575136, 0.165199387906645, 0.16505565776060127]}, "mutation_prompt": null}
{"id": "6b512531-f279-4439-9d51-b41ebe11b895", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)  # Modified line\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce dynamic scaling to the Levy flight step for enhanced exploration.", "configspace": "", "generation": 57, "fitness": 0.09346215014871147, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a2c38a26-db2d-4bfd-a3ac-0fb9d475c131", "metadata": {"aucs": [0.09348297298941144, 0.09332958260181146, 0.09357389485491152], "final_y": [0.16556212810691084, 0.16508661317669593, 0.16513108301602542]}, "mutation_prompt": null}
{"id": "97ef3943-52eb-4a6d-857f-8d751589ed58", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.15 * (opponent_vector - mutant_vector)  # Adjusted influence\n        mutant_vector -= levy_step  # Changed to subtraction to balance exploration\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.02, 0.05)  # Enhanced chaos effect\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce adaptive chaos-enhanced differential evolution for improved exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.09332822718540228, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "6b512531-f279-4439-9d51-b41ebe11b895", "metadata": {"aucs": [0.09363284721667042, 0.09260617827229745, 0.09374565606723895], "final_y": [0.16581710926036153, 0.16607644122480336, 0.16518523911301153]}, "mutation_prompt": null}
{"id": "34a4b75c-ccf7-4438-b2b1-3caaf802a19d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def local_search(self, vector, bounds):\n        perturbation = np.random.normal(0, 0.005, size=self.dim)  # New line\n        vector += perturbation  # New line\n        vector = np.clip(vector, bounds.lb, bounds.ub)  # New line\n        return vector  # New line\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial = self.local_search(trial, bounds)  # Modified line\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce a local search step with Gaussian perturbation to enhance exploitation.", "configspace": "", "generation": 59, "fitness": 0.09280664376165186, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6b512531-f279-4439-9d51-b41ebe11b895", "metadata": {"aucs": [0.0934414896272725, 0.09219861945516605, 0.09277982220251701], "final_y": [0.16549854573510092, 0.1651366927481327, 0.1651065422263801]}, "mutation_prompt": null}
{"id": "e3bd3562-e150-43e4-9dfb-243d0971daef", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.99 * x * (1.0 - x)  # Modified line\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Refine chaotic map scaling to subtly enhance convergence performance.", "configspace": "", "generation": 60, "fitness": 0.09320460757138542, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "6b512531-f279-4439-9d51-b41ebe11b895", "metadata": {"aucs": [0.0935122930911606, 0.09322536392578862, 0.09287616569720702], "final_y": [0.16550740107478867, 0.1651340596353693, 0.16625508630124464]}, "mutation_prompt": null}
{"id": "ae3c045a-790c-49b0-a9e2-b9edb30fa8db", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n        self.memory = []\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.015 * diversity_factor)  # Modified line (scale)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        if np.random.rand() < 0.5:  # Added memory usage\n            opponent_vector = self.memory[np.random.randint(len(self.memory))] if self.memory else opponent_vector\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector)\n        mutant_vector += levy_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def adaptive_population_size(self):  # New function for dynamic resizing\n        if self.current_evaluations / self.budget > 0.5:\n            self.population_size = max(self.population_size // 2, 10)\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            self.adaptive_population_size()  # Dynamic population resizing\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                    if len(self.memory) < 5:  # Memory size management\n                        self.memory.append(trial)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce adaptive memory and dynamic population resizing to enhance convergence speed and solution quality.", "configspace": "", "generation": 61, "fitness": 0.09344454367373427, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6b512531-f279-4439-9d51-b41ebe11b895", "metadata": {"aucs": [0.09395332928776756, 0.09292368070976642, 0.0934566210236688], "final_y": [0.16532693777336516, 0.16511247439976307, 0.1651595898702385]}, "mutation_prompt": null}
{"id": "61ae5f32-8ee1-49e9-8a9c-cdabd99ec9f2", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Integrate Gaussian mutation with chaotic exploration to enhance adaptability and diversity in Levy Flight-based optimization.", "configspace": "", "generation": 62, "fitness": 0.09357551381768044, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6b512531-f279-4439-9d51-b41ebe11b895", "metadata": {"aucs": [0.09395090750156687, 0.09293691554098804, 0.09383871841048641], "final_y": [0.16511743105519427, 0.16521779151179994, 0.1651938411372157]}, "mutation_prompt": null}
{"id": "c2878aa8-478e-4973-b04b-dc71ac8606ce", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.7, 1.3)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Refine adaptive CR calculation with a wider randomness range for enhanced exploration.", "configspace": "", "generation": 63, "fitness": 0.09335579381506498, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "61ae5f32-8ee1-49e9-8a9c-cdabd99ec9f2", "metadata": {"aucs": [0.09388454593520545, 0.09220849972130696, 0.09397433578868253], "final_y": [0.16511196975278686, 0.16539340763245391, 0.16499237111883358]}, "mutation_prompt": null}
{"id": "b9f13c95-fab2-44a5-a438-e24e742937bb", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def fractional_brownian_motion(self, hurst=0.7, scale=0.05):\n        return scipy.stats.norm.rvs(scale=scale, size=self.dim) * hurst\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        brownian_step = self.fractional_brownian_motion(scale=0.01 * diversity_factor)\n        mutant_vector += levy_step + brownian_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor)\n        adaptive_CR *= np.random.uniform(0.8, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhance adaptive dynamic scaling by introducing fractional Brownian motion and adaptive scheme based on population diversity.", "configspace": "", "generation": 64, "fitness": 0.09318356787095494, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "61ae5f32-8ee1-49e9-8a9c-cdabd99ec9f2", "metadata": {"aucs": [0.09354617006516142, 0.09229005082565578, 0.09371448272204763], "final_y": [0.16531526891942527, 0.1654994580892688, 0.16527181157747428]}, "mutation_prompt": null}
{"id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        # Change line: Introduce randomness in crossover rate using stochastic variation\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Incorporate stochastic variation in crossover rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.09364223297136369, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "61ae5f32-8ee1-49e9-8a9c-cdabd99ec9f2", "metadata": {"aucs": [0.09343466212416807, 0.093358026551003, 0.09413401023891999], "final_y": [0.1652403202098548, 0.16497659983497692, 0.16527153623460222]}, "mutation_prompt": null}
{"id": "36306375-8e50-493a-8db9-ea375abf8e9a", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * (1 + 0.2 * np.sin(self.current_evaluations))\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        chaotic_perturbation = self.chaotic_map(np.random.rand(self.dim)) * 0.05\n        mutant_vector += levy_step + chaotic_perturbation\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Enhance the mutation strategy by incorporating a dynamic weighting factor and a novel adaptive chaotic mutation.", "configspace": "", "generation": 66, "fitness": 0.09308019978446651, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "metadata": {"aucs": [0.09335236477236808, 0.09232623711798094, 0.0935619974630505], "final_y": [0.16538742518301142, 0.16544301896647873, 0.16529310061793723]}, "mutation_prompt": null}
{"id": "b7fdeb74-d67f-4009-93d8-77c1df5a667e", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3 * diversity_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce diversity control in CR scaling to enhance convergence.", "configspace": "", "generation": 67, "fitness": 0.09059990387057759, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "metadata": {"aucs": [0.08964260818152037, 0.09007387184499493, 0.09208323158521747], "final_y": [0.1660677652804161, 0.16554683966765338, 0.16547997427958216]}, "mutation_prompt": null}
{"id": "440d9a4b-52d8-4c07-b7ad-eadc416a96ab", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutant_vector += 0.1 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                \n                diversification_factor = 0.05 * np.random.randn(self.dim)  # New diversification mechanism\n                trial += diversification_factor\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Introduce a differential diversification mechanism to enhance search space coverage.", "configspace": "", "generation": 68, "fitness": 0.09316058076385081, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "metadata": {"aucs": [0.09425513094905613, 0.09114865166972463, 0.09407795967277166], "final_y": [0.16501382665572084, 0.16580554728442842, 0.1652414327894265]}, "mutation_prompt": null}
{"id": "164707d4-b1f3-457b-9d24-0f9ebbe28bad", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithLevyFlight:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9\n        self.F = 0.8\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def gaussian_mutation(self, scale=0.05):\n        return np.random.normal(0, scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.3)\n        # Change 1: Introduce dynamic selection for mutant vector\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        if np.random.rand() > 0.5:\n            mutant_vector += population[np.random.choice(np.delete(np.arange(self.population_size), [a, b, c, target_idx]), 1)][0]\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        gaussian_step = self.gaussian_mutation(scale=0.05 * diversity_factor)\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        # Change 2: Modify adaptive strategy for convergence\n        mutant_vector += np.random.uniform(0.05, 0.2) * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                # Change 3: Enhance selection pressure for better solutions\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < 0.1:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithLevyFlight", "description": "Integrate dynamic selection and adaptive mutation scaling for enhanced convergence in diverse landscapes.", "configspace": "", "generation": 69, "fitness": 0.07184543397155445, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithLevyFlight got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.072 with standard deviation 0.002. And the mean value of best solutions found was 0.254 (0. is the best).", "error": "", "parent_id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "metadata": {"aucs": [0.06936600868293952, 0.07169059942037415, 0.07447969381134967], "final_y": [0.26877193715147407, 0.2483683561025164, 0.24395593869407195]}, "mutation_prompt": null}
{"id": "37399351-106a-464f-9e1c-af85fc385f92", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithChaoticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Tuned to slightly enhance exploitation\n        self.F = 0.85  # Tuned to slightly enhance exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.1 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.4)  # Changed scaling to enhance diversification\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Enhanced adaptive mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.2 * (opponent_vector - mutant_vector) + gaussian_step  # Increased impact of opponent\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.7, 1.2)  # Tuned CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithChaoticMutation", "description": "Introduce adaptive chaotic mutation and enhanced diversity handling for improved convergence.", "configspace": "", "generation": 70, "fitness": 0.09411252045588174, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithChaoticMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6c7f3b9a-10bd-4ef3-913a-0f609a8feb87", "metadata": {"aucs": [0.09429388983449938, 0.09357902173316379, 0.09446464979998204], "final_y": [0.16580959637076775, 0.1651461421340601, 0.16517277986079004]}, "mutation_prompt": null}
{"id": "165b301a-e8dc-4b68-a8b1-c53d46987594", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithChaoticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Tuned to slightly enhance exploitation\n        self.F = 0.85  # Tuned to slightly enhance exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.rand(self.population_size, self.dim) * (upper - lower) + lower\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.2 * self.chaotic_map(np.random.rand())  # Adjusted chaotic impact\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.5)  # Broadened scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        if np.random.rand() > 0.5:  # Introduce conditional mutation phase\n            levy_step = self.levy_flight(scale=0.03 * diversity_factor)\n            mutant_vector += levy_step\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.07 * (1.0 - diversity_factor)  # Enhanced adaptive mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step  # Increased impact of opponent\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.3)  # Tuned CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.015, 0.025)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithChaoticMutation", "description": "Introduce multi-phase adaptive mutation and chaotic crossover for enhanced exploration-exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.09528044285750843, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithChaoticMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "37399351-106a-464f-9e1c-af85fc385f92", "metadata": {"aucs": [0.09500020840810774, 0.09528558853750069, 0.09555553162691688], "final_y": [0.165506566815929, 0.165950825683288, 0.16515027164898288]}, "mutation_prompt": null}
{"id": "4d48f263-f886-41f5-b785-23578d51790a", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        return np.random.normal(mean, std, (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Introduce quantum-inspired initialization and dynamic learning rates for mutation and crossover to enhance exploration and convergence.", "configspace": "", "generation": 72, "fitness": 0.0958768443935819, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "165b301a-e8dc-4b68-a8b1-c53d46987594", "metadata": {"aucs": [0.0965565813671121, 0.09551476470616593, 0.09555918710746769], "final_y": [0.16491371077937633, 0.16506673584103837, 0.16617918566043277]}, "mutation_prompt": null}
{"id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Introduce Gaussian perturbation in quantum initialization to improve diversity.", "configspace": "", "generation": 73, "fitness": 0.09592230457028332, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "4d48f263-f886-41f5-b785-23578d51790a", "metadata": {"aucs": [0.09617790120973113, 0.09606727159649597, 0.09552174090462284], "final_y": [0.16563330576856872, 0.16556815724697638, 0.16606942465296137]}, "mutation_prompt": null}
{"id": "4457f72f-f9e1-4d56-8c91-f106d01e1659", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.75  # Adjusted for improved exploration-exploitation balance\n        self.F = 0.85  # Balanced exploration factor\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Modified chaotic map for better unpredictability\n        return np.sin(x * np.pi)\n\n    def levy_flight(self, scale=0.02):  # Adjusted scale for variable step sizes\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))\n        return np.clip(init_population, lower, upper)  # Ensure within bounds\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.5)  # Tighter dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.07 * (1.0 - diversity_factor)  # Higher mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step\n        return np.clip(mutant_vector, bounds.lb, bounds.ub)\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.95, 1.1)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Integrate adaptive chaotic sequences with diversity-based mutation scaling for enhanced exploration-exploitation balance in quantum-initialized populations.", "configspace": "", "generation": 74, "fitness": 0.09574308705328845, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.09583430786728009, 0.09603857275422356, 0.0953563805383617], "final_y": [0.1654468543094456, 0.16535402384813114, 0.1664933003184792]}, "mutation_prompt": null}
{"id": "f552c602-5056-45b3-8bcb-549618d671fd", "solution": "import numpy as np\n\nclass AdaptiveGradientProjectionWithChaoticVariation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 50)\n        self.learning_rate = 0.01\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        return np.random.uniform(lower, upper, (self.population_size, self.dim))\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def gradient_step(self, individual, fitness, bounds):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        grad_individual = individual + perturbation\n        grad_individual = np.clip(grad_individual, bounds.lb, bounds.ub)\n        grad_fitness = func(grad_individual)\n        self.current_evaluations += 1\n\n        gradient = (grad_fitness - fitness) / (perturbation + 1e-8)\n        step = self.learning_rate * gradient\n        new_individual = individual - step\n        new_individual = np.clip(new_individual, bounds.lb, bounds.ub)\n        return new_individual\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.population_size):\n                individual = population[i]\n                fitness_val = fitness[i]\n\n                new_individual = self.gradient_step(individual, fitness_val, bounds)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                chaotic_perturbation = chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.005, 0.015)\n                new_individual += chaotic_perturbation\n                new_individual = np.clip(new_individual, bounds.lb, bounds.ub)\n\n                new_fitness_val = func(new_individual)\n                self.current_evaluations += 1\n\n                if new_fitness_val < fitness_val:\n                    new_population.append(new_individual)\n                    new_fitness.append(new_fitness_val)\n                else:\n                    new_population.append(individual)\n                    new_fitness.append(fitness_val)\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "AdaptiveGradientProjectionWithChaoticVariation", "description": "Adaptive Gradient Projection with Chaotic Variation blends gradient-inspired moves with chaos-driven diversification.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {}, "mutation_prompt": null}
{"id": "efd8abcb-cbfe-4c12-b95b-93d2becaf6c8", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9  # Adjusted for better exploration\n        self.F = 0.8  # Adjusted for balanced exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):  # Reduced scale for finer local search\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 3  # Broader spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.08, (self.population_size, self.dim))  # Enhanced perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.4 * self.chaotic_map(np.random.rand())  # Increased chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.4)  # Narrower dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.03 * diversity_factor)  # Adjusted scale for better exploration\n        mutant_vector += levy_step if np.random.rand() > 0.5 else 0  # Altered phase tweak logic\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.06 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step  # Changed opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.8, 1.1)  # Adjusted dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.03)  # Expanded scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Enhance exploration by introducing dynamic chaos intensity and adaptive Levy flight adjustments.", "configspace": "", "generation": 76, "fitness": 0.09519484424017337, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.09493402543590834, 0.09581580893957686, 0.09483469834503488], "final_y": [0.1658791047789412, 0.16535231373936476, 0.16654864850603268]}, "mutation_prompt": null}
{"id": "a4ff0f22-df75-41f7-ab27-32847194bf35", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.01):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))\n        return init_population\n\n    def entropy(self, population):\n        hist, _ = np.histogramdd(population, bins=10)\n        prob_density = hist / np.sum(hist)\n        prob_density = prob_density[prob_density > 0]\n        return -np.sum(prob_density * np.log(prob_density))\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, entropy_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())\n        adaptive_F = self.F * entropy_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * entropy_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.2 else 0\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - entropy_factor)\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, entropy_factor):\n        adaptive_CR = self.CR * (1.0 - entropy_factor) * np.random.uniform(0.9, 1.2)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            entropy_factor = 1.0 / (1.0 + self.entropy(population))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, entropy_factor)\n                trial = self.crossover(target, mutant, entropy_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Introduce dynamic chaos-based mutation and adaptive crossover influenced by population entropy to enhance exploration.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: MemoryError((61917364224,), dtype('int64')).", "error": "MemoryError((61917364224,), dtype('int64'))", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {}, "mutation_prompt": null}
{"id": "a3647326-7883-4c14-84f2-c9f1d7d95892", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.75  # Adjusted for dynamic exploitation\n        self.F = 0.85  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.02):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.4 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.9, 1.5)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.03 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.06 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.85, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.015, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Enhanced multi-population strategy with adaptive mutation scaling to improve convergence.", "configspace": "", "generation": 78, "fitness": 0.09560646972186271, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.09517882800190158, 0.09577965849229986, 0.09586092267138668], "final_y": [0.1665188240357568, 0.16559476614449598, 0.16564972510926046]}, "mutation_prompt": null}
{"id": "6a5278a0-4046-4446-a27c-a2932aa5348d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.017):  # Slightly adjusted scale for balanced exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.35 * self.chaotic_map(np.random.rand())  # Slightly increased chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Slightly modify chaotic influence and levy flight scale to enhance exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.09572633704867302, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.0960846712615736, 0.09581976165980144, 0.09527457822464402], "final_y": [0.16547489351489486, 0.16630728962512342, 0.16638489192247552]}, "mutation_prompt": null}
{"id": "b9889071-a3b6-48f9-8d8f-7a08c51be822", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        chaotic_perturbation = std * 0.01 * self.chaotic_map(np.random.rand(self.population_size, self.dim))\n        init_population += chaotic_perturbation  # Added chaotic perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_step = self.levy_flight(scale=0.02 * diversity_factor)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Improve diversity by introducing a chaotic perturbation during quantum initialization.", "configspace": "", "generation": 80, "fitness": 0.0956516588108306, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.09630210282999874, 0.09543993650825011, 0.09521293709424294], "final_y": [0.16531459666102089, 0.1658794318206075, 0.1665135876565368]}, "mutation_prompt": null}
{"id": "a7c21e1f-2b6f-49c2-b39d-3e681af56c5d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_scale = 0.02 * diversity_factor * (1.0 - self.current_evaluations / self.budget)  # Adjusted levy scaling\n        levy_step = self.levy_flight(scale=levy_scale)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Introduce dynamic levy flight scaling based on current evaluations to balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.09592510985184459, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "fc7421ea-dd4d-46a9-acfc-aee65d90e7ab", "metadata": {"aucs": [0.09618616356593834, 0.09606719111949602, 0.09552197487009939], "final_y": [0.16549261882411048, 0.16556891443515354, 0.1661089020130294]}, "mutation_prompt": null}
{"id": "056e183c-0741-44a0-ab01-deea7286d6ee", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_scale = 0.02 * diversity_factor * (1.0 - self.current_evaluations / self.budget)  # Adjusted levy scaling\n        levy_step = self.levy_flight(scale=levy_scale)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - diversity_factor)  # Adjusted mutation\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Introduce dynamic levy flight scaling based on current evaluations to balance exploration and exploitation.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "a7c21e1f-2b6f-49c2-b39d-3e681af56c5d", "metadata": {"aucs": [0.09618616356593834, 0.09606719111949602, 0.09552197487009939], "final_y": [0.16549261882411048, 0.16556891443515354, 0.1661089020130294]}, "mutation_prompt": null}
{"id": "765a7c96-e6bb-46dd-986f-dc22ad96384b", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedAdaptiveDynamicScalingWithQuantumMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted for dynamic exploitation\n        self.F = 0.9  # Adjusted for dynamic exploration\n        self.current_evaluations = 0\n\n    def chaotic_map(self, x):\n        return 3.9 * x * (1.0 - x)  # Reduced chaotic influence\n\n    def levy_flight(self, scale=0.015):  # Adjusted scale for better exploration\n        return scipy.stats.levy_stable.rvs(alpha=1.5, beta=0, scale=scale, size=self.dim)\n\n    def quantum_initialize_population(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4  # Quantum-inspired spread\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        init_population += np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Gaussian perturbation\n        return init_population\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, diversity_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        chaotic_factor = 1 + 0.3 * self.chaotic_map(np.random.rand())  # Further chaotic influence\n        adaptive_F = self.F * diversity_factor * chaotic_factor\n        adaptive_F *= np.random.uniform(0.85, 1.6)  # Broadened dynamic scaling range\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        levy_scale = 0.02 * diversity_factor * (1.0 - self.current_evaluations / self.budget)  # Adjusted levy scaling\n        levy_step = self.levy_flight(scale=levy_scale)\n        mutant_vector += levy_step if np.random.rand() > 0.3 else 0  # Conditional phase tweak\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.04 * (1.0 - diversity_factor)  # Reduced mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Increased opponent impact\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.CR * (1.0 - diversity_factor) * np.random.uniform(0.9, 1.2)  # Dynamic CR range\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        chaotic_sequence = np.random.rand(self.population_size)\n        population = self.quantum_initialize_population(bounds)  # Quantum-inspired initialization\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            diversity_factor = 1.0 / (1.0 + np.sqrt(diversity))\n\n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, diversity_factor)\n                trial = self.crossover(target, mutant, diversity_factor)\n\n                chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i])\n                trial += chaotic_sequence[i] * (bounds.ub - bounds.lb) * np.random.uniform(0.01, 0.02)  # Adjusted scaling\n                trial = np.clip(trial, bounds.lb, bounds.ub)\n\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedAdaptiveDynamicScalingWithQuantumMutation", "description": "Fine-tuned the chaotic influence and mutation scaling for enhanced convergence and stability.", "configspace": "", "generation": 83, "fitness": 0.0954709750519291, "feedback": "The algorithm EnhancedAdaptiveDynamicScalingWithQuantumMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.167 (0. is the best).", "error": "", "parent_id": "a7c21e1f-2b6f-49c2-b39d-3e681af56c5d", "metadata": {"aucs": [0.09587384299241253, 0.09549732016945345, 0.09504176199392134], "final_y": [0.16640590203762362, 0.16759616490067375, 0.1677871874904887]}, "mutation_prompt": null}
{"id": "2b86932d-c82b-4289-ab18-ba86e5235712", "solution": "import numpy as np\nimport scipy.stats\n\nclass HybridQuantumGaussianWalkWithAdaptiveLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8  # Mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.05, (self.population_size, self.dim))\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * landscape_factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.05 * (1.0 - landscape_factor)\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor)\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "HybridQuantumGaussianWalkWithAdaptiveLandscapeLearning", "description": "Hybrid Quantum-Gaussian Walk with Adaptive Landscape Learning for enhanced convergence in photonic structure optimization.", "configspace": "", "generation": 84, "fitness": 0.09617925454937544, "feedback": "The algorithm HybridQuantumGaussianWalkWithAdaptiveLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "a7c21e1f-2b6f-49c2-b39d-3e681af56c5d", "metadata": {"aucs": [0.0964868095097654, 0.09584399797907317, 0.09620695615928776], "final_y": [0.16557782912417318, 0.16633658600475754, 0.16568297831775403]}, "mutation_prompt": null}
{"id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.08 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Enhanced Hybrid Quantum-Gaussian Walk with Multi-Layered Adaptive Landscape Learning for improved photonic structure optimization.", "configspace": "", "generation": 85, "fitness": 0.09632749066740338, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "2b86932d-c82b-4289-ab18-ba86e5235712", "metadata": {"aucs": [0.09667786729034233, 0.09612705081819206, 0.09617755389367577], "final_y": [0.165045331295274, 0.16541947508164145, 0.16564738663647383]}, "mutation_prompt": null}
{"id": "0fbe87e7-43e0-4734-bdfd-960b089a8eb1", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb_scale = 0.03 * (1 + np.random.rand())\n        perturb = np.random.normal(0, std * perturb_scale, (self.population_size, self.dim))  # Adaptive perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.08 * (1.0 - landscape_factor) * (1 + np.random.rand())  # Adaptive mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Introducing adaptive perturbation and mutation scaling for enhanced dynamic exploration.", "configspace": "", "generation": 86, "fitness": 0.09626309479426139, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.0964401736106365, 0.09610689831483687, 0.0962422124573108], "final_y": [0.1655706185548359, 0.16527027384626403, 0.16497249452877405]}, "mutation_prompt": null}
{"id": "672b2335-481d-454d-9274-31e03a099088", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Introduced dynamic adaptive mutation scale to enhance exploration and exploitation balance for optimized photonic structure designs.", "configspace": "", "generation": 87, "fitness": 0.09630778771271135, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09663935070926344, 0.09613240491958586, 0.09615160750928475], "final_y": [0.16526571952065527, 0.1653808699588314, 0.16560348104784584]}, "mutation_prompt": null}
{"id": "69e3fca9-27a6-4155-8504-a609b0ae04f4", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Enhanced hybrid optimization with improved mutation scaling for better convergence on photonic structures.", "configspace": "", "generation": 88, "fitness": 0.09630778771271135, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09663935070926344, 0.09613240491958586, 0.09615160750928475], "final_y": [0.16526571952065527, 0.1653808699588314, 0.16560348104784584]}, "mutation_prompt": null}
{"id": "d1e336c3-fec9-4b78-a2c7-c9dac36d4aa6", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.08 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Fine-tuned mutation strategy using a more dynamic landscape factor to enhance convergence rates.", "configspace": "", "generation": 89, "fitness": 0.09617937331450203, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09637412272722812, 0.09614274292882763, 0.09602125428745034], "final_y": [0.16505895097906442, 0.16500977724150157, 0.16511008737753619]}, "mutation_prompt": null}
{"id": "0bad71c1-fb81-418d-9c57-fdfa5b4af9bf", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Adjusted crossover probability\n        self.F = 0.95  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 4.5  # Adjusted standard deviation\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.3)  # Adjusted adaptive factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n\n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.5 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted scaling factor\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.6)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Adaptive Quantum-Gaussian Walk with Enhanced Mutation Dynamics and Diversified Crossover Strategies.", "configspace": "", "generation": 90, "fitness": 0.09611068649761385, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09646737178696096, 0.0956148063051, 0.09624988140078061], "final_y": [0.1657102572738065, 0.16551810257792154, 0.1655804316460271]}, "mutation_prompt": null}
{"id": "6ac3674b-79cb-4283-bf25-f8549419ff4d", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(12 * dim, 120)  # Adjusted population size\n        self.CR = 0.85  # Adjusted crossover probability\n        self.F = 0.95  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 6  # Adjusted standard deviation\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.1)  # Slightly adjusted adaptive factor\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.10 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        gaussian_step += np.random.normal(0, mutation_scale * 0.5, size=self.dim)  # Added multi-scale mutation\n        mutant_vector += 0.3 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.4)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 1.5 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Adaptive Quantum Differential Evolution with Multi-Scale Mutation for Enhanced Photonic Structure Optimization.", "configspace": "", "generation": 91, "fitness": 0.09620551431902709, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09591996378580192, 0.09625378216351399, 0.09644279700776537], "final_y": [0.16548950844766785, 0.16506529355960398, 0.16497302256670288]}, "mutation_prompt": null}
{"id": "9cffafa8-066e-4f7c-9124-edfb39c29df2", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.09 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Improved mutation strategy with a slight increase in adaptive mutation scale for enhanced exploration.", "configspace": "", "generation": 92, "fitness": 0.09633818882187443, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8d76bf2c-8d0d-4749-aebd-84845ea88ee6", "metadata": {"aucs": [0.09667437479817431, 0.09612779515124825, 0.09621239651620073], "final_y": [0.16509050093980127, 0.16543248767235874, 0.16542224828596153]}, "mutation_prompt": null}
{"id": "46f364b3-7b67-4ed6-a41f-eb524745bb2e", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.8  # Adjusted crossover probability\n        self.F = 0.9  # Adjusted mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.03, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.2)\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.09 * (1.0 - landscape_factor)  # Adjusted mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5) * (0.8 + 0.2 * landscape_factor)  # Added factor for diversity\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))  # Adjusted landscape learning\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Introduced an additional adaptive factor in crossover to enhance solution diversity.", "configspace": "", "generation": 93, "fitness": 0.09606738958609203, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "9cffafa8-066e-4f7c-9124-edfb39c29df2", "metadata": {"aucs": [0.09610869472324013, 0.09613995525251717, 0.09595351878251879], "final_y": [0.1652088882656243, 0.16537164823106776, 0.16529733765989418]}, "mutation_prompt": null}
{"id": "9260f4e4-9b9e-48c6-a710-0334e24416bd", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.F = 0.95  # Slightly increased mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Increased perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.3)  # Adjusted landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Slightly increased mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.35 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.4)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Enhanced mutation and crossover strategies with dynamic adaptation to improve exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.09639753319074378, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "9cffafa8-066e-4f7c-9124-edfb39c29df2", "metadata": {"aucs": [0.09664817718389063, 0.09647577458104406, 0.09606864780729663], "final_y": [0.16494064831757127, 0.16499395037841358, 0.16519533948366738]}, "mutation_prompt": null}
{"id": "8a45ac04-5a19-473c-9d5b-34b3ab6e4008", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.F = 0.95  # Slightly increased mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.05, (self.population_size, self.dim))  # Increased perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.3)  # Adjusted landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Slightly increased mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.35 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.35)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Slightly increased adaptation of crossover probability for enhanced exploration in diverse landscapes.", "configspace": "", "generation": 95, "fitness": 0.0962872228582637, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "9260f4e4-9b9e-48c6-a710-0334e24416bd", "metadata": {"aucs": [0.09642357426015713, 0.09620657941156119, 0.0962315149030728], "final_y": [0.16512779104452324, 0.16508472309029698, 0.16509962209858897]}, "mutation_prompt": null}
{"id": "ea36b717-bbc1-4715-b833-9bccc616c718", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85\n        self.F = 0.95\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.08, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.5)  # Refined landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.12 * (1.0 - landscape_factor)  # Refined mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.4 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.3)  # Refined CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 3 * np.sqrt(diversity))  # Refined landscape factor calculation\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Enhanced local search capability using adaptive mutation and dynamic landscape-driven perturbation for robust exploration.", "configspace": "", "generation": 96, "fitness": 0.09613099673725571, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "9260f4e4-9b9e-48c6-a710-0334e24416bd", "metadata": {"aucs": [0.09646110474579106, 0.09606890932803214, 0.09586297613794392], "final_y": [0.1652500900531857, 0.16520700796350885, 0.165532814600446]}, "mutation_prompt": null}
{"id": "7fc51a64-0091-4458-9ca9-2b67f8b02047", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.F = 0.95  # Slightly increased mutation factor\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.06, (self.population_size, self.dim))  # Slightly increased perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.3)  # Adjusted landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.1 * (1.0 - landscape_factor)  # Slightly increased mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.35 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.4)  # Adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Slightly increased perturbation scale during the quantum Gaussian walk to enhance exploration.", "configspace": "", "generation": 97, "fitness": 0.09641427125936915, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "9260f4e4-9b9e-48c6-a710-0334e24416bd", "metadata": {"aucs": [0.0966326378419855, 0.09646632387296972, 0.09614385206315224], "final_y": [0.1649758194624591, 0.16507177906929882, 0.1651850455145425]}, "mutation_prompt": null}
{"id": "0ab6038d-31b8-4836-bffd-8dfd17dfa032", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85\n        self.F = 0.95\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.07, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.5)  # Further adjusted landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.15 * (1.0 - landscape_factor)  # Further increased mutation scale\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.3 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Further adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Enhanced mutation and crossover dynamics for robust exploration and exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.09648755471549175, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "7fc51a64-0091-4458-9ca9-2b67f8b02047", "metadata": {"aucs": [0.09670499071191863, 0.09646401210194766, 0.09629366133260897], "final_y": [0.16492341434979318, 0.16491542449661978, 0.16501725459841543]}, "mutation_prompt": null}
{"id": "f4593913-0bc0-42d0-a2a5-2e00331186a0", "solution": "import numpy as np\nimport scipy.stats\n\nclass EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(10 * dim, 100)\n        self.CR = 0.85\n        self.F = 0.95\n        self.current_evaluations = 0\n\n    def quantum_gaussian_walk(self, bounds):\n        lower, upper = bounds.lb, bounds.ub\n        mean = (upper + lower) / 2\n        std = (upper - lower) / 5\n        init_population = np.random.normal(mean, std, (self.population_size, self.dim))\n        perturb = np.random.normal(0, std * 0.07, (self.population_size, self.dim))  # Adjusted perturbation scale\n        return np.clip(init_population + perturb, lower, upper)\n\n    def evaluate(self, func, population):\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += len(population)\n        return fitness\n\n    def mutate(self, target_idx, bounds, population, landscape_factor):\n        a, b, c = np.random.choice(np.delete(np.arange(self.population_size), target_idx), 3, replace=False)\n        adaptive_F = self.F * (landscape_factor ** 1.25)  # Slightly reduced landscape factor exponent\n        mutant_vector = population[a] + adaptive_F * (population[b] - population[c])\n        \n        opponent_idx = np.random.randint(self.population_size)\n        opponent_vector = population[opponent_idx]\n        mutation_scale = 0.17 * (1.0 - landscape_factor)  # Increased mutation scale slightly\n        gaussian_step = np.random.normal(0, mutation_scale, size=self.dim)\n        mutant_vector += 0.35 * (opponent_vector - mutant_vector) + gaussian_step  # Adjusted weight\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, landscape_factor):\n        adaptive_CR = self.CR * (1.0 - landscape_factor ** 0.5)  # Further adjusted CR adaptation\n        crossover_points = np.random.rand(self.dim) < adaptive_CR\n        trial_vector = np.where(crossover_points, mutant, target)\n        return trial_vector\n\n    def optimize(self, func, bounds):\n        population = self.quantum_gaussian_walk(bounds)\n        fitness = self.evaluate(func, population)\n\n        while self.current_evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            diversity = np.std(population, axis=0).mean()\n            landscape_factor = 1.0 / (1.0 + 2 * np.sqrt(diversity))\n            \n            for i in range(self.population_size):\n                target = population[i]\n                mutant = self.mutate(i, bounds, population, landscape_factor)\n                trial = self.crossover(target, mutant, landscape_factor)\n                \n                trial = np.clip(trial, bounds.lb, bounds.ub)\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(target)\n                    new_fitness.append(fitness[i])\n\n                if self.current_evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        bounds = func.bounds\n        best_solution, best_value = self.optimize(func, bounds)\n        return best_solution, best_value", "name": "EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning", "description": "Refined crossover dynamics and adaptive mutation scaling for enhanced convergence and diversity maintenance.", "configspace": "", "generation": 99, "fitness": 0.09650632436413216, "feedback": "The algorithm EnhancedHybridQuantumGaussianWalkWithMultiLayeredLandscapeLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "0ab6038d-31b8-4836-bffd-8dfd17dfa032", "metadata": {"aucs": [0.0967238530105331, 0.09635678816755244, 0.09643833191431095], "final_y": [0.16499198533163106, 0.16530543614972038, 0.16494579764911732]}, "mutation_prompt": null}
