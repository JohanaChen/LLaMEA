{"id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization (PSO) with Differential Evolution (DE) for efficient exploration and exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.20542106691557246, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.205 with standard deviation 0.027. And the mean value of best solutions found was 0.422 (0. is the best).", "error": "", "parent_id": null, "metadata": {"aucs": [0.22423367323242638, 0.16760630449323177, 0.22442322302105921], "final_y": [0.04709065516745962, 0.9756084157899927, 0.2428461999129456]}, "mutation_prompt": null}
{"id": "39ff3ec3-1188-42c6-83aa-188e70a1e9bf", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20 \n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 1.5  # Adjusted social component\n        self.w = 0.9   # Initial inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # Dynamically adjust inertia weight\n            self.w = self.w_min + (0.9 - self.w_min) * (self.budget - evaluations) / self.budget\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Adaptive Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE by incorporating a dynamic inertia weight and adaptive differential evolution to improve convergence speed and solution quality in black-box optimization.", "configspace": "", "generation": 1, "fitness": 0.1757832880500516, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.176 with standard deviation 0.020. And the mean value of best solutions found was 0.701 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.201310731776985, 0.15306158046532325, 0.17297755190784658], "final_y": [0.45488594438249536, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "01f1a3e0-c998-40ca-9230-3c8c642ff549", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - (0.5 * (evaluations / self.budget))  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing Adaptive Parameters to Enhance the HybridPSODE's Dynamic Balance Between Exploration and Exploitation.", "configspace": "", "generation": 2, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "b9551857-f33d-4d1e-a7fc-e9fcc0396d23", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Initial inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduce adaptive inertia weight to improve convergence dynamics in the HybridPSODE algorithm.", "configspace": "", "generation": 3, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "53606079-0ef5-4071-bb7c-cc773a7fb46c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Increased initial inertia weight\n        self.F = 0.8   # Increased DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration and convergence by adjusting the PSO inertia weight dynamically and DE scaling factor adaptively.", "configspace": "", "generation": 4, "fitness": 0.17679339562704952, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.177 with standard deviation 0.022. And the mean value of best solutions found was 0.676 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.18735376071140064, 0.14554195069286124, 0.19748447547688663], "final_y": [0.4869896841576307, 1.265490512162812, 0.27493137513187854]}, "mutation_prompt": null}
{"id": "f866aba4-ce0b-4efc-ae13-07202eeb3afc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.75  # Inertia weight, increased from 0.7\n        self.F = 0.6   # DE scaling factor, increased from 0.5\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "A refined hybrid metaheuristic that slightly increases the inertia weight for enhanced exploration and adjusts DE scaling for diverse mutation vectors.", "configspace": "", "generation": 5, "fitness": 0.16820183732323904, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.168 with standard deviation 0.007. And the mean value of best solutions found was 0.697 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.17567973957840521, 0.15956293494044482, 0.1693628374508671], "final_y": [0.8119869818390905, 0.5318144151726159, 0.7457733121710622]}, "mutation_prompt": null}
{"id": "185b1537-9d14-46f5-bb56-41c12aa15ef2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Adjusted initial inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * (1 - evaluations / self.budget))  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive inertia weight to enhance exploration-exploitation balance in HybridPSODE.", "configspace": "", "generation": 6, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "8b9ab70c-ef69-43cd-a314-c80d7f23f3dc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Inertia weight (changed from 0.7)\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + (self.F + 0.3) * (b - c)  # Dynamic adjustment (added +0.3 to self.F)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Incorporate adaptive inertia weight and dynamic DE scaling factor to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 7, "fitness": 0.17679339562704952, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.177 with standard deviation 0.022. And the mean value of best solutions found was 0.676 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.18735376071140064, 0.14554195069286124, 0.19748447547688663], "final_y": [0.4869896841576307, 1.265490512162812, 0.27493137513187854]}, "mutation_prompt": null}
{"id": "bb879e16-e42b-4737-8983-e31bd38a0084", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Inertia weight (changed from 0.7 to 0.9)\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "A hybrid metaheuristic using adaptive inertia weight in PSO with DE for improved convergence in black-box optimization.", "configspace": "", "generation": 8, "fitness": 0.17098863762114336, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.171 with standard deviation 0.013. And the mean value of best solutions found was 0.763 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.18610770585469016, 0.15394304121270352, 0.17291516579603639], "final_y": [0.6414557412457077, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "03421609-1ee4-4d1a-b831-55be72f491c0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.05  # Cognitive component\n        self.c2 = 1.95  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.85  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Slightly adjusted PSO parameters to increase exploration and fine-tune DE crossover probability to enhance convergence.", "configspace": "", "generation": 9, "fitness": 0.18442763322614772, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.184 with standard deviation 0.023. And the mean value of best solutions found was 0.659 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.21227540146234924, 0.15577927802069058, 0.1852282201954033], "final_y": [0.2192894990097724, 1.1405699028790344, 0.6182528548332135]}, "mutation_prompt": null}
{"id": "b528fd0e-468b-4a68-8c29-f4868f413bc8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 1.5  # Cognitive component (reduced for better exploration)\n        self.c2 = 2.5  # Social component (increased for better exploitation)\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Refined hybrid metaheuristic by adjusting PSO parameters for better exploration and exploitation in black-box optimization.", "configspace": "", "generation": 10, "fitness": 0.17428224804813452, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.174 with standard deviation 0.014. And the mean value of best solutions found was 0.692 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.15462660788194005, 0.18117842566795495, 0.18704171059450858], "final_y": [0.8750810211500041, 0.6015316667475261, 0.5991767129598451]}, "mutation_prompt": null}
{"id": "0b126d4d-90ba-4971-8c4f-69780a8f75cf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Initial inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.4 + 0.5 * (self.budget - evaluations) / self.budget  # Dynamic inertia weight\n\n        return global_best", "name": "HybridPSODE", "description": "Improved HybridPSODE by adapting inertia weight dynamically for better convergence.", "configspace": "", "generation": 11, "fitness": 0.17098863762114336, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.171 with standard deviation 0.013. And the mean value of best solutions found was 0.763 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.18610770585469016, 0.15394304121270352, 0.17291516579603639], "final_y": [0.6414557412457077, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "87ea2e2e-dfa0-447d-adf0-b09d34d3b61b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight calculation\n            self.w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive inertia weight for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "e4586596-9e00-447c-9e45-130c9d4d96e8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Initial inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Dynamically adjust inertia weight\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhancing HybridPSODE by adjusting the inertia weight dynamically based on evaluations for improved convergence.", "configspace": "", "generation": 13, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "000648f0-8c55-4e4e-b823-9dfb4e20a92c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w_max = 0.9   # Max inertia weight\n        self.w_min = 0.4   # Min inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                w = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget))  # Adaptive inertia weight\n                velocity[i] = (w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "A refined HybridPSODE algorithm with improved balance between exploration and exploitation using adaptive inertia weight.", "configspace": "", "generation": 14, "fitness": 0.1731108259824258, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.735 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19244203980596197, 0.15397527234527908, 0.17291516579603639], "final_y": [0.5558733370084288, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "cfff83c2-24cc-4d11-b106-80203956f84f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # Dynamically adjust inertia weight\n            self.w = 0.9 - (0.5 * evaluations / self.budget)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Refined hybrid metaheuristic by adjusting the inertia weight dynamically to improve convergence speed.", "configspace": "", "generation": 15, "fitness": 0.1730041195369457, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.016. And the mean value of best solutions found was 0.736 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19212345441335188, 0.1539737384014488, 0.17291516579603639], "final_y": [0.5598913176014467, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "6834717c-b095-4b0d-9fa6-965b45548bd9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Inertia weight (changed from 0.7)\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                velocity[i] = np.clip(velocity[i], -0.5, 0.5)  # Velocity clamping (added)\n\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced inertia weight adaptation and velocity clamping to improve convergence in the HybridPSODE algorithm.", "configspace": "", "generation": 16, "fitness": 0.17228214849959855, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.018. And the mean value of best solutions found was 0.698 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.19414226038503024, 0.14957421347375632, 0.1731299716400091], "final_y": [0.4443871467918843, 1.0221279919889437, 0.6260119617672327]}, "mutation_prompt": null}
{"id": "cb5f8d25-0e72-4f95-beb6-6dd4417a296e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.95  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration-exploitation balance by modifying inertia weight and crossover probability for optimized convergence.", "configspace": "", "generation": 17, "fitness": 0.1717776916246124, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.018. And the mean value of best solutions found was 0.681 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.18910311597277285, 0.14712905611754457, 0.17910090278351976], "final_y": [0.592032765481887, 1.0221279919889437, 0.42901456431690915]}, "mutation_prompt": null}
{"id": "fa33d989-de22-4a5c-8781-8885853daa53", "solution": "import numpy as np\n\nclass HybridPSODEAdapt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size for diversity\n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 1.5  # Adjusted social component\n        self.w = 0.9   # Increased inertia weight initially\n        self.w_min = 0.4  # Minimum inertia weight\n        self.F = 0.8   # Increased DE scaling factor for more aggressive mutation\n        self.CR = 0.7  # Reduced DE crossover probability for more exploration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adapt inertia weight linearly over iterations\n            self.w = self.w_min + (0.9 - self.w_min) * (1 - evaluations/self.budget)\n\n        return global_best", "name": "HybridPSODEAdapt", "description": "HybridPSODE-Adapt: An adaptive hybrid metaheuristic combining PSO with DE that dynamically adjusts parameters for enhanced exploration and exploitation in black-box optimization.", "configspace": "", "generation": 18, "fitness": 0.16064732431378861, "feedback": "The algorithm HybridPSODEAdapt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.161 with standard deviation 0.007. And the mean value of best solutions found was 0.779 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.15270412679988177, 0.15949984836236908, 0.16973799777911502], "final_y": [1.147783846293391, 0.3372680330594985, 0.8519010674553472]}, "mutation_prompt": null}
{"id": "3ccb0bab-4774-443c-9f22-97ac9a81c0e2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - (0.5 * evaluations / self.budget)  # Dynamic inertia weight decay\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "A refined hybrid PSO-DE algorithm optimizing inertia weight decay dynamically for improved convergence in black-box optimization.", "configspace": "", "generation": 19, "fitness": 0.1555006398543883, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.156 with standard deviation 0.017. And the mean value of best solutions found was 0.911 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.13162206264499043, 0.16976411525621204, 0.1651157416619624], "final_y": [1.5236356814472782, 0.4604685868357896, 0.7497624084365971]}, "mutation_prompt": null}
{"id": "e1701fd2-294d-4f63-b470-28fc2a5b51e6", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Initial population size\n        self.alpha = 0.5    # Local search probability factor\n        self.beta = 0.1     # Adaptation rate for parameters\n        self.mutation_strength = 0.1  # Initial mutation strength\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n        convergence_rate = []\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                candidate = self.local_search(population[i], lb, ub, func)\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                # Adaptive parameter update based on convergence\n                if len(convergence_rate) > 5:  # Using a window of 5 evaluations\n                    recent_improvements = np.diff(convergence_rate[-5:])\n                    if np.all(recent_improvements < 0):\n                        self.mutation_strength = max(self.mutation_strength * (1 + self.beta), 0.001)\n                        self.alpha = min(self.alpha * (1 + self.beta), 1.0)\n                    else:\n                        self.mutation_strength = max(self.mutation_strength * (1 - self.beta), 0.001)\n                        self.alpha = max(self.alpha * (1 - self.beta), 0.1)\n\n                convergence_rate.append(global_best_value)\n                if evaluations >= self.budget:\n                    break\n\n        return global_best\n\n    def local_search(self, individual, lb, ub, func):\n        if np.random.rand() < self.alpha:\n            perturbation = np.random.normal(0, self.mutation_strength, self.dim)\n            local_candidate = individual + perturbation\n            local_candidate = np.clip(local_candidate, lb, ub)\n            if func(local_candidate) < func(individual):\n                return local_candidate\n        return individual", "name": "AdaptiveMemeticAlgorithm", "description": "Adaptive Memetic Algorithm (AMA) integrating local search with dynamic parameter tuning for enhancing exploration-exploitation balance in black-box optimization.", "configspace": "", "generation": 20, "fitness": 0.11614270713459458, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.116 with standard deviation 0.018. And the mean value of best solutions found was 3.321 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.11706366788235256, 0.09368607804178464, 0.13767837547964656], "final_y": [3.013572401918159, 5.057341765194638, 1.8930410401414617]}, "mutation_prompt": null}
{"id": "7841c3fb-c041-4a22-90ee-a43cdc29de30", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1_initial = 2.0  # Initial Cognitive component\n        self.c2_initial = 2.0  # Initial Social component\n        self.c1_final = 1.0    # Final Cognitive component\n        self.c2_final = 2.5    # Final Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            t = evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               c1 * r1 * (personal_best[i] - population[i]) + \n                               c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by adjusting PSO's cognitive and social component weights dynamically for improved convergence.", "configspace": "", "generation": 21, "fitness": 0.16416295387860336, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.164 with standard deviation 0.021. And the mean value of best solutions found was 0.582 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.1446994689545552, 0.15416178985524076, 0.1936276028260141], "final_y": [0.6525155124709574, 0.753300586643104, 0.33992360188453224]}, "mutation_prompt": null}
{"id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive DE scaling factor and velocity update for improved convergence.", "configspace": "", "generation": 22, "fitness": 0.2153739277732856, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.215 with standard deviation 0.023. And the mean value of best solutions found was 0.265 (0. is the best).", "error": "", "parent_id": "1cf4250a-fccc-46f7-ace1-6a43e2b0e873", "metadata": {"aucs": [0.24231165395439602, 0.18536079381678994, 0.21844933554867085], "final_y": [0.09917358024426445, 0.5051051514998718, 0.19181103866675173]}, "mutation_prompt": null}
{"id": "a8ccd734-c8f5-4880-bf52-e1823be79543", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.6   # Inertia weight (Modified line)\n        self.F = 0.6   # DE scaling factor (Modified line)\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Slightly adjusted inertia weight and DE scaling factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.18157772469352484, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.182 with standard deviation 0.019. And the mean value of best solutions found was 0.685 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.19445921759672047, 0.15406549213991472, 0.19620846434393935], "final_y": [0.437528479605669, 1.2403739181725233, 0.377726836261314]}, "mutation_prompt": null}
{"id": "3900a768-ea14-4c6b-9cc8-c356306da27c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (global_best - population[i])  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive DE strategy and improved exploration exploitation balance for better convergence.", "configspace": "", "generation": 24, "fitness": 0.16687429248145294, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.011. And the mean value of best solutions found was 0.841 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.1775315027300537, 0.15222293771885986, 0.1708684369954453], "final_y": [0.5466940428181642, 1.3310487455991111, 0.6460761406372431]}, "mutation_prompt": null}
{"id": "310f9b2e-bcbc-4db7-a90a-ba8db6a402d6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 25  # Increased population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.8 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with increased population size for better exploration and control over mutation strategy.", "configspace": "", "generation": 25, "fitness": 0.17826008901535406, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.178 with standard deviation 0.022. And the mean value of best solutions found was 0.394 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.16586665349649454, 0.20856471918478692, 0.16034889436478073], "final_y": [0.4303493873809571, 0.1474532312831487, 0.6031949750585966]}, "mutation_prompt": null}
{"id": "a31af000-b33b-4492-a573-081a83bc5b75", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            diversity_factor = np.std(population, axis=0) / (ub - lb)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) +\n                               self.c2 * r2 * (global_best - population[i]) + \n                               0.1 * diversity_factor)  # New line\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * np.var(b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive learning rates and diversity promotion for improved convergence and exploration.", "configspace": "", "generation": 26, "fitness": 0.11834176906444183, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.118 with standard deviation 0.006. And the mean value of best solutions found was 2.943 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.11222203226854366, 0.12592581457360086, 0.11687746035118096], "final_y": [3.3432649503948757, 2.4705831631219515, 3.015800314745497]}, "mutation_prompt": null}
{"id": "c3ea12d8-a1f5-4a83-b5fd-9cfb93e10120", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adaptive inertia weight\n                velocity[i] = (self.w * velocity[i] +\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                self.CR = 0.5 + 0.4 * (evaluations / self.budget)  # Adaptive crossover probability\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introducing adaptive inertia weight and crossover probability for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.15750751927271378, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.158 with standard deviation 0.006. And the mean value of best solutions found was 0.998 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.16453715634112887, 0.1494347406548988, 0.15855066082211366], "final_y": [0.7914341410016803, 1.102258676314137, 1.0990126052618412]}, "mutation_prompt": null}
{"id": "34f2bc4a-bacf-4b49-9b9e-ef86cd5837de", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.2  # Cognitive component (modified line)\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  \n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adjusted cognitive component for better exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.17014641798463404, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.170 with standard deviation 0.012. And the mean value of best solutions found was 0.827 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.1544492843823254, 0.173306835965217, 0.18268313360635968], "final_y": [0.9633889976792005, 0.8303552232324134, 0.6868944716049439]}, "mutation_prompt": null}
{"id": "caa6ba24-07e6-4d6c-874a-f601187450bf", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w_start = 0.9  # Start inertia weight\n        self.w_end = 0.4  # End inertia weight\n        self.F = 0.5\n        self.CR = 0.9\n\n    def chaotic_local_search(self, individual, lb, ub):\n        chaos_factor = 0.7\n        return np.clip(individual + chaos_factor * (np.random.rand(self.dim) - 0.5), lb, ub)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            w = self.w_end + (self.w_start - self.w_end) * ((self.budget - evaluations) / self.budget)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (w * velocity[i] +\n                               self.c1 * r1 * (personal_best[i] - population[i]) +\n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if np.random.rand() < 0.2:  # Apply chaotic local search\n                    candidate = self.chaotic_local_search(candidate, lb, ub)\n                    candidate_value = func(candidate)\n                    evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE with adaptive inertia weight and chaotic local search for improved exploration and convergence.", "configspace": "", "generation": 29, "fitness": 0.16122050850815892, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.161 with standard deviation 0.006. And the mean value of best solutions found was 0.799 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.1668450255902897, 0.1525588320456931, 0.16425766788849394], "final_y": [0.8872331250732172, 0.7730246489917352, 0.7352791878511961]}, "mutation_prompt": null}
{"id": "ebb69dde-55b9-467f-8972-709c774dd343", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] +\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced dynamic adaptation of inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.16670540866685077, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.026. And the mean value of best solutions found was 0.823 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.19982987567346044, 0.16301017804777007, 0.13727617227932176], "final_y": [0.38846626639052306, 0.4569222419678109, 1.624300230899791]}, "mutation_prompt": null}
{"id": "e297e253-079f-414f-8738-dabf26685bd2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.9 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.7 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive DE scaling factor and dynamic velocity update for improved exploration and convergence.", "configspace": "", "generation": 31, "fitness": 0.17072703665599057, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.171 with standard deviation 0.022. And the mean value of best solutions found was 0.908 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.15887719949646484, 0.15122827676024875, 0.20207563371125814], "final_y": [1.0822827115890166, 1.3273802958292813, 0.3130803030534074]}, "mutation_prompt": null}
{"id": "b5bda98f-6f8a-402c-8a2f-546ad31b7e23", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.6   # Inertia weight (Adjusted from 0.7)\n        self.F = 0.7   # DE scaling factor (Adjusted from 0.5)\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Optimized HybridPSODE with adjusted inertia weight and DE scaling factor for enhanced exploration-exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.17234696004703945, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.012. And the mean value of best solutions found was 0.792 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.18086976000431632, 0.1560526630003365, 0.18011845713646557], "final_y": [0.6329501991162779, 1.148362614963, 0.5934796392898086]}, "mutation_prompt": null}
{"id": "9009a019-20ce-4f12-bd84-800667689ce7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.85  # DE crossover probability - Modified line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.75 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with modified DE crossover probability and velocity update to improve exploration and convergence balance.", "configspace": "", "generation": 33, "fitness": 0.1782843570737148, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.178 with standard deviation 0.016. And the mean value of best solutions found was 0.704 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.1617031559607559, 0.1730752448742897, 0.20007467038609872], "final_y": [0.9708236212245437, 0.6816969034432093, 0.45865771002174466]}, "mutation_prompt": null}
{"id": "67d3d029-dc09-4435-94f9-ee73200c74fb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.9 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.7 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with altered DE mutation strategy and velocity scaling for further improved convergence.", "configspace": "", "generation": 34, "fitness": 0.20431371991787817, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.204 with standard deviation 0.015. And the mean value of best solutions found was 0.310 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.19432725716781185, 0.22488529391634093, 0.19372860866948172], "final_y": [0.4224700070604037, 0.23366959666763315, 0.2725824680377674]}, "mutation_prompt": null}
{"id": "472431ab-e379-48eb-9378-ed7d08cfef42", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.7   # DE scaling factor (changed)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = ((0.9 * self.w) * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Modified HybridPSODE with enhanced DE mutation scaling and adaptive inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridPSODE' object has no attribute 'CR'\").", "error": "AttributeError(\"'HybridPSODE' object has no attribute 'CR'\")", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {}, "mutation_prompt": null}
{"id": "f672c50c-7c3e-41f8-9bdd-3b221fa4c6fc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Modified line: dynamically adjust inertia weight\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhancing convergence by adjusting the inertia weight dynamically based on evaluations.", "configspace": "", "generation": 36, "fitness": 0.13857894009162722, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.139 with standard deviation 0.039. And the mean value of best solutions found was 1.901 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.10670012354854463, 0.11620027839930103, 0.19283641832703602], "final_y": [3.5009680001694274, 1.7562697148075102, 0.4460497575643321]}, "mutation_prompt": null}
{"id": "7c4ba9a4-820c-4eff-8544-40b67b8ceb93", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    self.F = 0.4 + 0.1 * np.sin(evaluations)  # Modified line\n                    mutation_vector = a + self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Fine-tuned HybridPSODE with enhanced inertia decay and dynamic DE scaling for improved diversity and convergence.", "configspace": "", "generation": 37, "fitness": 0.18296871746453344, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.183 with standard deviation 0.016. And the mean value of best solutions found was 0.541 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.18598069719791854, 0.162280800925252, 0.20064465427042977], "final_y": [0.5800939021904956, 0.8692734692280542, 0.1726648038177577]}, "mutation_prompt": null}
{"id": "621e7f35-8f3e-42ee-9493-a3813ff7d96d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * (self.w - 0.3 * (evaluations / self.budget)) * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + (0.6 + 0.2 * (evaluations / self.budget)) * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive DE mutation factor and inertia weight for improved exploration.", "configspace": "", "generation": 38, "fitness": 0.1855632356802964, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.018. And the mean value of best solutions found was 0.587 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.18655388688862085, 0.1635906136803632, 0.2065452064719051], "final_y": [0.48698935846442754, 0.9407256412187222, 0.33399260611311526]}, "mutation_prompt": null}
{"id": "5853a325-e74d-44a3-9019-870d77390de0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_factor = 0.4 + 0.6 * (evaluations / self.budget)  # Adjusted line\n                    mutation_vector = a + mutation_factor * self.F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic adjustment of DE scaling factor based on evaluation progression.", "configspace": "", "generation": 39, "fitness": 0.21299898471746348, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.213 with standard deviation 0.017. And the mean value of best solutions found was 0.290 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.2143649210185754, 0.23285773195287074, 0.1917743011809443], "final_y": [0.3298176880880576, 0.16371605352108032, 0.3770631616545388]}, "mutation_prompt": null}
{"id": "af745e82-f284-48c8-8da3-a8418b82adf4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.9   # Inertia weight (modified from 0.7)\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.8  # DE crossover probability (modified from 0.9)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Fine-tuning the inertia weight and DE crossover probability for improved exploration-exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.16124661753162364, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.161 with standard deviation 0.008. And the mean value of best solutions found was 0.974 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.1709673391903309, 0.1508827653226823, 0.16188974808185774], "final_y": [0.8568043199781743, 1.1041738765834344, 0.9603283868851258]}, "mutation_prompt": null}
{"id": "3d33d605-e44b-4668-bdd6-dfd0f12febbf", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.6   # Inertia weight (modified)\n        self.F = 0.7   # DE scaling factor (modified)\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutation_vector = a + 0.6 * self.F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Minor enhancements to inertia weight and DE scaling factor for improved exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.16697291399564274, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.021. And the mean value of best solutions found was 0.957 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.13879603736800095, 0.18830001617287195, 0.1738226884460553], "final_y": [1.8328140326337385, 0.42904892576815434, 0.6091299335393685]}, "mutation_prompt": null}
{"id": "3c239bc9-29fc-4f70-8e2d-1de34df1c13c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (0.8 * self.w * velocity[i] +  # Modified line\n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    F_dynamic = (0.5 + 0.5 * np.random.rand())  # Modified line\n                    mutation_vector = a + F_dynamic * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with increased diversity through adaptive scaling factor variation for improved convergence.", "configspace": "", "generation": 42, "fitness": 0.16929849947089223, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.002. And the mean value of best solutions found was 0.561 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.169832545417965, 0.16659699232355163, 0.17146596067116004], "final_y": [0.5982594347273547, 0.9113183307264707, 0.17345892800281265]}, "mutation_prompt": null}
{"id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced dynamic adaptation of the DE scaling factor and inertial weight to improve convergence and adaptability of the algorithm.", "configspace": "", "generation": 43, "fitness": 0.2333086442356936, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.233 with standard deviation 0.030. And the mean value of best solutions found was 0.170 (0. is the best).", "error": "", "parent_id": "c354b1cd-ce41-4a7a-b941-98be13332a6e", "metadata": {"aucs": [0.2522328094423888, 0.19148130341312963, 0.2562118198515624], "final_y": [0.1372938755594748, 0.28065801209216956, 0.09141697686247899]}, "mutation_prompt": null}
{"id": "54dd898a-86b5-4ceb-be40-3dd9cd5bf2c3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * (1 - evaluations / self.budget) * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced balance between exploration and exploitation by dynamically adjusting the cognitive component based on evaluations.", "configspace": "", "generation": 44, "fitness": 0.17787260816844697, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.178 with standard deviation 0.017. And the mean value of best solutions found was 0.372 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.183679690438861, 0.15535837544208142, 0.19457975862439847], "final_y": [0.6443615792229948, 0.24488418782905944, 0.22763747830497005]}, "mutation_prompt": null}
{"id": "f571560c-68c7-4ea8-8d28-56adbac30e97", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + np.sqrt(evaluations / self.budget))  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by adjusting DE scaling factor based on the square root of progress to improve diversity.", "configspace": "", "generation": 45, "fitness": 0.17841012421106076, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.178 with standard deviation 0.011. And the mean value of best solutions found was 0.408 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18713336373699996, 0.16355409826629375, 0.1845429106298886], "final_y": [0.47418454550410405, 0.30637900766780546, 0.4435067077046133]}, "mutation_prompt": null}
{"id": "44217c6f-77f2-46c3-8f35-e04f7c8f17e1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - (evaluations / self.budget) ** 2)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 - (evaluations / self.budget) ** 2)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced dynamic adaptation of DE scaling factor and inertia weight by introducing nonlinear decay to improve exploration-exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.1708804444753453, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.171 with standard deviation 0.014. And the mean value of best solutions found was 0.590 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17281297540698337, 0.1530491438980922, 0.18677921412096032], "final_y": [0.8439424794859275, 0.6176958371706004, 0.30834621637679194]}, "mutation_prompt": null}
{"id": "e99c95a0-4d18-4b99-85fb-f9725f797953", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # Adaptive population size\n            self.pop_size = int(20 * (1 - evaluations / self.budget) + 5)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive population size based on evaluation progress to enhance exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 20')", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {}, "mutation_prompt": null}
{"id": "518a1035-c21e-4948-9348-2eb9292481b3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    fitness_diff = np.abs(personal_best_values[i] - global_best_value)  # New line\n                    dynamic_F = self.F * (1 + evaluations / self.budget) * (1 - fitness_diff / np.max(personal_best_values))  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive mutation strategy based on fitness distance to improve exploration in HybridPSODE.", "configspace": "", "generation": 48, "fitness": 0.2225028430526438, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.223 with standard deviation 0.002. And the mean value of best solutions found was 0.258 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.22340193180409051, 0.22431423864474265, 0.2197923587090983], "final_y": [0.25705058592852104, 0.2569606684582434, 0.2594076190587714]}, "mutation_prompt": null}
{"id": "2ec6d10e-fa17-4188-84cb-b540eb4ef738", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                adaptive_CR = self.CR * (0.5 + 0.5 * (evaluations / self.budget))  # Modified line\n                if np.random.rand() < adaptive_CR:  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < adaptive_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive DE crossover probability (CR) based on evaluations to enhance exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.17694784739093813, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.177 with standard deviation 0.010. And the mean value of best solutions found was 0.342 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17112786676609848, 0.19118959744372044, 0.16852607796299546], "final_y": [0.48558441742613345, 0.11643332025254526, 0.42299671543702216]}, "mutation_prompt": null}
{"id": "92523e6a-c2d1-4966-8d74-e3484aa48284", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Improved the exploration-exploitation balance by dynamically adjusting the DE crossover probability as the budget progresses.", "configspace": "", "generation": 50, "fitness": 0.1727615842225365, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.019. And the mean value of best solutions found was 0.660 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.19021344575183785, 0.14565853457325306, 0.18241277234251863], "final_y": [0.44603676209193194, 0.9026602279963112, 0.6307575486381566]}, "mutation_prompt": null}
{"id": "e9085056-652c-422e-aee4-d5e13408a9a9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR * (1 - evaluations / self.budget):  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by modifying the DE crossover probability dynamically based on evaluations.", "configspace": "", "generation": 51, "fitness": 0.14677094181353167, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.010. And the mean value of best solutions found was 1.051 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1552830813045818, 0.13265716965727226, 0.15237257447874097], "final_y": [0.49530927666363295, 1.4474119570880348, 1.2109562239107499]}, "mutation_prompt": null}
{"id": "80e7a677-709c-49c9-ac90-c75d0227f4f6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Changed line\n                if np.random.rand() < dynamic_CR:  # Changed line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Improved convergence by scaling DE crossover probability and enhancing velocity adaptation.", "configspace": "", "generation": 52, "fitness": 0.17572824989400207, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.176 with standard deviation 0.042. And the mean value of best solutions found was 0.703 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.15441894006477985, 0.13827265225383967, 0.23449315736338672], "final_y": [0.23703487871706286, 1.7243644575447707, 0.1473547761466597]}, "mutation_prompt": null}
{"id": "cc03c749-38ba-4621-9d15-a796492da2e8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            self.pop_size = int(20 * (1 - evaluations / self.budget)) + 5  # Modified line\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing adaptive population size to balance exploration and exploitation across budget.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 20')", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {}, "mutation_prompt": null}
{"id": "6534290d-b7c0-402c-8d2e-49c7c302fdf1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20  # Initial population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.initial_pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.initial_pop_size\n        pop_size = self.initial_pop_size\n\n        while evaluations < self.budget:\n            for i in range(pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Opposition-based learning\n                opposition = lb + ub - candidate\n                opposition_value = func(opposition)\n                evaluations += 1\n\n                if opposition_value < func(candidate):\n                    candidate = opposition\n                    candidate_value = opposition_value\n                else:\n                    candidate_value = func(candidate)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n                \n                # Reduce population size adaptively\n                if evaluations % (self.budget // 4) == 0 and pop_size > 5:\n                    pop_size -= 1\n                    population = population[:pop_size]\n                    velocity = velocity[:pop_size]\n                    personal_best = personal_best[:pop_size]\n                    personal_best_values = personal_best_values[:pop_size]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive population size and opposition-based learning to improve exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 19').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 19')", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {}, "mutation_prompt": null}
{"id": "ba5e3477-c1b6-40c9-a3a0-0a11a829545a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n            self.pop_size = max(5, int(20 - 15 * (evaluations / self.budget)))  # New line\n\n        return global_best", "name": "HybridPSODE", "description": "Incorporated adaptive population size reduction to balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 55, "fitness": 0.1802370325573925, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.180 with standard deviation 0.020. And the mean value of best solutions found was 0.681 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18775062307338786, 0.19959152730714613, 0.15336894729164352], "final_y": [0.5155003795023889, 0.3726234884963845, 1.1559871691302992]}, "mutation_prompt": null}
{"id": "5f1b4298-7d32-4d72-9cc9-e5f82f68afd4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (0.9 - 0.4 * evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + 0.5 * evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by integrating adaptive inertia weight and mutation factor modulation to improve convergence rates.", "configspace": "", "generation": 56, "fitness": 0.16808110754241248, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.168 with standard deviation 0.006. And the mean value of best solutions found was 0.761 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.164632185978286, 0.16270574465953414, 0.17690539198941735], "final_y": [0.6210277462120783, 0.9043528023064656, 0.756576870806031]}, "mutation_prompt": null}
{"id": "2ee5fd12-11aa-4439-8b71-0cf1fbebdd12", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                stochastic_w = self.w * (1 - evaluations / self.budget) * np.random.uniform(0.9, 1.1)  # Modified line\n                velocity[i] = (stochastic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    stochastic_F = self.F * (1 + evaluations / self.budget) * np.random.uniform(0.9, 1.1)  # Modified line\n                    mutation_vector = a + stochastic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by introducing stochastic adjustment to DE scaling factor and inertia weight.", "configspace": "", "generation": 57, "fitness": 0.1663577982458833, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.166 with standard deviation 0.023. And the mean value of best solutions found was 0.950 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.19920910177526396, 0.14720036586819685, 0.15266392709418908], "final_y": [0.4354510127776238, 1.3152490255000604, 1.0988730089739724]}, "mutation_prompt": null}
{"id": "ba19791c-e780-426c-8544-4cb5e5fa01e2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive dynamic adjustment of crossover probability based on evaluation progress to enhance diversity and exploration.", "configspace": "", "generation": 58, "fitness": 0.17283705190287046, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.011. And the mean value of best solutions found was 0.451 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1802427861113034, 0.1811008940593497, 0.1571674755379583], "final_y": [0.36336487832012326, 0.5882146373492462, 0.40260158813739005]}, "mutation_prompt": null}
{"id": "e6ddc141-29d3-4d28-896e-fb6bdfc42cb6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 20  # Initial population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop_size = int(self.initial_pop_size * (1 + 0.5 * (1 - self.budget / self.budget)))  # Adaptive population size\n        population = np.random.uniform(lb, ub, (pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = pop_size\n\n        while evaluations < self.budget:\n            for i in range(pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive population size to balance exploration and exploitation dynamically.", "configspace": "", "generation": 59, "fitness": 0.14394646177752576, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.144 with standard deviation 0.026. And the mean value of best solutions found was 1.402 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18019135416469734, 0.12286360586138234, 0.12878442530649759], "final_y": [0.4665645405124611, 1.795824589860457, 1.9450841563409142]}, "mutation_prompt": null}
{"id": "3115dbec-c3d0-4e48-8204-1f73a9915ffb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                dynamic_c1 = self.c1 * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               dynamic_c1 * r1 * (personal_best[i] - population[i]) +  # Modified line\n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Incorporate a linearly decreasing cognitive component to balance exploration and exploitation in HybridPSODE.", "configspace": "", "generation": 60, "fitness": 0.17787260816844697, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.178 with standard deviation 0.017. And the mean value of best solutions found was 0.372 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.183679690438861, 0.15535837544208142, 0.19457975862439847], "final_y": [0.6443615792229948, 0.24488418782905944, 0.22763747830497005]}, "mutation_prompt": null}
{"id": "bf837844-2da2-474c-b0d1-4ffd641f31dc", "solution": "import numpy as np\n\nclass AdaptiveLRateMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.min_lr = 0.1   # Minimum learning rate\n        self.max_lr = 0.9   # Maximum learning rate\n        self.CR = 0.9       # DE crossover probability\n        self.mutation_factors = [0.5, 0.8, 1.2]  # Diverse mutation factors\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                lr = self.min_lr + (self.max_lr - self.min_lr) * (1 - evaluations / self.budget)\n                candidate = population[i] + lr * (global_best - population[i])\n                candidate = np.clip(candidate, lb, ub)\n\n                # Diverse Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    F = np.random.choice(self.mutation_factors)  # Randomly select mutation factor\n                    mutation_vector = a + F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "AdaptiveLRateMutation", "description": "Introduce adaptive learning rates and a diverse mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.19999888382643127, "feedback": "The algorithm AdaptiveLRateMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.200 with standard deviation 0.027. And the mean value of best solutions found was 0.453 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.16625747689432158, 0.23305431080143058, 0.20068486378354167], "final_y": [0.834456656676242, 0.17999362897514973, 0.34496381505777274]}, "mutation_prompt": null}
{"id": "871901e8-b546-4cd6-a82f-654068acdae1", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR * (1 - evaluations / self.budget):  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing adaptive crossover probability to further improve convergence.", "configspace": "", "generation": 62, "fitness": 0.16964535528440716, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.170 with standard deviation 0.008. And the mean value of best solutions found was 0.415 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18055674019510037, 0.16501095068313065, 0.16336837497499046], "final_y": [0.5090979395754279, 0.5608280555595505, 0.17527526045109593]}, "mutation_prompt": null}
{"id": "0cf1cf5f-621c-42fc-a436-8b31a2244ae9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Improved hybrid PSO-DE by dynamically adjusting both DE scaling factor and crossover probability for enhanced exploration and exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.14677094181353167, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.010. And the mean value of best solutions found was 1.051 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1552830813045818, 0.13265716965727226, 0.15237257447874097], "final_y": [0.49530927666363295, 1.4474119570880348, 1.2109562239107499]}, "mutation_prompt": null}
{"id": "0fba7468-2bbb-4bfb-b2bc-73c0721ed207", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                dynamic_c1 = self.c1 * (0.5 + evaluations / (2 * self.budget))  # Modified line\n                dynamic_c2 = self.c2 * (1.5 - evaluations / (2 * self.budget))  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               dynamic_c1 * r1 * (personal_best[i] - population[i]) +  # Modified line\n                               dynamic_c2 * r2 * (global_best - population[i]))  # Modified line\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by dynamically adjusting both the cognition and social components for improved exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.15088844311755212, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.151 with standard deviation 0.022. And the mean value of best solutions found was 1.194 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17623374059358665, 0.12246338833399695, 0.15396820042507275], "final_y": [0.4665645405124611, 2.4365658065662252, 0.6789278767817294]}, "mutation_prompt": null}
{"id": "cb51687b-56f0-41f4-8a19-6185ce0eed46", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget) \n                jitter = np.random.normal(0, 0.1, self.dim)  # Added line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]) + jitter)  # Modified line\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget) \n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced jitter to enhance exploration and prevent premature convergence by adding stochastic perturbations to the velocity.", "configspace": "", "generation": 65, "fitness": 0.186529761048429, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.031. And the mean value of best solutions found was 0.629 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.23059948501108507, 0.16516426053424815, 0.16382553759995377], "final_y": [0.08574586435890344, 0.9094561707462093, 0.8927254358650956]}, "mutation_prompt": null}
{"id": "d972a819-c2ac-4849-9804-8ac8efcfe421", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            if evaluations % (self.budget // 10) == 0:  # Adapt population size every 10% of the budget\n                self.pop_size = int(self.pop_size * (0.8 + 0.4 * np.random.rand()))\n                self.pop_size = max(5, min(self.pop_size, 30))  # Ensure pop_size is within reasonable bounds\n                population = population[:self.pop_size]\n                velocity = velocity[:self.pop_size]\n                personal_best = personal_best[:self.pop_size]\n                personal_best_values = personal_best_values[:self.pop_size]\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE by introducing a dynamic population size adaptation based on diversity to improve performance.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {}, "mutation_prompt": null}
{"id": "7f9936cf-e485-4932-9aec-373289424a1d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (np.tanh(1 - 2 * evaluations / self.budget))  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (np.tanh(1 + 2 * evaluations / self.budget))  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Improved adaptiveness by introducing non-linear scaling for DE and inertia weight.", "configspace": "", "generation": 67, "fitness": 0.18940849079208977, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.189 with standard deviation 0.004. And the mean value of best solutions found was 0.461 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18976482272304906, 0.19387802316004443, 0.1845826264931758], "final_y": [0.40239355014024714, 0.5291875416043054, 0.4522536657482133]}, "mutation_prompt": null}
{"id": "563fcd55-6398-4f04-9886-32e0acb64e74", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                # Adaptive population size update\n                self.pop_size = max(5, int(20 * (1 - evaluations / self.budget)))  # New line\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive population size based on evaluations to enhance exploration and exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.1694122517181181, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.016. And the mean value of best solutions found was 0.782 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.19237598813699208, 0.15974304260502792, 0.1561177244123343], "final_y": [0.43912066343915634, 1.0445424297722565, 0.8636702770326479]}, "mutation_prompt": null}
{"id": "a3866381-ed08-4869-9e4d-8fe178c6767e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced adaptive mechanism by introducing a dynamic crossover probability and population size to improve exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.16908908328106428, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.032. And the mean value of best solutions found was 0.509 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.12601691620803268, 0.20178246846902992, 0.17946786516613022], "final_y": [0.7756007887011024, 0.4272007545347302, 0.3255917134275917]}, "mutation_prompt": null}
{"id": "3fc40ec3-4d50-4d54-8504-2cfd6c80f657", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.95  # DE crossover probability (modified line)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Emphasize exploration by increasing DE crossover probability to enhance diversity in solutions.", "configspace": "", "generation": 70, "fitness": 0.18221504111716133, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.182 with standard deviation 0.019. And the mean value of best solutions found was 0.516 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18148052615016952, 0.20630843012187483, 0.15885616707943961], "final_y": [0.5240921490178645, 0.21910452733542554, 0.804176422206187]}, "mutation_prompt": null}
{"id": "e7c96bfd-cbbc-4c19-b7b9-8b0c832d3620", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.diversity_threshold = 0.1  # New parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            diversity = np.std(personal_best_values)  # New line\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] +\n                               self.c1 * r1 * (personal_best[i] - population[i]) +\n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    if diversity < self.diversity_threshold:  # New line\n                        dynamic_F = self.F * (1 + 2 * evaluations / self.budget)  # Modified line\n                    else:\n                        dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive mutation strategies and diversity preservation to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 71, "fitness": 0.16948316557939244, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.169 with standard deviation 0.009. And the mean value of best solutions found was 0.794 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1658193313799594, 0.16077273079875798, 0.1818574345594599], "final_y": [0.8381376249104996, 1.0120716069828626, 0.5325463942076161]}, "mutation_prompt": null}
{"id": "591be074-32cc-46f4-a108-bc366faa0c06", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR  # Modified line\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by introducing a variable adaptation for DE crossover probability based on evaluation progress.", "configspace": "", "generation": 72, "fitness": 0.1794223416623629, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.179 with standard deviation 0.015. And the mean value of best solutions found was 0.699 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18622687566153162, 0.15800874881806415, 0.1940314005074929], "final_y": [0.6058569454352511, 1.091754841357012, 0.3979204950002617]}, "mutation_prompt": null}
{"id": "08fdf257-39ee-468c-aced-98b047a3cddb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - (evaluations / self.budget) * 0.9)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + (evaluations / self.budget) * 1.1)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Optimized the dynamic adaptation by fine-tuning the DE scaling factor increment and inertia weight decrement rates to enhance convergence speed and solution quality.", "configspace": "", "generation": 73, "fitness": 0.14510428494476235, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.145 with standard deviation 0.025. And the mean value of best solutions found was 1.277 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17912218931458102, 0.12193412157564065, 0.1342565439440654], "final_y": [0.4883884332516878, 1.623109457534311, 1.7184904218482406]}, "mutation_prompt": null}
{"id": "9455f595-68c6-47dc-b781-5773f9a9b674", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    selected = np.random.choice(idxs, 3, replace=False)\n                    a, b, tournament_winner = population[selected[0]], population[selected[1]], population[selected[2]]\n                    dynamic_F = self.F * (1 + np.cos(np.pi * evaluations / self.budget))  # Modified line\n                    mutation_vector = a + dynamic_F * (b - tournament_winner)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced mutation strategy by scaling DE factor with cosine decay and integrating tournament selection to improve diversity and convergence.", "configspace": "", "generation": 74, "fitness": 0.17484061209378057, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.010. And the mean value of best solutions found was 0.641 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.183679690438861, 0.16092021418044156, 0.17992193166203918], "final_y": [0.6443615792229948, 0.6432275150799934, 0.6365437348478018]}, "mutation_prompt": null}
{"id": "c60ddc8e-1f5d-4936-8cae-66bf248d595e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.F = 0.5\n        self.CR = 0.9\n        self.velocity_clamp = 0.1  # Added line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                velocity[i] = np.clip(velocity[i], -self.velocity_clamp, self.velocity_clamp)  # Modified line\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    adaptive_F = self.F * (1.2 - evaluations / self.budget)  # Modified line\n                    mutation_vector = a + adaptive_F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive mutation strategy and velocity clamping to improve exploration and control convergence speed.", "configspace": "", "generation": 75, "fitness": 0.172241481986215, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.015. And the mean value of best solutions found was 0.271 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17586068445329428, 0.15211048020613338, 0.1887532812992173], "final_y": [0.2717076415377711, 0.3238839367250941, 0.21846660291003928]}, "mutation_prompt": null}
{"id": "64d9598c-d356-4305-b71b-6d1fc9669b36", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced adaptation by adjusting DE crossover probability dynamically to maintain exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.1794223416623629, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.179 with standard deviation 0.015. And the mean value of best solutions found was 0.699 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18622687566153162, 0.15800874881806415, 0.1940314005074929], "final_y": [0.6058569454352511, 1.091754841357012, 0.3979204950002617]}, "mutation_prompt": null}
{"id": "e6e33101-e654-420e-a10e-c848658b56c4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                learning_rate = 0.01  # New line\n                dynamic_w = self.w * (1 - evaluations / self.budget) * (1 + learning_rate)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget) * (1 - learning_rate)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced dynamic adaptation by introducing a learning rate for the DE scaling factor and inertia weight, improving convergence under budget constraints.", "configspace": "", "generation": 77, "fitness": 0.14307013583239114, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.143 with standard deviation 0.025. And the mean value of best solutions found was 1.651 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1781428396924002, 0.12286158891228738, 0.12820597889248586], "final_y": [0.5124157559474469, 2.4016502852700556, 2.038438193073256]}, "mutation_prompt": null}
{"id": "686ee142-553d-4483-95e1-9419a1b85531", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamically adjust population size\n            self.pop_size = max(10, int(20 * (1 - evaluations / self.budget)))\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by adjusting the population size dynamically based on iterations.", "configspace": "", "generation": 78, "fitness": 0.1716628681704592, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.172 with standard deviation 0.017. And the mean value of best solutions found was 0.765 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.19638496462535793, 0.15898853968263427, 0.15961510020338543], "final_y": [0.4364024222975619, 1.1431772069487018, 0.7148667967329914]}, "mutation_prompt": null}
{"id": "b8d4cdf4-1849-4ea8-9112-183b69b73cc3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                velocity_clamp = (ub - lb) * 0.1  # New line: added velocity clamping\n                velocity[i] = np.clip(velocity[i], -velocity_clamp, velocity_clamp)  # New line: apply clamping\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive velocity clamping to limit particle speed and maintain exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.11991594976805713, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.120 with standard deviation 0.026. And the mean value of best solutions found was 2.317 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.09126883649487483, 0.11478487655986425, 0.1536941362494323], "final_y": [3.6961724710965824, 2.821329642613842, 0.4348105154333148]}, "mutation_prompt": null}
{"id": "e1b3617d-ab1c-4be2-8098-b45cf9fa2d6c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                \n                # Modified line: Integrating DE dynamics into velocity update\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]) + \n                               self.F * (population[np.random.choice(self.pop_size)] - population[i]))\n\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with improved velocity update by incorporating differential evolution dynamics for better exploration.", "configspace": "", "generation": 80, "fitness": 0.17484312128963345, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.010. And the mean value of best solutions found was 0.639 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1882356733708468, 0.163031153971686, 0.17326253652636758], "final_y": [0.39308335652230464, 1.0415916074468854, 0.4823828134027471]}, "mutation_prompt": null}
{"id": "cdd82786-408b-4503-a036-c2913b26abfd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / (2 * self.budget))  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive crossover probability to enhance exploration and exploitation balance in the algorithm.", "configspace": "", "generation": 81, "fitness": 0.23089909199277817, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.231 with standard deviation 0.018. And the mean value of best solutions found was 0.223 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.24302597477403687, 0.24474562729729998, 0.20492567390699767], "final_y": [0.15801869963425852, 0.15863785825883162, 0.35354059615542366]}, "mutation_prompt": null}
{"id": "b186d2ca-24fb-4f4b-b0b2-ebd8aa492f72", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (0.5 + 0.5 * np.sin((evaluations / self.budget) * np.pi))\n                if np.random.rand() < dynamic_CR:  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive crossover probability to improve exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.16364831129910548, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.164 with standard deviation 0.014. And the mean value of best solutions found was 0.723 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1772483862643185, 0.16975485941400492, 0.143941688218993], "final_y": [0.5924196720111721, 0.45269687149631077, 1.1246509527238964]}, "mutation_prompt": null}
{"id": "d4c37162-70f1-420e-abc7-dd470ce981e7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Change 1: Diversified initialization strategy\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim)) * (1.1 - 0.2 * np.random.rand(self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Change 2: Adaptive velocity scaling\n                dynamic_w = self.w * (1 - (evaluations / self.budget)**2)\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced convergence by incorporating adaptive velocity scaling and a diversified initialization strategy.", "configspace": "", "generation": 83, "fitness": 0.1732790187327353, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.001. And the mean value of best solutions found was 0.485 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17363393084191903, 0.17388731096392518, 0.17231581439236165], "final_y": [0.23931554257750765, 0.5594965921441719, 0.655320132567987]}, "mutation_prompt": null}
{"id": "ad5123ae-19eb-455b-be50-a89c88ace873", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = np.random.normal(self.F, 0.1) * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced exploration by introducing stochastic mutation scaling factors using a Gaussian distribution.", "configspace": "", "generation": 84, "fitness": 0.16598416890716325, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.166 with standard deviation 0.015. And the mean value of best solutions found was 0.940 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1520332993819027, 0.18636386153618434, 0.1595553458034027], "final_y": [1.1059092299508846, 0.6308333990828207, 1.084719705211067]}, "mutation_prompt": null}
{"id": "f81c6348-4094-47a5-aa12-0cc0818ea30f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                self.pop_size = max(5, self.pop_size - (evaluations // (self.budget / 5)))  # Adaptive population reduction\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced an adaptive population size reduction to enhance exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object cannot be interpreted as an integer\").", "error": "TypeError(\"'float' object cannot be interpreted as an integer\")", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {}, "mutation_prompt": null}
{"id": "780041d6-374d-4046-8c31-ae0c3a90a955", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    dynamic_CR = self.CR * (1 - evaluations / self.budget)  # New line\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Refined the DE mutation strategy to include a dynamic crossover adaptation for enhanced exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.17302227050270647, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.173 with standard deviation 0.004. And the mean value of best solutions found was 0.420 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17794565960896147, 0.17353281371871576, 0.16758833818044216], "final_y": [0.656841660885707, 0.4668245038550343, 0.1351908527784903]}, "mutation_prompt": null}
{"id": "84ca5694-6982-4cad-832f-55c1b84c6d08", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - (evaluations / self.budget)**2)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Improved adaptation by dynamically adjusting the DE crossover probability and enhancing inertia weight decay.", "configspace": "", "generation": 87, "fitness": 0.1798594558117312, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.180 with standard deviation 0.018. And the mean value of best solutions found was 0.735 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18243950097916384, 0.15722333068229455, 0.19991553577373522], "final_y": [0.6686225747059346, 1.1399894510847715, 0.39515622366518144]}, "mutation_prompt": null}
{"id": "db1c47f2-2826-4816-9bf3-be03b47bc574", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (0.5 + evaluations / (2*self.budget))  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced a modulation in the DE scaling factor's dynamic adaptation curve for improved exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.1464101470625079, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.013. And the mean value of best solutions found was 1.023 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.15641034312700552, 0.1547414348308317, 0.12807866322968653], "final_y": [0.7137460955767138, 0.7972496375789873, 1.557852467532553]}, "mutation_prompt": null}
{"id": "807fa759-cb84-4df9-aaaa-96230e68d9ea", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR * (1 - evaluations / self.budget):  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced convergence by dynamically adjusting the DE crossover probability and cognitive component based on progress.", "configspace": "", "generation": 89, "fitness": 0.17457018552287143, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.017. And the mean value of best solutions found was 0.585 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18625573739079437, 0.1506171953567661, 0.18683762382105384], "final_y": [0.3200648892074596, 1.092319920330776, 0.3418600319834533]}, "mutation_prompt": null}
{"id": "838c8bc0-4e31-45c0-8020-ba5fd219b230", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n                velocity[i] = np.clip(velocity[i], -0.5, 0.5)  # Updated line\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR * (1 - evaluations / self.budget):  # Updated line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced balance between exploration and exploitation by adjusting DE crossover probability and particle velocity boundary.", "configspace": "", "generation": 90, "fitness": 0.1572478252508727, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.157 with standard deviation 0.007. And the mean value of best solutions found was 0.624 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.16209787730553704, 0.16208461509309113, 0.14756098335398993], "final_y": [0.21293617799027945, 0.5728422254305878, 1.0855566328526653]}, "mutation_prompt": null}
{"id": "703b6026-ef5f-4cba-bd6f-6a605bad8370", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Increased population size for diversity\n        self.c1_start, self.c1_end = 2.5, 0.5  # Adaptive cognitive component\n        self.c2_start, self.c2_end = 0.5, 2.5  # Adaptive social component\n        self.w_start, self.w_end = 0.9, 0.4  # Adaptive inertia weight\n        self.F = 0.4  # DE scaling factor\n        self.CR = 0.8  # Reduced DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                curr_progress = evaluations / self.budget\n                w = self.w_start - (self.w_start - self.w_end) * curr_progress\n                c1 = self.c1_start - (self.c1_start - self.c1_end) * curr_progress\n                c2 = self.c2_start + (self.c2_end - self.c2_start) * curr_progress\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity[i] = (w * velocity[i] + \n                               c1 * r1 * (personal_best[i] - population[i]) +\n                               c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced convergence by incorporating adaptive particle swarm parameters and hybridizing with a controlled mutation mechanism.", "configspace": "", "generation": 91, "fitness": 0.18655855332764415, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.187 with standard deviation 0.026. And the mean value of best solutions found was 0.530 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1930019085608775, 0.15259053346219575, 0.21408321795985918], "final_y": [0.13513271537390786, 1.1960570740950465, 0.2581964784944518]}, "mutation_prompt": null}
{"id": "1f99b055-ef7c-46f6-9d3a-0a4fb3f530f3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = 0.5 * (global_best + a) + dynamic_F * (b - c)  # Modified line\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced DE mutation strategy by using a weighted combination of best and random vectors to improve exploration.", "configspace": "", "generation": 92, "fitness": 0.1858789687682636, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.186 with standard deviation 0.007. And the mean value of best solutions found was 0.342 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.17614632299609068, 0.18989652410879687, 0.19159405919990324], "final_y": [0.2170045039298498, 0.5240759183224626, 0.2845278409554197]}, "mutation_prompt": null}
{"id": "580ce43f-d0b0-4249-8e64-c1bfc97f5f32", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # Dynamic population size adjustment\n            dynamic_pop_size = self.pop_size + int(evaluations / self.budget * 10)  # Changed line\n\n            for i in range(dynamic_pop_size):  # Changed line\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)\n                velocity[i % self.pop_size] = (dynamic_w * velocity[i % self.pop_size] + \n                                               self.c1 * r1 * (personal_best[i % self.pop_size] - population[i % self.pop_size]) + \n                                               self.c2 * r2 * (global_best - population[i % self.pop_size]))\n                candidate = population[i % self.pop_size] + velocity[i % self.pop_size]\n                candidate = np.clip(candidate, lb, ub)\n\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i % self.pop_size]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                if candidate_value < personal_best_values[i % self.pop_size]:\n                    personal_best[i % self.pop_size] = candidate\n                    personal_best_values[i % self.pop_size] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Introduced adaptive population size based on budget consumption to enhance exploration-exploitation balance.", "configspace": "", "generation": 93, "fitness": 0.16651765211911077, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.167 with standard deviation 0.013. And the mean value of best solutions found was 0.618 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1837985563885921, 0.15314371422439477, 0.16261068574434545], "final_y": [0.6269609496762292, 0.17148279336341102, 1.054248509276263]}, "mutation_prompt": null}
{"id": "aeb16d2e-b8b3-461d-8ed9-39d000d0a737", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # New line\n                if np.random.rand() < dynamic_CR:  # Changed line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced adaptability by introducing a dynamic DE crossover probability based on evaluation progress.", "configspace": "", "generation": 94, "fitness": 0.17457018552287143, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.175 with standard deviation 0.017. And the mean value of best solutions found was 0.585 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18625573739079437, 0.1506171953567661, 0.18683762382105384], "final_y": [0.3200648892074596, 1.092319920330776, 0.3418600319834533]}, "mutation_prompt": null}
{"id": "304b5a05-0798-41bd-92ee-4341f4d22bf2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR * (1 - evaluations / self.budget):  # Modified line\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced the DE mutation strategy by dynamically adjusting the crossover probability to improve exploration.", "configspace": "", "generation": 95, "fitness": 0.14677094181353167, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.147 with standard deviation 0.010. And the mean value of best solutions found was 1.051 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.1552830813045818, 0.13265716965727226, 0.15237257447874097], "final_y": [0.49530927666363295, 1.4474119570880348, 1.2109562239107499]}, "mutation_prompt": null}
{"id": "9b8fc2a2-2b5c-49ef-859a-22de2c267430", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (0.5 + 0.5 * (1 - evaluations / self.budget))  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + 0.5 * evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced the dynamic adaptation of DE scaling factor and inertia weight for improved convergence by adjusting their update equations.", "configspace": "", "generation": 96, "fitness": 0.1626945610888192, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.163 with standard deviation 0.018. And the mean value of best solutions found was 0.681 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18046399436354377, 0.16925103747862136, 0.13836865142429244], "final_y": [0.5152970097637151, 0.17198933829497395, 1.3565133740840325]}, "mutation_prompt": null}
{"id": "75d8ec3d-314a-4f51-af3f-188bc780a882", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                dynamic_CR = self.CR * (1 - evaluations / self.budget)  # Modified line\n                if np.random.rand() < dynamic_CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < dynamic_CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced population diversity by adjusting the DE crossover probability dynamically to improve exploration.", "configspace": "", "generation": 97, "fitness": 0.1794223416623629, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.179 with standard deviation 0.015. And the mean value of best solutions found was 0.699 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18622687566153162, 0.15800874881806415, 0.1940314005074929], "final_y": [0.6058569454352511, 1.091754841357012, 0.3979204950002617]}, "mutation_prompt": null}
{"id": "39ca2479-c3e8-43eb-b1b6-2d5af2cc658c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                dynamic_c1 = self.c1 * (1 - evaluations / self.budget)  # New modification\n                velocity[i] = (dynamic_w * velocity[i] + \n                               dynamic_c1 * r1 * (personal_best[i] - population[i]) +  # Changed line\n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + evaluations / self.budget)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced the update strategy by incorporating a dynamic cognitive component and adjusted DE mutation strategy to improve exploration-exploitation balance.", "configspace": "", "generation": 98, "fitness": 0.14615050738982102, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.146 with standard deviation 0.025. And the mean value of best solutions found was 1.246 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.18019135416469734, 0.12246338833399695, 0.13579677967076875], "final_y": [0.4665645405124611, 2.4365658065662252, 0.8344998562487641]}, "mutation_prompt": null}
{"id": "1040ebca-773a-490d-94b4-a1a6788f0326", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 20  # Population size\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.7   # Inertia weight\n        self.F = 0.5   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                dynamic_w = self.w * (1 - evaluations / self.budget)  # Modified line\n                velocity[i] = (dynamic_w * velocity[i] + \n                               self.c1 * r1 * (personal_best[i] - population[i]) + \n                               self.c2 * r2 * (global_best - population[i]))\n                candidate = population[i] + velocity[i]\n                candidate = np.clip(candidate, lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if np.random.rand() < self.CR:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    dynamic_F = self.F * (1 + (evaluations / self.budget)**1.5)  # Modified line\n                    mutation_vector = a + dynamic_F * (b - c)\n                    mutation_vector = np.clip(mutation_vector, lb, ub)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    candidate[crossover] = mutation_vector[crossover]\n\n                candidate_value = func(candidate)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best[i] = candidate\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best = candidate\n                        global_best_value = candidate_value\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "HybridPSODE", "description": "Enhanced adaptation by scaling differential weight `F` non-linearly for improved exploration and convergence.", "configspace": "", "generation": 99, "fitness": 0.16596865924886942, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.166 with standard deviation 0.017. And the mean value of best solutions found was 0.689 (0. is the best).", "error": "", "parent_id": "f1883095-de88-4d22-97af-3c9fbaef3b7e", "metadata": {"aucs": [0.183679690438861, 0.14218872198607269, 0.17203756532167458], "final_y": [0.6443615792229948, 0.5795955344186793, 0.8439942987666825]}, "mutation_prompt": null}
