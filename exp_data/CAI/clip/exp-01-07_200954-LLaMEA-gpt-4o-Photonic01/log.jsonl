{"id": "886577a7-f8fc-42f0-adca-0a299a856ca9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for _ in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                else:\n                    accept_prob = np.exp((fitness[i] - trial_fitness) / self.temperature)\n                    if np.random.rand() < accept_prob:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n            self.temperature *= self.cooling_rate\n\n        return best_solution, best_fitness", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for efficient exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 0, "fitness": 0.06520540296222081, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.065 with standard deviation 0.003. And the mean value of best solutions found was 0.209 (0. is the best).", "error": "", "parent_id": null, "metadata": {"aucs": [0.06376999401986194, 0.06268040751751924, 0.06916580734928124], "final_y": [0.19248682010484208, 0.23189290390532613, 0.20376885531206546]}, "mutation_prompt": null}
{"id": "8a179b97-46a8-40c6-95d5-67eb2744367f", "solution": "import numpy as np\n\nclass PSOMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.mutation_factor = 0.1\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for _ in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities \n                          + self.cognitive_weight * r1 * (personal_best_positions - population) \n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            # Update personal bests\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            # Update global best\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            # Apply mutation strategy\n            mutation_prob = np.random.rand(self.population_size, self.dim)\n            mutation_mask = mutation_prob < self.mutation_factor\n            mutated_population = np.where(mutation_mask, \n                                          np.random.rand(self.population_size, self.dim) * (ub - lb) + lb, \n                                          new_population)\n\n            # Evaluate mutated individuals\n            mutated_fitness = np.array([func(ind) for ind in mutated_population])\n            evals += np.sum(mutation_mask)\n\n            # Select between mutated and new individuals\n            improved_mask = mutated_fitness < new_fitness\n            population[improved_mask] = mutated_population[improved_mask]\n            fitness[improved_mask] = mutated_fitness[improved_mask]\n\n            # Re-evaluate global best from possible mutated improvements\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "PSOMS", "description": "A novel algorithm combining Particle Swarm Optimization with a Self-Adaptive Mutation Strategy for improved balance between exploration and exploitation across diverse search spaces.", "configspace": "", "generation": 1, "fitness": 0.07630755272379226, "feedback": "The algorithm PSOMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.076 with standard deviation 0.003. And the mean value of best solutions found was 0.236 (0. is the best).", "error": "", "parent_id": "886577a7-f8fc-42f0-adca-0a299a856ca9", "metadata": {"aucs": [0.0765994870990293, 0.07199792675076155, 0.08032524432158594], "final_y": [0.23795624604913979, 0.24470207875414918, 0.22636670580512785]}, "mutation_prompt": null}
{"id": "a263e85c-31d1-4a38-8e05-4d68b3c8fade", "solution": "import numpy as np\n\nclass LAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.mutation_factor_min = 0.05\n        self.mutation_factor_max = 0.2\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities \n                          + self.cognitive_weight * r1 * (personal_best_positions - population) \n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            # Update personal bests\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            # Update global best\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            # Adaptive mutation factor\n            progress_ratio = iteration / self.iterations\n            mutation_factor = self.mutation_factor_min + (self.mutation_factor_max - self.mutation_factor_min) * (1 - progress_ratio)\n\n            # Apply mutation strategy\n            mutation_prob = np.random.rand(self.population_size, self.dim)\n            mutation_mask = mutation_prob < mutation_factor\n            mutated_population = np.where(mutation_mask, \n                                          np.random.rand(self.population_size, self.dim) * (ub - lb) + lb, \n                                          new_population)\n\n            # Evaluate mutated individuals\n            mutated_fitness = np.array([func(ind) for ind in mutated_population])\n            evals += np.sum(mutation_mask)\n\n            # Select between mutated and new individuals\n            improved_mask = mutated_fitness < new_fitness\n            population[improved_mask] = mutated_population[improved_mask]\n            fitness[improved_mask] = mutated_fitness[improved_mask]\n\n            # Re-evaluate global best from possible mutated improvements\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "LAMS", "description": "An enhanced PSO with Layered Adaptive Mutation Strategy (LAMS) that dynamically adjusts mutation based on search progress to optimize exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.07662410480463348, "feedback": "The algorithm LAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.077 with standard deviation 0.001. And the mean value of best solutions found was 0.238 (0. is the best).", "error": "", "parent_id": "8a179b97-46a8-40c6-95d5-67eb2744367f", "metadata": {"aucs": [0.07624622580302187, 0.07751657282756474, 0.07610951578331382], "final_y": [0.23851583503469864, 0.23055462174564867, 0.2443348894959646]}, "mutation_prompt": null}
{"id": "d4d2e28c-553d-4d07-87bc-e5616b0ec8de", "solution": "import numpy as np\n\nclass QD_GPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.sigma_min = 0.1\n        self.sigma_max = 0.5\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities \n                          + self.cognitive_weight * r1 * (personal_best_positions - population) \n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            # Update personal bests\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            # Update global best\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            # Adaptive Gaussian perturbation\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Evaluate quantum-inspired individuals\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            evals += self.population_size\n\n            # Select between quantum and new individuals\n            improved_mask = quantum_fitness < new_fitness\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            # Re-evaluate global best from possible quantum improvements\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QD_GPSO", "description": "Quantum-inspired Dynamic Gaussian Particle Swarm Optimization (QD-GPSO) leverages quantum-based mechanisms with adaptive Gaussian perturbation for enhanced exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.08719069924484361, "feedback": "The algorithm QD_GPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.003. And the mean value of best solutions found was 0.175 (0. is the best).", "error": "", "parent_id": "a263e85c-31d1-4a38-8e05-4d68b3c8fade", "metadata": {"aucs": [0.09028709901707954, 0.08817363686073254, 0.08311136185671875], "final_y": [0.16871093302966578, 0.184118119517793, 0.17229897728319798]}, "mutation_prompt": null}
{"id": "8ce15cca-ae17-4c72-9891-54654b48f630", "solution": "import numpy as np\n\nclass QD_GPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.sigma_min = 0.1\n        self.sigma_max = 0.5\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n            \n            # Dynamically adjust inertia weight\n            self.inertia_weight = 0.9 - (iteration / self.iterations) * 0.5\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities \n                          + self.cognitive_weight * r1 * (personal_best_positions - population) \n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            # Update personal bests\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            # Update global best\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            # Adaptive Gaussian perturbation\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Evaluate quantum-inspired individuals\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            evals += self.population_size\n\n            # Select between quantum and new individuals\n            improved_mask = quantum_fitness < new_fitness\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            # Re-evaluate global best from possible quantum improvements\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QD_GPSO", "description": "Improved exploration by dynamically adjusting the inertia weight based on iteration progress.", "configspace": "", "generation": 4, "fitness": 0.07558339608708853, "feedback": "The algorithm QD_GPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.076 with standard deviation 0.003. And the mean value of best solutions found was 0.188 (0. is the best).", "error": "", "parent_id": "d4d2e28c-553d-4d07-87bc-e5616b0ec8de", "metadata": {"aucs": [0.07542336246190606, 0.0718091581196979, 0.07951766767966162], "final_y": [0.2047074081828767, 0.18845145507250227, 0.17199717674067183]}, "mutation_prompt": null}
{"id": "0e6987fb-b25e-4f15-b36c-d89e903b8c12", "solution": "import numpy as np\n\nclass QE_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.F_min = 0.5\n        self.F_max = 0.9\n        self.CR = 0.9\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            progress_ratio = iteration / self.iterations\n            F = self.F_min + (self.F_max - self.F_min) * progress_ratio\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant_vector = x1 + F * (x2 - x3)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover_mask):\n                    crossover_mask[np.random.randint(0, self.dim)] = True\n\n                trial_vector = np.where(crossover_mask, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_position = trial_vector\n                        global_best_fitness = trial_fitness\n\n            # Adaptive quantum-inspired perturbation\n            sigma = self.F_max * (1 - progress_ratio)\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            evals += self.population_size\n\n            improved_mask = quantum_fitness < fitness\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QE_ADE", "description": "Quantum-Enhanced Adaptive Differential Evolution (QE-ADE) incorporates quantum-inspired adaptation with a dynamic differential mutation mechanism to balance global exploration and local exploitation.", "configspace": "", "generation": 5, "fitness": 0.07204036445078359, "feedback": "The algorithm QE_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.072 with standard deviation 0.002. And the mean value of best solutions found was 0.215 (0. is the best).", "error": "", "parent_id": "d4d2e28c-553d-4d07-87bc-e5616b0ec8de", "metadata": {"aucs": [0.06970871322700112, 0.07275896514193103, 0.0736534149834186], "final_y": [0.22603367223972892, 0.23363386816905163, 0.1846841799903296]}, "mutation_prompt": null}
{"id": "1dc4a751-7db9-4acd-8e91-dd64db4b104f", "solution": "import numpy as np\n\nclass QD_GPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.sigma_min = 0.1\n        self.sigma_max = 0.5\n        self.iterations = budget // self.population_size\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            self.social_weight = 1.5 + 0.5 * (1 - iteration / self.iterations)  # Dynamic adjustment\n            velocities = (self.inertia_weight * velocities \n                          + self.cognitive_weight * r1 * (personal_best_positions - population) \n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            # Evaluate new population\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            # Update personal bests\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            # Update global best\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            # Adaptive Gaussian perturbation\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Evaluate quantum-inspired individuals\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            evals += self.population_size\n\n            # Select between quantum and new individuals\n            improved_mask = quantum_fitness < new_fitness\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            # Re-evaluate global best from possible quantum improvements\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QD_GPSO", "description": "Enhanced QD-GPSO with dynamic social weight adjustment for improved exploitation.", "configspace": "", "generation": 6, "fitness": 0.0859084684046002, "feedback": "The algorithm QD_GPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.086 with standard deviation 0.006. And the mean value of best solutions found was 0.185 (0. is the best).", "error": "", "parent_id": "d4d2e28c-553d-4d07-87bc-e5616b0ec8de", "metadata": {"aucs": [0.09341952081502392, 0.0862642656903696, 0.07804161870840709], "final_y": [0.17170498186157357, 0.19094703862868245, 0.19132511307937872]}, "mutation_prompt": null}
{"id": "3215044e-c504-4628-9c36-f017b000cd6a", "solution": "import numpy as np\n\nclass QDL_PAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6  # Changed from 0.7 to enhance exploration\n        self.cognitive_weight = 1.7  # Changed from 1.5 for better personal search\n        self.social_weight = 1.3  # Changed from 1.5 to reduce premature convergence\n        self.sigma_min = 0.1\n        self.sigma_max = 0.4  # Reduced max sigma for smoother convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius = 0.05  # New parameter for local search\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Adaptive Local Search\n            local_perturbation = np.random.uniform(-self.adaptive_radius, self.adaptive_radius,\n                                                   (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL", "description": "Enhanced Quantum Dynamic PSO using Adaptive Local Exploration (QDL-PAL) integrates adaptive local search with quantum perturbation to balance exploration and exploitation more effectively.", "configspace": "", "generation": 7, "fitness": 0.0920028800241189, "feedback": "The algorithm QDL_PAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "d4d2e28c-553d-4d07-87bc-e5616b0ec8de", "metadata": {"aucs": [0.09593247734947674, 0.08790380384985363, 0.09217235887302633], "final_y": [0.16486066168784652, 0.181886423769274, 0.16485794562119194]}, "mutation_prompt": null}
{"id": "b53599b3-3f00-40bc-a498-56a1a4040897", "solution": "import numpy as np\n\nclass QDL_PAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 32  # Increased from 30 to improve exploration\n        self.inertia_weight = 0.6  # Changed from 0.7 to enhance exploration\n        self.cognitive_weight = 1.7  # Changed from 1.5 for better personal search\n        self.social_weight = 1.3  # Changed from 1.5 to reduce premature convergence\n        self.sigma_min = 0.1\n        self.sigma_max = 0.4  # Reduced max sigma for smoother convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius = 0.05  # New parameter for local search\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Adaptive Local Search\n            local_perturbation = np.random.uniform(-self.adaptive_radius, self.adaptive_radius,\n                                                   (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL", "description": "Slightly increased the population size in QDL-PAL to enhance diversity and exploration capability.", "configspace": "", "generation": 8, "fitness": 0.08281780816222824, "feedback": "The algorithm QDL_PAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.083 with standard deviation 0.012. And the mean value of best solutions found was 0.203 (0. is the best).", "error": "", "parent_id": "3215044e-c504-4628-9c36-f017b000cd6a", "metadata": {"aucs": [0.06581381505991579, 0.08899790840527744, 0.0936417010214915], "final_y": [0.2626722095038284, 0.1818875377032908, 0.16485867041330182]}, "mutation_prompt": null}
{"id": "3b070980-7397-4d42-a916-fc3d269e7a3a", "solution": "import numpy as np\n\nclass QDL_PAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6  # Changed from 0.7 to enhance exploration\n        self.cognitive_weight = 1.7  # Changed from 1.5 for better personal search\n        self.social_weight = 1.3  # Changed from 1.5 to reduce premature convergence\n        self.sigma_min = 0.1\n        self.sigma_max = 0.4  # Reduced max sigma for smoother convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius = 0.1  # Increased parameter for local search\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Adaptive Local Search\n            local_perturbation = np.random.uniform(-self.adaptive_radius, self.adaptive_radius,\n                                                   (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL", "description": "Improved exploration by increasing the adaptive radius to 0.1 for better local search.", "configspace": "", "generation": 9, "fitness": 0.09206671702823892, "feedback": "The algorithm QDL_PAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "3215044e-c504-4628-9c36-f017b000cd6a", "metadata": {"aucs": [0.09585987671768037, 0.08813959759813628, 0.09220067676890009], "final_y": [0.16485935101634053, 0.18187913912603526, 0.16491279963778793]}, "mutation_prompt": null}
{"id": "b257eae8-e88f-4b55-9827-961556f507fc", "solution": "import numpy as np\n\nclass QDL_PAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6  # Changed from 0.7 to enhance exploration\n        self.cognitive_weight = 1.7  # Changed from 1.5 for better personal search\n        self.social_weight = 1.35  # Adjusted from 1.3 for better convergence\n        self.sigma_min = 0.1\n        self.sigma_max = 0.4  # Reduced max sigma for smoother convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius = 0.1  # Increased parameter for local search\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Adaptive Local Search\n            local_perturbation = np.random.uniform(-self.adaptive_radius, self.adaptive_radius,\n                                                   (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL", "description": "Enhanced global exploration by adjusting social weight for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.09171455565189934, "feedback": "The algorithm QDL_PAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "3b070980-7397-4d42-a916-fc3d269e7a3a", "metadata": {"aucs": [0.09488859037606578, 0.08766856470942441, 0.09258651187020783], "final_y": [0.16485714999270062, 0.18188262471768835, 0.16486573060226128]}, "mutation_prompt": null}
{"id": "f03fd080-c19e-4d9a-a432-1e3a54e2f8c3", "solution": "import numpy as np\n\nclass QDL_PAL_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.5  # Adjusted for enhanced exploration\n        self.cognitive_weight = 1.8  # Enhanced personal search\n        self.social_weight = 1.4  # Slight increase for better convergence\n        self.sigma_min = 0.05  # Reduced for finer local search\n        self.sigma_max = 0.35  # Smoothed convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius = 0.12  # Slight increase for local search\n        self.communication_factor = 0.2  # New parameter for inter-agent collaboration\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2, r3 = np.random.rand(3)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population)\n                          - self.communication_factor * r3 * (population.mean(axis=0) - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            local_perturbation = np.random.uniform(-self.adaptive_radius, self.adaptive_radius,\n                                                   (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL_Enhanced", "description": "Enhanced agent communication and adaptive learning for improved global convergence.", "configspace": "", "generation": 11, "fitness": 0.0795002076908609, "feedback": "The algorithm QDL_PAL_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.080 with standard deviation 0.017. And the mean value of best solutions found was 0.220 (0. is the best).", "error": "", "parent_id": "3b070980-7397-4d42-a916-fc3d269e7a3a", "metadata": {"aucs": [0.09340271519766397, 0.08949222444881233, 0.05560568342610639], "final_y": [0.16513031983043314, 0.1819016978584289, 0.31337269120097067]}, "mutation_prompt": null}
{"id": "c7b1ac36-564b-441e-8ea6-57ed400f5d50", "solution": "import numpy as np\n\nclass QDL_PAL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6\n        self.cognitive_weight = 1.7\n        self.social_weight = 1.3\n        self.sigma_min = 0.1\n        self.sigma_max = 0.4\n        self.iterations = budget // self.population_size\n        self.adaptive_radius_min = 0.05  # Adjusted for dynamic range\n        self.adaptive_radius_max = 0.2  # Adjusted for dynamic range\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            # Dynamic Adaptive Local Search\n            adaptive_radius = self.adaptive_radius_min + (self.adaptive_radius_max - self.adaptive_radius_min) * (1 - progress_ratio)\n            local_perturbation = np.random.uniform(-adaptive_radius, adaptive_radius, (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness)\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL", "description": "Enhance exploitation by dynamically adjusting the adaptive radius based on convergence progress.", "configspace": "", "generation": 12, "fitness": 0.09216023420026602, "feedback": "The algorithm QDL_PAL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "3b070980-7397-4d42-a916-fc3d269e7a3a", "metadata": {"aucs": [0.09588019864422115, 0.08798219405120833, 0.09261830990536857], "final_y": [0.16485962706738877, 0.18188045687855603, 0.1648611635068017]}, "mutation_prompt": null}
{"id": "0e8a6658-597d-4fce-91fe-1bdef0ad239b", "solution": "import numpy as np\n\nclass QDL_PAL_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7  # Adjusted for better exploration\n        self.cognitive_weight = 1.5  # Reduced to balance exploration and exploitation\n        self.social_weight = 1.5  # Increased for stronger global influence\n        self.sigma_min = 0.05  # Reduced for refined local exploration\n        self.sigma_max = 0.3  # Reduced for stability in convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius_min = 0.02  # Narrowed for precise local search\n        self.adaptive_radius_max = 0.15  # Reduced to maintain balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.05 * (ub - lb)  # Reduced initial velocity\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            adaptive_radius = self.adaptive_radius_min + (self.adaptive_radius_max - self.adaptive_radius_min) * (1 - progress_ratio)\n            local_perturbation = np.random.uniform(-adaptive_radius, adaptive_radius, (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            noise_selection_mask = np.random.rand(self.population_size) < 0.75  # Selective noise application\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness) & noise_selection_mask\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL_Enhanced", "description": "Enhance convergence by integrating informed swarm movement and selective noise application.", "configspace": "", "generation": 13, "fitness": 0.09272180111516437, "feedback": "The algorithm QDL_PAL_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "c7b1ac36-564b-441e-8ea6-57ed400f5d50", "metadata": {"aucs": [0.09394067216101554, 0.09034107646987954, 0.09388365471459803], "final_y": [0.16485820875771462, 0.18188540521704077, 0.1648604617312237]}, "mutation_prompt": null}
{"id": "7e0d45fd-7a95-4c1a-a0e3-63db2e2102a5", "solution": "import numpy as np\n\nclass QDL_PAL_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7  # Adjusted for better exploration\n        self.cognitive_weight = 1.5  # Reduced to balance exploration and exploitation\n        self.social_weight = 1.7  # Changed for stronger global influence\n        self.sigma_min = 0.05  # Reduced for refined local exploration\n        self.sigma_max = 0.3  # Reduced for stability in convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius_min = 0.02  # Narrowed for precise local search\n        self.adaptive_radius_max = 0.15  # Reduced to maintain balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.05 * (ub - lb)  # Reduced initial velocity\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            adaptive_radius = self.adaptive_radius_min + (self.adaptive_radius_max - self.adaptive_radius_min) * (1 - progress_ratio)\n            local_perturbation = np.random.uniform(-adaptive_radius, adaptive_radius, (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            noise_selection_mask = np.random.rand(self.population_size) < 0.75  # Selective noise application\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness) & noise_selection_mask\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL_Enhanced", "description": "Refine convergence by enhancing global influence and reducing local exploitation.", "configspace": "", "generation": 14, "fitness": 0.09223006374802116, "feedback": "The algorithm QDL_PAL_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.092 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "0e8a6658-597d-4fce-91fe-1bdef0ad239b", "metadata": {"aucs": [0.09378813356272875, 0.08953782479722083, 0.09336423288411388], "final_y": [0.16493751485412866, 0.18189241599565287, 0.16487192233813286]}, "mutation_prompt": null}
{"id": "970d543e-28ab-468e-9e86-a9e03ec95fd1", "solution": "import numpy as np\n\nclass QDL_PAL_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9  # Adjusted for better exploration\n        self.cognitive_weight = 1.5  # Reduced to balance exploration and exploitation\n        self.social_weight = 1.5  # Increased for stronger global influence\n        self.sigma_min = 0.05  # Reduced for refined local exploration\n        self.sigma_max = 0.3  # Reduced for stability in convergence\n        self.iterations = budget // self.population_size\n        self.adaptive_radius_min = 0.02  # Narrowed for precise local search\n        self.adaptive_radius_max = 0.15  # Reduced to maintain balance\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        velocities = np.random.rand(self.population_size, self.dim) * 0.05 * (ub - lb)  # Reduced initial velocity\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_idx = np.argmin(fitness)\n        global_best_position = population[global_best_idx]\n        global_best_fitness = fitness[global_best_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(2)\n            velocities = (self.inertia_weight * velocities\n                          + self.cognitive_weight * r1 * (personal_best_positions - population)\n                          + self.social_weight * r2 * (global_best_position - population))\n            new_population = np.clip(population + velocities, lb, ub)\n\n            new_fitness = np.array([func(ind) for ind in new_population])\n            evals += self.population_size\n\n            better_mask = new_fitness < personal_best_fitness\n            personal_best_positions[better_mask] = new_population[better_mask]\n            personal_best_fitness[better_mask] = new_fitness[better_mask]\n\n            min_new_fitness_idx = np.argmin(new_fitness)\n            if new_fitness[min_new_fitness_idx] < global_best_fitness:\n                global_best_position = new_population[min_new_fitness_idx]\n                global_best_fitness = new_fitness[min_new_fitness_idx]\n\n            progress_ratio = iteration / self.iterations\n            sigma = self.sigma_min + (self.sigma_max - self.sigma_min) * progress_ratio\n\n            gaussian_noise = np.random.normal(0, sigma, (self.population_size, self.dim))\n            quantum_population = np.clip(new_population + gaussian_noise, lb, ub)\n\n            adaptive_radius = self.adaptive_radius_min + (self.adaptive_radius_max - self.adaptive_radius_min) * (1 - progress_ratio)\n            local_perturbation = np.random.uniform(-adaptive_radius, adaptive_radius, (self.population_size, self.dim))\n            local_population = np.clip(new_population + local_perturbation, lb, ub)\n\n            quantum_fitness = np.array([func(ind) for ind in quantum_population])\n            local_fitness = np.array([func(ind) for ind in local_population])\n            evals += 2 * self.population_size\n\n            noise_selection_mask = np.random.rand(self.population_size) < 0.75  # Selective noise application\n            improved_mask = (quantum_fitness < new_fitness) & (quantum_fitness < local_fitness) & noise_selection_mask\n            population[improved_mask] = quantum_population[improved_mask]\n            fitness[improved_mask] = quantum_fitness[improved_mask]\n\n            local_improved_mask = local_fitness < fitness\n            population[local_improved_mask] = local_population[local_improved_mask]\n            fitness[local_improved_mask] = local_fitness[local_improved_mask]\n\n            if np.min(fitness) < global_best_fitness:\n                global_best_idx = np.argmin(fitness)\n                global_best_position = population[global_best_idx]\n                global_best_fitness = fitness[global_best_idx]\n\n        return global_best_position, global_best_fitness", "name": "QDL_PAL_Enhanced", "description": "Adjust inertia weight dynamically for improved balance between exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.084172761328639, "feedback": "The algorithm QDL_PAL_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.084 with standard deviation 0.005. And the mean value of best solutions found was 0.199 (0. is the best).", "error": "", "parent_id": "0e8a6658-597d-4fce-91fe-1bdef0ad239b", "metadata": {"aucs": [0.08895637820465441, 0.07673688709038962, 0.086825018690873], "final_y": [0.17398548688388948, 0.2285691607275394, 0.1930127045121106]}, "mutation_prompt": null}
{"id": "81064b70-6be3-4a9b-91be-93b7704cb9f0", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2 = np.random.rand(2)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + self.cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + self.social_weight * r2 * (global_best_position - swarm['positions']))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive inertia weight and multi-swarm strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 16, "fitness": 0.09281227799793375, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "0e8a6658-597d-4fce-91fe-1bdef0ad239b", "metadata": {"aucs": [0.0949632533934025, 0.0883131913118872, 0.09516038928851156], "final_y": [0.1648559264664079, 0.18187894750191025, 0.16486228248920998]}, "mutation_prompt": null}
{"id": "3b75ca56-f049-43c9-9805-95cec3c13057", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)  # New random variable\n\n                # Adjusted velocities with adaptive neighborhood influence\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + self.cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + self.social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.5 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions']))  # New influence\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive neighborhood influence to enhance local search capabilities.", "configspace": "", "generation": 17, "fitness": 0.09448567039704947, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "81064b70-6be3-4a9b-91be-93b7704cb9f0", "metadata": {"aucs": [0.09484133327246058, 0.09542369520460092, 0.09319198271408691], "final_y": [0.1648568506350151, 0.1648829608782919, 0.16485588035703314]}, "mutation_prompt": null}
{"id": "6e4de92d-c567-42f2-9647-9412b1b5d00d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                # Dynamic weights adjustment\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Adjusted velocities with adaptive neighborhood influence\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.5 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions']))  # New influence\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce dynamic cognitive and social weights to further enhance convergence.", "configspace": "", "generation": 18, "fitness": 0.09457613649062502, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "3b75ca56-f049-43c9-9805-95cec3c13057", "metadata": {"aucs": [0.09424933304113003, 0.09499605842377146, 0.09448301800697356], "final_y": [0.1649235316335348, 0.16486225997771164, 0.16485614263259107]}, "mutation_prompt": null}
{"id": "531ce766-ed2e-4739-8d02-e19ba9ac602d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                # Dynamic weights adjustment\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Adjusted velocities with adaptive neighborhood influence\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.5 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a random exploration factor to increase diversity and escape local optima.", "configspace": "", "generation": 19, "fitness": 0.09458193252403313, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6e4de92d-c567-42f2-9647-9412b1b5d00d", "metadata": {"aucs": [0.09434036909805654, 0.09425552295219164, 0.09514990552185121], "final_y": [0.164855957571708, 0.16485598855918338, 0.16485617943249442]}, "mutation_prompt": null}
{"id": "6742db60-afff-4993-b932-f80cee22e2ba", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2  # Changed from 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                # Dynamic weights adjustment\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Adjusted velocities with adaptive neighborhood influence\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.7 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed random influence from 0.5\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic inertia weight update strategy and amplify exploration with a variable random factor.", "configspace": "", "generation": 20, "fitness": 0.09462881302437331, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "531ce766-ed2e-4739-8d02-e19ba9ac602d", "metadata": {"aucs": [0.09478303847680258, 0.09391184954285414, 0.09519155105346322], "final_y": [0.16485601451918896, 0.16485606747546422, 0.16485607415335735]}, "mutation_prompt": null}
{"id": "286ea600-2bfe-4d68-91c4-9c389af7f2be", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2  # Changed from 0.4\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.rand(self.population_size, self.dim) * 0.1 * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                # Dynamic weights adjustment\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Adjusted velocities with adaptive neighborhood influence\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.75 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed random influence from 0.7\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improved swarm exploration by slightly increasing the random influence factor in velocity update.", "configspace": "", "generation": 21, "fitness": 0.0946052502558304, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6742db60-afff-4993-b932-f80cee22e2ba", "metadata": {"aucs": [0.09424197364207798, 0.09422091903373875, 0.09535285809167449], "final_y": [0.16485608484773484, 0.1648560503559433, 0.16485609817417257]}, "mutation_prompt": null}
{"id": "63256a9c-8040-46ea-9a76-415686355b3d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance exploration by varying the neighborhood influence factor and improving velocity initialization.", "configspace": "", "generation": 22, "fitness": 0.09588249978953856, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6742db60-afff-4993-b932-f80cee22e2ba", "metadata": {"aucs": [0.09649083010009818, 0.0954311965311957, 0.09572547273732179], "final_y": [0.1648561430898301, 0.16485594444385543, 0.16485615204703352]}, "mutation_prompt": null}
{"id": "72da766d-d9bb-44c8-b287-c168c800bd66", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.base_population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.base_population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.base_population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.base_population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            population_size = int(self.base_population_size + 10 * (iteration / self.iterations))  # Dynamic population size\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improve the swarm's adaptiveness by introducing dynamic population size adjustment based on iteration progress.", "configspace": "", "generation": 23, "fitness": 0.09579228597741907, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09640061628595487, 0.09534098272351532, 0.09563525892278701], "final_y": [0.1648561430898301, 0.16485594444385543, 0.16485615204703352]}, "mutation_prompt": null}
{"id": "af5e487f-5b36-46d1-b8d8-5687428084b8", "solution": "import numpy as np\n\nclass LevyDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.3\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n        \n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n    \n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / (np.abs(v)**(1 / beta))\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2 = np.random.rand(2)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                levy_steps = self.levy_flight((self.population_size, self.dim))\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + levy_steps * 0.05)  # Integrating Lévy flights for exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n            \n            if iteration % 5 == 0:  # Dynamic sharing between swarms\n                for i in range(self.num_swarms):\n                    next_swarm = self.swarms[(i + 1) % self.num_swarms]\n                    self.swarms[i]['positions'] = np.concatenate((self.swarms[i]['positions'], next_swarm['positions'][:self.population_size//2]), axis=0)\n                    self.swarms[i]['velocities'] = np.concatenate((self.swarms[i]['velocities'], next_swarm['velocities'][:self.population_size//2]), axis=0)\n\n        return global_best_position, global_best_fitness", "name": "LevyDynamicSwarmOptimizer", "description": "Improve exploration-exploitation balance by integrating Lévy flights and dynamic swarm sharing for cross-boundary learning.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (30,10) (45,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (30,10) (45,10) ')", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {}, "mutation_prompt": null}
{"id": "d148f77c-6097-4025-bf6d-410a67fd2aad", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.dynamic_population = 10  # Change 1: Introduce dynamic population size\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n\n                self.dynamic_population = int(5 + 25 * (iteration / self.iterations))  # Change 2: Adjust population dynamically\n                neighborhood_influence = 0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations)  # Change 3: Adaptive neighborhood\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + neighborhood_influence * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce dynamic swarm sizes and adaptive neighborhood influence to improve convergence and exploration simultaneously.", "configspace": "", "generation": 25, "fitness": 0.09557904893493985, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09601369998569609, 0.09508232390237503, 0.09564112291674842], "final_y": [0.1648560547329304, 0.1648559566543909, 0.16485596455057028]}, "mutation_prompt": null}
{"id": "eedf800f-a984-4c93-9f2f-f09deb33f2a9", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for i, swarm in enumerate(self.swarms):\n                inertia_weight = (self.inertia_max - (self.inertia_max - self.inertia_min) * \n                                  (iteration / self.iterations) ** 2)  # Nonlinear inertia adjustment\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n            # Dynamic swarm merging\n            if iteration % (self.iterations // 3) == 0:\n                merged_swarm_positions = np.vstack([swarm['positions'] for swarm in self.swarms])\n                self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n                for j, swarm in enumerate(self.swarms):\n                    start = (j * len(merged_swarm_positions)) // self.num_swarms\n                    end = ((j + 1) * len(merged_swarm_positions)) // self.num_swarms\n                    swarm['positions'] = merged_swarm_positions[start:end]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a nonlinear inertia weight and dynamic swarm merging to improve convergence and diversity.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for *: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for *: 'float' and 'NoneType'\")", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {}, "mutation_prompt": null}
{"id": "2f01fc41-89be-46f8-9feb-9225ddc1ab55", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Change: Adjust inertia weight based on fitness improvement\n                if np.any(swarm['fitness'] < global_best_fitness):\n                    inertia_weight *= 0.98\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic inertia weight adjustment based on fitness improvements to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.09588249978953856, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09649083010009818, 0.0954311965311957, 0.09572547273732179], "final_y": [0.1648561430898301, 0.16485594444385543, 0.16485615204703352]}, "mutation_prompt": null}
{"id": "3d7406a0-545f-46a9-9bd7-ad98caa237cd", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                fitness_variance = np.var(swarm['fitness'])  # Calculate fitness variance\n                cognitive_weight = self.cognitive_weight * (1 - fitness_variance)  # Adapt cognitive weight\n                social_weight = self.social_weight * (fitness_variance)  # Adapt social weight\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improve convergence by dynamically adapting cognitive and social weights based on fitness variance.", "configspace": "", "generation": 28, "fitness": 0.09496890530702662, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.168 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09469297418927658, 0.09507528078567651, 0.09513846094612677], "final_y": [0.16983896175314328, 0.16628188301896463, 0.1667546312347432]}, "mutation_prompt": null}
{"id": "d8fe13d7-dcf6-4d7b-b76d-8f33921bd291", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim)) * (ub - lb)  # Modified velocity range\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3, r4 = np.random.rand(4)  # Additional randomness for adaptive behavior\n\n                adaptive_cognitive = self.cognitive_weight * (1 + 0.5 * np.sin(iteration))  # Adaptive cognitive factor\n                adaptive_social = self.social_weight * (1 + 0.5 * np.cos(iteration))  # Adaptive social factor\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improved by incorporating dynamic swarm size adjustment and adaptive cognitive-social factor balancing for enhanced convergence and exploration.", "configspace": "", "generation": 29, "fitness": 0.08516941285336517, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.085 with standard deviation 0.010. And the mean value of best solutions found was 0.202 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.08974662801440003, 0.071518439611163, 0.0942431709345325], "final_y": [0.18187836438538096, 0.2578105785017384, 0.1648563518937709]}, "mutation_prompt": null}
{"id": "db2308db-2feb-4511-ac09-0bca6abdc8d6", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed neighborhood influence\n                                       + 0.15 * np.random.randn(*swarm['positions'].shape))  # Enhanced random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n            # Sub-swarm reallocation step\n            if iteration % 5 == 0:  # Reallocate every 5 iterations\n                self.swarms.sort(key=lambda s: np.min(s['fitness']))  # Sort based on swarm's best fitness\n                self.swarms.append(self.swarms.pop(0))  # Move the least successful swarm to the end\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Adaptive exploration by dynamic sub-swarm reallocation and enhanced velocity perturbation.", "configspace": "", "generation": 30, "fitness": 0.09567170105809993, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09633159465939167, 0.09507706965916418, 0.09560643885574394], "final_y": [0.16485629335388619, 0.16485626449069202, 0.1648564255013889]}, "mutation_prompt": null}
{"id": "01322410-caf1-4327-9929-2772795920b1", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**1.05)  # Adjusted decay\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a slight adjustment to the inertia weight decay to enhance convergence speed.", "configspace": "", "generation": 31, "fitness": 0.09584371555185656, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09645958698649648, 0.09540530463561203, 0.09566625503346116], "final_y": [0.16485593903996754, 0.1648559919180227, 0.16485610068179057]}, "mutation_prompt": null}
{"id": "f1a5f666-1b89-437c-9e9c-2c24cc460920", "solution": "import numpy as np\n\nclass LevyFlightMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def levy_flight(self, size, beta=1.5):\n        # Implementing Levy Flight\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                # Adaptive cognitive and social weights\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                # Update velocities with Levy flight influence\n                levy_step = self.levy_flight((self.population_size, self.dim)) * 0.01  # Levy step size\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + levy_step)\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "LevyFlightMultiSwarmOptimizer", "description": "Integrate a Levy flight-inspired mutation mechanism into each swarm to enhance global exploration and escape from local optima.", "configspace": "", "generation": 32, "fitness": 0.09579429228324739, "feedback": "The algorithm LevyFlightMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09584625965107973, 0.09576731157359752, 0.09576930562506492], "final_y": [0.16485578390069988, 0.16485577804837115, 0.16485577561922926]}, "mutation_prompt": null}
{"id": "4a80ae12-cb2f-4b1d-bd0e-c7af58695813", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 32  # Changed population size\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.85 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Slightly increased neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "An optimized version of AdaptiveMultiSwarmOptimizer with enhanced velocity control and dynamic swarm size adjustment.", "configspace": "", "generation": 33, "fitness": 0.09563929902494872, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09468337440892316, 0.0961363889107486, 0.0960981337551744], "final_y": [0.1648561269272103, 0.16485613929302823, 0.1648560322862077]}, "mutation_prompt": null}
{"id": "e5e52fd5-2fca-40a7-8128-c4e92f5df080", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                adaptive_cognitive_weight = self.cognitive_weight * (1 - swarm['fitness'].min() / global_best_fitness)  # Adaptive change 1\n                adaptive_social_weight = self.social_weight * (swarm['fitness'].min() / global_best_fitness)  # Adaptive change 2\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])  # Change 3\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])  # Change 4\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive personal and social weights to enhance convergence.", "configspace": "", "generation": 34, "fitness": 0.09060551893984052, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.002. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09315280035678153, 0.09018858210975, 0.08847517435299002], "final_y": [0.16485680687798143, 0.16797165252967006, 0.16485638358743226]}, "mutation_prompt": null}
{"id": "562742c9-266e-45e3-a407-ab1ddd314a7a", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n\n                adaptive_cognitive_weight = self.cognitive_weight + 0.5 * np.sin(iteration / self.iterations * np.pi)  # Changed to adaptive cognitive weight\n                adaptive_social_weight = self.social_weight + 0.5 * np.cos(iteration / self.iterations * np.pi)  # Changed to adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Optimize convergence by introducing adaptive learning rates and dynamic swarm communication.", "configspace": "", "generation": 35, "fitness": 0.09325571381864768, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.093 with standard deviation 0.002. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09516154038574753, 0.08976807776780227, 0.09483752330239326], "final_y": [0.1648563025665606, 0.1818783424385655, 0.1648561512548311]}, "mutation_prompt": null}
{"id": "f5ba37ed-8791-4646-84a8-58e5f865edf2", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (0.5 + 0.5 * np.sin(iteration / self.iterations * np.pi))  # Changed to dynamic cognitive weight\n                social_weight = self.social_weight * (0.5 + 0.5 * np.cos(iteration / self.iterations * np.pi))      # Changed to dynamic social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.5 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Adjusted neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Shift to a dynamic cognitive-social balance and refine neighborhood influence for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.09440603493189052, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09052548836290897, 0.0967630420738731, 0.09592957435888949], "final_y": [0.181878703579343, 0.16485625617293242, 0.16485604614232785]}, "mutation_prompt": null}
{"id": "dd39030e-5371-4449-8da2-714e31743996", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            if iteration % (self.iterations // 4) == 0 and iteration > 0:  # Dynamic swarm merging every 25% of iterations\n                best_swarm_idx = np.argmin([np.min(swarm['fitness']) for swarm in self.swarms])\n                for i, swarm in enumerate(self.swarms):\n                    if i != best_swarm_idx:\n                        self.swarms[best_swarm_idx]['positions'] = np.vstack((self.swarms[best_swarm_idx]['positions'], swarm['positions']))\n                        self.swarms[best_swarm_idx]['velocities'] = np.vstack((self.swarms[best_swarm_idx]['velocities'], swarm['velocities']))\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce dynamic swarm merging to enhance information sharing and convergence rate in multi-swarm optimization.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (30,10) (90,10) ').", "error": "ValueError('operands could not be broadcast together with shapes (30,10) (90,10) ')", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {}, "mutation_prompt": null}
{"id": "d3929363-9652-4f15-9156-195033db2589", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations) * (1 + np.std(swarm['fitness']) / np.mean(swarm['fitness']))  # Dynamic social weight adjustment\n                \n                velocity_scale = 1 + 0.5 * np.std(swarm['positions']) / np.mean(swarm['positions'])  # Adaptive velocity scaling\n                swarm['velocities'] = velocity_scale * (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improve convergence by optimizing swarm diversity through adaptive velocity scaling and dynamic social interaction adjustment.", "configspace": "", "generation": 38, "fitness": 0.09517762710649642, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09519703946813185, 0.09467196989085447, 0.09566387196050297], "final_y": [0.1648562190290973, 0.16485606400451858, 0.16485620169858306]}, "mutation_prompt": null}
{"id": "569aa15d-ce1f-4dc3-a8a8-c85ad63faaa3", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.9 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Slightly increased neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improve global convergence by slightly increasing the neighborhood influence factor.", "configspace": "", "generation": 39, "fitness": 0.09588184938619522, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.0960410816690297, 0.0955203765650312, 0.09608408992452477], "final_y": [0.1648561459968092, 0.16485602816526013, 0.16485616948759252]}, "mutation_prompt": null}
{"id": "ae1df579-0d16-4b6b-aba7-0dca4aea5d90", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n\n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.5 * r3 * (np.var(swarm['positions'], axis=0) - swarm['positions'])  # Dynamic neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['velocities'] *= 0.9  # Adaptive velocity scaling\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Optimize swarm convergence by introducing dynamic neighborhood influence and adaptive velocity scaling.", "configspace": "", "generation": 40, "fitness": 0.06838801152397356, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.068 with standard deviation 0.000. And the mean value of best solutions found was 0.188 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.06779100486094125, 0.06854595899250815, 0.06882707071847127], "final_y": [0.18835586586628483, 0.18929544812519905, 0.18534034537378052]}, "mutation_prompt": null}
{"id": "c563bf2a-b07b-43fd-bcf8-c672b7564063", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2 = np.random.rand(2)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                if np.random.rand() < 0.1:  # Add probabilistic exploration\n                    swarm['velocities'] += 0.5 * np.random.randn(*swarm['positions'].shape)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * np.random.rand() * (np.mean(swarm['positions'], axis=0) - swarm['positions']))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance optimization by incorporating a dynamic weight adjustment strategy and probabilistic exploration within swarms.", "configspace": "", "generation": 41, "fitness": 0.09532576578680574, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.095 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09527952596147038, 0.09475045785862968, 0.09594731354031716], "final_y": [0.16485578007151125, 0.16485577316827849, 0.16485578321730332]}, "mutation_prompt": null}
{"id": "9400dd0d-524d-4be9-88d9-039aee10cf8e", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)  # Changed velocity initialization\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.85 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed neighborhood influence\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Random exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improve swarm cohesion by slightly increasing the neighborhood influence factor to enhance convergence.", "configspace": "", "generation": 42, "fitness": 0.0957857618190852, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09599714444723029, 0.09550817761903796, 0.09585196339098734], "final_y": [0.16485608068195023, 0.16485601844301612, 0.1648560442464153]}, "mutation_prompt": null}
{"id": "45e876a3-a00e-497c-8bba-53ff1fbb79e5", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1, r2, r3 = np.random.rand(3)\n                \n                cognitive_weight = self.cognitive_weight * (1 - iteration / self.iterations)\n                social_weight = self.social_weight * (iteration / self.iterations)\n                \n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.15 * np.random.randn(*swarm['positions'].shape))  # Increased random exploration from 0.1 to 0.15\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance exploration by increasing the random exploration factor in velocity update.", "configspace": "", "generation": 43, "fitness": 0.0958784160282475, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.09650799233750385, 0.09543923916449426, 0.0956880165827444], "final_y": [0.16485645084438683, 0.16485637634628247, 0.16485614340276888]}, "mutation_prompt": null}
{"id": "a8017bef-114a-40df-9362-3bae3fad563c", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive cognitive and social weights to balance exploration and exploitation dynamically.", "configspace": "", "generation": 44, "fitness": 0.0959207192338396, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "63256a9c-8040-46ea-9a76-415686355b3d", "metadata": {"aucs": [0.0962141833479413, 0.09559657847263048, 0.09595139588094703], "final_y": [0.1648561857404761, 0.16485614899630108, 0.16485606830782162]}, "mutation_prompt": null}
{"id": "66d297e7-77d1-44ec-8d6c-1d6fc08b2572", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                # Change: Adjust population size dynamically based on budget\n                dynamic_population_size = int(np.clip(self.population_size * (1 + 0.5 * (1 - evals / self.budget)), 10, 50))\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic swarm size adjustment to enhance early exploration and late exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.0959207192338396, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a8017bef-114a-40df-9362-3bae3fad563c", "metadata": {"aucs": [0.0962141833479413, 0.09559657847263048, 0.09595139588094703], "final_y": [0.1648561857404761, 0.16485614899630108, 0.16485606830782162]}, "mutation_prompt": null}
{"id": "c94325b6-928b-4b2f-afdc-031e0397d9b8", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n                tendency_factor = 1.2\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape) * tendency_factor)\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a tendency factor to enhance adaptive behavior further and balance exploration with exploitation.", "configspace": "", "generation": 46, "fitness": 0.0959106636214158, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a8017bef-114a-40df-9362-3bae3fad563c", "metadata": {"aucs": [0.09621493541373527, 0.095574302766407, 0.09594275268410513], "final_y": [0.16485600483385, 0.16485625497833112, 0.16485598886847408]}, "mutation_prompt": null}
{"id": "2af55bc9-9491-42f5-a03f-e43ed419a3b4", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.2 * np.random.uniform(-1, 1, swarm['positions'].shape))  # Mutation effect\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm diversity by tweaking velocity calculation and introducing mutation, while maintaining adaptive balance.", "configspace": "", "generation": 47, "fitness": 0.09569025848913586, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a8017bef-114a-40df-9362-3bae3fad563c", "metadata": {"aucs": [0.09588711850026488, 0.09536217052876728, 0.0958214864383754], "final_y": [0.1648562787655269, 0.16485615191192748, 0.16485614061289122]}, "mutation_prompt": null}
{"id": "4d5eb314-5b87-4326-b26e-756d7be87b62", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) # Small stochastic term added\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a small stochastic term in the position update to enhance diversity and prevent premature convergence.", "configspace": "", "generation": 48, "fitness": 0.09599445628420278, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a8017bef-114a-40df-9362-3bae3fad563c", "metadata": {"aucs": [0.09624778482625485, 0.09566255607925722, 0.09607302794709627], "final_y": [0.164855947537777, 0.16485605528085534, 0.16485594652252233]}, "mutation_prompt": null}
{"id": "4d49056d-1a10-48f5-a1ab-e500bdc51c20", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**1.2) # Enhanced inertia adaptation\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - evals / self.budget)  # Adaptive cognitive weight\n                adaptive_social_weight = self.social_weight * (evals / self.budget)  # Adaptive social weight\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) # Small stochastic term added\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic swarm size and enhanced inertia adaptation to improve exploration and exploitation balance in the multi-swarm optimization.", "configspace": "", "generation": 49, "fitness": 0.0959801212259775, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "4d5eb314-5b87-4326-b26e-756d7be87b62", "metadata": {"aucs": [0.09625148176909848, 0.09561519415270614, 0.0960736877561279], "final_y": [0.1648561506124503, 0.1648559953909564, 0.1648560054817616]}, "mutation_prompt": null}
{"id": "8f1a8524-8463-4adc-987f-6c4617a7ef0d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                # Adjusted adaptive cognitive and social weights\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) # Small stochastic term added\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Adjust the adaptive cognitive and social weights to dynamically balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 50, "fitness": 0.09634337418893209, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "4d5eb314-5b87-4326-b26e-756d7be87b62", "metadata": {"aucs": [0.09642079187317865, 0.0963010263043016, 0.09630830438931604], "final_y": [0.1648560651747596, 0.16485593567180257, 0.1648561067333737]}, "mutation_prompt": null}
{"id": "93f1ffdd-7ccd-4e47-8869-ea0a5635a990", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                # Adjusted adaptive cognitive and social weights\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.9 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions']) # Updated influence factor\n                                       + 0.05 * np.random.randn(*swarm['positions'].shape)) # Tweaked stochastic term\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) \n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Refining the swarm's movement strategy by tweaking the velocity update to improve convergence speed.", "configspace": "", "generation": 51, "fitness": 0.09631007441131993, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8f1a8524-8463-4adc-987f-6c4617a7ef0d", "metadata": {"aucs": [0.09644891630149866, 0.09619911377808144, 0.09628219315437969], "final_y": [0.16485587820682612, 0.16485584836652578, 0.16485586388528295]}, "mutation_prompt": null}
{"id": "884611ba-dfbb-4f4a-a330-2d0a8ef57e7f", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n            # Dynamic swarm merging strategy\n            if iteration % 10 == 0:  \n                self.swarms = sorted(self.swarms, key=lambda s: np.min(s['fitness']))\n                for i in range(1, self.num_swarms):\n                    if np.any(self.swarms[i]['fitness'] < self.swarms[i-1]['fitness']):\n                        self.swarms[i-1]['positions'] = np.vstack((self.swarms[i-1]['positions'], self.swarms[i]['positions']))\n                        self.swarms[i-1]['velocities'] = np.vstack((self.swarms[i-1]['velocities'], self.swarms[i]['velocities']))\n                        self.swarms[i-1]['fitness'] = np.concatenate((self.swarms[i-1]['fitness'], self.swarms[i]['fitness']))\n                        self.swarms[i]['positions'] = None\n                        self.swarms[i]['velocities'] = None\n                        self.swarms[i]['fitness'] = None\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce dynamic swarm merging based on performance to enhance convergence efficiency.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'NoneType'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'NoneType'\")", "parent_id": "8f1a8524-8463-4adc-987f-6c4617a7ef0d", "metadata": {}, "mutation_prompt": null}
{"id": "f513bded-dbeb-42fa-b0bd-7795e2f65065", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                # Adjusted adaptive cognitive and social weights\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.9 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + 0.1 * np.random.randn(*swarm['positions'].shape))  # Adjusted swarm mean factor\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Small stochastic term added\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance information sharing by adjusting the swarm mean factor for improved exploration-exploitation balance in multi-swarm optimization.", "configspace": "", "generation": 53, "fitness": 0.09631905338261004, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8f1a8524-8463-4adc-987f-6c4617a7ef0d", "metadata": {"aucs": [0.09649650105599172, 0.09618356964324615, 0.09627708944859226], "final_y": [0.16485613733405247, 0.1648559678548951, 0.16485608077557123]}, "mutation_prompt": null}
{"id": "a2f6b0d4-1e73-49b1-8e29-9cfac3e8cae7", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                # Adjusted adaptive cognitive and social weights\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                # Introduce a feedback mechanism based on swarm performance\n                feedback_term = 0.1 * np.std(swarm['fitness'])\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) # Small stochastic term added\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic adjustment to each swarm's velocity update by incorporating a simple feedback mechanism based on swarm performance.", "configspace": "", "generation": 54, "fitness": 0.09642257928870768, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8f1a8524-8463-4adc-987f-6c4617a7ef0d", "metadata": {"aucs": [0.09656980503473933, 0.09638605975457781, 0.09631187307680589], "final_y": [0.16485577315739075, 0.16485577304849608, 0.16485577296815412]}, "mutation_prompt": null}
{"id": "bf546f54-9462-45ea-9982-d5ddfc1dcce3", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness'])  # Increased feedback\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm exploration by amplifying feedback term based on fitness diversity.", "configspace": "", "generation": 55, "fitness": 0.0964027286824601, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a2f6b0d4-1e73-49b1-8e29-9cfac3e8cae7", "metadata": {"aucs": [0.09651944839799564, 0.09638512801910437, 0.09630360963028028], "final_y": [0.1648557727401745, 0.16485577273982, 0.16485577384175]}, "mutation_prompt": null}
{"id": "d6a8f6be-95eb-4c53-adb1-8a819640ebe6", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                # Decaying feedback mechanism to improve convergence\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a decaying feedback term to improve swarm exploration and convergence.", "configspace": "", "generation": 56, "fitness": 0.09642329276389427, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "a2f6b0d4-1e73-49b1-8e29-9cfac3e8cae7", "metadata": {"aucs": [0.09657181703290152, 0.09638604754379354, 0.09631201371498777], "final_y": [0.1648557731184107, 0.16485577382399708, 0.16485577394658169]}, "mutation_prompt": null}
{"id": "5bdb47c5-a987-4061-9c48-f5b87348cb59", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            if iteration > 0 and iteration % (self.iterations // 5) == 0:  # regroup swarms every 20% iterations\n                # Dynamic regrouping strategy\n                all_positions = np.vstack([swarm['positions'] for swarm in self.swarms])\n                np.random.shuffle(all_positions)\n                split_indices = np.array_split(all_positions, self.num_swarms)\n                for i, swarm in enumerate(self.swarms):\n                    swarm['positions'] = split_indices[i]\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic regrouping strategy for swarms to enhance diversity and convergence.", "configspace": "", "generation": 57, "fitness": 0.09365838007130185, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.003. And the mean value of best solutions found was 0.171 (0. is the best).", "error": "", "parent_id": "d6a8f6be-95eb-4c53-adb1-8a819640ebe6", "metadata": {"aucs": [0.09575114063555668, 0.08995858642329002, 0.09526541315505888], "final_y": [0.16485733367751454, 0.18187810077437827, 0.1648561929128759]}, "mutation_prompt": null}
{"id": "847f6620-188a-47b1-bdc1-24eda0799761", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.5)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                # Decaying feedback mechanism with dynamic scaling\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - evals / self.budget)  # modified line\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic scaling of feedback term based on budget utilization to further refine convergence.", "configspace": "", "generation": 58, "fitness": 0.09642313238719835, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "d6a8f6be-95eb-4c53-adb1-8a819640ebe6", "metadata": {"aucs": [0.09657128647578517, 0.09638606534122918, 0.09631204534458071], "final_y": [0.16485577334020785, 0.16485577369957427, 0.1648557732069399]}, "mutation_prompt": null}
{"id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  # Changed 0.5 to 0.3\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic adjustment to the cognitive weight for better personal best exploration.", "configspace": "", "generation": 59, "fitness": 0.0964464277868804, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "d6a8f6be-95eb-4c53-adb1-8a819640ebe6", "metadata": {"aucs": [0.0965961832290726, 0.09629986150574166, 0.09644323862582693], "final_y": [0.16485577350269154, 0.16485577315352384, 0.1648557729304011]}, "mutation_prompt": null}
{"id": "aa3c65ab-af22-40e8-839c-dd29ae7f2ec5", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.4)  # Changed from **0.5 to **0.4\n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance global exploration by adjusting the social weight decay rate for improved convergence.", "configspace": "", "generation": 60, "fitness": 0.09611150327935496, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.09652838887872273, 0.09600963988441202, 0.0957964810749301], "final_y": [0.1648557731049619, 0.16485577319189326, 0.16485577309042443]}, "mutation_prompt": null}
{"id": "ae29eb8e-ef98-44c8-ab13-5a70b23df998", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.7)  # Changed 0.5 to 0.7\n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a nonlinear adaptive social weight to better balance exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.09620228362828039, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.0962792224426896, 0.09603393331663934, 0.09629369512551222], "final_y": [0.16485577292985065, 0.16485577313135424, 0.16485577315345445]}, "mutation_prompt": null}
{"id": "a7a11415-c8aa-4c1c-8b3d-608a5195c761", "solution": "import numpy as np\n\nclass ScaleFreeAdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.scale_factor = 0.5\n        self.crossover_rate = 0.9\n        self.local_search_prob = 0.3\n        self.evals = 0\n        self.max_iter = budget // self.population_size\n\n    def _generate_offspring(self, population, fitness, lb, ub):\n        idxs = np.arange(self.population_size)\n        np.random.shuffle(idxs)\n        \n        offspring = np.empty_like(population)\n        for i in range(self.population_size):\n            a, b, c = population[idxs[i]], population[idxs[(i+1)%self.population_size]], population[idxs[(i+2)%self.population_size]]\n            mutant = np.clip(a + self.scale_factor * (b - c), lb, ub)\n            cross_points = np.random.rand(self.dim) < self.crossover_rate\n            offspring[i] = np.where(cross_points, mutant, population[i])\n        return offspring\n\n    def _local_search(self, ind, func, lb, ub):\n        perturbation = np.random.uniform(-0.1, 0.1, size=self.dim) * (ub - lb)\n        new_ind = np.clip(ind + perturbation, lb, ub)\n        if func(new_ind) < func(ind):\n            return new_ind\n        return ind\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n        fitness = np.array([func(ind) for ind in population])\n        self.evals = self.population_size\n        \n        best_idx = np.argmin(fitness)\n        best_pos, best_fit = population[best_idx], fitness[best_idx]\n\n        for iteration in range(self.max_iter):\n            if self.evals >= self.budget:\n                break\n\n            offspring = self._generate_offspring(population, fitness, lb, ub)\n            offspring_fitness = np.array([func(ind) for ind in offspring])\n            self.evals += self.population_size\n\n            for i in range(self.population_size):\n                if offspring_fitness[i] < fitness[i]:\n                    population[i] = offspring[i]\n                    fitness[i] = offspring_fitness[i]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_prob:\n                    population[i] = self._local_search(population[i], func, lb, ub)\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fit:\n                best_pos, best_fit = population[best_idx], fitness[best_idx]\n\n            self.scale_factor = 0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.max_iter)\n            self.crossover_rate = 0.9 - 0.4 * (iteration / self.max_iter)\n            self.local_search_prob = 0.3 + 0.2 * np.cos(2 * np.pi * iteration / self.max_iter)\n        \n        return best_pos, best_fit", "name": "ScaleFreeAdaptiveMemeticAlgorithm", "description": "Implement a Scale-Free Adaptive Memetic Algorithm (SFAMA) with dynamic local search intensification using success-history based parameter adaptation.", "configspace": "", "generation": 62, "fitness": 0.08684297259948219, "feedback": "The algorithm ScaleFreeAdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.087 with standard deviation 0.003. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.08385325912986041, 0.08599768993700696, 0.09067796873157918], "final_y": [0.16487821917743906, 0.16485913770612137, 0.1648590216759208]}, "mutation_prompt": null}
{"id": "9f968cbd-8a4d-45e6-b9f5-63e881e6e742", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape) + 0.05 * np.std(swarm['positions'], axis=0), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a diversity-based exploration mechanism to enhance swarm diversity and avoid premature convergence.", "configspace": "", "generation": 63, "fitness": 0.09602213902536076, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.09602623802669219, 0.09555247698829772, 0.09648770206109236], "final_y": [0.16485577336333723, 0.16485577302133836, 0.16485577331143975]}, "mutation_prompt": null}
{"id": "66de5a44-b449-49ff-b4a3-d6804e75c837", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.01 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n                \n                # Introduce a diversity preservation mechanism\n                diversity = np.linalg.norm(np.std(swarm['positions'], axis=0))\n                if diversity < 1e-3:\n                    swarm['positions'] += np.random.uniform(-0.1, 0.1, swarm['positions'].shape) * (ub - lb)\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a diversity preservation mechanism to the swarm to enhance exploration capabilities.", "configspace": "", "generation": 64, "fitness": 0.0964464277868804, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.0965961832290726, 0.09629986150574166, 0.09644323862582693], "final_y": [0.16485577350269154, 0.16485577315352384, 0.1648557729304011]}, "mutation_prompt": null}
{"id": "70fad488-899c-440b-b503-5642d79274cb", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Changed 0.01 to 0.02\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic swarm diversity mechanism to improve exploration and convergence speed.", "configspace": "", "generation": 65, "fitness": 0.09644763974091826, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "8ca62cad-eeb4-46cb-8745-d336e49fc983", "metadata": {"aucs": [0.09659415115538117, 0.09630588505330817, 0.09644288301406545], "final_y": [0.16485577477106161, 0.16485577735284607, 0.1648557765800146]}, "mutation_prompt": null}
{"id": "9af58e00-0815-49e9-bf25-2cacc66a4cd6", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.1  # Changed from 0.2 to 0.1\n        self.inertia_max = 1.0  # Changed from 0.9 to 1.0\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None,\n            'leader': None  # New field for leader\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n            swarm['leader'] = np.copy(swarm['positions'][min_idx])  # Initialize leader\n    \n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = (self.inertia_max - self.inertia_min) * np.sin(np.pi * iteration / (2 * self.iterations)) + self.inertia_min  # Adaptive inertia\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                r3 = np.random.rand(self.dim)\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (swarm['leader'] - swarm['positions'])  # Leader influence\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n                swarm['leader'] = np.copy(swarm['positions'][min_idx])  # Update leader\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm exploration by integrating a leader-follower mechanism and adaptive inertia weight adjustment.", "configspace": "", "generation": 66, "fitness": 0.09354685693681945, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.094 with standard deviation 0.001. And the mean value of best solutions found was 0.166 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.0942074633758675, 0.09426549657340078, 0.09216761086119007], "final_y": [0.16715108216074426, 0.16524184321067537, 0.166612996512419]}, "mutation_prompt": null}
{"id": "1fc081ca-770e-42ec-8ec9-8b30e35dbf8b", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape)\n                                       + 0.005 * np.random.uniform(-1, 1, swarm['velocities'].shape))  # Changed line\n\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) \n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a subtle random shift in swarm velocities to enhance exploration.", "configspace": "", "generation": 67, "fitness": 0.09634961812371083, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09667456628144844, 0.0961239166839638, 0.09625037140572024], "final_y": [0.1648557766515456, 0.16485577611223068, 0.16485577940564522]}, "mutation_prompt": null}
{"id": "423f58b2-094c-4afc-a549-4fcc556eeb6b", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.2 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Changed 0.1 to 0.2\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.05 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Changed 0.02 to 0.05\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhanced swarm feedback and mobility for improved convergence in variable-dimensional spaces.", "configspace": "", "generation": 68, "fitness": 0.09639434200164591, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09647745247508754, 0.09625907267075129, 0.0964465008590989], "final_y": [0.16485579951308627, 0.16485578962152558, 0.16485579333636258]}, "mutation_prompt": null}
{"id": "926b44c3-9f87-4d51-a0d6-f0fdcc33a863", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Changed 0.02 to 0.03\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a more aggressive mutation by increasing the perturbation factor for enhancing global exploration.", "configspace": "", "generation": 69, "fitness": 0.09644676524093636, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09659502937296494, 0.09630962024373935, 0.09643564610610478], "final_y": [0.16485578081746632, 0.1648557819061922, 0.1648557831247437]}, "mutation_prompt": null}
{"id": "0e820e6d-fcf7-4ce9-8865-1ee3c0ef31ff", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n        self.velocity_clamp = (ub - lb) * 0.1  # New line for velocity clamping\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        previous_velocity = [np.zeros((self.population_size, self.dim)) for _ in range(self.num_swarms)]  # New line for historical velocities\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for i, swarm in enumerate(self.swarms):\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape)\n                                       + 0.2 * previous_velocity[i])  # New line for using previous velocity\n\n                swarm['velocities'] = np.clip(swarm['velocities'], -self.velocity_clamp, self.velocity_clamp)  # New line for clamping velocities\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n                \n                previous_velocity[i] = np.copy(swarm['velocities'])  # New line to update previous velocities\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Incorporate historical velocity information and velocity clamping to enhance algorithm stability and prevent erratic updates.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'ub' is not defined\").", "error": "NameError(\"name 'ub' is not defined\")", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {}, "mutation_prompt": null}
{"id": "dcbf8cfb-382c-4937-a2cd-9c7cf830d0e0", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Changed 0.1 to 0.15\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.75 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed 0.8 to 0.75\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm convergence by refining velocity update through improved feedback and adaptive weights.", "configspace": "", "generation": 71, "fitness": 0.09636275206698353, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09656347444357072, 0.09595887117426904, 0.09656591058311081], "final_y": [0.1648557767011719, 0.1648557749997014, 0.164855776436591]}, "mutation_prompt": null}
{"id": "9856ea0e-02a3-4f6a-9190-4abc231a4326", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 + 0.2 * (iteration / self.iterations))  # Increased influence over iterations\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Changed 0.01 to 0.02\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance convergence by increasing cognitive weight influence over iterations.", "configspace": "", "generation": 72, "fitness": 0.09637184141928512, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09655380638842437, 0.09643908564656245, 0.09612263222286854], "final_y": [0.1648557812580268, 0.1648557795006288, 0.16485577689612274]}, "mutation_prompt": null}
{"id": "d05e8fe9-09e1-4b66-9ef4-b0f126c78ce8", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                # Refined feedback term\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Refine the feedback term calculation to enhance swarm convergence.", "configspace": "", "generation": 73, "fitness": 0.0964146030401692, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09648694739876884, 0.09631282128689889, 0.0964440404348399], "final_y": [0.16485577543111285, 0.16485577994679346, 0.16485577699560638]}, "mutation_prompt": null}
{"id": "7ac3ab3b-4c71-40a2-a903-9f49ca494603", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand(self.population_size, self.dim)\n                r2 = np.random.rand(self.population_size, self.dim)\n                r3 = np.random.rand(self.population_size, self.dim)\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                diversity_factor = np.std(swarm['positions'], axis=0) * (1 - iteration / self.iterations)  # Changed line\n                feedback_term = 0.1 * np.std(swarm['fitness']) * diversity_factor  # Changed line\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)  # Changed 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape) removed\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce an adaptive diversity mechanism to maintain swarm variety and improve convergence robustness.", "configspace": "", "generation": 74, "fitness": 0.09624499090944245, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09620838072265492, 0.09608447980163215, 0.09644211220404031], "final_y": [0.16485577190470002, 0.16485577191234413, 0.16485577190508538]}, "mutation_prompt": null}
{"id": "fa405310-cd35-4ccb-bd2f-230845d81349", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                # Slight change: Increase 0.02 to 0.03 for better exploration\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  \n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance global exploration by slightly increasing the velocity perturbation factor, promoting diverse solutions.", "configspace": "", "generation": 75, "fitness": 0.09644676524093636, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09659502937296494, 0.09630962024373935, 0.09643564610610478], "final_y": [0.16485578081746632, 0.1648557819061922, 0.1648557831247437]}, "mutation_prompt": null}
{"id": "a5f85b38-dfe2-40a2-bdff-6ac06c350c82", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + 0.9 * swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n            if iteration % (self.iterations // self.num_swarms) == 0:\n                self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        \n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm exploration and exploitation using adaptive velocity scaling and dynamic sub-swarm reformation.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for /: 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for /: 'NoneType' and 'int'\")", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {}, "mutation_prompt": null}
{"id": "1b4c2e18-df69-4cf6-ac00-f83fc60be360", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * (iteration / self.iterations)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.1 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.85 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Changed 0.8 to 0.85\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.025 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Changed 0.02 to 0.025\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance diversity and convergence by fine-tuning position updates and swarm interactions.", "configspace": "", "generation": 77, "fitness": 0.09631487620429517, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09665067444315445, 0.09605019420966343, 0.09624375996006762], "final_y": [0.16485577874234747, 0.1648557780019294, 0.16485578173187532]}, "mutation_prompt": null}
{"id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive non-linear inertia weight and enhanced feedback mechanism to improve global search capabilities.", "configspace": "", "generation": 78, "fitness": 0.09656918543800508, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "70fad488-899c-440b-b503-5642d79274cb", "metadata": {"aucs": [0.09669574818242122, 0.09646870763678339, 0.09654310049481063], "final_y": [0.16485577569784515, 0.16485577717818856, 0.16485581179955722]}, "mutation_prompt": null}
{"id": "8d1af958-904c-43fa-aa64-779dd1fdc78f", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Adjusted feedback term\n\n                # Change: Introduce non-linear adjustment to weight terms\n                adaptive_cognitive_weight *= ((iteration / self.iterations)**0.5)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce nonlinear acceleration coefficients to enhance convergence speed.", "configspace": "", "generation": 79, "fitness": 0.09647572062716152, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.0967547176656175, 0.09614580451927501, 0.09652663969659203], "final_y": [0.1648557761331303, 0.16485577759118564, 0.16485577686142538]}, "mutation_prompt": null}
{"id": "f1245e9c-9132-47e1-a533-84029d3ac9c1", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.4)  # Adjusted from 0.3\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.6)  # Adjusted from 0.5\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + 0.95 * swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Introduced cooling schedule\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a velocity cooling schedule and adjust adaptive weights to enhance convergence speed and accuracy.", "configspace": "", "generation": 80, "fitness": 0.09635564926764344, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.09664912172818307, 0.09618414395258024, 0.09623368212216699], "final_y": [0.16485601893842328, 0.16485577731780554, 0.16521684577098295]}, "mutation_prompt": null}
{"id": "f99350f9-41e8-4e4c-a822-4e70967967c3", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)\n\n                velocity_scale = np.mean(swarm['fitness']) / (np.std(swarm['fitness']) + 1e-5)  # Self-adaptive velocity scaling\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['velocities'] *= velocity_scale  # Apply velocity scaling\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce self-adaptive velocity scaling and swarm diversity preservation mechanism for enhanced exploration-exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.048614654946796766, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.049 with standard deviation 0.000. And the mean value of best solutions found was 0.409 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.04879850903945626, 0.04796023551767703, 0.049085220283257014], "final_y": [0.4073425911909888, 0.41379549904142643, 0.4051421831226424]}, "mutation_prompt": null}
{"id": "7ecaa083-2121-4136-8a7c-93d7cbe30535", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) \n                random_factor = np.random.rand() * 0.1  # Introduced dynamic random factor\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape)\n                                       + random_factor)  # Added random factor to velocity update\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic random factor in velocity update and enhance feedback based on relative fitness improvement.", "configspace": "", "generation": 82, "fitness": 0.0964122741562415, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.09661721534113843, 0.0960564481246543, 0.09656315900293178], "final_y": [0.16551872982777127, 0.16492522682053778, 0.16493737791843677]}, "mutation_prompt": null}
{"id": "f88e9ee5-3cfd-47ad-a1b6-f2ae04bb8715", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n            self.population_size = max(10, int(30 * (1 - iteration / self.iterations)))  # Dynamic swarm size adjustment\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic swarm size adjustment based on iteration progression to enhance exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.09654696912627118, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.09662629653248711, 0.0964731840909484, 0.09654142675537802], "final_y": [0.16491371721462578, 0.16485577450774058, 0.16488093570570794]}, "mutation_prompt": null}
{"id": "6e922cf4-7238-4d20-adb1-72418cea5581", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations)  # Adjusted feedback term\n\n                # Introduce dynamic swarm interactions\n                cross_interaction = 0.1 * (global_best_position - np.mean(swarm['positions'], axis=0))\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape)\n                                       + cross_interaction)\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce dynamic swarm interactions to enhance diversity and convergence speed.", "configspace": "", "generation": 84, "fitness": 0.09654442644880128, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.09678127584109586, 0.09620928701380671, 0.09664271649150125], "final_y": [0.1648557765381542, 0.1648557757805693, 0.16485577752418012]}, "mutation_prompt": null}
{"id": "fa3f4157-05dc-4b0f-b236-df3c5d26b048", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Fine-tune feedback mechanism by introducing an oscillating modulation factor for more dynamic search behavior.", "configspace": "", "generation": 85, "fitness": 0.0965737831879903, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "6f1e5de9-72dd-43b0-a5fa-90c0c40c9d13", "metadata": {"aucs": [0.0966962565179218, 0.09647174005998826, 0.09655335298606083], "final_y": [0.16485577581817634, 0.16485577570119336, 0.164855787622192]}, "mutation_prompt": null}
{"id": "ed8bd98d-fb93-405a-b8bd-6cca2a2c2ba0", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.6 + 0.4 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Fine-tune the oscillating feedback term modulation to enhance diversity and convergence balance.", "configspace": "", "generation": 86, "fitness": 0.09657328538586811, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "fa3f4157-05dc-4b0f-b236-df3c5d26b048", "metadata": {"aucs": [0.09669628822049503, 0.09647039417271985, 0.09655317376438943], "final_y": [0.16485577690161934, 0.16485577646110372, 0.1648557876649367]}, "mutation_prompt": null}
{"id": "674dfd4b-d7ce-4c6a-a510-070f1da7240f", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))\n\n                diversity_term = 0.05 * np.std(swarm['positions'], axis=0)  # New diversity preservation term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape)\n                                       + diversity_term * r2)  # Add diversity term influence\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'], lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Incorporate a diversity preservation mechanism and enhanced parameter adaptation for more robust exploration and exploitation.", "configspace": "", "generation": 87, "fitness": 0.09623294138542819, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "fa3f4157-05dc-4b0f-b236-df3c5d26b048", "metadata": {"aucs": [0.09646811536138666, 0.0958420457506376, 0.0963886630442603], "final_y": [0.16487880791025256, 0.16485707576199693, 0.1650967305673744]}, "mutation_prompt": null}
{"id": "86ce5466-864e-433e-8cbf-c4cae64ee0c9", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for i, swarm in enumerate(self.swarms):\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))\n\n                # Introduce influence from best particles of neighboring swarms\n                neighbor_influence = 0.2 * (self.swarms[(i-1) % self.num_swarms]['personal_best_positions'][np.argmin(self.swarms[(i-1) % self.num_swarms]['personal_best_fitness'])] - swarm['positions'])\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + neighbor_influence\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.02 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a dynamic influence from the best particles of neighboring swarms for enhanced diversity and convergence.", "configspace": "", "generation": 88, "fitness": 0.09653994678150805, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "fa3f4157-05dc-4b0f-b236-df3c5d26b048", "metadata": {"aucs": [0.09646827933359492, 0.0967698138397296, 0.09638174717119963], "final_y": [0.16485577560295828, 0.16485577620479996, 0.16485577668250406]}, "mutation_prompt": null}
{"id": "e13da35a-ddfe-4176-bea8-f870729ee476", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Enhance swarm diversity by slightly increasing the random perturbation factor to escape local optima more effectively.", "configspace": "", "generation": 89, "fitness": 0.0965768770010808, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "fa3f4157-05dc-4b0f-b236-df3c5d26b048", "metadata": {"aucs": [0.09669791477863399, 0.09647104850328547, 0.09656166772132291], "final_y": [0.16485578509499454, 0.16485578361463138, 0.16485578484560992]}, "mutation_prompt": null}
{"id": "913d58de-de14-4c8b-ba49-a093fe15135f", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.04 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Increased random perturbation factor\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Slightly increased the random perturbation factor to enhance exploration capabilities and escape local optima more effectively.", "configspace": "", "generation": 90, "fitness": 0.09657616578188626, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09669614641985425, 0.09647041825691682, 0.09656193266888768], "final_y": [0.16485578446906568, 0.16485578524622113, 0.16485579494383718]}, "mutation_prompt": null}
{"id": "375271cb-c1eb-422a-a8cb-7b9ee5300af0", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.9 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Increased velocity update factor\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Slightly increase the velocity update factor to enhance exploration capability.", "configspace": "", "generation": 91, "fitness": 0.09647179028529311, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09654515910154982, 0.09640981121186176, 0.09646040054246774], "final_y": [0.16485577858796996, 0.16485577928274897, 0.16485578358941244]}, "mutation_prompt": null}
{"id": "80461230-ace3-4bb5-ade3-e4d8cd54240c", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(20, int(30 * (budget / 1000)))  # Changed line\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduced dynamic adaptation of the population size to improve exploration and exploitation balance over iterations.", "configspace": "", "generation": 92, "fitness": 0.09127506343560428, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.091 with standard deviation 0.001. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09091682944393364, 0.09083044310420008, 0.09207791775867913], "final_y": [0.16552824735083282, 0.16594307493302285, 0.16493519504552656]}, "mutation_prompt": null}
{"id": "9e4aedd6-9dd3-4b5e-b836-a5ef3e834833", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                perturbation_factor = 0.03 * (1 - iteration / self.iterations)  # Adaptive perturbation\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + perturbation_factor * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce an adaptive random perturbation based on the iteration count to improve exploration capabilities.", "configspace": "", "generation": 93, "fitness": 0.09656911071616144, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09669685420000951, 0.09647102112262651, 0.0965394568258483], "final_y": [0.16485577194913648, 0.1648557719166257, 0.16489003137305147]}, "mutation_prompt": null}
{"id": "bb6279f5-71fd-4397-ad90-72e03e4b1364", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  \n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  \n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       # Increased impact of global best position\n                                       + 1.2 * adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub) \n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Slightly adjust velocity calculation to improve convergence speed by increasing the impact of the global best position.", "configspace": "", "generation": 94, "fitness": 0.09653830896811448, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09674903926095357, 0.09631443976581755, 0.0965514478775723], "final_y": [0.16485578026627157, 0.164855785083468, 0.1648557802199786]}, "mutation_prompt": null}
{"id": "cdb454b5-f952-4140-b97e-bfbe35771101", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.75 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])  # Slightly adjusted influence of mean position\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.04 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Further increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Refine swarm adaptability by adjusting the balance between exploration and exploitation through dynamic perturbation.", "configspace": "", "generation": 95, "fitness": 0.09641904900087735, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09655689380903698, 0.09609099904180496, 0.09660925415179011], "final_y": [0.16485579433559217, 0.16485578155605018, 0.16485579427571995]}, "mutation_prompt": null}
{"id": "5e6970f7-7558-4776-92dd-1b21c7637bf9", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.20 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Further enhance swarm diversity by slightly adjusting the feedback term to maintain exploration potential.", "configspace": "", "generation": 96, "fitness": 0.09657472234320308, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.097 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09669503527726298, 0.09646740964232414, 0.09656172211002212], "final_y": [0.16485578355933883, 0.16485578594510508, 0.16485578320075012]}, "mutation_prompt": null}
{"id": "f2a56601-92e5-41ac-88b1-c5ee2ab0909c", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.7)  # Changed to slightly different power for improvement\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Improved inertia update for better exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.0964713548439851, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09658551952224903, 0.09643133182939201, 0.09639721318031425], "final_y": [0.16485578516610377, 0.16485578329732842, 0.16485578582687221]}, "mutation_prompt": null}
{"id": "fc8aefc0-8430-42fe-a68d-e65605320945", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.35)  # Changed exponent to 0.35\n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.45)  # Changed exponent to 0.45\n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                swarm['velocities'] = (inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce non-linear weight adjustment for cognitive and social components to enhance convergence dynamics.", "configspace": "", "generation": 98, "fitness": 0.09649931425824483, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.096 with standard deviation 0.000. And the mean value of best solutions found was 0.165 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.09671046050255427, 0.09631443783485649, 0.09647304443732374], "final_y": [0.16485579451555676, 0.16485578431838555, 0.1648558221292461]}, "mutation_prompt": null}
{"id": "32fb62ff-1188-46a0-b627-e0e07b1ec6a5", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_min = 0.2\n        self.inertia_max = 0.9\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.num_swarms = 3\n        self.swarms = [self._initialize_swarm() for _ in range(self.num_swarms)]\n        self.iterations = budget // (self.population_size * self.num_swarms)\n\n    def _initialize_swarm(self):\n        return {\n            'positions': None,\n            'velocities': None,\n            'fitness': None,\n            'personal_best_positions': None,\n            'personal_best_fitness': None\n        }\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        global_best_position = None\n        global_best_fitness = float('inf')\n\n        for swarm in self.swarms:\n            swarm['positions'] = np.random.rand(self.population_size, self.dim) * (ub - lb) + lb\n            swarm['velocities'] = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim)) * (ub - lb)\n            swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n            evals += self.population_size\n\n            swarm['personal_best_positions'] = np.copy(swarm['positions'])\n            swarm['personal_best_fitness'] = np.copy(swarm['fitness'])\n\n            min_idx = np.argmin(swarm['fitness'])\n            if swarm['fitness'][min_idx] < global_best_fitness:\n                global_best_position = swarm['positions'][min_idx]\n                global_best_fitness = swarm['fitness'][min_idx]\n\n        for iteration in range(self.iterations):\n            if evals >= self.budget:\n                break\n\n            for swarm in self.swarms:\n                inertia_weight = self.inertia_max - (self.inertia_max - self.inertia_min) * ((iteration / self.iterations)**0.5)  # Changed to non-linear\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                r3 = np.random.rand()\n\n                adaptive_cognitive_weight = self.cognitive_weight * (1 - (evals / self.budget)**0.3)  \n                adaptive_social_weight = self.social_weight * ((evals / self.budget)**0.5)  \n\n                feedback_term = 0.15 * np.std(swarm['fitness']) * (1 - iteration / self.iterations) * (0.5 + 0.5 * np.sin(2 * np.pi * iteration / self.iterations))  # Adjusted feedback term\n\n                momentum_factor = 0.9  # New momentum factor\n                swarm['velocities'] = (momentum_factor * swarm['velocities'] + inertia_weight * swarm['velocities']\n                                       + adaptive_cognitive_weight * r1 * (swarm['personal_best_positions'] - swarm['positions'])\n                                       + adaptive_social_weight * r2 * (global_best_position - swarm['positions'])\n                                       + 0.8 * r3 * (np.mean(swarm['positions'], axis=0) - swarm['positions'])\n                                       + feedback_term * np.random.randn(*swarm['positions'].shape))\n                swarm['positions'] = np.clip(swarm['positions'] + swarm['velocities'] + 0.03 * np.random.uniform(-1, 1, swarm['positions'].shape), lb, ub)  # Slightly increased random perturbation\n\n                swarm['fitness'] = np.array([func(ind) for ind in swarm['positions']])\n                evals += self.population_size\n\n                better_mask = swarm['fitness'] < swarm['personal_best_fitness']\n                swarm['personal_best_positions'][better_mask] = swarm['positions'][better_mask]\n                swarm['personal_best_fitness'][better_mask] = swarm['fitness'][better_mask]\n\n                min_idx = np.argmin(swarm['fitness'])\n                if swarm['fitness'][min_idx] < global_best_fitness:\n                    global_best_position = swarm['positions'][min_idx]\n                    global_best_fitness = swarm['fitness'][min_idx]\n\n        return global_best_position, global_best_fitness", "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce a momentum factor to slightly adjust the velocity update for improved convergence.", "configspace": "", "generation": 99, "fitness": 0.0804894347748883, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.080 with standard deviation 0.008. And the mean value of best solutions found was 0.227 (0. is the best).", "error": "", "parent_id": "e13da35a-ddfe-4176-bea8-f870729ee476", "metadata": {"aucs": [0.0832258772258545, 0.06930357597816605, 0.08893885112064437], "final_y": [0.2147089546049279, 0.2772995362873111, 0.18966597701684995]}, "mutation_prompt": null}
