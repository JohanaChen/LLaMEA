{"id": "ec8d97ca-a5b6-4454-901d-38fde5f813b9", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "A novel hybrid Particle-Swarm-Genetic algorithm that adapts exploration and exploitation by combining particle swarm dynamics with genetic crossover to efficiently navigate complex photonic structure landscapes.", "configspace": "", "generation": 0, "fitness": 0.2758996543350739, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2771593615944591, 0.2733773671108044, 0.27716223429995823]}, "mutation_prompt": null}
{"id": "03bcafbd-0ed2-46b5-b093-b6ada8308210", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.7  # Modified from 1.5 to 1.7\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced social coefficient to improve global exploration in the HybridPSOGA algorithm.", "configspace": "", "generation": 1, "fitness": 0.27480192231669315, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "ec8d97ca-a5b6-4454-901d-38fde5f813b9", "metadata": {"aucs": [0.2777283482612106, 0.26926187615020214, 0.27741554253866674]}, "mutation_prompt": null}
{"id": "d198fc60-378b-49c1-9906-d444c7c8c578", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced HybridPSOGA by fine-tuning the inertia weight for improved balance between exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.2775627723636916, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "ec8d97ca-a5b6-4454-901d-38fde5f813b9", "metadata": {"aucs": [0.27767793003023933, 0.2774818649127053, 0.27752852214813006]}, "mutation_prompt": null}
{"id": "e6eebba3-798f-4cbd-a895-9c763d3ba1b9", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced HybridPSOGA by incorporating adaptive mutation rate based on iteration progress for improved balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.2775882521906538, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "d198fc60-378b-49c1-9906-d444c7c8c578", "metadata": {"aucs": [0.27776507822130647, 0.2774475150422251, 0.2775521633084299]}, "mutation_prompt": null}
{"id": "6527a25c-4df5-421f-ae6b-27aa53e10aa4", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.7  # Adjusted social coefficient from 1.5 to 1.7\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Improved Enhanced HybridPSOGA by adjusting the social coefficient to enhance alignment with the global best position.", "configspace": "", "generation": 4, "fitness": 0.2749298034146643, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "e6eebba3-798f-4cbd-a895-9c763d3ba1b9", "metadata": {"aucs": [0.27781660492808735, 0.26925559656522113, 0.2777172087506843]}, "mutation_prompt": null}
{"id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introducing dynamic adjustment of the inertia weight to enhance convergence speed and accuracy.", "configspace": "", "generation": 5, "fitness": 0.2775992259780921, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "e6eebba3-798f-4cbd-a895-9c763d3ba1b9", "metadata": {"aucs": [0.27776196646678186, 0.2775427070648928, 0.2774930044026017]}, "mutation_prompt": null}
{"id": "0303d01d-a67c-4e5c-be93-7e5ddbd57eaa", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.6  # Adjusted social coefficient from 1.5 to 1.6\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introducing a small adjustment to the social coefficient to balance local and global search more effectively.", "configspace": "", "generation": 6, "fitness": 0.27614902691816806, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "metadata": {"aucs": [0.2770672563903752, 0.2735815262305732, 0.2777982981335557]}, "mutation_prompt": null}
{"id": "e33f2592-d930-4817-bb12-639fd117907a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.6  # Increased from 1.5 to 1.6\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhancing exploration by increasing the cognitive coefficient slightly for better local searching ability.", "configspace": "", "generation": 7, "fitness": 0.27702147292619134, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "metadata": {"aucs": [0.27753509701899615, 0.27623653471946685, 0.27729278704011107]}, "mutation_prompt": null}
{"id": "98accda9-b4fb-4bd2-a3ae-ba00c04f3f2e", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            self.cognitive_coef = 1.5 + 0.5 * evaluations / self.budget  # Adaptive cognitive coefficient\n            self.social_coef = 1.5 + 0.5 * (1 - evaluations / self.budget)  # Adaptive social coefficient\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introducing adaptive cognitive and social coefficients to enhance exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.27320844820972573, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "metadata": {"aucs": [0.2733859821302087, 0.2732023494514818, 0.2730370130474866]}, "mutation_prompt": null}
{"id": "de98891a-a166-4b20-9d81-6501dda5c939", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.6  # Changed from 1.5 to 1.6\n        self.social_coef = 1.6  # Changed from 1.5 to 1.6\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Slightly increased cognitive and social coefficients to improve individual and collective exploration capabilities.", "configspace": "", "generation": 9, "fitness": 0.27636934548349057, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "metadata": {"aucs": [0.2777632521627298, 0.27356583238616605, 0.27777895190157587]}, "mutation_prompt": null}
{"id": "6c346034-0cd1-4264-b0e2-c7e2b37aaaad", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)  # Dynamic social coefficient\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced social learning by adapting social coefficient dynamically for improved exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.27772679621599633, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "fc0b48d0-50b7-4a60-af68-0337fed47ec2", "metadata": {"aucs": [0.2778011214156889, 0.277751705089912, 0.27762756214238815]}, "mutation_prompt": null}
{"id": "2f0c67de-4d56-41d1-8871-a7817ff1b26b", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.8  # Increased cognitive coefficient from 1.5 to 1.8\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)  # Dynamic social coefficient\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced exploration by increasing cognitive coefficient for faster convergence.", "configspace": "", "generation": 11, "fitness": 0.2775076168144842, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6c346034-0cd1-4264-b0e2-c7e2b37aaaad", "metadata": {"aucs": [0.27781552952388333, 0.27791030663397587, 0.27679701428559345]}, "mutation_prompt": null}
{"id": "c8c192ea-81b5-4d29-81c2-6aff3a452edf", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6  # Adjusted inertia weight from 0.7 to 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)  # Dynamic social coefficient\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Adaptive mutation rate based on progress\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            # Genetic Crossover and Mutation\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adjust the mutation value to expand exploration slightly\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce minor adjustment in mutation mechanism to enhance exploration.", "configspace": "", "generation": 12, "fitness": 0.27784784485131614, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "6c346034-0cd1-4264-b0e2-c7e2b37aaaad", "metadata": {"aucs": [0.2778072031296409, 0.2778992944402796, 0.27783703698402795]}, "mutation_prompt": null}
{"id": "9b6a92e5-77fb-4f3d-a39e-c90c4174999b", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)  # Dynamic cognitive coefficient\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by adjusting the cognitive coefficient dynamically.", "configspace": "", "generation": 13, "fitness": 0.27785723117555877, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "c8c192ea-81b5-4d29-81c2-6aff3a452edf", "metadata": {"aucs": [0.2778114368222162, 0.277895322598119, 0.27786493410634117]}, "mutation_prompt": null}
{"id": "23452a5f-2237-4d27-a025-0ccd90f7bf39", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.exp(-3 * evaluations / self.budget)  # Non-linear reduction\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by reducing inertia weight non-linearly near convergence.", "configspace": "", "generation": 14, "fitness": 0.27785329562194866, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "9b6a92e5-77fb-4f3d-a39e-c90c4174999b", "metadata": {"aucs": [0.277817501645813, 0.27789567573485063, 0.2778467094851824]}, "mutation_prompt": null}
{"id": "c5d602e8-f8c8-48fe-ad9a-1f08dcd0860f", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = max(0.1, 0.4 + 0.2 * (1 - evaluations / self.budget))  # Decay\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            population = offspring\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Incorporate inertia weight decay to balance exploration and exploitation progressively.", "configspace": "", "generation": 15, "fitness": 0.27785723117555877, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "9b6a92e5-77fb-4f3d-a39e-c90c4174999b", "metadata": {"aucs": [0.2778114368222162, 0.277895322598119, 0.27786493410634117]}, "mutation_prompt": null}
{"id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)  # Dynamic cognitive coefficient\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            if evaluations % 10 == 0:  # Adjust population size dynamically\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = offspring[:self.population_size]\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by dynamically adjusting the population size.", "configspace": "", "generation": 16, "fitness": 0.2778918103912585, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "9b6a92e5-77fb-4f3d-a39e-c90c4174999b", "metadata": {"aucs": [0.27779340813165954, 0.2780219973369147, 0.2778600257052012]}, "mutation_prompt": null}
{"id": "781bccd6-5b07-4975-8c5c-a8c78b2255fd", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n        self.elite_fraction = 0.1  # Added elitism parameter\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            elite_count = max(1, int(self.elite_fraction * self.population_size))  # Select elite individuals\n            elite_indices = np.argsort(personal_best_scores)[:elite_count]\n            elite_offspring = offspring[elite_indices]\n            population = np.vstack((elite_offspring, offspring[:self.population_size - elite_count]))  # Replace worst with elites\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive learning rates and elitism to balance exploration and exploitation dynamically.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 40')", "parent_id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "metadata": {}, "mutation_prompt": null}
{"id": "12f015a0-baee-4d29-a164-ba4a42a694e8", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            learning_factor = 1.4 - 0.8 * (evaluations / self.budget)  # Change 1\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 learning_factor * self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +  # Change 2\n                                 learning_factor * self.social_coef * r2 * (global_best_position - population[i]))  # Change 3\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = offspring[:self.population_size]\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive learning factors to improve balancing between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.27761600713104884, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "metadata": {"aucs": [0.2779295607430402, 0.2776185517957278, 0.2772999088543785]}, "mutation_prompt": null}
{"id": "b8ed9939-3ab3-45e2-9f09-4adf498cd246", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    if np.random.rand() < 0.5:  # Dynamic crossover decision\n                        parent2 = 0.5 * (parent1 + parent2)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.05  # Adjusted mutation strength\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.95))\n\n            population = offspring[:self.population_size]\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "HybridPSOGA-Improved: Exploit adaptive learning rates and dynamic crossover to enhance exploration and convergence.", "configspace": "", "generation": 19, "fitness": 0.277803654105295, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "metadata": {"aucs": [0.2778278493057844, 0.277978310440696, 0.2776048025694047]}, "mutation_prompt": null}
{"id": "8671f13d-89d3-4b8b-9d72-d20ec657fd5a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n        last_global_best_score = personal_best_scores[global_best_index]\n\n        while evaluations < self.budget:\n            improvement_rate = (last_global_best_score - personal_best_scores[global_best_index]) / last_global_best_score\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget) * (1 + improvement_rate) # Changed line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.uniform(lb[mutation_dim], ub[mutation_dim]) * 0.1\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = offspring[:self.population_size]\n            last_global_best_score = personal_best_scores[global_best_index]\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance adaptive parameter adjustment by incorporating feedback from the best solution's improvement rate.", "configspace": "", "generation": 20, "fitness": 0.2778918103912585, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "metadata": {"aucs": [0.27779340813165954, 0.2780219973369147, 0.2778600257052012]}, "mutation_prompt": null}
{"id": "7acd9d60-0d16-4a48-b830-c8b7e4a52931", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * (1 - evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)  # Dynamic crossover probability\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = offspring[:self.population_size]\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive mutation and dynamic crossover strategies to enhance diversity and convergence speed.", "configspace": "", "generation": 21, "fitness": 0.2778919589022483, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "1e9187df-09eb-4d91-8368-81faf45f5f5a", "metadata": {"aucs": [0.27796719435128747, 0.2780017122507721, 0.2777069701046855]}, "mutation_prompt": null}
{"id": "7acd6161-a9d4-4ba1-ad10-107d1a2530d7", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by incorporating nonlinear inertia weight and elitism in GA crossover.", "configspace": "", "generation": 22, "fitness": 0.2778920982542043, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "7acd9d60-0d16-4a48-b830-c8b7e4a52931", "metadata": {"aucs": [0.2779602099822266, 0.27800347651440505, 0.2777126082659813]}, "mutation_prompt": null}
{"id": "33889ca3-63ee-4cd8-8b8d-42e92e0563d8", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.1 * (1 - evaluations / self.budget)  # Changed line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.85))  # Changed line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by introducing dynamic population resizing and adaptive crossover in HybridPSOGA to improve convergence rate.", "configspace": "", "generation": 23, "fitness": 0.27646166181238446, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "7acd6161-a9d4-4ba1-ad10-107d1a2530d7", "metadata": {"aucs": [0.27370156031306725, 0.27797203439895246, 0.2777113907251336]}, "mutation_prompt": null}
{"id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Incorporate decay in mutation rate adaptation to improve exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.2778921162784031, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "7acd6161-a9d4-4ba1-ad10-107d1a2530d7", "metadata": {"aucs": [0.27796020022128953, 0.27800358276137516, 0.27771256585254456]}, "mutation_prompt": null}
{"id": "f7162864-ecd9-4337-af81-428dee7d8758", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.6 + 0.3 * np.sin(np.pi * evaluations / self.budget)  # Adaptive crossover\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    alpha = np.random.uniform(0.3, 0.7)  # Intermediate recombination\n                    offspring[i] = alpha * parent1 + (1 - alpha) * parent2\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            # Local search refinement\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    local_point = offspring[i] + np.random.normal(0, 0.01, self.dim)\n                    local_point = np.clip(local_point, lb, ub)\n                    local_score = func(local_point)\n                    evaluations += 1\n                    if local_score < personal_best_scores[i]:\n                        personal_best_scores[i] = local_score\n                        personal_best_positions[i] = local_point\n                        if local_score < personal_best_scores[global_best_index]:\n                            global_best_index = i\n                            global_best_position = personal_best_positions[global_best_index]\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce local search refinement and adaptive crossover operator for enhanced convergence.", "configspace": "", "generation": 25, "fitness": 0.2778787882835042, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2779600062182517, 0.27790559070244925, 0.2777707679298117]}, "mutation_prompt": null}
{"id": "0ed5b1b7-904c-45fb-adea-dd073f04248c", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Uniform mutation\n                    offspring[i, mutation_dim] = np.random.uniform(lb[mutation_dim], ub[mutation_dim])\n\n            if evaluations % 10 == 0:\n                idx = np.random.randint(0, self.population_size)\n                offspring[idx] = np.random.uniform(lb, ub, self.dim)  # Random reinitialization\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Implement uniform mutation and enhance offspring diversity with random reinitialization.", "configspace": "", "generation": 26, "fitness": 0.2775302710360486, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2777646601207969, 0.2778041821254418, 0.27702197086190705]}, "mutation_prompt": null}
{"id": "0c030228-490c-46a5-bfd2-f2d895a34900", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)  # Added r3 for randomness\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]) +\n                                 0.1 * r3 * (ub - lb))  # Add randomness to velocity\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Refine the velocity update by adding randomness to enhance exploration.", "configspace": "", "generation": 27, "fitness": 0.2732421198938643, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2736097156249292, 0.2720683619540195, 0.2740482821026443]}, "mutation_prompt": null}
{"id": "c06f9dd8-ed0b-4428-8727-53a17832cbb9", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * (0.9 + 0.1 * evaluations / self.budget)))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce a dynamic population size adjustment based on convergence to enhance diversity.", "configspace": "", "generation": 28, "fitness": 0.2778921162784031, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.27796020022128953, 0.27800358276137516, 0.27771256585254456]}, "mutation_prompt": null}
{"id": "28ad8830-c5e8-49ff-98ee-6ded6c0a84eb", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.3 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.2 * np.exp(-0.5 * evaluations / self.budget)\n            self.social_coef = 1.2 * np.log(1 + evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance adaptive dynamics by integrating a nonlinear decay in social and cognitive coefficients to optimize convergence.", "configspace": "", "generation": 29, "fitness": 0.2759478177224029, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2747908931034465, 0.27631247692993066, 0.2767400831338316]}, "mutation_prompt": null}
{"id": "17cc23eb-59cb-404b-9b9a-fbbf4fa2be63", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n        self.elite_fraction = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            elite_count = max(1, int(self.population_size * self.elite_fraction))\n            elite_indices = np.argsort(personal_best_scores)[:elite_count]\n            elite_set = personal_best_positions[elite_indices]\n\n            self.population_size = max(10, int(self.initial_population_size * 0.85**(evaluations // 10)))\n\n            population = np.vstack([offspring[:self.population_size], elite_set[:min(elite_count, self.population_size)]])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Improve exploration by incorporating dynamic population size and adaptive elite selection.", "configspace": "", "generation": 30, "fitness": 0.27744319191471895, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2765017846955844, 0.2779154597349811, 0.2779123313135913]}, "mutation_prompt": null}
{"id": "fa223ae3-a8f6-46c2-80b3-678b0000d3f2", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n\n            neighbors = np.random.choice(self.population_size, (self.population_size, 2), replace=False)\n            for i in range(self.population_size):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = population[neighbors[i]]\n                    cross_point = np.random.randint(1, self.dim)\n                    population[i, :cross_point], population[i, cross_point:] = parent2[:cross_point], parent1[cross_point:]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    population[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive crossover with dynamic neighborhood structure to enhance diversity and convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {}, "mutation_prompt": null}
{"id": "f0f5fa40-47dd-4d8d-8d54-cac526902e4b", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            progress_ratio = evaluations / self.budget\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * progress_ratio)\n            self.cognitive_coef = 1.0 + 0.5 * np.sin(np.pi * progress_ratio)  # Changed line\n            self.social_coef = 1.0 + 0.5 * np.cos(np.pi * progress_ratio)    # Changed line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * np.sin(np.pi * progress_ratio)  # Changed line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]        ", "name": "HybridPSOGA", "description": "Introduce adaptive learning rates for cognitive and social coefficients to dynamically adjust the balance between exploration and exploitation.", "configspace": "", "generation": 32, "fitness": 0.27638753294107593, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.27790900460844536, 0.2735600710634607, 0.2776935231513218]}, "mutation_prompt": null}
{"id": "85b7f3e8-512b-43fd-aa97-cb5b18d57874", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity_scale = 0.5 + 0.5 * (evaluations / self.budget)  # Adaptive velocity scaling\n                velocities[i] = velocity_scale * (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)  # Decay mutation rate\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    # Adaptive mutation: use Gaussian noise\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive velocities scaling for improved convergence.", "configspace": "", "generation": 33, "fitness": 0.27786173311112367, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2778653448559877, 0.2779248399251898, 0.27779501455219346]}, "mutation_prompt": null}
{"id": "40fa5f08-8bda-4df0-b08d-0041b55fe626", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    diff_vec = parent1 + np.random.rand() * (global_best_position - parent2)\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = diff_vec[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    offspring[i, mutation_dim] += np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n\n            if evaluations % 15 == 0:\n                self.population_size = max(10, int(self.population_size * 0.85))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Integrate a differential evolution-inspired mechanism and adaptive population resizing to enhance exploration capabilities.", "configspace": "", "generation": 34, "fitness": 0.27607910118160167, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2729731028769873, 0.27767896139416615, 0.27758523927365153]}, "mutation_prompt": null}
{"id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance global exploration by introducing an adaptive cluster-based perturbation approach.", "configspace": "", "generation": 35, "fitness": 0.27797312463338414, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f183ffbb-3c69-4eff-94cf-d3a402cff9b3", "metadata": {"aucs": [0.2779178263282239, 0.2780316387531181, 0.27796990881881034]}, "mutation_prompt": null}
{"id": "61949792-c78b-4986-a82b-c94028fd6dfb", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.3 * np.cos(np.pi * evaluations / self.budget)  # Modified\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            velocity_clamp = (ub - lb) * 0.1  # Added line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = np.clip((self.inertia_weight * velocities[i] +\n                                         self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                         self.social_coef * r2 * (global_best_position - population[i])), -velocity_clamp, velocity_clamp)  # Modified\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive velocity clamping and dynamic inertia weight modulation to improve the convergence speed and balance exploration-exploitation.", "configspace": "", "generation": 36, "fitness": 0.27782598822909454, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2779055143626975, 0.2777631447862364, 0.2778093055383497]}, "mutation_prompt": null}
{"id": "d280784b-1792-4ab9-a8a3-b4f027ab6aeb", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.05 + 0.05 * np.sin(np.pi * evaluations / self.budget)\n            self.cross_prob = 0.5 + 0.5 * (1 - np.cos(np.pi * evaluations / self.budget))\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Improve local exploration by dynamically adjusting mutation and crossover rates based on evaluation progress.", "configspace": "", "generation": 37, "fitness": 0.27789486156833915, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.277904409415077, 0.2779191413898531, 0.2778610339000873]}, "mutation_prompt": null}
{"id": "227fa444-1851-4b03-9ac8-7ca5c13293ea", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.5 + 0.3 * (np.sin(2 * np.pi * evaluations / self.budget))  # Dynamic adjustment\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce dynamic adjustment to social coefficient for improved convergence.", "configspace": "", "generation": 38, "fitness": 0.27634624471599395, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.27786660446409805, 0.27759516193513256, 0.2735769677487512]}, "mutation_prompt": null}
{"id": "6bb48755-0e33-4bc1-a7d6-6be6323f76cb", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.05 * np.exp(-evaluations / self.budget)  # Changed line\n            self.cross_prob = 0.5 + 0.3 * (1 - evaluations / self.budget)  # Changed line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_points = np.random.choice(self.dim, size=self.dim//2, replace=False)  # Changed line\n                    for cp in cross_points:\n                        offspring[i, cp], offspring[(i+1) % self.population_size, cp] = parent2[cp], parent1[cp]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Incorporate a dynamic crossover operation and selective mutation to improve exploration and convergence.", "configspace": "", "generation": 39, "fitness": 0.2759777920026134, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.27332381111043214, 0.2776143545537614, 0.2769952103436467]}, "mutation_prompt": null}
{"id": "0261786e-dc90-4518-9a0e-6546f3b83a17", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i] * (1 - evaluations / self.budget)  # Adaptive learning rate\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            elite_indices = np.argsort(personal_best_scores)[:3]  # Select top 3 elites\n            elite_individuals = personal_best_positions[elite_indices]\n            population = np.vstack([offspring[:self.population_size], elite_individuals])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Incorporate an adaptive learning rate and elite selection to enhance exploration and exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.27788162787855186, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2778240828845052, 0.2779069577339749, 0.2779138430171755]}, "mutation_prompt": null}
{"id": "e83e91ab-b3af-4124-a8a2-e20f60c855c8", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Changed line\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance global exploration by introducing adaptive dynamic scaling of the cognitive and social coefficients.", "configspace": "", "generation": 41, "fitness": 0.27794694770551304, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2778766834998476, 0.2779836383728198, 0.2779805212438716]}, "mutation_prompt": null}
{"id": "ba945f36-02d8-465b-a873-420c38d71731", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n        reset_interval = 5\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            if evaluations % reset_interval == 0:\n                population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by integrating periodic re-initialization of particles to escape local optima.", "configspace": "", "generation": 42, "fitness": 0.27650338486239523, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2736750577824679, 0.27797876946424105, 0.2778563273404767]}, "mutation_prompt": null}
{"id": "4f1bacb2-e572-4e6c-82ba-37eb76df0c51", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (0.9 * velocities[i] +\n                                 self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce momentum to velocities for smoother convergence.", "configspace": "", "generation": 43, "fitness": 0.2560848032918562, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.01.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2566462319388563, 0.2638496255253323, 0.2477585524113799]}, "mutation_prompt": null}
{"id": "8069328e-9763-41d2-a01e-2db33a08bdf2", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.3 * np.cos(np.pi * evaluations / self.budget)  # Adjusted decay formula\n            # self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            # self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.8 - 0.3 * (evaluations / self.budget)  # Adjusted decay formula\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance global exploration by adjusting the inertia weight and crossover probability decay rates dynamically.", "configspace": "", "generation": 44, "fitness": 0.27585037389998396, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2774260637139522, 0.2727737775221666, 0.27735128046383306]}, "mutation_prompt": null}
{"id": "fde7fad4-ff5d-47f0-b764-236649b330bf", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.05 * np.exp(-evaluations / self.budget)  # Adjusted mutation rate decay factor\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "HybridPSOGA with an adaptive decay factor for mutation rate based on evaluations and budget.", "configspace": "", "generation": 45, "fitness": 0.27790770013473565, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2778739835407621, 0.27797252126004746, 0.2778765956033974]}, "mutation_prompt": null}
{"id": "f7d98c9e-a14e-4db6-b74d-67fa3477cb51", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] *= 1.05  # Change: Introduce momentum factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce momentum to enhance the global exploration by dynamically adjusting velocity scaling.", "configspace": "", "generation": 46, "fitness": 0.2764570591043441, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2778552559736316, 0.2736091391443789, 0.27790678219502185]}, "mutation_prompt": null}
{"id": "1176dcf6-381c-4e04-b247-736cc9623217", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.2 * np.cos(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0 or evaluations % 15 == 0:\n                self.population_size = max(10, int(self.population_size * (0.9 + 0.1 * np.sin(evaluations / self.budget * np.pi))))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce dynamic population resizing to balance exploration and exploitation effectively.", "configspace": "", "generation": 47, "fitness": 0.27796862293728974, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.277907317354366, 0.2780308019730259, 0.27796774948447733]}, "mutation_prompt": null}
{"id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:  # Modified line\n                self.population_size = max(10, int(self.population_size * 0.92))  # Modified line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Incorporate dynamic scaling of inertia weight to enhance exploration and convergence balance.", "configspace": "", "generation": 48, "fitness": 0.27799246281610634, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "eee04dbd-028a-4da6-8849-6a583e8f9690", "metadata": {"aucs": [0.2779859931618949, 0.278014688365094, 0.27797670692133014]}, "mutation_prompt": null}
{"id": "b68924da-8c74-45a2-b518-49033a9977d1", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n        success_rate = 0.5  # New line to track success rate\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - success_rate)  # Modified line\n            self.social_coef = 1.0 + 0.5 * success_rate  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            successful_updates = 0  # New line to count successful updates\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                    successful_updates += 1  # New line to increment successful updates\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            success_rate = successful_updates / self.population_size  # New line to calculate success rate\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive cognitive and social coefficients based on success rate to enhance local and global search balance.", "configspace": "", "generation": 49, "fitness": 0.2764414345366792, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.27793197610997455, 0.2737402351579943, 0.2776520923420688]}, "mutation_prompt": null}
{"id": "bc1ba4ba-783f-45e7-96fb-9085bf4ee780", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 1.2 + 0.8 * (1 - evaluations / self.budget)  # Modified line\n            self.social_coef = 1.0 + 0.6 * (evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05 * np.sin(evaluations / self.budget))  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive mutation scaling and enhanced swarm intelligence to improve convergence efficiency.", "configspace": "", "generation": 50, "fitness": 0.2777027964923819, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2772897055259591, 0.2779300265278185, 0.2778886574233681]}, "mutation_prompt": null}
{"id": "7fbee4be-f967-42db-a5b5-e7e650bedd90", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            velocity_clamp = (ub - lb) * 0.1  # New line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = np.clip((self.inertia_weight * velocities[i] +\n                                         self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                         self.social_coef * r2 * (global_best_position - population[i])), -velocity_clamp, velocity_clamp)  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive velocity clamping and additional mutation scaling to enhance exploration during late stages.", "configspace": "", "generation": 51, "fitness": 0.27781946249039513, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2778256073698788, 0.27791243521105935, 0.2777203448902472]}, "mutation_prompt": null}
{"id": "c33e8a0c-1935-459f-8516-e8bf62e956bd", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / (self.budget * 0.8))  # Modified line\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.93))  # Modified line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce a dynamic population size and enhance local search to improve convergence efficiency.", "configspace": "", "generation": 52, "fitness": 0.2779922022292795, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2779826126967716, 0.27801307514671203, 0.27798091884435494]}, "mutation_prompt": null}
{"id": "2e45dc62-b51a-4548-937b-cd3630f9bea6", "solution": "import numpy as np\n\nclass EnhancedHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7  # Increased initial inertia weight\n        self.cognitive_coef = 1.5\n        self.social_coef = 2.0  # Increased social coefficient for better convergence\n        self.mutation_rate = 0.2  # Increased initial mutation rate\n        self.cross_prob = 0.8  # Increased crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.3 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 2.0 - 0.5 * (evaluations / self.budget)  # Modified line\n            self.social_coef = 1.5 + 0.5 * (evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.15 * np.exp(-evaluations / self.budget)  # Modified line\n            self.cross_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 15 == 0:  # Modified line\n                self.population_size = max(5, int(self.population_size * 0.9))  # Modified line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "EnhancedHybridPSOGA", "description": "Introduce adaptive population resizing and enhanced leader selection to improve convergence and solution quality.", "configspace": "", "generation": 53, "fitness": 0.2759662115828139, "feedback": "The algorithm EnhancedHybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.27728612776857153, 0.27352943248420614, 0.27708307449566405]}, "mutation_prompt": null}
{"id": "c1df08bc-ea70-4dc0-b9f3-d2592d6abb11", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            learning_rate = 0.1 + 0.9 * (1 - evaluations / self.budget)  # Modified line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) * learning_rate +  # Modified line\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Employ adaptive learning rates to improve convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.27798665695796837, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2779757261482678, 0.278018989323357, 0.27796525540228034]}, "mutation_prompt": null}
{"id": "dee588b5-facb-4849-9982-1599ec71847a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0: \n                self.population_size = max(10, int(self.population_size * 0.95 + 0.05 * (self.budget - evaluations) / self.budget * 50))  # Modified line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive population size scaling for enhanced convergence speed and solution diversity.", "configspace": "", "generation": 55, "fitness": 0.27795519907826943, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2779383771765066, 0.27800709123196565, 0.277920128826336]}, "mutation_prompt": null}
{"id": "9b7593e8-9056-43b0-b6a2-3bd60c79781e", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * np.var(population, axis=0).mean()  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce an adaptive social coefficient based on the global best position's variance to enhance convergence.", "configspace": "", "generation": 56, "fitness": 0.23634921311112952, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.232603981708018, 0.23834480608611286, 0.2380988515392577]}, "mutation_prompt": null}
{"id": "ce8a5dc1-7ac1-410e-80cd-00c7beb07492", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n        prev_global_best_score = personal_best_scores[global_best_index]\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                if personal_best_scores[global_best_index] == prev_global_best_score:\n                    self.population_size = max(10, int(self.population_size * 0.95))  # Change line\n                else:\n                    self.population_size = min(100, int(self.population_size * 1.05))  # Change line\n                prev_global_best_score = personal_best_scores[global_best_index]  # Change line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce a dynamic population resizing mechanism based on convergence rate to enhance diversity and solution quality.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {}, "mutation_prompt": null}
{"id": "800d0f9c-92f9-4795-9d61-40a99994dd43", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-np.linalg.norm(global_best_position - cluster_center) / (np.linalg.norm(ub - lb)))\n\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce a dynamic mutation rate scaling based on the distance to the global best position to enhance local exploitation.", "configspace": "", "generation": 58, "fitness": 0.2779694565231613, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2779653977843891, 0.27795733803287026, 0.2779856337522245]}, "mutation_prompt": null}
{"id": "3a2e00d7-f93c-45a4-96fe-aaa846e0b0ec", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:  # Modified line\n                self.population_size = max(10, int(self.population_size * 0.92))  # Modified line\n\n            if evaluations % 50 == 0:  # New line added\n                velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))  # New line added\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce random re-initialization of velocities to boost global search capability occasionally.", "configspace": "", "generation": 59, "fitness": 0.27799073949213954, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.2780044982122335, 0.27803091745794195, 0.2779368028062431]}, "mutation_prompt": null}
{"id": "5c5742b8-aded-41af-a5c8-025951ec430b", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    diversity_factor = np.std(population[:, mutation_dim]) / (ub[mutation_dim] - lb[mutation_dim])  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02)\n                    offspring[i, mutation_dim] += perturbation * (1 + diversity_factor) + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhanced mutation strategy by incorporating diversity measure to boost exploration.", "configspace": "", "generation": 60, "fitness": 0.277986953976514, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.27797785124686347, 0.27800977883591294, 0.2779732318467656]}, "mutation_prompt": null}
{"id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive mutation scaling based on evaluation progress to enhance exploration and convergence.", "configspace": "", "generation": 61, "fitness": 0.27799418607992027, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "8e0fc1da-b4ab-4dee-9695-d901d4e8c41f", "metadata": {"aucs": [0.27798700226136375, 0.2780135960170316, 0.27798195996136554]}, "mutation_prompt": null}
{"id": "35ff4f19-24be-4cae-ad94-38884e7db899", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                learning_factor = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Modified line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) * learning_factor +  # Modified line\n                                 self.social_coef * r2 * (global_best_position - population[i]) * learning_factor)  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance local search by integrating a dynamic learning factor for personal and social components.", "configspace": "", "generation": 62, "fitness": 0.27799331454187065, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2779850579650872, 0.278012496353947, 0.2779823893065778]}, "mutation_prompt": null}
{"id": "8c7e650d-917a-486e-8791-14e9ec450f13", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.3 * np.cos(np.pi * evaluations / self.budget)  # Changed line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.2 + 0.3 * (evaluations / self.budget)  # Changed line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    if np.random.rand() < 0.2:  # Added line\n                        perturbation += np.random.normal(0, 0.1 * (ub[mutation_dim] - lb[mutation_dim]))  # Added line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce time-varying particle swarm inertia and neighborhood search to improve convergence and exploration.", "configspace": "", "generation": 63, "fitness": 0.27626380914042575, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2775785355925423, 0.27358915127810224, 0.27762374055063277]}, "mutation_prompt": null}
{"id": "61a0ea95-4d55-4233-b804-1c18d54973f4", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.6 * (evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by introducing dynamic adjustment to the social coefficient weighting.", "configspace": "", "generation": 64, "fitness": 0.27799361013996976, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.27798389774266974, 0.2780142491180174, 0.2779826835592222]}, "mutation_prompt": null}
{"id": "3a9f6793-55db-4054-a717-bb2a5da36bbb", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]) +\n                                 0.05 * np.random.normal(0, 1, self.dim))  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance diversity by introducing controlled randomization in velocity updates.", "configspace": "", "generation": 65, "fitness": 0.2777890745770747, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2774918709465869, 0.27791691648687433, 0.27795843629776285]}, "mutation_prompt": null}
{"id": "8725229a-0636-4155-b80f-84a4ad3eefd6", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]) +\n                                 0.05 * r2 * (global_best_position - population[i]))  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance the global information sharing by adding a small weight to the global best position in the velocity update.", "configspace": "", "generation": 66, "fitness": 0.2765166612550716, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2779247701858102, 0.27368505033742385, 0.2779401632419808]}, "mutation_prompt": null}
{"id": "228444b5-66df-4afa-9222-0184b2f14b47", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Modified line below for adding randomness\n                random_component = np.random.normal(0, 0.1, self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]) +\n                                 random_component)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:  # Modified line to enhance mutation\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    if np.random.rand() > 0.5:  # Added line to induce more randomness\n                        perturbation *= -1\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Improve exploration by introducing randomness into velocity updates and enhance global diversity via adaptive mutation.", "configspace": "", "generation": 67, "fitness": 0.2777790108797967, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2776567445795952, 0.2778045816652758, 0.2778757063945191]}, "mutation_prompt": null}
{"id": "fa28c10d-ca65-4b37-9b68-f1fed3226e37", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            diversity_factor = np.std(population, axis=0) / (ub - lb)  # New line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocity_scaling = 1 + 0.5 * (1 - diversity_factor.mean())  # New line\n                velocities[i] = (self.inertia_weight * velocities[i] * velocity_scaling +  # Modified line\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce diversity through adaptive velocity scaling based on population convergence to improve exploration.", "configspace": "", "generation": 68, "fitness": 0.277748163003265, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.27770132068149256, 0.2777277260532216, 0.2778154422750808]}, "mutation_prompt": null}
{"id": "7462f1a7-6250-4c37-aaf9-6aac658b709d", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * np.tanh(1 - evaluations / self.budget)  # Modified line\n            self.social_coef = 1.0 + 0.5 * np.tanh(evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:  # Modified line\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce non-linear scaling of cognitive and social coefficients for a more dynamic strategy.", "configspace": "", "generation": 69, "fitness": 0.27799243471990526, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2779746736027481, 0.2780217122276466, 0.27798091832932115]}, "mutation_prompt": null}
{"id": "c14c0976-7611-4bd9-a461-815f361288a2", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            velocity_cap = (ub - lb) * 0.1 * (1 - evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -velocity_cap, velocity_cap)  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce a dynamic velocity cap that scales with evaluation progress to improve convergence stability.", "configspace": "", "generation": 70, "fitness": 0.277821807687264, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.27780893215131586, 0.27790624689148846, 0.2777502440189876]}, "mutation_prompt": null}
{"id": "4b990e05-ca2d-4b30-8413-b9eecf5e5be2", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Chaotic inertia weight\n            self.inertia_weight = 0.5 + 0.4 * np.abs(np.sin(np.pi * evaluations / self.budget))\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            # Dynamically adjust mutation rate\n            self.mutation_rate = 0.1 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce chaotic inertia weight factor and dynamically adjust mutation rate for improved convergence.", "configspace": "", "generation": 71, "fitness": 0.2779650552440429, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2779476275665477, 0.27797917968660935, 0.2779683584789717]}, "mutation_prompt": null}
{"id": "f77cd40e-8c32-4755-bb02-323ccfccc5d5", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            velocity_bound = (ub - lb) * (0.1 + 0.4 * (1 - evaluations / self.budget))  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = np.clip(self.inertia_weight * velocities[i] +  # Modified line\n                                       self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                       self.social_coef * r2 * (global_best_position - population[i]), \n                                       -velocity_bound, velocity_bound)  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92 * (0.5 + evaluations / self.budget)))  # Modified line\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce dynamic population sizing and adaptive velocity bounds for improved convergence and exploration.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 23')", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {}, "mutation_prompt": null}
{"id": "feb91472-5896-4b05-9be1-409084fcde49", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.7 * (evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.95))  # Modified line\n\n            if evaluations % 15 == 0:  # Modified line\n                top_indices = np.argsort(personal_best_scores)[:int(self.population_size * 0.5)]  # Modified line\n                population = np.vstack([offspring[top_indices], global_best_position])  # Modified line\n            else:\n                population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by introducing dynamic population resizing and adaptive social influence adjustments.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 23 is out of bounds for axis 0 with size 23').", "error": "IndexError('index 23 is out of bounds for axis 0 with size 23')", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {}, "mutation_prompt": null}
{"id": "e663281f-8a35-4454-9bbf-34e72b01c3ec", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                improvement_factor = 1 + (personal_best_scores[global_best_index] - personal_best_scores[i]) / (np.abs(personal_best_scores[global_best_index]) + 1e-9)  # Modified line\n                velocities[i] *= improvement_factor  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce velocity scaling based on fitness improvement to enhance convergence.", "configspace": "", "generation": 74, "fitness": 0.2696304622947446, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.01.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2704125102134928, 0.26228534927611313, 0.27619352739462777]}, "mutation_prompt": null}
{"id": "e2e6c117-4491-4050-80b7-4c8f7faa9851", "solution": "# Description: Enhance convergence by adjusting velocity update and personal best strategy, and adding a random restart mechanism.\n# Code:\nimport numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -0.1*(ub-lb), 0.1*(ub-lb))  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                else:  # Modified line\n                    personal_best_positions[i] = np.random.uniform(lb, ub)  # Modified line\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * np.exp(-evaluations / self.budget)\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by adjusting velocity update and personal best strategy, and adding a random restart mechanism.", "configspace": "", "generation": 75, "fitness": 0.272316193526404, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.2727267950183123, 0.27234675820013243, 0.2718750273607673]}, "mutation_prompt": null}
{"id": "3b1953ec-06ba-482e-90b3-1f139ee0349a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5  # Modified line\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by increasing mutation rate variability based on non-linear decay.", "configspace": "", "generation": 76, "fitness": 0.27799455394361355, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "da6917ab-b2c0-446c-a1bf-ebbde3df81d8", "metadata": {"aucs": [0.27798709061890337, 0.2780139647720674, 0.27798260643986983]}, "mutation_prompt": null}
{"id": "c99ef198-20c4-42a5-a6f0-e4bad24e5e40", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    adaptive_scaling = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.01 * np.linalg.norm(velocities[i]))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation + adaptive_scaling  # Modified line\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Refine exploration by adding adaptive random scaling based on current momentum.", "configspace": "", "generation": 77, "fitness": 0.27786743350005966, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3b1953ec-06ba-482e-90b3-1f139ee0349a", "metadata": {"aucs": [0.2777734751713862, 0.2779255248558882, 0.2779033004729047]}, "mutation_prompt": null}
{"id": "fdf9c1ad-5588-40c6-91bf-e33c7a8b2096", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            velocity_scale = 0.5 + 0.5 * (1 - evaluations / self.budget)  # New line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] *= velocity_scale  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introducing adaptive velocity scaling to refine convergence by dynamically adjusting velocity limits.", "configspace": "", "generation": 78, "fitness": 0.2779906691259028, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3b1953ec-06ba-482e-90b3-1f139ee0349a", "metadata": {"aucs": [0.277992286413275, 0.27802151555645593, 0.27795820540797755]}, "mutation_prompt": null}
{"id": "d6b7e1e4-7f84-4e7d-abd1-f912e6e77526", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.15 * (1 - evaluations / self.budget)**0.5  # Modified line\n            self.cross_prob = 0.75 + 0.2 * (1 - evaluations / self.budget)  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (global_best_position[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation  # Modified line\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by introducing adaptive mutation guided by the best solutions.", "configspace": "", "generation": 79, "fitness": 0.2765283212158283, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3b1953ec-06ba-482e-90b3-1f139ee0349a", "metadata": {"aucs": [0.27799307911031423, 0.27798585864198844, 0.27360602589518235]}, "mutation_prompt": null}
{"id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Refine exploration by altering perturbation in mutation to enhance convergence.", "configspace": "", "generation": 80, "fitness": 0.2780035200237928, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "3b1953ec-06ba-482e-90b3-1f139ee0349a", "metadata": {"aucs": [0.2779972464820485, 0.27802648882464354, 0.2779868247646864]}, "mutation_prompt": null}
{"id": "7523cbed-e3ef-4f5c-867d-be43621f369f", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.6 + 0.3 * (1 - evaluations / self.budget)  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance search efficiency by dynamically adjusting particle velocity and crossover strategy.", "configspace": "", "generation": 81, "fitness": 0.2757959065980862, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.277065294215907, 0.277111542144854, 0.27321088343349775]}, "mutation_prompt": null}
{"id": "a5ff1a71-fd02-400d-ba4a-b6c5fe5745b9", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            diversity = np.std(population, axis=0)\n            self.cross_prob = 0.5 + 0.5 * np.exp(-np.linalg.norm(diversity) / (self.dim * 0.1))  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploitation by dynamically adjusting crossover probability based on cluster similarity.", "configspace": "", "generation": 82, "fitness": 0.27793300236111457, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779422307119862, 0.2780025581906689, 0.27785421818068856]}, "mutation_prompt": null}
{"id": "fe3fad11-bdaa-4519-96d4-d22288fdac66", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.5 + 0.5 * (np.std(personal_best_scores) / np.mean(personal_best_scores))  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by dynamically adjusting crossover probability based on population diversity.", "configspace": "", "generation": 83, "fitness": 0.27791686135116656, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27786703348384234, 0.2779987122486406, 0.27788483832101674]}, "mutation_prompt": null}
{"id": "01dfa39a-00ea-485c-a43d-3aacacca3879", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    pert_scale = 0.03 * (ub[mutation_dim] - lb[mutation_dim]) * (1 - evaluations / self.budget)  # Modified line\n                    perturbation = np.random.normal(0, pert_scale)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive mutation scaling to enhance the convergence rate of the algorithm.", "configspace": "", "generation": 84, "fitness": 0.27800175963752977, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779977121709455, 0.27802089932030316, 0.2779866674213407]}, "mutation_prompt": null}
{"id": "e9ed6922-2591-41b1-bc36-e683eb335c4f", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.3 * np.sin(2 * np.pi * evaluations / self.budget)  # Modified line\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Adjust inertia weight dynamics and mutation perturbation for enhanced convergence.", "configspace": "", "generation": 85, "fitness": 0.27797118428066686, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27793838707098917, 0.27801014570827187, 0.2779650200627396]}, "mutation_prompt": null}
{"id": "d8e95a20-9ad9-4224-a9bf-7a1b621c075c", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            diversity = np.mean(np.std(population, axis=0))\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5 * (0.5 + diversity)  # Modified line\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget) * diversity  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by introducing dynamic adjustment of mutation perturbation and crossover probability based on diversity.", "configspace": "", "generation": 86, "fitness": 0.27748257980474345, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27743274723890543, 0.2775504470387562, 0.2774645451365687]}, "mutation_prompt": null}
{"id": "6dfdd5e8-c710-4a2f-b0d0-f53d37e72050", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - np.cos(np.pi * evaluations / self.budget)))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploration by adjusting the perturbation factor in mutation based on a cosine function.", "configspace": "", "generation": 87, "fitness": 0.27798082779929295, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779747152175144, 0.27799972814142415, 0.27796804003894027]}, "mutation_prompt": null}
{"id": "aa2b9ec3-ba79-4b07-a069-4943b6e071a9", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.6 + 0.4 * np.abs(np.sin(np.pi * evaluations / self.budget))  # Modified line\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploitation by adapting crossover probability and mutation based on function landscape curvature.", "configspace": "", "generation": 88, "fitness": 0.27787145294506804, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27785574626369114, 0.2779814805385915, 0.27777713203292154]}, "mutation_prompt": null}
{"id": "177a5fd9-c8a2-4911-bd4e-af0b9de8b46a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.3 * (1 - evaluations / self.budget)  # Modified line\n            self.social_coef = 1.0 + 0.7 * (evaluations / self.budget)  # Modified line\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance the algorithm's convergence by improving exploitation through dynamic cognitive and social coefficients tuning.", "configspace": "", "generation": 89, "fitness": 0.27798412474843737, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779832627595771, 0.2779916672952585, 0.27797744419047654]}, "mutation_prompt": null}
{"id": "ae84b77a-7cec-4472-b166-ccbcd1bf40a1", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance exploitation by introducing adaptive velocity clamping to improve convergence speed.", "configspace": "", "generation": 90, "fitness": 0.2779460378226219, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27798947273137176, 0.2778822960903531, 0.2779663446461408]}, "mutation_prompt": null}
{"id": "69397d3b-577c-4b20-a04f-f60b0634ef32", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                scaling_factor = 1 + 0.01 * np.cos(2 * np.pi * evaluations / self.budget)  # New line\n                population[i] += velocities[i] * scaling_factor  # Modified line\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive scaling of velocity vector to balance exploration and exploitation dynamically.", "configspace": "", "generation": 91, "fitness": 0.27637647334694665, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27367573283379243, 0.27756389485090927, 0.2778897923561382]}, "mutation_prompt": null}
{"id": "ba5322e5-7d75-41cb-b900-8930a531fc3a", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                velocities[i] *= 1.1  # Modified line\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.05)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by dynamically adjusting velocity influence and mutation diversity.", "configspace": "", "generation": 92, "fitness": 0.27650826350820973, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27796413565101996, 0.2737583363504432, 0.27780231852316606]}, "mutation_prompt": null}
{"id": "2fa3bc07-30d2-4695-ab35-22ae78e748b5", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            velocity_scale = 0.1 + 0.9 * (evaluations / self.budget)  # Changed line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = velocity_scale * (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation_scale = np.sqrt(evaluations / self.budget)  # Changed line\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03 * perturbation_scale)  # Changed line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Introduce adaptive velocity scaling and dynamic mutation perturbation to enhance search efficiency.", "configspace": "", "generation": 93, "fitness": 0.27507303238251946, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2718725735049815, 0.2767372802969268, 0.27660924334565007]}, "mutation_prompt": null}
{"id": "750fa866-7a3e-42e5-a805-6732d13cde24", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)  # Modified line\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)  # Modified line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    offspring[i, mutation_dim] += perturbation + cluster_perturbation  # Modified line\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by dynamically adjusting inertia and mutation based on evaluations.", "configspace": "", "generation": 94, "fitness": 0.2779824823477759, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779658513693499, 0.27800888943373636, 0.2779727062402414]}, "mutation_prompt": null}
{"id": "628414ae-9e74-4fe6-a976-7bc643f8fbc6", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    cosine_similarity = np.clip(np.dot(population[i], cluster_center) / (np.linalg.norm(population[i]) * np.linalg.norm(cluster_center)), -1, 1)  # New line\n                    influence_factor = 1 - (np.arccos(cosine_similarity) / np.pi)  # New line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation * influence_factor  # Modified line\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by introducing a dynamic neighborhood influence based on cosine similarity.", "configspace": "", "generation": 95, "fitness": 0.27799993998757794, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2780029332503826, 0.27802097710873497, 0.2779759096036163]}, "mutation_prompt": null}
{"id": "a4e111c8-e46a-440b-b1b7-34279b000a44", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            diversity = np.std(population, axis=0)  # Added line\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, diversity[mutation_dim] * 0.02 * (1 - evaluations / self.budget)) # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by dynamically adjusting mutation amplitude based on diversity.", "configspace": "", "generation": 96, "fitness": 0.27798412031745456, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779892880975027, 0.27800593132459894, 0.2779571415302621]}, "mutation_prompt": null}
{"id": "de0f846f-e42b-4996-91a2-741b1acf09ad", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    distance_factor = np.linalg.norm(global_best_position - population[i]) / np.linalg.norm(ub - lb)  # New line\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * distance_factor)  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by integrating a dynamic mutation scaling factor related to the distance from the global best.", "configspace": "", "generation": 97, "fitness": 0.27798075239238756, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2779862259058975, 0.2779987140867365, 0.27795731718452876]}, "mutation_prompt": null}
{"id": "17aabd9b-f6f8-4836-a8a8-0fcdb35bec18", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.01 * (1 - evaluations / self.budget))  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (global_best_position[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation  # Modified line\n\n            if evaluations % 20 == 0:  # Modified line\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by modifying mutation and selection strategies.", "configspace": "", "generation": 98, "fitness": 0.27798133022659266, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.2780013621255284, 0.2779882333926331, 0.27795439516161646]}, "mutation_prompt": null}
{"id": "e0a04b2f-ec4b-4ee0-813c-f6617a15b9a3", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.6\n        self.cognitive_coef = 1.5\n        self.social_coef = 1.5\n        self.mutation_rate = 0.1\n        self.cross_prob = 0.7\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.array([func(ind) for ind in personal_best_positions])\n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.cognitive_coef = 1.0 + 0.5 * (1 - evaluations / self.budget)\n            self.social_coef = 1.0 + 0.5 * (evaluations / self.budget)\n            cluster_center = np.mean(population, axis=0)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coef * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.social_coef * r2 * (global_best_position - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n\n                score = func(population[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n\n                    if score < personal_best_scores[global_best_index]:\n                        global_best_index = i\n                        global_best_position = personal_best_positions[global_best_index]\n\n            self.mutation_rate = 0.1 * (1 - evaluations / self.budget)**0.5\n            self.cross_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)\n\n            offspring = np.copy(population)\n            for i in range(0, self.population_size, 2):\n                if np.random.rand() < self.cross_prob:\n                    parent1, parent2 = offspring[i], offspring[(i+1) % self.population_size]\n                    cross_point = np.random.randint(1, self.dim)\n                    offspring[i, :cross_point], offspring[(i+1) % self.population_size, :cross_point] = parent2[:cross_point], parent1[:cross_point]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_dim = np.random.randint(self.dim)\n                    perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.03)\n                    cluster_perturbation = np.random.normal(0, (ub[mutation_dim] - lb[mutation_dim]) * 0.02 * (1 - evaluations / self.budget))\n                    diversification_factor = np.random.uniform(-0.1, 0.1) * np.cos(2 * np.pi * evaluations / self.budget)  # Modified line\n                    offspring[i, mutation_dim] += perturbation + (cluster_center[mutation_dim] - population[i, mutation_dim]) * cluster_perturbation + diversification_factor  # Modified line\n\n            if evaluations % 10 == 0:\n                self.population_size = max(10, int(self.population_size * 0.92))\n\n            population = np.vstack([offspring[:self.population_size], global_best_position])\n\n        return global_best_position, personal_best_scores[global_best_index]", "name": "HybridPSOGA", "description": "Enhance convergence by introducing adaptive diversification of population dynamics.", "configspace": "", "generation": 99, "fitness": 0.27790009326738185, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "24b63577-0cb9-4ff4-a86a-97e79f29a31e", "metadata": {"aucs": [0.27786487956257255, 0.27792314262819984, 0.27791225761137317]}, "mutation_prompt": null}
