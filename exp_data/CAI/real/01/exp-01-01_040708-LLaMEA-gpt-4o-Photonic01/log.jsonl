{"id": "053257ba-72c5-4a16-b6dc-92b51222d602", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Evolution crossover for effective global search in high-dimensional spaces.", "configspace": "", "generation": 0, "fitness": 0.25711848950295046, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.25711848950295046, 0.25711848950295046, 0.25711848950295046]}, "mutation_prompt": null}
{"id": "acedb9b2-16b6-46da-8caa-30a9895156e4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            self.w = 0.9 - (0.5 * num_evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced adaptive inertia and crossover rates in HybridPSO_DE for enhanced convergence and exploration balance.", "configspace": "", "generation": 1, "fitness": 0.2556851170197195, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2556851170197195, 0.2556851170197195, 0.2556851170197195]}, "mutation_prompt": null}
{"id": "6748bf9b-bf3b-4cf0-ad17-94a5658ae8f1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.9  # Inertia weight (changed from 0.5 to 0.9 for better exploration early in the process)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.9 - (0.5 * num_evaluations / self.budget)  # Dynamic inertia weight adjustment\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Improved inertia weight adjustment in HybridPSO_DE for better exploration-exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.2557034761087672, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2557034761087672, 0.2557034761087672, 0.2557034761087672]}, "mutation_prompt": null}
{"id": "477be649-ee14-46fa-bc86-f93f46f3505a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w_max = 0.9  # Max inertia weight\n        self.w_min = 0.4  # Min inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            w = self.w_max - ((self.w_max - self.w_min) * num_evaluations / self.budget)\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight for improved exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.2557026036233724, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2557026036233724, 0.2557026036233724, 0.2557026036233724]}, "mutation_prompt": null}
{"id": "1c679324-6b0d-48b3-ad00-42819f61d70b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w_max = 0.9  # Adaptive inertia weight max\n        self.w_min = 0.4  # Adaptive inertia weight min\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * num_evaluations / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with Adaptive Inertia Weight for Better Exploration-Exploitation Trade-off.", "configspace": "", "generation": 4, "fitness": 0.2556851170197195, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2556851170197195, 0.2556851170197195, 0.2556851170197195]}, "mutation_prompt": null}
{"id": "07dbad88-f56a-4500-a3d1-c90d52112bbf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Adjust inertia weight dynamically\n                self.w = 0.9 - 0.4 * (num_evaluations / self.budget)\n\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    \n                    # Adjust mutation factor dynamically\n                    self.f = 0.8 * (1 - num_evaluations / self.budget) + 0.2\n\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced dynamic adjustment of the inertia weight and mutation factor to enhance convergence and exploration balance.", "configspace": "", "generation": 5, "fitness": 0.2556928197819477, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2556928197819477, 0.2556928197819477, 0.2556928197819477]}, "mutation_prompt": null}
{"id": "4c0070e9-da1b-4d1d-acb7-8e5b1c38cd2e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # New line 1\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i]) +\n                    random_perturbation  # New line 2\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Incorporate random perturbations in PSO velocity update to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 6, "fitness": 0.25329049290281314, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.25329049290281314, 0.25329049290281314, 0.25329049290281314]}, "mutation_prompt": null}
{"id": "47e414ea-e06b-492e-aec1-014f208dea0d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            self.w = 0.4 + 0.5 * (1 - num_evaluations / self.budget)  # Adjust inertia weight dynamically\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE by adjusting the inertia weight dynamically to improve convergence speed and solution quality.", "configspace": "", "generation": 7, "fitness": 0.2556851170197195, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2556851170197195, 0.2556851170197195, 0.2556851170197195]}, "mutation_prompt": null}
{"id": "d0b43552-de43-450c-8320-fc3292104bc2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.9  # Changed Inertia weight to start with a higher value\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.9 - 0.9 * (num_evaluations / self.budget)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhanced velocity update with adaptive inertia for improved convergence in HybridPSO_DE.", "configspace": "", "generation": 8, "fitness": 0.255745839935029, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.255745839935029, 0.255745839935029, 0.255745839935029]}, "mutation_prompt": null}
{"id": "70ae5c96-c490-4c1a-98bd-01d3a70ece3f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.9  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            self.w = 0.9 - (0.9 - 0.4) * (num_evaluations / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + self.f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE with adaptive inertia weight for improved convergence rate.", "configspace": "", "generation": 9, "fitness": 0.2557026036233724, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2557026036233724, 0.2557026036233724, 0.2557026036233724]}, "mutation_prompt": null}
{"id": "443ecd46-18f5-41f9-8d5a-acf85d8738e5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (num_evaluations / self.budget)  # Dynamic mutation factor\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])  # Updated mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic mutation factor in the DE component to adaptively balance exploration and exploitation during the optimization process.", "configspace": "", "generation": 10, "fitness": 0.2614012098822768, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "053257ba-72c5-4a16-b6dc-92b51222d602", "metadata": {"aucs": [0.2614012098822768, 0.2614012098822768, 0.2614012098822768]}, "mutation_prompt": null}
{"id": "cd1c714c-87a5-42ab-9bb7-ab54693482df", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.5 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.5 * adapt_factor  # Modify social component\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (num_evaluations / self.budget)  # Dynamic mutation factor\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])  # Updated mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance the local search by introducing a self-adaptive parameter to adjust the cognitive and social components dynamically.", "configspace": "", "generation": 11, "fitness": 0.2769316991651274, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "443ecd46-18f5-41f9-8d5a-acf85d8738e5", "metadata": {"aucs": [0.2769316991651274, 0.2769316991651274, 0.2769316991651274]}, "mutation_prompt": null}
{"id": "69d729f7-90b4-4d3c-b519-10216c75192c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            self.w = 0.5 + 0.4 * adapt_factor  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.5 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.5 * adapt_factor  # Modify social component\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (num_evaluations / self.budget)  # Dynamic mutation factor\n                    self.cr = 0.9 - 0.4 * adapt_factor  # Adaptive crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])  # Updated mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:  # Adaptive crossover probability\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce an adaptive inertia weight and adjust DE crossover probability for enhanced exploration and exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.2656748983641668, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "cd1c714c-87a5-42ab-9bb7-ab54693482df", "metadata": {"aucs": [0.2656748983641668, 0.2656748983641668, 0.2656748983641668]}, "mutation_prompt": null}
{"id": "1c01f827-39c0-4c73-ba0a-392b47b564b6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.5 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.5 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (num_evaluations / self.budget)  # Dynamic mutation factor\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])  # Updated mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight to balance exploration and exploitation dynamically.", "configspace": "", "generation": 13, "fitness": 0.27739648466752864, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "cd1c714c-87a5-42ab-9bb7-ab54693482df", "metadata": {"aucs": [0.27739648466752864, 0.27739648466752864, 0.27739648466752864]}, "mutation_prompt": null}
{"id": "f3dc376c-9527-4b0a-bc8a-05d9573ab85f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (num_evaluations / self.budget)  # Dynamic mutation factor\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])  # Updated mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic learning factor to enhance convergence through improved diversity and adaptability.", "configspace": "", "generation": 14, "fitness": 0.27740420746392147, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "1c01f827-39c0-4c73-ba0a-392b47b564b6", "metadata": {"aucs": [0.27740420746392147, 0.27740420746392147, 0.27740420746392147]}, "mutation_prompt": null}
{"id": "520309b7-a665-46f8-b846-721e65879091", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploration by incorporating a stochastic component in DE mutation and adjusting crossover probability dynamically with evaluations.", "configspace": "", "generation": 15, "fitness": 0.27787554775858236, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "f3dc376c-9527-4b0a-bc8a-05d9573ab85f", "metadata": {"aucs": [0.27787554775858236, 0.27787554775858236, 0.27787554775858236]}, "mutation_prompt": null}
{"id": "3d46a143-c23e-4b66-8044-fa5c31b09943", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (1 - adapt_factor ** 2)  # Non-linear stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Incorporate a non-linear adaptive mutation factor for better exploration and convergence.", "configspace": "", "generation": 16, "fitness": 0.2772652707506421, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "520309b7-a665-46f8-b846-721e65879091", "metadata": {"aucs": [0.2772652707506421, 0.2772652707506421, 0.2772652707506421]}, "mutation_prompt": null}
{"id": "9b65e16c-fb01-44f5-8c77-b95abab32144", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor)  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.4 + 0.5 * (1 - adapt_factor)  # Adaptive mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n            \n            # Elite retention step\n            elite_indices = np.argsort(personal_best_fitness)[:2]  # Select top 2 elites\n            swarm_position[-2:] = personal_best_position[elite_indices]\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance convergence by introducing an adaptive mutation factor and incorporating elite retention to maintain diversity.", "configspace": "", "generation": 17, "fitness": 0.2778381949517027, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "520309b7-a665-46f8-b846-721e65879091", "metadata": {"aucs": [0.2778381949517027, 0.2778381949517027, 0.2778381949517027]}, "mutation_prompt": null}
{"id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce nonlinear weight adjustment for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.27787877222347823, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "520309b7-a665-46f8-b846-721e65879091", "metadata": {"aucs": [0.27787877222347823, 0.27787877222347823, 0.27787877222347823]}, "mutation_prompt": null}
{"id": "85ec575a-b5d8-42c7-b429-cc6972bd2432", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.7 + 0.3 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Refine the balance between exploration and exploitation by adjusting mutation factor.", "configspace": "", "generation": 19, "fitness": 0.2777652890719071, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2777652890719071, 0.2777652890719071, 0.2777652890719071]}, "mutation_prompt": null}
{"id": "446d30c3-d114-4d11-933c-7625bc80649d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n            self.population_size = int(40 * (0.5 + 0.5 * (num_evaluations / self.budget)))  # Dynamic population size adjustment\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic population size adjustment to enhance convergence speed.", "configspace": "", "generation": 20, "fitness": 0.2775714326881439, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2775714326881439, 0.2775714326881439, 0.2775714326881439]}, "mutation_prompt": null}
{"id": "8aef4a0f-9426-4102-bfed-1284e35d27ab", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                if num_evaluations % (self.budget // 10) == 0:  # Maintain diversity\n                    swarm_velocity[i] += 0.1 * np.random.uniform(-1, 1, self.dim)\n\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Integrate diversity preservation mechanism to enhance exploration in the hybrid optimization strategy.", "configspace": "", "generation": 21, "fitness": 0.27787877222347823, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787877222347823, 0.27787877222347823, 0.27787877222347823]}, "mutation_prompt": null}
{"id": "f0b9c930-4ffa-4b19-b440-44d8da8db52b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.3 + 0.7 * (1 - adapt_factor**2)  # Nonlinear inertia weight adjustment\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce dynamic adjustment of inertia weight to further improve convergence balancing exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.27016884877427316, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27016884877427316, 0.27016884877427316, 0.27016884877427316]}, "mutation_prompt": null}
{"id": "59fd2356-00ef-4f99-9b51-f43657a9eb7b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            dynamic_population_size = int(self.population_size * (0.5 + 0.5 * (num_evaluations / self.budget)))  # Adjust population size dynamically\n            for i in range(dynamic_population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(dynamic_population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(dynamic_population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce dynamic population size to balance exploration and exploitation over iterations.", "configspace": "", "generation": 23, "fitness": 0.27332808303492706, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27332808303492706, 0.27332808303492706, 0.27332808303492706]}, "mutation_prompt": null}
{"id": "625c0341-0d64-44ed-92e4-50388eff36ea", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**3)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic scaling factor for the inertia weight to improve convergence.", "configspace": "", "generation": 24, "fitness": 0.2778614498495079, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778614498495079, 0.2778614498495079, 0.2778614498495079]}, "mutation_prompt": null}
{"id": "d9c57e05-bcd9-4b75-8e6a-869474dc56ad", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand() * np.cos(num_evaluations / self.budget * np.pi / 2)  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Incorporate a small nonlinear adjustment to the DE mutation factor for improved diversity.", "configspace": "", "generation": 25, "fitness": 0.27787808274709513, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787808274709513, 0.27787808274709513, 0.27787808274709513]}, "mutation_prompt": null}
{"id": "2d0208dc-4990-493e-b631-f5d9d5993069", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce nonlinear weight adjustment for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787877222347823, 0.27787877222347823, 0.27787877222347823]}, "mutation_prompt": null}
{"id": "830919c1-d282-4961-9801-c995be542e3f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor * np.random.rand()  # Stochastic cognitive scaling\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce stochastic cognitive scaling to further refine the balance between exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.2771437334285328, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2771437334285328, 0.2771437334285328, 0.2771437334285328]}, "mutation_prompt": null}
{"id": "db7a624a-c81c-40ff-86ce-a785942908f1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.4 + 0.6 * np.random.rand()  # Stochastic mutation factor adjusted\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic adjustment to the DE mutation factor to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.2777375421853433, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2777375421853433, 0.2777375421853433, 0.2777375421853433]}, "mutation_prompt": null}
{"id": "2371afc9-87e8-4646-b12d-b88cc36174cf", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * ((1 + adapt_factor) * (self.best_global_position - swarm_position[i]))  # Change here\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploration by increasing the dimension-based randomness factor in PSO velocity update.", "configspace": "", "generation": 29, "fitness": 0.24700137262891753, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.24700137262891753, 0.24700137262891753, 0.24700137262891753]}, "mutation_prompt": null}
{"id": "24b21c6b-dfda-42c4-a3e9-c644d1df3dfc", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor * (ub - lb).sum()  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce an adaptive cognitive component scaling based on search space size to enhance exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.2670358432595876, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2670358432595876, 0.2670358432595876, 0.2670358432595876]}, "mutation_prompt": null}
{"id": "3cbdb24e-6246-4b2e-b266-d4832a8f5ec8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = adapt_factor * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive dynamic mutation factor to enhance exploration capabilities.", "configspace": "", "generation": 31, "fitness": 0.2773089272072813, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2773089272072813, 0.2773089272072813, 0.2773089272072813]}, "mutation_prompt": null}
{"id": "3d5d1bab-f87f-466e-94b0-55407bf1da32", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n            self.population_size = max(20, int(40 * (1 - adapt_factor)))  # Dynamically adjust population size\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic population size adjustment to adapt exploration and exploitation phases.", "configspace": "", "generation": 32, "fitness": 0.277878714433635, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.277878714433635, 0.277878714433635, 0.277878714433635]}, "mutation_prompt": null}
{"id": "4f03d81e-7ec8-4470-ac19-f13677bbd978", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.3 + 0.7 * np.random.rand()  # Adjusted mutation factor range for diversity\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation factor for enhanced diversity and convergence.", "configspace": "", "generation": 33, "fitness": 0.27689921876928303, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27689921876928303, 0.27689921876928303, 0.27689921876928303]}, "mutation_prompt": null}
{"id": "9fe36b78-eb21-4eb0-ae19-d17658f74952", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce nonlinear weight adjustment for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787877222347823, 0.27787877222347823, 0.27787877222347823]}, "mutation_prompt": null}
{"id": "181e5505-8565-45be-abc0-e7792e9150e3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.2 + 0.8 * (adapt_factor**2)  # Nonlinear inertia weight with faster decay\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight decay for improved convergence speed.", "configspace": "", "generation": 35, "fitness": 0.2663316594157471, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2663316594157471, 0.2663316594157471, 0.2663316594157471]}, "mutation_prompt": null}
{"id": "6d8c9a35-df7e-4d2c-97eb-84af2a99ede0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor**2  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a nonlinear cognitive component adjustment for improved solution convergence.", "configspace": "", "generation": 36, "fitness": 0.2778669251495287, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778669251495287, 0.2778669251495287, 0.2778669251495287]}, "mutation_prompt": null}
{"id": "77b22ed8-150b-40dd-bd0f-5826418c1fc0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**3)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Fine-tune the inertia weight formula for improved exploitation in late stages.", "configspace": "", "generation": 37, "fitness": 0.2778614498495079, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778614498495079, 0.2778614498495079, 0.2778614498495079]}, "mutation_prompt": null}
{"id": "708f659c-b355-46fe-9672-142b45a72e5b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            stochastic_exploration = np.random.rand() * adapt_factor  # New stochastic exploration factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i]) +\n                    stochastic_exploration * (np.random.uniform(lb, ub, self.dim) - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a stochastic exploration factor to enhance global search capability.", "configspace": "", "generation": 38, "fitness": 0.2577217245409019, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2577217245409019, 0.2577217245409019, 0.2577217245409019]}, "mutation_prompt": null}
{"id": "f87bbacf-859d-43a3-abf0-0c2289b561fe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = (1 - num_evaluations / self.budget)**2  # Adjusted adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce nonlinear weight adjustment for enhanced balance between exploration and exploitation, with improved adaptive factor calculation.", "configspace": "", "generation": 39, "fitness": 0.2778476875251342, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778476875251342, 0.2778476875251342, 0.2778476875251342]}, "mutation_prompt": null}
{"id": "13977ab4-ab1c-41c1-b03b-93efb8ff209c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.5 * (1 - adapt_factor**2)  # Fine-tuned nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Fine-tune the inertia weight function for enhanced convergence control.", "configspace": "", "generation": 40, "fitness": 0.2778503864169911, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778503864169911, 0.2778503864169911, 0.2778503864169911]}, "mutation_prompt": null}
{"id": "ad01850f-15f0-4204-9545-bc63ff396c56", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 41  # Increased population size for better exploration\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Increase the population size for broader exploration capabilities.", "configspace": "", "generation": 41, "fitness": 0.266665586906188, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.266665586906188, 0.266665586906188, 0.266665586906188]}, "mutation_prompt": null}
{"id": "1e180d52-b3d1-4b04-9c35-eee329011d30", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.6 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the stochastic mutation factor range to enhance exploration.", "configspace": "", "generation": 42, "fitness": 0.2706555468135601, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2706555468135601, 0.2706555468135601, 0.2706555468135601]}, "mutation_prompt": null}
{"id": "a610269c-bd17-4bf1-af43-5bdc420b3ab5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.3 + 0.7 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance the balance between exploration and exploitation by adjusting the mutation factor range in Differential Evolution.", "configspace": "", "generation": 43, "fitness": 0.27689921876928303, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27689921876928303, 0.27689921876928303, 0.27689921876928303]}, "mutation_prompt": null}
{"id": "41a275ed-78e6-44d1-a74e-ade15fff1c5e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                # Apply dynamic speed clamping\n                max_velocity = (ub - lb) * adapt_factor\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -max_velocity, max_velocity)\n                \n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive particle speed clamping for dynamic control of exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.27787877222347823, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787877222347823, 0.27787877222347823, 0.27787877222347823]}, "mutation_prompt": null}
{"id": "dfa83a49-111c-4783-810e-4ea039d6665c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.5 + 0.5 * (1 - adapt_factor**3)  # Nonlinear inertia weight with smoothing\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce dynamic inertia weight smoothing to enhance convergence stability.", "configspace": "", "generation": 45, "fitness": 0.2695267612527079, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2695267612527079, 0.2695267612527079, 0.2695267612527079]}, "mutation_prompt": null}
{"id": "2ca379a4-a094-492f-a19f-16d066ac24f5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            self.population_size = int(40 + 10 * adapt_factor)  # Adaptive population size scaling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive population size scaling to enhance solution diversity over iterations.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {}, "mutation_prompt": null}
{"id": "bb8b7d89-db3f-4e1c-afd3-e06299932b2d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                learning_rate = 0.1 * adapt_factor  # Added learning rate decay\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                ) * learning_rate\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Incorporate learning rate decay to improve diversity and convergence rate.", "configspace": "", "generation": 47, "fitness": 0.2720693128012477, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2720693128012477, 0.2720693128012477, 0.2720693128012477]}, "mutation_prompt": null}
{"id": "07dc54d0-9066-4826-b47a-5d5221b6c8c8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.3 * (1 - adapt_factor**2)  # Nonlinear inertia weight decay\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight decay for enhanced fine-tuning in exploitation phase.", "configspace": "", "generation": 48, "fitness": 0.27787357476368246, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.27787357476368246, 0.27787357476368246, 0.27787357476368246]}, "mutation_prompt": null}
{"id": "5b09d6a9-02cc-4966-bd75-7207548ecfea", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.8 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Utilize an adaptive cognitive component to dynamically adjust exploration and exploitation across evaluations.", "configspace": "", "generation": 49, "fitness": 0.2776488506863618, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2776488506863618, 0.2776488506863618, 0.2776488506863618]}, "mutation_prompt": null}
{"id": "142696a5-a133-4e41-a0f5-510408677084", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            self.population_size = int(40 + 10 * (1 - adapt_factor))  # Dynamic adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic population size adjustment for improved convergence throughout the optimization process.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 40 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 40 is out of bounds for axis 0 with size 40')", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {}, "mutation_prompt": null}
{"id": "c4b07505-850a-491b-be00-71b7310a3f2b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Starting number of particles\n        self.population_size = self.initial_population_size\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            # Dynamically adjust population size based on evaluations\n            self.population_size = self.initial_population_size - int(self.initial_population_size * (num_evaluations / self.budget))\n            \n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce dynamic population size to improve adaptability based on convergence progress.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {}, "mutation_prompt": null}
{"id": "1f06f947-e910-4bc6-8add-f4d9baa6178a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * adapt_factor  # Adaptive mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness and np.random.rand() < 0.5:  # Enhanced DE trial selection\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation factor and enhanced DE trial selection for improved exploration.", "configspace": "", "generation": 52, "fitness": 0.2775952100032336, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2775952100032336, 0.2775952100032336, 0.2775952100032336]}, "mutation_prompt": null}
{"id": "23b22b3a-764a-4c56-8cda-93b5de45b294", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        velocity_clamp = (ub - lb) * 0.1  # New: Adaptive velocity clamping factor\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget\n            if num_evaluations % (self.budget // 5) == 0:  # New: Dynamic regrouping\n                swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor\n                self.c2 = 1.5 - 0.7 * adapt_factor\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                # New: Apply velocity clamping\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -velocity_clamp, velocity_clamp)\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity clamping and dynamic swarm regrouping for improved diversity and convergence.", "configspace": "", "generation": 53, "fitness": 0.277665452363267, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.277665452363267, 0.277665452363267, 0.277665452363267]}, "mutation_prompt": null}
{"id": "151efd13-07b3-46c3-af6e-90b9377ab6c2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            self.population_size = int(40 - adapt_factor * 20)  # Adaptive population size\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive population size adjustment for better resource allocation.", "configspace": "", "generation": 54, "fitness": 0.2767067411681411, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2767067411681411, 0.2767067411681411, 0.2767067411681411]}, "mutation_prompt": null}
{"id": "3adab8fc-320b-49d6-8944-fd0f98101d55", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            self.population_size = int(40 * (1 - adapt_factor**2)) + 1  # Dynamic population size adjustment\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic population size adjustment to improve exploration in early iterations and exploitation in later iterations.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' cannot be empty unless no samples are taken\").", "error": "ValueError(\"'a' cannot be empty unless no samples are taken\")", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {}, "mutation_prompt": null}
{"id": "4226ef96-2ef1-4e28-b6d7-51541bc847be", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 40  # Initial number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        dynamic_population_size = self.initial_population_size\n        swarm_position = np.random.uniform(lb, ub, (dynamic_population_size, self.dim))\n        swarm_velocity = np.zeros((dynamic_population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(dynamic_population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(dynamic_population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget\n            for i in range(dynamic_population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor\n                self.c2 = 1.5 - 0.7 * adapt_factor\n                self.w = 0.4 + 0.6 * (1 - adapt_factor**2)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)\n                    indices = list(range(dynamic_population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n            # Adaptive population size\n            dynamic_population_size = max(20, int(self.initial_population_size * (1 - num_evaluations / self.budget)))\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive population size for improved resource allocation and optimization efficiency.", "configspace": "", "generation": 56, "fitness": 0.26611592583527244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.26611592583527244, 0.26611592583527244, 0.26611592583527244]}, "mutation_prompt": null}
{"id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the inertia weight's nonlinear factor to enhance exploration in early stages.", "configspace": "", "generation": 57, "fitness": 0.2778799486756668, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "b21b47e7-c905-44e3-ba0b-06dc56fe23cf", "metadata": {"aucs": [0.2778799486756668, 0.2778799486756668, 0.2778799486756668]}, "mutation_prompt": null}
{"id": "9b74e41c-03fa-4a13-99ad-9a008fec2eb2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.6 + 0.5 * np.random.rand()  # Slight increase in mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploitation by slightly increasing the DE mutation factor.", "configspace": "", "generation": 58, "fitness": 0.27065350744451966, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27065350744451966, 0.27065350744451966, 0.27065350744451966]}, "mutation_prompt": null}
{"id": "fea85a52-ceb9-463a-9cdb-3df3f2e0edf9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 42  # Number of particles increased from 40 to 42\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Strengthen the exploration by increasing the population size to improve global search.", "configspace": "", "generation": 59, "fitness": 0.2568532596515236, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2568532596515236, 0.2568532596515236, 0.2568532596515236]}, "mutation_prompt": null}
{"id": "3dec8149-3a7c-4db7-94f2-ed072cd578bd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                distance_to_best = np.linalg.norm(swarm_position[i] - self.best_global_position)\n                self.w = 0.4 + 0.5 * (1 - adapt_factor**2) * (1 - distance_to_best / np.linalg.norm(ub - lb))  # Adaptive inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight based on distance to the global best to balance exploration and exploitation dynamically.", "configspace": "", "generation": 60, "fitness": 0.277877116607398, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.277877116607398, 0.277877116607398, 0.277877116607398]}, "mutation_prompt": null}
{"id": "b150ab7d-1723-4b41-9572-2c08f06fa35d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.6 + 0.45 * (1 - adapt_factor**2)  # Adjusted nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Shifted the inertia weight dynamic scaling to focus more on exploration at the start and transition smoothly to exploitation.", "configspace": "", "generation": 61, "fitness": 0.2678455363984201, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2678455363984201, 0.2678455363984201, 0.2678455363984201]}, "mutation_prompt": null}
{"id": "daf47f2b-f984-4240-84ba-af2d1cc0ab92", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.3 + 0.7 * adapt_factor  # Linear adjustment for DE mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced a linear adjustment for the DE mutation factor to enhance local exploitation towards the end of the budget.", "configspace": "", "generation": 62, "fitness": 0.2685460196953332, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2685460196953332, 0.2685460196953332, 0.2685460196953332]}, "mutation_prompt": null}
{"id": "7055913c-1e4f-4861-a580-3f654da4f647", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + (0.5 * np.sin(num_evaluations / self.budget * np.pi))  # Adaptive mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive mutation factor for DE to enhance diversification and convergence.", "configspace": "", "generation": 63, "fitness": 0.26731865994033255, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26731865994033255, 0.26731865994033255, 0.26731865994033255]}, "mutation_prompt": null}
{"id": "b0a89fd2-a844-4ce3-9117-1d9c4d15d051", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n        self.velocity_clamp = 0.1  # Max velocity clamp factor\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                # Apply velocity clamping\n                swarm_velocity[i] = np.clip(swarm_velocity[i], -self.velocity_clamp, self.velocity_clamp)\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Integrate adaptive velocity clamping to prevent runaway particles and bolster convergence stability.", "configspace": "", "generation": 64, "fitness": 0.25800436422954676, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.25800436422954676, 0.25800436422954676, 0.25800436422954676]}, "mutation_prompt": null}
{"id": "c21e5dbe-ad32-47a8-8364-6830209fa999", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.6  # Adjusted cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.6 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly adjust the cognitive component to balance exploration and exploitation better.", "configspace": "", "generation": 65, "fitness": 0.27776853716394634, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27776853716394634, 0.27776853716394634, 0.27776853716394634]}, "mutation_prompt": null}
{"id": "528598a0-4fe8-4be4-8f03-2e27f13afda3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.6 + 0.4 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced an adaptive mutation factor in DE based on evaluations to enhance diversity.", "configspace": "", "generation": 66, "fitness": 0.2723422788762314, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2723422788762314, 0.2723422788762314, 0.2723422788762314]}, "mutation_prompt": null}
{"id": "000553d1-7b18-4ba2-896f-0bf7a5c8972b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * adapt_factor  # Adaptive mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced adaptive mutation factor based on evaluations to enhance exploration-exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.27729934055327543, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27729934055327543, 0.27729934055327543, 0.27729934055327543]}, "mutation_prompt": null}
{"id": "926159f1-64e4-4673-82d5-585c9da95909", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] * (0.5 + 0.5 * np.random.rand()) +  # Deceleration mechanism\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.7 + 0.3 * np.random.rand()  # Updated dynamic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploration by making the mutation factor dynamic and introducing a velocity deceleration mechanism.", "configspace": "", "generation": 68, "fitness": 0.2770191410862066, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2770191410862066, 0.2770191410862066, 0.2770191410862066]}, "mutation_prompt": null}
{"id": "bd182c0f-9879-479c-bd7b-e97db1cddb97", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 42  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Adjusted the initial population size to enhance the diversity in the search process.", "configspace": "", "generation": 69, "fitness": 0.2568532596515236, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2568532596515236, 0.2568532596515236, 0.2568532596515236]}, "mutation_prompt": null}
{"id": "e4f2f7b3-65c2-4a09-bf9a-1900de98a5fe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 42  # Number of particles (changed from 40 to 42)\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly adjust the initial population size to improve exploration and diversity in early stages.", "configspace": "", "generation": 70, "fitness": 0.2568532596515236, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2568532596515236, 0.2568532596515236, 0.2568532596515236]}, "mutation_prompt": null}
{"id": "33de1692-0b0c-4df9-afdb-3d03041b99fb", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2.1)  # Slightly adjusted nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Fine-tune the inertia weight's nonlinear factor to slightly enhance stability and performance in solution convergence.", "configspace": "", "generation": 71, "fitness": 0.2778647033609375, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2778647033609375, 0.2778647033609375, 0.2778647033609375]}, "mutation_prompt": null}
{"id": "350d4f87-7fc2-499e-be2d-83a3bac34e4d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                perturbation = np.random.uniform(-0.01, 0.01, self.dim)  # Introduce perturbation\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i]) + \n                    perturbation  # Apply perturbation\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce slight random perturbations to swarm positions during velocity updates to enhance exploration.", "configspace": "", "generation": 72, "fitness": 0.27569476851628083, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27569476851628083, 0.27569476851628083, 0.27569476851628083]}, "mutation_prompt": null}
{"id": "47b64b28-0425-482e-9990-0d79b42cea11", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 41  # Number of particles increased by 1\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the population size for enhanced exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.26726662120744404, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26726662120744404, 0.26726662120744404, 0.26726662120744404]}, "mutation_prompt": null}
{"id": "4d6f3074-4aaf-45a0-bc24-f6ced0e780a5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i]) +\n                    np.random.uniform(-0.1, 0.1, self.dim) * adapt_factor  # Decaying random component\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a decaying random velocity component to enhance exploration and convergence.", "configspace": "", "generation": 74, "fitness": 0.2772287890139217, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2772287890139217, 0.2772287890139217, 0.2772287890139217]}, "mutation_prompt": null}
{"id": "630fde37-1489-4cb4-9fbf-c6ee790df5a2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 41  # Slightly increased number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Increase the population size slightly to enhance diversity in the search space.", "configspace": "", "generation": 75, "fitness": 0.26726662120744404, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26726662120744404, 0.26726662120744404, 0.26726662120744404]}, "mutation_prompt": null}
{"id": "951f3afa-1a74-4257-aaa5-36bb3176fb82", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.85 + 0.25 * (1 - adapt_factor)  # Slightly increased dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the DE crossover probability dynamically to explore the search space more effectively in later stages.", "configspace": "", "generation": 76, "fitness": 0.27065350744451966, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27065350744451966, 0.27065350744451966, 0.27065350744451966]}, "mutation_prompt": null}
{"id": "fb4963c8-fe2f-4086-91b4-8ed79534e03b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.6  # Cognitive component adjusted\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly adjust the initial cognitive component to enhance early exploration balance.", "configspace": "", "generation": 77, "fitness": 0.2778799486756668, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2778799486756668, 0.2778799486756668, 0.2778799486756668]}, "mutation_prompt": null}
{"id": "31f4d94f-6da1-4406-a790-ae1718364406", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n            self.population_size = min(40, int(20 + 20 * adapt_factor))  # Dynamic population size adjustment\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploration by dynamically adjusting the population size based on evaluations.", "configspace": "", "generation": 78, "fitness": 0.26611592583527244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26611592583527244, 0.26611592583527244, 0.26611592583527244]}, "mutation_prompt": null}
{"id": "5c59d5fb-fffa-4c57-84c5-11b4a39f706b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            diversity = np.std(swarm_position, axis=0).mean()  # Calculate swarm diversity\n            adapt_factor = 1 - num_evaluations / self.budget\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor\n                self.c2 = 1.5 - 0.7 * adapt_factor\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * diversity  # Use swarm diversity for mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - diversity)  # Use diversity for crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive scaling of mutation factor and crossover probability based on swarm diversity to enhance convergence speed.", "configspace": "", "generation": 79, "fitness": 0.2772520158157682, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2772520158157682, 0.2772520158157682, 0.2772520158157682]}, "mutation_prompt": null}
{"id": "8abc88b1-ba0e-4e88-a7b7-4e4a960a83f9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    diversity = np.std(personal_best_fitness) / self.best_global_fitness  # Calculate fitness diversity\n                    dynamic_f = 0.5 + 0.5 * np.random.rand() * diversity  # Dynamic mutation factor based on diversity\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive DE mutation factor based on fitness diversity to enhance convergence.", "configspace": "", "generation": 80, "fitness": 0.27364224968112827, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27364224968112827, 0.27364224968112827, 0.27364224968112827]}, "mutation_prompt": null}
{"id": "300d3791-f9ea-4392-8913-b7e5b49dd4b8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.6 + 0.4 * np.random.rand()  # Stochastic mutation factor with slight adjustment\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a dynamic adjustment to the Differential Evolution mutation factor to better balance exploration and exploitation.", "configspace": "", "generation": 81, "fitness": 0.2723422788762314, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2723422788762314, 0.2723422788762314, 0.2723422788762314]}, "mutation_prompt": null}
{"id": "5e8aea0d-915f-43f1-bd3f-d7b3281f1cb9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        midpoint = (lb + ub) / 2  # Midpoint of bounds\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = midpoint + dynamic_f * (swarm_position[a] - swarm_position[b])  # Reflect mutation\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced adaptive boundaries using midpoint reflection to enhance exploration and prevent stagnation.", "configspace": "", "generation": 82, "fitness": 0.27755952417630503, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27755952417630503, 0.27755952417630503, 0.27755952417630503]}, "mutation_prompt": null}
{"id": "a7a09a19-f69b-47e1-a42d-b2e22dfd3967", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2) + 0.05 * np.random.rand()  # Nonlinear inertia weight with added randomness\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Add randomness to the inertia weight to enhance exploration.", "configspace": "", "generation": 83, "fitness": 0.2628130538450053, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2628130538450053, 0.2628130538450053, 0.2628130538450053]}, "mutation_prompt": null}
{"id": "3b03e1e6-4420-4a2e-ae80-15c7b7c3e7b5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 + 0.3 * (1 - adapt_factor)  # Adaptive adjustment to social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce an adaptive adjustment to the social component to better balance exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.24927669375239225, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.24927669375239225, 0.24927669375239225, 0.24927669375239225]}, "mutation_prompt": null}
{"id": "494af694-b11c-443c-b1e2-2a64333b089f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.7 + 0.3 * (1 - adapt_factor)  # Adjusted dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Adjusted the dynamic crossover probability to improve diversity and exploration.", "configspace": "", "generation": 85, "fitness": 0.27074148578217594, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27074148578217594, 0.27074148578217594, 0.27074148578217594]}, "mutation_prompt": null}
{"id": "4147144f-24f8-4f54-ba86-38a0b9876aa3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2) + 0.02 * np.random.rand()  # Nonlinear inertia weight with random factor\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced a small random factor to the inertia weight update to enhance stochastic exploration.", "configspace": "", "generation": 86, "fitness": 0.26282880371449524, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26282880371449524, 0.26282880371449524, 0.26282880371449524]}, "mutation_prompt": null}
{"id": "5e776bea-71e0-435d-a9a3-f06e77716c21", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                velocity_scaling = 1.0 + adapt_factor  # Dynamic velocity scaling\n                swarm_velocity[i] = velocity_scaling * (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce dynamic velocity scaling to balance exploration and exploitation phases in the swarm.", "configspace": "", "generation": 87, "fitness": 0.25159202521176993, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.25159202521176993, 0.25159202521176993, 0.25159202521176993]}, "mutation_prompt": null}
{"id": "a14158e1-2edb-4e7a-84a3-a1d3fa30fce2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (1 - adapt_factor**2) * np.random.rand()  # Slight nonlinear enhancement\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce a slight nonlinear enhancement to the stochastic mutation factor to improve diversity.", "configspace": "", "generation": 88, "fitness": 0.27755741155544433, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27755741155544433, 0.27755741155544433, 0.27755741155544433]}, "mutation_prompt": null}
{"id": "6b4e5801-4e5f-492f-af1b-61a4bf591bba", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.6 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.4 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Adjust cognitive and social component adaptation to enhance dynamic exploration-exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.27630817554431975, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27630817554431975, 0.27630817554431975, 0.27630817554431975]}, "mutation_prompt": null}
{"id": "ad2f4f95-e330-4e83-9897-29f16a566080", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.6 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance exploration by slightly increasing the cognitive component's adaptation factor in the early stages.", "configspace": "", "generation": 90, "fitness": 0.27776853716394634, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27776853716394634, 0.27776853716394634, 0.27776853716394634]}, "mutation_prompt": null}
{"id": "4beb72df-8245-4c91-8ee7-20d5a9b3cfe6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c] + self.best_global_position - swarm_position[a]) * 0.1\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced a slight bias in DE mutation towards the global best to enhance exploitation in the late stages.", "configspace": "", "generation": 91, "fitness": 0.2772794401305505, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2772794401305505, 0.2772794401305505, 0.2772794401305505]}, "mutation_prompt": null}
{"id": "f582accc-abe6-4a7e-accd-99b81a45e90a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.4 + 0.6 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the DE mutation factor's range to enhance exploration capabilities.", "configspace": "", "generation": 92, "fitness": 0.2777350001913821, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2777350001913821, 0.2777350001913821, 0.2777350001913821]}, "mutation_prompt": null}
{"id": "95315e0c-e2e3-441b-a689-2fbbba2d275e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * (1 - adapt_factor**2)  # Nonlinear mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced a nonlinear factor to dynamically adjust the DE mutation factor for enhanced exploration.", "configspace": "", "generation": 93, "fitness": 0.2773520729416634, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2773520729416634, 0.2773520729416634, 0.2773520729416634]}, "mutation_prompt": null}
{"id": "ae274c59-5bab-4bb4-a779-06fd5f77f003", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                velocity_scale = 0.9 * adapt_factor + 0.1  # Adaptive velocity scaling added\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] * velocity_scale +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity scaling for more balanced exploration and exploitation in the PSO component.", "configspace": "", "generation": 94, "fitness": 0.27785117000749493, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27785117000749493, 0.27785117000749493, 0.27785117000749493]}, "mutation_prompt": null}
{"id": "1ad235fe-ded7-4a3a-8cd5-78dfe76cd92d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * adapt_factor  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Enhance the DE mutation factor's adaptability based on the evaluation ratio to improve convergence.", "configspace": "", "generation": 95, "fitness": 0.27729934055327543, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.27729934055327543, 0.27729934055327543, 0.27729934055327543]}, "mutation_prompt": null}
{"id": "09f7a398-1081-466b-af90-e223ec2407c9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            swarm_diversity = np.mean(np.std(swarm_position, axis=0))  # Swarm diversity\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.5 * swarm_diversity  # Adaptive inertia weight based on diversity\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight based on current swarm diversity to enhance convergence.", "configspace": "", "generation": 96, "fitness": 0.26611592583527244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26611592583527244, 0.26611592583527244, 0.26611592583527244]}, "mutation_prompt": null}
{"id": "f86b3977-d935-4be1-8736-6d7b2dde64f7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Slightly increase the inertia weight's nonlinear factor to enhance exploration in early stages.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2778799486756668, 0.2778799486756668, 0.2778799486756668]}, "mutation_prompt": null}
{"id": "606f496f-9878-44b5-a885-7ad77063f188", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            for i in range(self.population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n            \n            self.population_size = max(10, int(40 * adapt_factor))  # Dynamically reduce population size\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduced a dynamic population size reduction to improve convergence speed.", "configspace": "", "generation": 98, "fitness": 0.26611592583527244, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.26611592583527244, 0.26611592583527244, 0.26611592583527244]}, "mutation_prompt": null}
{"id": "0bddb733-1a18-4121-924a-56ece21501d5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Number of particles\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.f = 0.5  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        self.best_global_position = None\n        self.best_global_fitness = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_position = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        swarm_velocity = np.zeros((self.population_size, self.dim))\n        personal_best_position = np.copy(swarm_position)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n\n        num_evaluations = 0\n        while num_evaluations < self.budget:\n            adapt_factor = 1 - num_evaluations / self.budget  # New adaptive factor\n            current_population_size = int(self.population_size * (0.5 + 0.5 * adapt_factor))  # Adaptive population size\n            for i in range(current_population_size):\n                fitness = func(swarm_position[i])\n                num_evaluations += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_position[i] = swarm_position[i]\n\n                if fitness < self.best_global_fitness:\n                    self.best_global_fitness = fitness\n                    self.best_global_position = swarm_position[i]\n\n            for i in range(current_population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.c1 = 1.5 + 0.7 * adapt_factor  # Modify cognitive component\n                self.c2 = 1.5 - 0.7 * adapt_factor  # Modify social component\n                self.w = 0.4 + 0.65 * (1 - adapt_factor**2)  # Nonlinear inertia weight\n                swarm_velocity[i] = (\n                    self.w * swarm_velocity[i] +\n                    self.c1 * r1 * (personal_best_position[i] - swarm_position[i]) +\n                    self.c2 * r2 * (self.best_global_position - swarm_position[i])\n                )\n                swarm_position[i] += swarm_velocity[i]\n                swarm_position[i] = np.clip(swarm_position[i], lb, ub)\n\n                # Differential Evolution mutation and crossover\n                if num_evaluations < self.budget:\n                    dynamic_f = 0.5 + 0.5 * np.random.rand()  # Stochastic mutation factor\n                    dynamic_cr = 0.8 + 0.2 * (1 - adapt_factor)  # Dynamic crossover probability\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = swarm_position[a] + dynamic_f * (swarm_position[b] - swarm_position[c])\n                    trial_vector = np.copy(swarm_position[i])\n                    \n                    for j in range(self.dim):\n                        if np.random.rand() < dynamic_cr:  # Use dynamic_cr instead of self.cr\n                            trial_vector[j] = mutant_vector[j]\n                    \n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    trial_fitness = func(trial_vector)\n                    num_evaluations += 1\n\n                    if trial_fitness < fitness:\n                        swarm_position[i] = trial_vector\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best_position[i] = trial_vector\n                        if trial_fitness < self.best_global_fitness:\n                            self.best_global_fitness = trial_fitness\n                            self.best_global_position = trial_vector\n\n        return self.best_global_position, self.best_global_fitness", "name": "HybridPSO_DE", "description": "Introduce adaptive population size reduction to focus exploration as the budget depletes, improving convergence.", "configspace": "", "generation": 99, "fitness": 0.2773833289240838, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.00.", "error": "", "parent_id": "2262a074-c2a1-4c7f-8a8d-5520efd66068", "metadata": {"aucs": [0.2773833289240838, 0.2773833289240838, 0.2773833289240838]}, "mutation_prompt": null}
