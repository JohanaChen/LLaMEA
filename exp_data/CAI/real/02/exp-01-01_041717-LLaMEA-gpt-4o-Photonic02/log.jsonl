{"id": "749b1128-a50d-421a-ada4-c742cd97ce95", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Parameter Control for Efficient Black Box Optimization in Photonic Structures.", "configspace": "", "generation": 0, "fitness": 0.8495209395841642, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.02.", "error": "", "parent_id": null, "metadata": {"aucs": [0.864737525623769, 0.8343043535445593]}, "mutation_prompt": null}
{"id": "f06b99c7-4cc3-4fc9-896f-50dcf09abe8f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n            self.population_size = int(10 * dim * (1 - evaluations / self.budget) + self.dim)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing adaptive population size scaling with budget utilization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {}, "mutation_prompt": null}
{"id": "44ac76bd-74b4-46bb-9b5e-d6c7530aa02a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection and Local Search Intensification\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    # Local search intensification\n                    local_search_step = 0.1 * (bounds[:, 1] - bounds[:, 0])\n                    local_trial = np.clip(population[i] + np.random.uniform(-local_search_step, local_search_step), bounds[:, 0], bounds[:, 1])\n                    local_trial_fitness = func(local_trial)\n                    evaluations += 1\n                    if local_trial_fitness < fitness[i]:\n                        population[i] = local_trial\n                        fitness[i] = local_trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Local Search Intensification for Improved Optimization Results.", "configspace": "", "generation": 2, "fitness": 0.7918541180955314, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.01.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.799229310994988, 0.7844789251960749]}, "mutation_prompt": null}
{"id": "ca845f92-4bd9-4d75-9c97-6dda7c6738d6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Dynamic initial population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.initial_population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.initial_population_size\n        \n        while evaluations < self.budget:\n            current_population_size = int(self.initial_population_size * (1 - evaluations / self.budget)) + 1  # Progressive resizing\n            for i in range(current_population_size):\n                indices = np.arange(current_population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Progressive Population Resizing for Improved Black Box Optimization in Photonic Structures.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {}, "mutation_prompt": null}
{"id": "54b027b5-a8bb-485c-9bd6-aee32b157544", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.6  # Slightly increased initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Slightly increased initial mutation factor for broader exploration early in the optimization process.", "configspace": "", "generation": 4, "fitness": 0.715964560343487, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.00.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.7198940897169123, 0.7120350309700616]}, "mutation_prompt": null}
{"id": "cc3837ac-5a00-4071-97d1-81b79c8bf85d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            scaling_factor = 1 + 0.2 * np.sin(np.pi * evaluations / self.budget)  # New scaling factor for mutation\n            self.mutation_factor = (0.8 * (1 - evaluations / self.budget) + 0.1) * scaling_factor\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a scaling factor to the mutation factor for enhanced exploration during early iterations.", "configspace": "", "generation": 5, "fitness": 0.7870033409071793, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.818655781562459, 0.7553509002518994]}, "mutation_prompt": null}
{"id": "8b77e2cb-f259-42c6-ad79-fc7470c6ef56", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                dynamic_scaling = np.std(population, axis=0) / np.ptp(bounds, axis=1)  # New line added\n                mutant = np.clip(a + self.mutation_factor * (b - c) * dynamic_scaling, bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation strategy by introducing a dynamic scaling factor based on population diversity to improve exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.6861764267797517, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.6577819710031316, 0.7145708825563718]}, "mutation_prompt": null}
{"id": "ca55f60e-a74f-42b4-9c03-c8779278d909", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            diversity = np.std(population, axis=0).mean()  # Calculate population diversity\n            self.mutation_factor = (0.8 * (1 - evaluations / self.budget) + 0.1) * diversity  # Adaptive mutation factor\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling for the mutation factor based on population diversity to enhance exploration.", "configspace": "", "generation": 7, "fitness": 0.5978354405841155, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.07.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.6656903628098858, 0.5299805183583453]}, "mutation_prompt": null}
{"id": "dc99358a-6136-447d-a52b-86b2adaa2c3e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial) + 0.01 * np.linalg.norm(trial - population[i])\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced selection strategy with a penalty factor increases convergence efficiency.", "configspace": "", "generation": 8, "fitness": 0.6742837698857784, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.7026434491174858, 0.6459240906540711]}, "mutation_prompt": null}
{"id": "5b61e797-f20c-4803-b03a-36c3d2bf097b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - evaluations / self.budget) + 0.2  # Adjusted line\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with a refined dynamic mutation factor for enhanced convergence in photonic structure optimization.", "configspace": "", "generation": 9, "fitness": 0.8013987497666881, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8297038384295679, 0.7730936611038083]}, "mutation_prompt": null}
{"id": "b7958b88-1f35-41c1-bd31-79ef5834443d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n            # Adjust population size dynamically\n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget) + self.dim)\n            if self.population_size > len(population):\n                new_individuals = np.random.rand(self.population_size - len(population), self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n                population = np.vstack([population, new_individuals])\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                fitness = np.concatenate([fitness, new_fitness])\n                evaluations += len(new_fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced an adaptive population size to improve convergence rate without increasing budget.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {}, "mutation_prompt": null}
{"id": "0bcb146f-4253-470b-8cb1-adc43ad34788", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (population[np.argmin(fitness)] - a), bounds[:, 0], bounds[:, 1])  # Refined mutation strategy\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Refined Mutation Strategy for Enhanced Exploration.", "configspace": "", "generation": 11, "fitness": 0.8353884317065925, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84 with standard deviation 0.02.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.854318330784686, 0.816458532628499]}, "mutation_prompt": null}
{"id": "a16ecbdd-b388-46a6-98d4-cd256394de16", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation factor adaptation for improved convergence by slightly modifying its formula.", "configspace": "", "generation": 12, "fitness": 0.8006599008548205, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.04.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8391434125116776, 0.7621763891979635]}, "mutation_prompt": null}
{"id": "83ea8a99-f41c-4050-b38f-45b8148d57d7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n            # Adjust population size dynamically\n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget) + 1)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive population size strategy to balance exploration and exploitation in Differential Evolution.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {}, "mutation_prompt": null}
{"id": "03682d02-c2da-497c-b099-86994188623b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * np.exp(-evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating exponential decay to the mutation factor for improved convergence.", "configspace": "", "generation": 14, "fitness": 0.6907806209750489, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.7240668835238678, 0.65749435842623]}, "mutation_prompt": null}
{"id": "6aaf61b6-d482-445d-a977-2bafb3d8fc7e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover probability for improved photonic structure optimization. ", "configspace": "", "generation": 15, "fitness": 0.7901260097801349, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8220778980219479, 0.758174121538322]}, "mutation_prompt": null}
{"id": "8cb6b46f-c715-44aa-9ddb-bfa5bdfced92", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.6  # Initial mutation factor updated for improved exploration\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Enhanced Mutation Factor for Better Convergence in Photonic Structures Optimization.", "configspace": "", "generation": 16, "fitness": 0.8013788449427915, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.02.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8188515641607472, 0.7839061257248359]}, "mutation_prompt": null}
{"id": "501ba70d-aacc-48d2-88a6-d9a4a7288a71", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - evaluations / self.budget) + 0.1  # Adjust decay factor\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation strategy by adjusting mutation factor decay for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.8006599008548205, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.04.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8391434125116776, 0.7621763891979635]}, "mutation_prompt": null}
{"id": "ef1634cf-fa00-4167-a288-b32978c7b3a2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                trial = np.clip(trial, bounds[:, 0], bounds[:, 1])  # Ensure trial is within bounds\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a boundary check for trial solutions to improve constraint handling and solution feasibility.", "configspace": "", "generation": 18, "fitness": 0.8073745609513333, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.01.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8195370759589498, 0.7952120459437169]}, "mutation_prompt": null}
{"id": "f8b65971-bf0f-4797-b81e-aaec274a4ddd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adjusted initial population size for improved convergence.", "configspace": "", "generation": 19, "fitness": 0.7700198655678223, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8021483904120558, 0.7378913407235888]}, "mutation_prompt": null}
{"id": "7edcb6d0-f5b2-4b75-860c-0e2bb55fe02e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly increased population size for better exploration\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by slightly increasing the population size to improve exploration.", "configspace": "", "generation": 20, "fitness": 0.7866134011439067, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.02.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.8079601716416961, 0.7652666306461172]}, "mutation_prompt": null}
{"id": "ab465ab7-c137-43b6-8a45-e1b333bac3e1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                adapt_mutation_factor = self.mutation_factor + 0.1 * np.random.rand()  # Dynamic mutation\n                mutant = np.clip(a + adapt_mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.8 * (evaluations / self.budget) + 0.2  # Dynamic crossover\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Mutation and Crossover Strategies for Improved Photonic Structure Optimization.", "configspace": "", "generation": 21, "fitness": 0.7262272139412314, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.04.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.6835134637159306, 0.768940964166532]}, "mutation_prompt": null}
{"id": "5efe107f-cd2b-43cd-9e60-1efbce93611f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget) + self.dim)  # Updated line\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic adaptation of population size for improved exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {}, "mutation_prompt": null}
{"id": "8fdc1afb-32b0-49c1-9957-afa15db4d5a0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n        self.rejuvenation_threshold = 0.3  # Threshold for rejuvenating population\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (evaluations / self.budget) + 0.1\n\n            # Population Rejuvenation\n            if np.std(fitness) < self.rejuvenation_threshold:\n                population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Population Rejuvenation for Improved Exploration in Photonic Structures.", "configspace": "", "generation": 23, "fitness": 0.5972866361694056, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.03.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.5706966407701967, 0.6238766315686146]}, "mutation_prompt": null}
{"id": "b3e4762c-393f-4987-bc75-88a3c307252e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Crossover Probability for Improved Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 24, "fitness": 0.9586793173941333, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "749b1128-a50d-421a-ada4-c742cd97ce95", "metadata": {"aucs": [0.9565150946196461, 0.9608435401686203]}, "mutation_prompt": null}
{"id": "a6bc58e3-1105-4dca-98f7-10fb5d7e5927", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.3  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Mutation Factor Scaling for Improved Exploration.", "configspace": "", "generation": 25, "fitness": 0.9088007220701961, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.912918632438668, 0.9046828117017243]}, "mutation_prompt": null}
{"id": "cc5f58f4-9d07-4300-bafe-8168ae92dcc6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n            # Adaptive scaling of population size\n            self.population_size = int(10 * dim * (1 - evaluations / self.budget) + 5)\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling for the population size based on budget utilization to enhance convergence speed.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {}, "mutation_prompt": null}
{"id": "bc7775a3-fe27-47d8-8cf9-7d48381755d0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Line changed\n            self.crossover_probability = 0.7 + 0.2 * np.random.rand()  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing self-adaptive mutation and crossover strategies to further enhance convergence in photonic structure optimization.", "configspace": "", "generation": 27, "fitness": 0.9065030081922255, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8962621454855392, 0.9167438708989119]}, "mutation_prompt": null}
{"id": "057f6911-10ce-484e-af35-089c11a938ff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n        self.operator_probability = 0.5  # Initial operator probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                if np.random.rand() < self.operator_probability:\n                    mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                else:\n                    mutant = np.clip(a - self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.operator_probability = min(1.0, self.operator_probability + 0.1)  # Increase probability\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Operator Probability Learning for Enhanced Photonic Structure Optimization.", "configspace": "", "generation": 28, "fitness": 0.9170487762441769, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9173326437548253, 0.9167649087335286]}, "mutation_prompt": null}
{"id": "9422aead-750b-434c-af34-40b9d56e1924", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.population_size = int((10 * self.dim) * (1 - evaluations / self.budget)) + 1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing dynamic population size adjustment based on remaining budget for improved exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {}, "mutation_prompt": null}
{"id": "c7acb2f8-e205-4bc7-88be-fd925bd0182b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.population_size = max(4, int(10 * self.dim * (1 - evaluations / self.budget)))  # Population size change\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Size Adjustment for Improved Exploration and Exploitation Balance in Photonic Structure Optimization.", "configspace": "", "generation": 30, "fitness": 0.8941883851914333, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8841047222653139, 0.9042720481175527]}, "mutation_prompt": null}
{"id": "7f3984de-4b73-4bff-8d4b-7a454adbaf69", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            \n            # Dynamic adjustment of population size\n            self.population_size = int(self.initial_population_size * (0.5 + 0.5 * (1 - evaluations / self.budget)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a dynamic population size scaling to balance exploration and exploitation for enhanced convergence.", "configspace": "", "generation": 31, "fitness": 0.9354375806987737, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9346952875951913, 0.9361798738023561]}, "mutation_prompt": null}
{"id": "3430e974-3114-425e-a9c4-003b2801c71b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.2  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Dynamic Crossover and Adaptive Mutation Scaling for Enhanced Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 32, "fitness": 0.9174490636466022, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9143778447121977, 0.9205202825810067]}, "mutation_prompt": null}
{"id": "558cd88f-ec89-42c7-8f81-024ecaeb27a8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - evaluations / self.budget) + 0.2  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Scaling Factor for Improved Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 33, "fitness": 0.923939184987765, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.02.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9404948896672235, 0.9073834803083065]}, "mutation_prompt": null}
{"id": "170be96a-0abd-4c0f-9f27-036da73114f7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            # Line changed below\n            self.mutation_factor = 0.9 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Modified mutation factor adaptation to enhance exploration and exploitation balance, improving convergence in photonic structure optimization.", "configspace": "", "generation": 34, "fitness": 0.9232147283946218, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9205875944600005, 0.9258418623292431]}, "mutation_prompt": null}
{"id": "be049cd3-1334-4cad-9c4c-bd6bb4626a24", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by further refining the mutation factor adaptation for better convergence.", "configspace": "", "generation": 35, "fitness": 0.9232147283946218, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9205875944600005, 0.9258418623292431]}, "mutation_prompt": null}
{"id": "fca351d3-6544-46e1-b33f-72e40e839ad8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            \n            # Line changed\n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget)) + 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Population Size for Improved Convergence and Diversity in Photonic Structure Optimization.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {}, "mutation_prompt": null}
{"id": "faa05079-731f-41f8-a79e-eed6045ec6eb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            \n            # Adjust population size dynamically\n            self.population_size = max(4, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic population size adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.8941883851914333, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8841047222653139, 0.9042720481175527]}, "mutation_prompt": null}
{"id": "facbcb9c-b9db-4d71-a417-c6559672d22b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.mutation_factor = 0.5 * (1 + np.cos(np.pi * evaluations / self.budget))  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            if evaluations % (self.budget // 4) == 0:  # Line changed\n                population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]  # Line changed\n                fitness = np.array([func(ind) for ind in population])  # Reset population periodically\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Advanced Adaptive Differential Evolution with Self-Adaptive Mutation and Restart Mechanism for Accelerated Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 38, "fitness": 0.8451693474603934, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.02.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8295459497321152, 0.8607927451886718]}, "mutation_prompt": null}
{"id": "8b5cff3c-92fc-41a5-a975-0cf3f923fa27", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                self.mutation_factor = np.random.uniform(0.4, 0.9)  # Line changed for random mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Randomized Scaling Factor for Enhanced Global Search in Photonic Structure Optimization.", "configspace": "", "generation": 39, "fitness": 0.9293908720417972, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.02.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9479454878438938, 0.9108362562397007]}, "mutation_prompt": null}
{"id": "6a0900a5-c85f-4eb3-ad31-14748dd77c0c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.3  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Mutation Factor Adaptation for Precise Photonic Structure Optimization.", "configspace": "", "generation": 40, "fitness": 0.8818735609915247, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8851997934425966, 0.8785473285404529]}, "mutation_prompt": null}
{"id": "f26fc2a9-45c2-42b3-925b-3e6bb5f88698", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Dynamic resizing of the population\n            if evaluations > self.budget / 2 and evaluations % self.population_size == 0:\n                self.population_size = max(5 * self.dim, int(self.population_size * 0.9))\n\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic scaling of the population size based on budget utilization to improve convergence.", "configspace": "", "generation": 41, "fitness": 0.92771847138361, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9251940466966617, 0.9302428960705581]}, "mutation_prompt": null}
{"id": "8fb123c0-d734-4152-944c-77671504bfd2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.5 * (1 - (evaluations / self.budget) ** 2) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Nonlinear Mutation Factor Decay for Faster Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 42, "fitness": 0.945089236975484, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9466675932312497, 0.9435108807197182]}, "mutation_prompt": null}
{"id": "b4bc1b04-b54c-4214-b2eb-9de72658937f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Dynamic population size based on dimension (line changed)\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "A subtle yet strategic adjustment to the population size scaling factor enhances adaptability and convergence precision for photonic structure optimization.", "configspace": "", "generation": 43, "fitness": 0.8911070936073505, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.89 with standard deviation 0.02.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9145555279085386, 0.8676586593061625]}, "mutation_prompt": null}
{"id": "b4b3d5a8-71b7-4b19-9cf1-c83d9ed4a173", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Dynamic Mutation\n                mutation_scale = np.exp(-fitness[i])  # New line for dynamic mutation factor\n                mutant = np.clip(a + mutation_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                \n                # Fitness-based Crossover\n                crossover = np.random.rand(self.dim) < (self.crossover_probability * (1 - fitness[i] / np.max(fitness)))  # New line for fitness-based crossover\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Mutation Strategy and Fitness-based Crossover Probability for Optimized Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 44, "fitness": 0.7710628299894394, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.07.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8394857492791439, 0.702639910699735]}, "mutation_prompt": null}
{"id": "a128ef89-50bb-49a8-a6e5-c81cd5e6c2b1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.initial_population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.initial_population_size\n        \n        while evaluations < self.budget:\n            self.population_size = max(4, int(self.initial_population_size * (1 - evaluations / self.budget)))  # Line changed\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introducing a dynamic population size reduction strategy to enhance convergence speed while respecting the budget constraints.", "configspace": "", "generation": 45, "fitness": 0.9276444256187801, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9379818939785413, 0.9173069572590191]}, "mutation_prompt": null}
{"id": "21120545-e582-4cd0-afa3-5d5478992c19", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters based on fitness\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.min(fitness) / np.max(fitness))\n            self.crossover_probability = 0.5 + 0.4 * (1 - np.min(fitness) / np.max(fitness))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Fitness-Based Dynamic Crossover and Mutation for Enhanced Global Optimization.", "configspace": "", "generation": 46, "fitness": 0.9205014863185994, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.02.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9048963468972346, 0.9361066257399642]}, "mutation_prompt": null}
{"id": "139191a9-a7d4-41ca-a1d4-c3cbf7c7de44", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1 \n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget)) + 1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic population resizing mechanism to enhance exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {}, "mutation_prompt": null}
{"id": "c55e2cfd-4759-46c4-92a4-e80a752ea8dc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - evaluations / self.budget) + 0.2  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Modified the dynamic adaptation of the mutation factor and crossover probability to improve convergence rate and exploration in the search space.", "configspace": "", "generation": 48, "fitness": 0.8487673245415139, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8547532329083434, 0.8427814161746844]}, "mutation_prompt": null}
{"id": "203a1e35-d59e-476a-90c1-7f8fdb70fbf3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Reduced Mutation Factor Decay for Better Exploration in Photonic Structure Optimization.", "configspace": "", "generation": 49, "fitness": 0.914723021635605, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.919362930402334, 0.9100831128688761]}, "mutation_prompt": null}
{"id": "431c8dc5-0774-43c1-a3f9-db874e4ef8bf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Reduced Mutation Factor Dynamics for More Stable Convergence in Photonic Structure Optimization.", "configspace": "", "generation": 50, "fitness": 0.914723021635605, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.91 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.919362930402334, 0.9100831128688761]}, "mutation_prompt": null}
{"id": "3b18a44b-f693-4ee3-afd8-dd6ef35c5d06", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n\n                # Mutation and Crossover\n                diversity = np.std(population, axis=0)  # Calculate diversity\n                self.mutation_factor = 0.5 + 0.5 * diversity.mean()  # Adjust scale factor dynamically\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a novel mutation strategy that adjusts the scale factor dynamically based on the population diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.6143528077142842, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.04.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.6530598333664239, 0.5756457820621446]}, "mutation_prompt": null}
{"id": "468cbbf1-5f3a-466b-81c1-3b649241aaa6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.2\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with a Modified Mutation Strategy for Better Exploration in Photonic Structure Optimization.", "configspace": "", "generation": 52, "fitness": 0.9222741335048266, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9257546622127623, 0.918793604796891]}, "mutation_prompt": null}
{"id": "6d4b1bb0-f7a5-44bb-8edd-aceae5820e0e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            population_std = np.std(population, axis=0).mean()  # Calculate population diversity\n            self.mutation_factor = 0.8 * (1 - evaluations / self.budget) + 0.1 + 0.1 * (1 - population_std / bounds.ptp(axis=1).mean())\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate an adaptive mutation factor based on population diversity to enhance convergence in photonic structure optimization.", "configspace": "", "generation": 53, "fitness": 0.8998244042783882, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.01.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.8871739447544602, 0.9124748638023161]}, "mutation_prompt": null}
{"id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by dynamically adjusting mutation factor based on population diversity.", "configspace": "", "generation": 54, "fitness": 0.9711614203645061, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "b3e4762c-393f-4987-bc75-88a3c307252e", "metadata": {"aucs": [0.9735999246004605, 0.9687229161285518]}, "mutation_prompt": null}
{"id": "e5c7859c-8dc2-41af-b1e1-bcb0334dab68", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by updating both mutation factor and crossover probability based on population diversity and evaluation progress.", "configspace": "", "generation": 55, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "e63060b7-5f7b-4d56-86c9-3c28c5fdd7f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced diversity through adaptive crossover probability based on fitness variance.", "configspace": "", "generation": 56, "fitness": 0.9558531869552676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.954478959748444, 0.957227414162091]}, "mutation_prompt": null}
{"id": "7fd25b7b-7e61-45c3-bce4-b7bd7b412ae7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Optimized convergence by adjusting mutation factor based on fitness variability with a higher influence factor.", "configspace": "", "generation": 57, "fitness": 0.9599065409088271, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9582003655514736, 0.9616127162661806]}, "mutation_prompt": null}
{"id": "77212af4-27e2-4751-b671-20f8f43b203f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            self.population_size = int(10 * dim * (1 - evaluations / self.budget)) + dim  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved exploration by dynamically adjusting population size based on evaluation progress.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {}, "mutation_prompt": null}
{"id": "aab32a90-f563-414e-9c77-030a0cb3cd6c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        previous_best_fitness = np.min(fitness)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            current_best_fitness = np.min(fitness)\n            improvement_rate = (previous_best_fitness - current_best_fitness) / previous_best_fitness if previous_best_fitness != 0 else 0\n            self.mutation_factor = 0.5 + 0.3 * improvement_rate  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1  # Line changed\n            previous_best_fitness = current_best_fitness  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by introducing a variable scaling factor for the mutation strategy based on fitness improvement rate.", "configspace": "", "generation": 59, "fitness": 0.9419626437799513, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9364677810478124, 0.9474575065120904]}, "mutation_prompt": null}
{"id": "175f92be-5044-4295-811d-035cec525b92", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by dynamically adjusting both mutation factor and crossover probability based on population diversity and search progress.", "configspace": "", "generation": 60, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "fe3e0411-a7fe-4a8b-a835-d468046e5497", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-8)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved parameter adaptation by refining mutation factor adjustment based on fitness variance.", "configspace": "", "generation": 61, "fitness": 0.9430043291704271, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9554103011816147, 0.9305983571592393]}, "mutation_prompt": null}
{"id": "64258c75-2e0b-4e3f-a1e8-ecb1ade9a0f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - (np.std(fitness) / (np.mean(fitness) + 1e-10))) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced balance between exploration and exploitation through adaptive mutation factor adjustment.", "configspace": "", "generation": 62, "fitness": 0.9711613407735566, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9735997663425863, 0.9687229152045269]}, "mutation_prompt": null}
{"id": "af60ec0a-dcc5-46a3-abb9-242c5c86e23c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved mutation factor adaptation by incorporating both fitness diversity and current iteration ratio.", "configspace": "", "generation": 63, "fitness": 0.9576531610878062, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9684336097311923, 0.9468727124444201]}, "mutation_prompt": null}
{"id": "b21d1552-0a1e-4d06-a076-ae409cb66559", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.min(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by adjusting mutation factor based on the difference between current best and average population fitness.", "configspace": "", "generation": 64, "fitness": 0.9238426253963827, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.02.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9401135963247192, 0.9075716544680462]}, "mutation_prompt": null}
{"id": "b56b75fa-102e-4be4-a15f-e58134ca6e1a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by dynamically adjusting crossover probability based on population fitness diversity.", "configspace": "", "generation": 65, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "2942f8c9-904f-4e01-b2e2-fa6a24bdeb25", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by dynamically adjusting mutation factor and incorporating diversity-based scaling.", "configspace": "", "generation": 66, "fitness": 0.9711614203645061, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9735999246004605, 0.9687229161285518]}, "mutation_prompt": null}
{"id": "c24ca303-bf1f-4ae5-bb9d-49a6859390f8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.var(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Further enhance convergence by refining mutation factor calculation based on fitness variance.", "configspace": "", "generation": 67, "fitness": 0.9199821429226651, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9342998056427892, 0.9056644802025411]}, "mutation_prompt": null}
{"id": "ebc61dff-1336-40ee-9720-aa6cdb3f8f9f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptive mechanism by incorporating population diversity into crossover probability adjustment.", "configspace": "", "generation": 68, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "81df5998-5134-4621-9527-a2ecc92f6987", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / (np.mean(fitness) + np.std(fitness))) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation by introducing fitness diversity scaling in mutation factor.", "configspace": "", "generation": 69, "fitness": 0.947052215168065, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9483267184454148, 0.9457777118907152]}, "mutation_prompt": null}
{"id": "49cce217-a72b-41e9-bb9b-6101f1b5c939", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by refining the adaptation formula of the mutation factor.", "configspace": "", "generation": 70, "fitness": 0.9599065409088271, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9582003655514736, 0.9616127162661806]}, "mutation_prompt": null}
{"id": "a96caccc-b989-4e6c-9d76-845b7ee8eee8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-10)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by dynamically adjusting both mutation factor and crossover probability more precisely based on fitness diversity.", "configspace": "", "generation": 71, "fitness": 0.9711613407735566, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9735997663425863, 0.9687229152045269]}, "mutation_prompt": null}
{"id": "abd94409-620f-495a-8175-772f3749f54c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.var(fitness) / (np.mean(fitness)**2)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by adjusting mutation factor using adaptive scaling based on fitness variance.", "configspace": "", "generation": 72, "fitness": 0.9505460466730846, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.948700307346133, 0.9523917860000362]}, "mutation_prompt": null}
{"id": "cc8c194a-38cc-48a6-ae79-6fe50db4a920", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.6 * (1 - np.std(fitness) / np.mean(fitness)) + 0.2  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by refining mutation factor adaptation based on fitness variability.", "configspace": "", "generation": 73, "fitness": 0.9671829948142844, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9688582602294897, 0.965507729399079]}, "mutation_prompt": null}
{"id": "d86625e3-9753-47c2-b700-09da107c5371", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation using fitness variance to dynamically adjust both mutation factor and crossover probability.", "configspace": "", "generation": 74, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "0f591ea8-e547-4700-9563-e7bcbcc3f565", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.var(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by introducing self-adapting mutation strategy based on fitness variance.", "configspace": "", "generation": 75, "fitness": 0.9199821429226651, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9342998056427892, 0.9056644802025411]}, "mutation_prompt": null}
{"id": "11c3c458-8b04-4fc0-a34a-b3b07d18d2ad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a dynamic adjustment to the crossover probability for more refined exploration towards the end of the evaluation budget.", "configspace": "", "generation": 76, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "75be88f8-b00a-4cb8-925b-a7278552e706", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-9)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Further enhances convergence by refining the mutation factor adaptation based on fitness diversity.", "configspace": "", "generation": 77, "fitness": 0.9711029705908027, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9734830342944564, 0.9687229068871491]}, "mutation_prompt": null}
{"id": "00612b97-95b0-40f9-9cb5-f5e39537e639", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.var(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by adjusting mutation factor based on fitness variance over time.", "configspace": "", "generation": 78, "fitness": 0.92695627364881, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9305223314624163, 0.9233902158352036]}, "mutation_prompt": null}
{"id": "2307a1c2-3f5f-452a-a692-b07d4f9b52bd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.6 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptation by refining mutation factor calculation for improved diversity handling.", "configspace": "", "generation": 79, "fitness": 0.9558095132955264, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9670233542446254, 0.9445956723464275]}, "mutation_prompt": null}
{"id": "847f2c91-4865-4d6b-aa5c-39054a545f05", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.var(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by refining mutation adaptation using fitness variance.", "configspace": "", "generation": 80, "fitness": 0.92695627364881, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9305223314624163, 0.9233902158352036]}, "mutation_prompt": null}
{"id": "d5483344-34c9-4d2f-aae4-693e70a9936c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.7 * (1 - np.std(fitness) / np.mean(fitness)) + 0.2  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by fine-tuning the dynamic adaptation formula of the mutation factor.", "configspace": "", "generation": 81, "fitness": 0.9412775740096107, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9356397692150213, 0.9469153788042]}, "mutation_prompt": null}
{"id": "0d285ce8-071e-426d-8491-8363662ba59c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation by introducing fitness diversity in parameter tuning for better convergence.", "configspace": "", "generation": 82, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "d0aa6433-48a6-4bdc-ae54-b75754acd6f1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness) + np.min(fitness) / np.max(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by adjusting mutation factor using fitness diversity and individual fitness.", "configspace": "", "generation": 83, "fitness": 0.9600830765348964, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9687387581134794, 0.9514273949563136]}, "mutation_prompt": null}
{"id": "2bfb6c11-8aa5-4457-ba7d-33c832fc0162", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c) * np.std(population, axis=0), bounds[:, 0], bounds[:, 1])  # Change\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Improved diversity in evolution by introducing a scaling factor in mutation based on population diversity.", "configspace": "", "generation": 84, "fitness": 0.5853570080471885, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.06.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6456142472345394, 0.5250997688598376]}, "mutation_prompt": null}
{"id": "bd75fd49-663d-4752-a6fb-df5c12783b7b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.7 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by modifying crossover probability based on fitness diversity.", "configspace": "", "generation": 85, "fitness": 0.5920988953570971, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5435276073578257]}, "mutation_prompt": null}
{"id": "0d7bd777-7ef7-4f71-82f0-9953c261cb6e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                random_individual = population[np.random.choice(self.population_size)]  # Line changed\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (random_individual - a), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced population diversity by adding a random individual to mutation, improving exploration.  ", "configspace": "", "generation": 86, "fitness": 0.9641276045508604, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9735604902500632, 0.9546947188516577]}, "mutation_prompt": null}
{"id": "d63a3aec-fc19-491b-b123-93b8e7ddfa7c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1 * (1 - np.min(fitness) / np.max(fitness))  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploitation by adjusting mutation factor based on fitness improvements.", "configspace": "", "generation": 87, "fitness": 0.9522676131434418, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9663357299507804, 0.9381994963361032]}, "mutation_prompt": null}
{"id": "ada6c8d0-e248-4dd2-aaed-f96cf39bdd8e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-9)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced stability by refining mutation factor adaptation to balance exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.9711029705908027, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9734830342944564, 0.9687229068871491]}, "mutation_prompt": null}
{"id": "304550fa-96ca-42f8-9c13-cf91cfb974a7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation factor adaptation for better exploration-exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.9599065409088271, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9582003655514736, 0.9616127162661806]}, "mutation_prompt": null}
{"id": "6bfd7352-4697-4322-8892-dd03d502ea5a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            diversity = np.std(fitness) / np.mean(fitness)\n            self.mutation_factor = 0.8 * (1 - diversity) + 0.1\n            self.crossover_probability = 0.9 * (1 - diversity) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting both mutation factor and crossover probability based on population diversity and progress.", "configspace": "", "generation": 90, "fitness": 0.5936767507289906, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.5466833181016126]}, "mutation_prompt": null}
{"id": "d0694720-6033-4026-8ffa-b09dfe8dbdcc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1 * (np.min(fitness) / np.max(fitness))  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced selection pressure by incorporating a fitness-based scaling of the mutation factor.", "configspace": "", "generation": 91, "fitness": 0.9647516302855308, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9584777594169521, 0.9710255011541093]}, "mutation_prompt": null}
{"id": "3eb4d17e-73d8-4584-91ea-beb46b626422", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.9 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by dynamically adapting mutation factor with a fine-tuned scaling function.", "configspace": "", "generation": 92, "fitness": 0.9594712064667592, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9557626856475772, 0.9631797272859411]}, "mutation_prompt": null}
{"id": "8cd02e5d-1de3-42a3-ab7b-90cef7583d8f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            successful_trials = 0  # Counter for successful trials\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    successful_trials += 1  # Increment if a successful trial\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1 * (successful_trials / self.population_size)  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by adapting the mutation factor based on both population diversity and success rate of recent trials.", "configspace": "", "generation": 93, "fitness": 0.9492142330781221, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9633621266677964, 0.9350663394884478]}, "mutation_prompt": null}
{"id": "276988d5-5d85-4f14-a129-9a5abb71fd8a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.7 * (1 - np.std(fitness) / np.mean(fitness)) + 0.3  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by leveraging population diversity-driven crossover probability adjustment.", "configspace": "", "generation": 94, "fitness": 0.70373969964262, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.06.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.6406701833563686, 0.7668092159288714]}, "mutation_prompt": null}
{"id": "d05de761-ad3f-45f1-86bf-b2e32b84d894", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            \n            # Dynamically adjust population size based on budget utilization\n            self.population_size = int(10 * self.dim * (1 - evaluations / self.budget) + self.dim)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by updating population size dynamically based on budget utilization.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {}, "mutation_prompt": null}
{"id": "e4f877e6-a073-44b4-bb34-43a515c3c5b8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters with elitism\n            self.mutation_factor = 0.9 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n            best_index = np.argmin(fitness)  # Elitism: always keep the best solution\n            population[0], fitness[0] = population[best_index], fitness[best_index]  # Line added\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by modifying mutation factor based on diversity and introducing elitism for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.9253471244419917, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.93 with standard deviation 0.04.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.8832610512181696, 0.967433197665814]}, "mutation_prompt": null}
{"id": "5a83032d-162d-4fa6-92c9-d6b18fba4995", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (np.std(fitness) / np.mean(fitness)) + 0.1  # Line changed\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced convergence by refining crossover probability adaptation to consider population diversity.", "configspace": "", "generation": 97, "fitness": 0.9558531869552676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.954478959748444, 0.957227414162091]}, "mutation_prompt": null}
{"id": "50752f1c-4911-426a-ac85-56ffac278897", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - (np.std(fitness) / np.mean(fitness))) * (1 - evaluations / self.budget) + 0.1  # Line changed\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced mutation factor adaptation by considering fitness diversity and progress through the budget.", "configspace": "", "generation": 98, "fitness": 0.9576531610878062, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9684336097311923, 0.9468727124444201]}, "mutation_prompt": null}
{"id": "d8b82839-6777-4a86-93b1-dfba0c65241c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Dynamic population size based on dimension\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_probability = 0.7  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population within bounds\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                indices = indices[indices != i]  # Exclude the current index\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                \n                # Mutation and Crossover\n                mutant = np.clip(a + self.mutation_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                if np.random.rand() < 0.02:  # Introduce a small chance of random restart\n                    mutant = np.random.rand(self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n                crossover = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Check if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adaptation of differential evolution parameters\n            self.mutation_factor = 0.8 * (1 - np.std(fitness) / np.mean(fitness)) + 0.1\n            self.crossover_probability = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by incorporating a small probability of a random restart to increase exploration.", "configspace": "", "generation": 99, "fitness": 0.9564070326384793, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01.", "error": "", "parent_id": "8da68de5-7be4-4aa5-a1de-4fb79edbe5fe", "metadata": {"aucs": [0.9690358381014363, 0.9437782271755221]}, "mutation_prompt": null}
